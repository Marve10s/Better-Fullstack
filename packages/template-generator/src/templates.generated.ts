// Auto-generated - DO NOT EDIT
// Run 'bun run generate-templates' to regenerate

export const EMBEDDED_TEMPLATES: Map<string, string> = new Map([
  ["python-base/.env.example", `# Environment Configuration
# Copy this file to .env and update the values

# Application
DEBUG=true
HOST=0.0.0.0
PORT=8000

# Database (if using SQLAlchemy/SQLModel)
DATABASE_URL=sqlite:///./app.db

# OpenAI (if using AI frameworks)
OPENAI_API_KEY=your-openai-api-key

# Anthropic (if using Anthropic SDK)
ANTHROPIC_API_KEY=your-anthropic-api-key

# Celery (if using task queue)
CELERY_BROKER_URL=redis://localhost:6379/0
CELERY_RESULT_BACKEND=redis://localhost:6379/0
`],
  ["python-base/alembic.ini.hbs", `{{#if (ne pythonOrm "none")}}
{{#if (or (eq pythonOrm "sqlalchemy") (eq pythonOrm "sqlmodel"))}}
# Alembic configuration file

[alembic]
# path to migration scripts
script_location = migrations

# template used to generate migration files
# file_template = %%(rev)s_%%(slug)s

# sys.path path, will be prepended to sys.path if present.
# defaults to the current working directory.
prepend_sys_path = src

# timezone to use when rendering the date within the migration file
# as well as the filename.
# If specified, requires the python>=3.9 or backports.zoneinfo library.
# Any required deps can installed by adding \`alembic[tz]\` to the pip requirements
# string value is passed to ZoneInfo()
# leave blank for localtime
# timezone =

# max length of characters to apply to the
# "slug" field
# truncate_slug_length = 40

# set to 'true' to run the environment during
# the 'revision' command, regardless of autogenerate
# revision_environment = false

# set to 'true' to allow .pyc and .pyo files without
# a source .py file to be detected as revisions in the
# versions/ directory
# sourceless = false

# version location specification; This defaults
# to migrations/versions.  When using multiple version
# directories, initial revisions must be specified with --version-path.
# The path separator used here should be the separator specified by "version_path_separator" below.
# version_locations = %(here)s/bar:%(here)s/bat:migrations/versions

# version path separator; As mentioned above, this is the character used to split
# version_locations. The default within new alembic.ini files is "os", which uses os.pathsep.
# If this key is omitted entirely, it falls back to the legacy behavior of splitting on spaces and/or commas.
# Valid values for version_path_separator are:
#
# version_path_separator = :
# version_path_separator = ;
# version_path_separator = space
version_path_separator = os  # Use os.pathsep. Default configuration used for new projects.

# set to 'true' to search source files recursively
# in each "version_locations" directory
# new in Alembic version 1.10
# recursive_version_locations = false

# the output encoding used when revision files
# are written from script.py.mako
# output_encoding = utf-8

sqlalchemy.url = driver://user:pass@localhost/dbname


[post_write_hooks]
# post_write_hooks defines scripts or Python functions that are run
# on newly generated revision scripts.  See the documentation for further
# detail and examples

# format using "black" - use the console_scripts runner, against the "black" entrypoint
# hooks = black
# black.type = console_scripts
# black.entrypoint = black
# black.options = -q

# lint with attempts to fix using "ruff" - use the exec runner, execute a binary
# hooks = ruff
# ruff.type = exec
# ruff.executable = %(here)s/.venv/bin/ruff
# ruff.options = check --fix REVISION_SCRIPT_FILENAME

# Logging configuration
[loggers]
keys = root,sqlalchemy,alembic

[handlers]
keys = console

[formatters]
keys = generic

[logger_root]
level = WARN
handlers = console
qualname =

[logger_sqlalchemy]
level = WARN
handlers =
qualname = sqlalchemy.engine

[logger_alembic]
level = INFO
handlers =
qualname = alembic

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatter_generic]
format = %(levelname)-5.5s [%(name)s] %(message)s
datefmt = %H:%M:%S
{{/if}}
{{/if}}
`],
  ["python-base/pyproject.toml.hbs", `[project]
name = "{{projectName}}"
version = "0.1.0"
description = "A Python project created with Better Fullstack"
readme = "README.md"
requires-python = ">=3.11"
license = { text = "MIT" }
authors = [
    { name = "Your Name", email = "your.email@example.com" }
]

dependencies = [
{{#if (eq pythonWebFramework "fastapi")}}
    "fastapi>=0.115.0",
    "uvicorn[standard]>=0.32.0",
{{/if}}
{{#if (eq pythonWebFramework "django")}}
    "django>=5.1",
    "django-cors-headers>=4.6.0",
{{/if}}
{{#if (eq pythonOrm "sqlalchemy")}}
    "sqlalchemy>=2.0.36",
    "alembic>=1.14.0",
    "aiosqlite>=0.20.0",
{{/if}}
{{#if (eq pythonOrm "sqlmodel")}}
    "sqlmodel>=0.0.22",
    "alembic>=1.14.0",
{{/if}}
{{#if (eq pythonValidation "pydantic")}}
    "pydantic>=2.10.0",
    "pydantic-settings>=2.6.0",
{{/if}}
{{#if (includes pythonAi "langchain")}}
    "langchain>=0.3.0",
    "langchain-openai>=0.2.0",
{{/if}}
{{#if (includes pythonAi "llamaindex")}}
    "llama-index>=0.11.0",
    "llama-index-llms-openai>=0.3.0",
    "llama-index-embeddings-openai>=0.3.0",
{{/if}}
{{#if (includes pythonAi "openai-sdk")}}
    "openai>=1.55.0",
{{/if}}
{{#if (includes pythonAi "anthropic-sdk")}}
    "anthropic>=0.39.0",
{{/if}}
{{#if (includes pythonAi "langgraph")}}
    "langgraph>=0.2.0",
    "langchain-core>=0.3.0",
    "langchain-openai>=0.2.0",
{{/if}}
{{#if (includes pythonAi "crewai")}}
    "crewai>=0.80.0",
{{/if}}
{{#if (eq pythonTaskQueue "celery")}}
    "celery[redis]>=5.4.0",
{{/if}}
    "python-dotenv>=1.0.1",
]

[project.optional-dependencies]
dev = [
{{#if (eq pythonQuality "ruff")}}
    "ruff>=0.8.0",
{{/if}}
    "pytest>=8.3.0",
    "pytest-asyncio>=0.24.0",
]

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[tool.hatch.build.targets.wheel]
packages = ["src/app"]

{{#if (eq pythonQuality "ruff")}}
[tool.ruff]
target-version = "py311"
line-length = 100

[tool.ruff.lint]
select = [
    "E",      # pycodestyle errors
    "W",      # pycodestyle warnings
    "F",      # Pyflakes
    "I",      # isort
    "B",      # flake8-bugbear
    "C4",     # flake8-comprehensions
    "UP",     # pyupgrade
]
ignore = [
    "E501",   # line too long (handled by formatter)
]

[tool.ruff.format]
quote-style = "double"
indent-style = "space"
{{/if}}

[tool.pytest.ini_options]
testpaths = ["tests"]
asyncio_mode = "auto"
`],
  ["python-base/_gitignore", `# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]
*$py.class

# C extensions
*.so

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg

# PyInstaller
*.manifest
*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/

# Translations
*.mo
*.pot

# Environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# Spyder project settings
.spyderproject
.spyproject

# Rope project settings
.ropeproject

# mkdocs documentation
/site

# mypy
.mypy_cache/
.dmypy.json
dmypy.json

# Pyre type checker
.pyre/

# pytype static type analyzer
.pytype/

# Cython debug symbols
cython_debug/

# uv
.uv/
uv.lock

# IDE
.idea/
.vscode/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db
`],
  ["extras/env.d.ts.hbs", `import { type server } from "@{{projectName}}/infra/alchemy.run";

// This file infers types for the cloudflare:workers environment from your Alchemy Worker.
// @see https://alchemy.run/concepts/bindings/#type-safe-bindings

export type CloudflareEnv = typeof server.Env;

declare global {
  type Env = CloudflareEnv;
}

declare module "cloudflare:workers" {
  namespace Cloudflare {
    export interface Env extends CloudflareEnv {}
  }
}
`],
  ["extras/bunfig.toml.hbs", `[install]
{{#if (or (includes frontend "nuxt"))}}
linker = "hoisted" # having issues with Nuxt when linker is isolated
{{else}}
linker = "isolated"
{{/if}}`],
  ["extras/pnpm-workspace.yaml", `packages:
  - "apps/*"
  - "packages/*"
`],
  ["extras/_npmrc.hbs", `node-linker=isolated
{{#if (includes frontend "nuxt")}}
shamefully-hoist=true
strict-peer-dependencies=false
{{/if}}`],
  ["go-base/sqlc.yaml.hbs", `{{#if (eq goOrm "sqlc")}}
version: "2"
sql:
  - engine: "postgresql"
    queries: "sql/queries/"
    schema: "sql/schema/"
    gen:
      go:
        package: "db"
        out: "internal/db"
        sql_package: "pgx/v5"
        emit_json_tags: true
        emit_empty_slices: true
        emit_result_struct_pointers: true
{{/if}}
`],
  ["go-base/.env.example", `# Application settings
HOST=0.0.0.0
PORT=8080

# Database settings (if using GORM or sqlc)
DATABASE_URL=postgres://user:password@localhost:5432/dbname?sslmode=disable

# gRPC settings (if using gRPC)
GRPC_PORT=50051

# Logging level
LOG_LEVEL=debug
`],
  ["go-base/go.mod.hbs", `module {{projectName}}

go 1.22

require (
{{#if (eq goWebFramework "gin")}}
	github.com/gin-gonic/gin v1.10.0
{{/if}}
{{#if (eq goWebFramework "echo")}}
	github.com/labstack/echo/v4 v4.12.0
{{/if}}
{{#if (eq goOrm "gorm")}}
	gorm.io/gorm v1.25.12
	gorm.io/driver/sqlite v1.5.7
	gorm.io/driver/postgres v1.5.11
{{/if}}
{{#if (eq goOrm "sqlc")}}
	github.com/jackc/pgx/v5 v5.7.2
{{/if}}
{{#if (eq goApi "grpc-go")}}
	google.golang.org/grpc v1.69.4
	google.golang.org/protobuf v1.36.3
{{/if}}
{{#if (eq goCli "cobra")}}
	github.com/spf13/cobra v1.8.1
{{/if}}
{{#if (eq goCli "bubbletea")}}
	github.com/charmbracelet/bubbletea v1.2.4
	github.com/charmbracelet/lipgloss v1.0.0
{{/if}}
{{#if (eq goLogging "zap")}}
	go.uber.org/zap v1.27.0
{{/if}}
	github.com/joho/godotenv v1.5.1
)
`],
  ["go-base/_gitignore", `# Binaries
*.exe
*.exe~
*.dll
*.so
*.dylib
/bin/

# Test binary
*.test

# Output of the go coverage tool
*.out

# Dependency directories
/vendor/

# Go workspace file
go.work
go.work.sum

# IDE specific files
.idea/
.vscode/
*.swp
*.swo

# Environment files
.env
.env.local
.env.*.local

# Build output
/dist/
/build/

# SQLite database files
*.db
*.sqlite
*.sqlite3

# Logs
*.log
logs/

# OS generated files
.DS_Store
Thumbs.db
`],
  ["rust-base/.env.example", `# Application
RUST_LOG=debug
APP_ENV=development

# Server
HOST=127.0.0.1
PORT=3000

# gRPC (if using tonic)
# GRPC_PORT=50051

# Database (if using)
# DATABASE_URL=postgres://user:password@localhost:5432/dbname
# DATABASE_URL=sqlite:./data.db

# JWT Secret (if using jsonwebtoken)
# JWT_SECRET=your-secret-key-here
`],
  ["rust-base/Cargo.toml.hbs", `[workspace]
resolver = "2"
members = [
    "crates/server",
{{#if (eq rustApi "tonic")}}
    "crates/proto",
{{/if}}
{{#if (eq rustFrontend "leptos")}}
    "crates/client",
{{/if}}
{{#if (eq rustFrontend "dioxus")}}
    "crates/dioxus-client",
{{/if}}
{{#if (eq rustCli "clap")}}
    "crates/cli",
{{/if}}
{{#if (eq rustCli "ratatui")}}
    "crates/tui",
{{/if}}
]

[workspace.package]
version = "0.1.0"
edition = "2021"
authors = ["Your Name <your.email@example.com>"]
license = "MIT"
repository = ""

[workspace.dependencies]
# Async runtime
tokio = { version = "1.43", features = ["full"] }

# Serialization
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"

# Error handling
thiserror = "2.0"
anyhow = "1.0"

# Logging
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter"] }

# Environment variables
dotenvy = "0.15"

{{#if (eq rustWebFramework "axum")}}
# Web framework (Axum)
axum = "0.8"
tower = "0.5"
tower-http = { version = "0.6", features = ["cors", "trace"] }
{{/if}}
{{#if (eq rustWebFramework "actix-web")}}
# Web framework (Actix-web)
actix-web = "4"
actix-rt = "2"
actix-cors = "0.7"
{{/if}}

{{#if (eq rustOrm "sqlx")}}
# Database (SQLx)
sqlx = { version = "0.8", features = ["runtime-tokio", "postgres", "sqlite", "mysql", "migrate"] }
{{/if}}
{{#if (eq rustOrm "sea-orm")}}
# Database (SeaORM)
sea-orm = { version = "1.1", features = ["runtime-tokio-rustls", "sqlx-postgres", "sqlx-sqlite", "sqlx-mysql"] }
sea-orm-migration = "1.1"
{{/if}}

{{#if (eq rustApi "tonic")}}
# gRPC (Tonic)
tonic = "0.12"
tonic-build = "0.12"
prost = "0.13"
{{/if}}
{{#if (eq rustApi "async-graphql")}}
# GraphQL (async-graphql)
async-graphql = "7"
{{#if (eq rustWebFramework "axum")}}
async-graphql-axum = "7"
{{/if}}
{{#if (eq rustWebFramework "actix-web")}}
async-graphql-actix-web = "7"
{{/if}}
{{/if}}

{{#if (eq rustFrontend "leptos")}}
# Frontend (Leptos)
leptos = { version = "0.7", features = ["csr"] }
leptos_router = { version = "0.7", features = ["csr"] }
leptos_meta = { version = "0.7", features = ["csr"] }
console_error_panic_hook = "0.1"
console_log = "1"
log = "0.4"
wasm-bindgen = "0.2"
wasm-bindgen-futures = "0.4"
web-sys = { version = "0.3", features = ["Window", "Document", "Element", "HtmlElement", "console"] }
{{/if}}
{{#if (eq rustFrontend "dioxus")}}
# Frontend (Dioxus)
dioxus = { version = "0.6", features = ["router"] }
dioxus-router = "0.6"
dioxus-logger = "0.6"
console_error_panic_hook = "0.1"
wasm-bindgen = "0.2"
{{/if}}

{{#if (eq rustCli "clap")}}
# CLI (Clap)
clap = { version = "4", features = ["derive"] }
{{/if}}
{{#if (eq rustCli "ratatui")}}
# TUI (Ratatui)
ratatui = "0.29"
crossterm = "0.28"
tracing-appender = "0.2"
{{/if}}

{{#if (includes rustLibraries "validator")}}
# Validation
validator = { version = "0.19", features = ["derive"] }
{{/if}}
{{#if (includes rustLibraries "jsonwebtoken")}}
# JWT
jsonwebtoken = "9"
{{/if}}
{{#if (includes rustLibraries "argon2")}}
# Password hashing
argon2 = "0.5"
{{/if}}
{{#if (includes rustLibraries "tokio-test")}}
# Testing
tokio-test = "0.4"
{{/if}}
{{#if (includes rustLibraries "mockall")}}
# Mocking
mockall = "0.13"
{{/if}}

[profile.dev]
opt-level = 0

[profile.release]
opt-level = 3
lto = true
codegen-units = 1
`],
  ["rust-base/rust-toolchain.toml.hbs", `[toolchain]
channel = "stable"
components = ["rustfmt", "clippy"]
{{#if (or (eq rustFrontend "leptos") (eq rustFrontend "dioxus"))}}
targets = ["wasm32-unknown-unknown"]
{{/if}}
`],
  ["rust-base/_gitignore", `# Generated by Cargo
/target/
Cargo.lock

# IDE
.idea/
.vscode/
*.swp
*.swo
*~

# OS
.DS_Store
Thumbs.db

# Environment
.env
.env.local
.env.*.local

# Build artifacts
*.pdb

# Debug
debug/

# Documentation (generated)
/target/doc/
`],
  ["base/package.json.hbs", `{
  "name": "better-fullstack",
  "private": true,
  "type": "module",
  "workspaces": [
    "apps/*",
    "packages/*"
  ],
  "scripts": {}
}
`],
  ["base/tsconfig.json.hbs", `{
  "extends": "@{{projectName}}/config/tsconfig.base.json",
}
`],
  ["base/_gitignore", `# Dependencies
node_modules
.pnp
.pnp.js

# Build outputs
dist
build
*.tsbuildinfo

# Environment variables
.env
.env*.local

# IDEs and editors
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json
.idea
*.swp
*.swo
*~
.DS_Store

# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Turbo
.turbo

# Better Fullstack
.alchemy

# Testing
coverage
.nyc_output

# Misc
*.tgz
.cache
tmp
temp`],
  ["python-base/migrations/env.py.hbs", `{{#if (ne pythonOrm "none")}}
{{#if (or (eq pythonOrm "sqlalchemy") (eq pythonOrm "sqlmodel"))}}
"""Alembic migration environment configuration."""

import os
from logging.config import fileConfig

from alembic import context
from dotenv import load_dotenv
from sqlalchemy import engine_from_config, pool
{{#if (eq pythonOrm "sqlmodel")}}
from sqlmodel import SQLModel
{{/if}}

# Load environment variables
load_dotenv()

# this is the Alembic Config object, which provides
# access to the values within the .ini file in use.
config = context.config

# Override sqlalchemy.url from environment
config.set_main_option("sqlalchemy.url", os.getenv("DATABASE_URL", "sqlite:///./app.db"))

# Interpret the config file for Python logging.
# This line sets up loggers basically.
if config.config_file_name is not None:
    fileConfig(config.config_file_name)

# add your model's MetaData object here
# for 'autogenerate' support
{{#if (eq pythonOrm "sqlalchemy")}}
from app.models import Base

target_metadata = Base.metadata
{{/if}}
{{#if (eq pythonOrm "sqlmodel")}}
from app import models  # noqa: F401 - Import to register models

target_metadata = SQLModel.metadata
{{/if}}

# other values from the config, defined by the needs of env.py,
# can be acquired:
# my_important_option = config.get_main_option("my_important_option")
# ... etc.


def run_migrations_offline() -> None:
    """Run migrations in 'offline' mode.

    This configures the context with just a URL
    and not an Engine, though an Engine is acceptable
    here as well.  By skipping the Engine creation
    we don't even need a DBAPI to be available.

    Calls to context.execute() here emit the given string to the
    script output.

    """
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )

    with context.begin_transaction():
        context.run_migrations()


def run_migrations_online() -> None:
    """Run migrations in 'online' mode.

    In this scenario we need to create an Engine
    and associate a connection with the context.

    """
    connectable = engine_from_config(
        config.get_section(config.config_ini_section, {}),
        prefix="sqlalchemy.",
        poolclass=pool.NullPool,
    )

    with connectable.connect() as connection:
        context.configure(connection=connection, target_metadata=target_metadata)

        with context.begin_transaction():
            context.run_migrations()


if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()
{{/if}}
{{/if}}
`],
  ["python-base/migrations/script.py.mako.hbs", `{{#if (ne pythonOrm "none")}}
{{#if (or (eq pythonOrm "sqlalchemy") (eq pythonOrm "sqlmodel"))}}
"""\${message}

Revision ID: \${up_revision}
Revises: \${down_revision | comma,n}
Create Date: \${create_date}

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
\${imports if imports else ""}

# revision identifiers, used by Alembic.
revision: str = \${repr(up_revision)}
down_revision: Union[str, None] = \${repr(down_revision)}
branch_labels: Union[str, Sequence[str], None] = \${repr(branch_labels)}
depends_on: Union[str, Sequence[str], None] = \${repr(depends_on)}


def upgrade() -> None:
    \${upgrades if upgrades else "pass"}


def downgrade() -> None:
    \${downgrades if downgrades else "pass"}
{{/if}}
{{/if}}
`],
  ["python-base/tests/test_main.py.hbs", `"""Tests for main application."""

{{#if (eq pythonWebFramework "fastapi")}}
import pytest
from fastapi.testclient import TestClient

from app.main import app


@pytest.fixture
def client():
    """Create a test client."""
    return TestClient(app)


def test_root(client):
    """Test root endpoint."""
    response = client.get("/")
    assert response.status_code == 200
    assert response.json() == {"message": "Welcome to {{projectName}}!"}


def test_health(client):
    """Test health endpoint."""
    response = client.get("/health")
    assert response.status_code == 200
    assert response.json() == {"status": "healthy"}
{{#if (includes pythonAi "langchain")}}


def test_langchain_chat_endpoint_validation(client):
    """Test LangChain chat endpoint validates request body."""
    # Test missing message field
    response = client.post("/ai/chat", json={})
    assert response.status_code == 422


def test_langchain_chat_endpoint_with_history_validation(client):
    """Test LangChain chat endpoint validates history format."""
    # Test with invalid history format (missing required fields)
    response = client.post(
        "/ai/chat",
        json={
            "message": "Hello",
            "history": [{"invalid": "field"}],
        },
    )
    assert response.status_code == 422


def test_langchain_completion_endpoint_validation(client):
    """Test LangChain completion endpoint validates request body."""
    # Test missing prompt field
    response = client.post("/ai/completion", json={})
    assert response.status_code == 422


def test_langchain_completion_temperature_validation(client):
    """Test LangChain completion endpoint validates temperature range."""
    # Test temperature out of range
    response = client.post(
        "/ai/completion",
        json={"prompt": "Hello", "temperature": 3.0},
    )
    assert response.status_code == 422
{{/if}}
{{#if (includes pythonAi "llamaindex")}}


def test_llamaindex_chat_endpoint_validation(client):
    """Test LlamaIndex chat endpoint validates request body."""
    # Test missing message field
    response = client.post("/ai/llamaindex/chat", json={})
    assert response.status_code == 422


def test_llamaindex_chat_endpoint_with_history_validation(client):
    """Test LlamaIndex chat endpoint validates history format."""
    # Test with invalid history format (missing required fields)
    response = client.post(
        "/ai/llamaindex/chat",
        json={
            "message": "Hello",
            "history": [{"invalid": "field"}],
        },
    )
    assert response.status_code == 422


def test_llamaindex_completion_endpoint_validation(client):
    """Test LlamaIndex completion endpoint validates request body."""
    # Test missing prompt field
    response = client.post("/ai/llamaindex/completion", json={})
    assert response.status_code == 422


def test_llamaindex_completion_temperature_validation(client):
    """Test LlamaIndex completion endpoint validates temperature range."""
    # Test temperature out of range
    response = client.post(
        "/ai/llamaindex/completion",
        json={"prompt": "Hello", "temperature": 3.0},
    )
    assert response.status_code == 422
{{/if}}
{{#if (includes pythonAi "openai-sdk")}}


def test_openai_chat_endpoint_validation(client):
    """Test OpenAI chat endpoint validates request body."""
    # Test missing message field
    response = client.post("/ai/openai/chat", json={})
    assert response.status_code == 422


def test_openai_chat_endpoint_with_history_validation(client):
    """Test OpenAI chat endpoint validates history format."""
    # Test with invalid history format (missing required fields)
    response = client.post(
        "/ai/openai/chat",
        json={
            "message": "Hello",
            "history": [{"invalid": "field"}],
        },
    )
    assert response.status_code == 422


def test_openai_completion_endpoint_validation(client):
    """Test OpenAI completion endpoint validates request body."""
    # Test missing prompt field
    response = client.post("/ai/openai/completion", json={})
    assert response.status_code == 422


def test_openai_completion_temperature_validation(client):
    """Test OpenAI completion endpoint validates temperature range."""
    # Test temperature out of range
    response = client.post(
        "/ai/openai/completion",
        json={"prompt": "Hello", "temperature": 3.0},
    )
    assert response.status_code == 422
{{/if}}
{{#if (includes pythonAi "anthropic-sdk")}}


def test_anthropic_chat_endpoint_validation(client):
    """Test Anthropic chat endpoint validates request body."""
    # Test missing message field
    response = client.post("/ai/anthropic/chat", json={})
    assert response.status_code == 422


def test_anthropic_chat_endpoint_with_history_validation(client):
    """Test Anthropic chat endpoint validates history format."""
    # Test with invalid history format (missing required fields)
    response = client.post(
        "/ai/anthropic/chat",
        json={
            "message": "Hello",
            "history": [{"invalid": "field"}],
        },
    )
    assert response.status_code == 422


def test_anthropic_completion_endpoint_validation(client):
    """Test Anthropic completion endpoint validates request body."""
    # Test missing prompt field
    response = client.post("/ai/anthropic/completion", json={})
    assert response.status_code == 422


def test_anthropic_completion_temperature_validation(client):
    """Test Anthropic completion endpoint validates temperature range."""
    # Test temperature out of range (Anthropic max is 1.0)
    response = client.post(
        "/ai/anthropic/completion",
        json={"prompt": "Hello", "temperature": 1.5},
    )
    assert response.status_code == 422
{{/if}}
{{#if (includes pythonAi "langgraph")}}


def test_langgraph_chat_endpoint_validation(client):
    """Test LangGraph chat endpoint validates request body."""
    # Test missing message field
    response = client.post("/ai/langgraph/chat", json={})
    assert response.status_code == 422


def test_langgraph_chat_endpoint_with_history_validation(client):
    """Test LangGraph chat endpoint validates history format."""
    # Test with invalid history format (missing required fields)
    response = client.post(
        "/ai/langgraph/chat",
        json={
            "message": "Hello",
            "history": [{"invalid": "field"}],
        },
    )
    assert response.status_code == 422


def test_langgraph_agent_endpoint_validation(client):
    """Test LangGraph agent endpoint validates request body."""
    # Test missing message field
    response = client.post("/ai/langgraph/agent", json={})
    assert response.status_code == 422


def test_langgraph_agent_max_iterations_validation(client):
    """Test LangGraph agent endpoint validates max_iterations range."""
    # Test max_iterations out of range
    response = client.post(
        "/ai/langgraph/agent",
        json={"message": "Hello", "max_iterations": 100},
    )
    assert response.status_code == 422


def test_langgraph_completion_endpoint_validation(client):
    """Test LangGraph completion endpoint validates request body."""
    # Test missing prompt field
    response = client.post("/ai/langgraph/completion", json={})
    assert response.status_code == 422


def test_langgraph_completion_temperature_validation(client):
    """Test LangGraph completion endpoint validates temperature range."""
    # Test temperature out of range
    response = client.post(
        "/ai/langgraph/completion",
        json={"prompt": "Hello", "temperature": 3.0},
    )
    assert response.status_code == 422
{{/if}}
{{#if (includes pythonAi "crewai")}}


def test_crewai_research_endpoint_validation(client):
    """Test CrewAI research endpoint validates request body."""
    # Test missing topic field
    response = client.post("/ai/crewai/research", json={})
    assert response.status_code == 422


def test_crewai_research_endpoint_empty_topic_validation(client):
    """Test CrewAI research endpoint validates topic is not empty."""
    # Test with empty topic
    response = client.post(
        "/ai/crewai/research",
        json={"topic": ""},
    )
    assert response.status_code == 422


def test_crewai_analysis_endpoint_validation(client):
    """Test CrewAI analysis endpoint validates request body."""
    # Test missing data field
    response = client.post("/ai/crewai/analysis", json={})
    assert response.status_code == 422


def test_crewai_analysis_endpoint_empty_data_validation(client):
    """Test CrewAI analysis endpoint validates data is not empty."""
    # Test with empty data
    response = client.post(
        "/ai/crewai/analysis",
        json={"data": ""},
    )
    assert response.status_code == 422


def test_crewai_custom_endpoint_validation(client):
    """Test CrewAI custom endpoint validates request body."""
    # Test missing required fields
    response = client.post("/ai/crewai/custom", json={})
    assert response.status_code == 422


def test_crewai_custom_endpoint_missing_expected_output_validation(client):
    """Test CrewAI custom endpoint validates expected_output is required."""
    # Test missing expected_output
    response = client.post(
        "/ai/crewai/custom",
        json={"task_description": "Do something"},
    )
    assert response.status_code == 422


def test_crewai_completion_endpoint_validation(client):
    """Test CrewAI completion endpoint validates request body."""
    # Test missing prompt field
    response = client.post("/ai/crewai/completion", json={})
    assert response.status_code == 422


def test_crewai_completion_endpoint_empty_prompt_validation(client):
    """Test CrewAI completion endpoint validates prompt is not empty."""
    # Test with empty prompt
    response = client.post(
        "/ai/crewai/completion",
        json={"prompt": ""},
    )
    assert response.status_code == 422
{{/if}}
{{#if (and (eq pythonOrm "none") (eq pythonValidation "pydantic"))}}


def test_create_item(client):
    """Test creating an item with valid data."""
    response = client.post(
        "/items",
        json={"name": "Test Item", "description": "A test item", "price": 9.99, "quantity": 5},
    )
    assert response.status_code == 201
    data = response.json()
    assert data["name"] == "Test Item"
    assert data["price"] == 9.99
    assert data["quantity"] == 5
    assert "id" in data


def test_create_item_validation_error(client):
    """Test validation error for invalid item data."""
    # Price must be positive
    response = client.post(
        "/items",
        json={"name": "Test Item", "price": -1.0},
    )
    assert response.status_code == 422


def test_create_item_missing_required_field(client):
    """Test validation error for missing required field."""
    response = client.post(
        "/items",
        json={"description": "No name or price"},
    )
    assert response.status_code == 422


def test_list_items(client):
    """Test listing items."""
    # Create an item first
    client.post("/items", json={"name": "Item 1", "price": 10.0})
    response = client.get("/items")
    assert response.status_code == 200
    assert isinstance(response.json(), list)


def test_get_item_not_found(client):
    """Test getting non-existent item."""
    response = client.get("/items/99999")
    assert response.status_code == 404


def test_send_message(client):
    """Test sending a contact message with validated email."""
    response = client.post(
        "/contact",
        json={
            "email": "test@example.com",
            "subject": "Test Subject",
            "content": "Test message content",
        },
    )
    assert response.status_code == 200
    data = response.json()
    assert data["success"] is True
    assert "test@example.com" in data["message"]


def test_send_message_invalid_email(client):
    """Test validation error for invalid email."""
    response = client.post(
        "/contact",
        json={
            "email": "not-an-email",
            "subject": "Test Subject",
            "content": "Test message content",
        },
    )
    assert response.status_code == 422
{{/if}}
{{/if}}
{{#if (eq pythonWebFramework "django")}}
import pytest
from django.test import Client


@pytest.fixture
def client():
    """Create a test client."""
    return Client()


def test_root(client):
    """Test root endpoint."""
    response = client.get("/")
    assert response.status_code == 200
    assert response.json() == {"message": "Welcome to {{projectName}}!"}


def test_health(client):
    """Test health endpoint."""
    response = client.get("/health")
    assert response.status_code == 200
    assert response.json() == {"status": "healthy"}
{{/if}}
{{#if (eq pythonWebFramework "none")}}
def test_main():
    """Test main module imports correctly."""
    from app import main

    assert main is not None
{{/if}}
`],
  ["python-base/tests/test_database.py.hbs", `{{#if (ne pythonOrm "none")}}
{{#if (eq pythonOrm "sqlalchemy")}}
"""Tests for database models and CRUD operations."""

import pytest
from sqlalchemy import create_engine
from sqlalchemy.orm import Session, sessionmaker
from sqlalchemy.pool import StaticPool

from app import crud
from app.models import Base, Post, User
{{#if (eq pythonValidation "pydantic")}}
from app.schemas import PostCreate, PostUpdate, UserCreate, UserUpdate
{{/if}}


@pytest.fixture
def db_session():
    """Create a test database session."""
    # Use in-memory SQLite for testing
    engine = create_engine(
        "sqlite:///:memory:",
        connect_args={"check_same_thread": False},
        poolclass=StaticPool,
    )
    Base.metadata.create_all(bind=engine)
    TestingSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
    session = TestingSessionLocal()
    try:
        yield session
    finally:
        session.close()
        Base.metadata.drop_all(bind=engine)


class TestUserModel:
    """Tests for User model."""

    def test_create_user(self, db_session: Session):
        """Test creating a user."""
        user = User(email="test@example.com", name="Test User")
        db_session.add(user)
        db_session.commit()
        db_session.refresh(user)

        assert user.id is not None
        assert user.email == "test@example.com"
        assert user.name == "Test User"
        assert user.created_at is not None
        assert user.updated_at is not None

    def test_user_repr(self, db_session: Session):
        """Test User string representation."""
        user = User(email="test@example.com")
        db_session.add(user)
        db_session.commit()

        assert "test@example.com" in repr(user)


class TestPostModel:
    """Tests for Post model."""

    def test_create_post(self, db_session: Session):
        """Test creating a post."""
        user = User(email="author@example.com")
        db_session.add(user)
        db_session.commit()

        post = Post(title="Test Post", content="Test content", author_id=user.id)
        db_session.add(post)
        db_session.commit()
        db_session.refresh(post)

        assert post.id is not None
        assert post.title == "Test Post"
        assert post.content == "Test content"
        assert post.author_id == user.id
        assert post.created_at is not None
        assert post.updated_at is not None

    def test_post_repr(self, db_session: Session):
        """Test Post string representation."""
        post = Post(title="Test Title", author_id=1)
        db_session.add(post)
        db_session.commit()

        assert "Test Title" in repr(post)


class TestUserCrud:
    """Tests for User CRUD operations."""

{{#if (eq pythonValidation "pydantic")}}
    def test_create_user(self, db_session: Session):
        """Test creating a user via CRUD."""
        user_data = UserCreate(email="crud@example.com", name="CRUD User")
        user = crud.create_user(db_session, user_data)

        assert user.id is not None
        assert user.email == "crud@example.com"
        assert user.name == "CRUD User"
{{else}}
    def test_create_user(self, db_session: Session):
        """Test creating a user via CRUD."""
        user = crud.create_user(db_session, email="crud@example.com", name="CRUD User")

        assert user.id is not None
        assert user.email == "crud@example.com"
        assert user.name == "CRUD User"
{{/if}}

    def test_get_user(self, db_session: Session):
        """Test getting a user by ID."""
        user = User(email="get@example.com")
        db_session.add(user)
        db_session.commit()

        result = crud.get_user(db_session, user.id)
        assert result is not None
        assert result.email == "get@example.com"

    def test_get_user_not_found(self, db_session: Session):
        """Test getting a non-existent user."""
        result = crud.get_user(db_session, 999)
        assert result is None

    def test_get_user_by_email(self, db_session: Session):
        """Test getting a user by email."""
        user = User(email="email@example.com")
        db_session.add(user)
        db_session.commit()

        result = crud.get_user_by_email(db_session, "email@example.com")
        assert result is not None
        assert result.id == user.id

    def test_get_users(self, db_session: Session):
        """Test listing users with pagination."""
        for i in range(5):
            db_session.add(User(email=f"user{i}@example.com"))
        db_session.commit()

        # Test default pagination
        users = crud.get_users(db_session)
        assert len(users) == 5

        # Test with limit
        users = crud.get_users(db_session, limit=2)
        assert len(users) == 2

        # Test with skip
        users = crud.get_users(db_session, skip=3)
        assert len(users) == 2

{{#if (eq pythonValidation "pydantic")}}
    def test_update_user(self, db_session: Session):
        """Test updating a user."""
        user = User(email="old@example.com", name="Old Name")
        db_session.add(user)
        db_session.commit()

        update_data = UserUpdate(name="New Name")
        updated = crud.update_user(db_session, user.id, update_data)

        assert updated is not None
        assert updated.name == "New Name"
        assert updated.email == "old@example.com"

    def test_update_user_not_found(self, db_session: Session):
        """Test updating a non-existent user."""
        update_data = UserUpdate(name="New Name")
        result = crud.update_user(db_session, 999, update_data)
        assert result is None
{{else}}
    def test_update_user(self, db_session: Session):
        """Test updating a user."""
        user = User(email="old@example.com", name="Old Name")
        db_session.add(user)
        db_session.commit()

        updated = crud.update_user(db_session, user.id, name="New Name")

        assert updated is not None
        assert updated.name == "New Name"
        assert updated.email == "old@example.com"

    def test_update_user_not_found(self, db_session: Session):
        """Test updating a non-existent user."""
        result = crud.update_user(db_session, 999, name="New Name")
        assert result is None
{{/if}}

    def test_delete_user(self, db_session: Session):
        """Test deleting a user."""
        user = User(email="delete@example.com")
        db_session.add(user)
        db_session.commit()

        result = crud.delete_user(db_session, user.id)
        assert result is True
        assert crud.get_user(db_session, user.id) is None

    def test_delete_user_not_found(self, db_session: Session):
        """Test deleting a non-existent user."""
        result = crud.delete_user(db_session, 999)
        assert result is False


class TestPostCrud:
    """Tests for Post CRUD operations."""

{{#if (eq pythonValidation "pydantic")}}
    def test_create_post(self, db_session: Session):
        """Test creating a post via CRUD."""
        user = User(email="author@example.com")
        db_session.add(user)
        db_session.commit()

        post_data = PostCreate(title="CRUD Post", content="Content", author_id=user.id)
        post = crud.create_post(db_session, post_data)

        assert post.id is not None
        assert post.title == "CRUD Post"
        assert post.author_id == user.id
{{else}}
    def test_create_post(self, db_session: Session):
        """Test creating a post via CRUD."""
        user = User(email="author@example.com")
        db_session.add(user)
        db_session.commit()

        post = crud.create_post(db_session, title="CRUD Post", author_id=user.id, content="Content")

        assert post.id is not None
        assert post.title == "CRUD Post"
        assert post.author_id == user.id
{{/if}}

    def test_get_post(self, db_session: Session):
        """Test getting a post by ID."""
        post = Post(title="Get Post", author_id=1)
        db_session.add(post)
        db_session.commit()

        result = crud.get_post(db_session, post.id)
        assert result is not None
        assert result.title == "Get Post"

    def test_get_posts(self, db_session: Session):
        """Test listing posts with pagination."""
        for i in range(5):
            db_session.add(Post(title=f"Post {i}", author_id=1))
        db_session.commit()

        posts = crud.get_posts(db_session)
        assert len(posts) == 5

        posts = crud.get_posts(db_session, limit=2)
        assert len(posts) == 2

    def test_get_posts_by_author(self, db_session: Session):
        """Test getting posts by author."""
        db_session.add(Post(title="Author 1 Post", author_id=1))
        db_session.add(Post(title="Author 2 Post", author_id=2))
        db_session.add(Post(title="Author 1 Post 2", author_id=1))
        db_session.commit()

        posts = crud.get_posts_by_author(db_session, 1)
        assert len(posts) == 2

{{#if (eq pythonValidation "pydantic")}}
    def test_update_post(self, db_session: Session):
        """Test updating a post."""
        post = Post(title="Old Title", author_id=1)
        db_session.add(post)
        db_session.commit()

        update_data = PostUpdate(title="New Title")
        updated = crud.update_post(db_session, post.id, update_data)

        assert updated is not None
        assert updated.title == "New Title"
{{else}}
    def test_update_post(self, db_session: Session):
        """Test updating a post."""
        post = Post(title="Old Title", author_id=1)
        db_session.add(post)
        db_session.commit()

        updated = crud.update_post(db_session, post.id, title="New Title")

        assert updated is not None
        assert updated.title == "New Title"
{{/if}}

    def test_delete_post(self, db_session: Session):
        """Test deleting a post."""
        post = Post(title="Delete Post", author_id=1)
        db_session.add(post)
        db_session.commit()

        result = crud.delete_post(db_session, post.id)
        assert result is True
        assert crud.get_post(db_session, post.id) is None
{{/if}}
{{#if (eq pythonOrm "sqlmodel")}}
"""Tests for SQLModel models and CRUD operations."""

import pytest
from sqlmodel import Session, SQLModel, create_engine
from sqlmodel.pool import StaticPool

from app import crud
from app.models import Post, PostCreate, PostUpdate, User, UserCreate, UserUpdate


@pytest.fixture
def db_session():
    """Create a test database session."""
    # Use in-memory SQLite for testing
    engine = create_engine(
        "sqlite:///:memory:",
        connect_args={"check_same_thread": False},
        poolclass=StaticPool,
    )
    SQLModel.metadata.create_all(engine)
    with Session(engine) as session:
        yield session
    SQLModel.metadata.drop_all(engine)


class TestUserModel:
    """Tests for User model."""

    def test_create_user(self, db_session: Session):
        """Test creating a user."""
        user = User(email="test@example.com", name="Test User")
        db_session.add(user)
        db_session.commit()
        db_session.refresh(user)

        assert user.id is not None
        assert user.email == "test@example.com"
        assert user.name == "Test User"
        assert user.created_at is not None
        assert user.updated_at is not None

    def test_user_model_validation(self):
        """Test User model validation."""
        # Valid email
        user = UserCreate(email="valid@example.com", name="Test")
        assert user.email == "valid@example.com"


class TestPostModel:
    """Tests for Post model."""

    def test_create_post(self, db_session: Session):
        """Test creating a post."""
        user = User(email="author@example.com")
        db_session.add(user)
        db_session.commit()

        post = Post(title="Test Post", content="Test content", author_id=user.id)
        db_session.add(post)
        db_session.commit()
        db_session.refresh(post)

        assert post.id is not None
        assert post.title == "Test Post"
        assert post.content == "Test content"
        assert post.author_id == user.id
        assert post.created_at is not None
        assert post.updated_at is not None


class TestUserCrud:
    """Tests for User CRUD operations."""

    def test_create_user(self, db_session: Session):
        """Test creating a user via CRUD."""
        user_data = UserCreate(email="crud@example.com", name="CRUD User")
        user = crud.create_user(db_session, user_data)

        assert user.id is not None
        assert user.email == "crud@example.com"
        assert user.name == "CRUD User"

    def test_get_user(self, db_session: Session):
        """Test getting a user by ID."""
        user = User(email="get@example.com")
        db_session.add(user)
        db_session.commit()

        result = crud.get_user(db_session, user.id)
        assert result is not None
        assert result.email == "get@example.com"

    def test_get_user_not_found(self, db_session: Session):
        """Test getting a non-existent user."""
        result = crud.get_user(db_session, 999)
        assert result is None

    def test_get_user_by_email(self, db_session: Session):
        """Test getting a user by email."""
        user = User(email="email@example.com")
        db_session.add(user)
        db_session.commit()

        result = crud.get_user_by_email(db_session, "email@example.com")
        assert result is not None
        assert result.id == user.id

    def test_get_users(self, db_session: Session):
        """Test listing users with pagination."""
        for i in range(5):
            db_session.add(User(email=f"user{i}@example.com"))
        db_session.commit()

        # Test default pagination
        users = crud.get_users(db_session)
        assert len(users) == 5

        # Test with limit
        users = crud.get_users(db_session, limit=2)
        assert len(users) == 2

        # Test with skip
        users = crud.get_users(db_session, skip=3)
        assert len(users) == 2

    def test_update_user(self, db_session: Session):
        """Test updating a user."""
        user = User(email="old@example.com", name="Old Name")
        db_session.add(user)
        db_session.commit()

        update_data = UserUpdate(name="New Name")
        updated = crud.update_user(db_session, user.id, update_data)

        assert updated is not None
        assert updated.name == "New Name"
        assert updated.email == "old@example.com"

    def test_update_user_not_found(self, db_session: Session):
        """Test updating a non-existent user."""
        update_data = UserUpdate(name="New Name")
        result = crud.update_user(db_session, 999, update_data)
        assert result is None

    def test_delete_user(self, db_session: Session):
        """Test deleting a user."""
        user = User(email="delete@example.com")
        db_session.add(user)
        db_session.commit()

        result = crud.delete_user(db_session, user.id)
        assert result is True
        assert crud.get_user(db_session, user.id) is None

    def test_delete_user_not_found(self, db_session: Session):
        """Test deleting a non-existent user."""
        result = crud.delete_user(db_session, 999)
        assert result is False


class TestPostCrud:
    """Tests for Post CRUD operations."""

    def test_create_post(self, db_session: Session):
        """Test creating a post via CRUD."""
        user = User(email="author@example.com")
        db_session.add(user)
        db_session.commit()

        post_data = PostCreate(title="CRUD Post", content="Content", author_id=user.id)
        post = crud.create_post(db_session, post_data)

        assert post.id is not None
        assert post.title == "CRUD Post"
        assert post.author_id == user.id

    def test_get_post(self, db_session: Session):
        """Test getting a post by ID."""
        post = Post(title="Get Post", author_id=1)
        db_session.add(post)
        db_session.commit()

        result = crud.get_post(db_session, post.id)
        assert result is not None
        assert result.title == "Get Post"

    def test_get_posts(self, db_session: Session):
        """Test listing posts with pagination."""
        for i in range(5):
            db_session.add(Post(title=f"Post {i}", author_id=1))
        db_session.commit()

        posts = crud.get_posts(db_session)
        assert len(posts) == 5

        posts = crud.get_posts(db_session, limit=2)
        assert len(posts) == 2

    def test_get_posts_by_author(self, db_session: Session):
        """Test getting posts by author."""
        db_session.add(Post(title="Author 1 Post", author_id=1))
        db_session.add(Post(title="Author 2 Post", author_id=2))
        db_session.add(Post(title="Author 1 Post 2", author_id=1))
        db_session.commit()

        posts = crud.get_posts_by_author(db_session, 1)
        assert len(posts) == 2

    def test_update_post(self, db_session: Session):
        """Test updating a post."""
        post = Post(title="Old Title", author_id=1)
        db_session.add(post)
        db_session.commit()

        update_data = PostUpdate(title="New Title")
        updated = crud.update_post(db_session, post.id, update_data)

        assert updated is not None
        assert updated.title == "New Title"

    def test_delete_post(self, db_session: Session):
        """Test deleting a post."""
        post = Post(title="Delete Post", author_id=1)
        db_session.add(post)
        db_session.commit()

        result = crud.delete_post(db_session, post.id)
        assert result is True
        assert crud.get_post(db_session, post.id) is None
{{/if}}
{{/if}}
`],
  ["python-base/tests/__init__.py", `"""Test package."""
`],
  ["addons/lefthook/lefthook.yml.hbs", `# Lefthook configuration
# https://github.com/evilmartians/lefthook

pre-commit:
  parallel: true
  jobs:
{{#if (includes addons "biome")}}
    - name: biome
      glob: "*.{js,ts,cjs,mjs,d.cts,d.mts,jsx,tsx,json,jsonc}"
      run: {{packageManager}} biome check --write --no-errors-on-unmatched --files-ignore-unknown=true {staged_files}
      stage_fixed: true
{{else if (includes addons "oxlint")}}
    - name: oxlint
      run: {{packageManager}} oxlint --fix {staged_files}
      stage_fixed: true
    - name: oxfmt
      run: {{packageManager}} oxfmt --write {staged_files}
      stage_fixed: true
{{else}}
    # Add your pre-commit commands here
    # Example:
    # - name: lint
    #   run: {{packageManagerRunCmd}} lint
{{/if}}
`],
  ["addons/biome/biome.json.hbs", `{
    "$schema": "./node_modules/@biomejs/biome/configuration_schema.json",
	"vcs": {
		"enabled": false,
		"clientKind": "git",
		"useIgnoreFile": false
	},
	"files": {
		"ignoreUnknown": false,
		"includes": [
			"**",
			"!**/.next",
			"!**/dist",
			"!**/.turbo",
			"!**/dev-dist",
			"!**/.zed",
			"!**/.vscode",
			"!**/routeTree.gen.ts",
			"!**/src-tauri",
			"!**/.nuxt",
			"!bts.jsonc",
			"!**/.expo",
			"!**/.wrangler",
			"!**/.alchemy",
			"!**/.svelte-kit",
			"!**/wrangler.jsonc",
			"!**/.source",
			"!**/convex/_generated"
		]
	},
	"formatter": {
		"enabled": true,
		"indentStyle": "tab"
	},
	"assist": { "actions": { "source": { "organizeImports": "on" } } },
	"linter": {
		"enabled": true,
		"rules": {
			"recommended": true,
			"correctness": {
				"useExhaustiveDependencies": "info"
			},
			"nursery": {
				"useSortedClasses": {
					"level": "warn",
					"fix": "safe",
					"options": {
						"functions": ["clsx", "cva", "cn"]
					}
				}
			},
			"style": {
				"noParameterAssign": "error",
				"useAsConstAssertion": "error",
				"useDefaultParameterLast": "error",
				"useEnumInitializers": "error",
				"useSelfClosingElements": "error",
				"useSingleVarDeclarator": "error",
				"noUnusedTemplateLiteral": "error",
				"useNumberNamespace": "error",
				"noInferrableTypes": "error",
				"noUselessElse": "error"
			}
		}
	},
	"javascript": {
		"formatter": {
			"quoteStyle": "double"
		}
	},
	"css": {
		"parser": {
			"tailwindDirectives": true
		}
	}
	{{#if (or (includes frontend "svelte") (includes frontend "nuxt"))}}
	,
	"overrides": [
		{
			"includes": ["**/*.svelte", "**/*.vue"],
			"linter": {
				"rules": {
					"style": {
						"useConst": "off",
						"useImportType": "off"
					},
					"correctness": {
						"noUnusedVariables": "off",
						"noUnusedImports": "off"
					}
				}
			}
		}
	]
	{{/if}}
}
`],
  ["go-base/proto/greeter.proto.hbs", `{{#if (eq goApi "grpc-go")}}
syntax = "proto3";

package proto;

option go_package = "{{projectName}}/proto";

// The greeting service definition
service Greeter {
  // Sends a greeting
  rpc SayHello (HelloRequest) returns (HelloReply) {}
  // Sends multiple greetings
  rpc SayHelloStream (HelloRequest) returns (stream HelloReply) {}
}

// The request message containing the user's name
message HelloRequest {
  string name = 1;
}

// The response message containing the greeting
message HelloReply {
  string message = 1;
}
{{/if}}
`],
  ["go-base/proto/greeter.go.hbs", `{{#if (eq goApi "grpc-go")}}
package proto

import (
	"context"
	"fmt"
	"time"
)

// GreeterService implements the Greeter gRPC service
type GreeterService struct {
	UnimplementedGreeterServer
}

// SayHello implements the Greeter.SayHello RPC
func (s *GreeterService) SayHello(ctx context.Context, req *HelloRequest) (*HelloReply, error) {
	name := req.GetName()
	if name == "" {
		name = "World"
	}
	return &HelloReply{
		Message: fmt.Sprintf("Hello, %s!", name),
	}, nil
}

// SayHelloStream implements the Greeter.SayHelloStream RPC
func (s *GreeterService) SayHelloStream(req *HelloRequest, stream Greeter_SayHelloStreamServer) error {
	name := req.GetName()
	if name == "" {
		name = "World"
	}

	// Send 5 greetings with a small delay
	for i := 1; i <= 5; i++ {
		if err := stream.Send(&HelloReply{
			Message: fmt.Sprintf("Hello #%d, %s!", i, name),
		}); err != nil {
			return err
		}
		time.Sleep(500 * time.Millisecond)
	}

	return nil
}
{{/if}}
`],
  ["go-base/proto/greeter.pb.go.hbs", `{{#if (eq goApi "grpc-go")}}
// Code generated by protoc-gen-go. DO NOT EDIT.
// This is a placeholder file. Run \`protoc\` to regenerate.
//
// To generate Go code from the proto file, run:
//   protoc --go_out=. --go_opt=paths=source_relative \\
//     --go-grpc_out=. --go-grpc_opt=paths=source_relative \\
//     proto/greeter.proto
//
// Install protoc and the Go plugins:
//   brew install protobuf
//   go install google.golang.org/protobuf/cmd/protoc-gen-go@latest
//   go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest

package proto

// HelloRequest is the request message for SayHello
type HelloRequest struct {
	Name string \`json:"name"\`
}

func (x *HelloRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

// HelloReply is the response message for SayHello
type HelloReply struct {
	Message string \`json:"message"\`
}

func (x *HelloReply) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}
{{/if}}
`],
  ["go-base/proto/greeter_grpc.pb.go.hbs", `{{#if (eq goApi "grpc-go")}}
// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// This is a placeholder file. Run \`protoc\` to regenerate.
//
// To generate Go code from the proto file, run:
//   protoc --go_out=. --go_opt=paths=source_relative \\
//     --go-grpc_out=. --go-grpc_opt=paths=source_relative \\
//     proto/greeter.proto

package proto

import (
	"context"

	"google.golang.org/grpc"
)

// GreeterClient is the client API for Greeter service
type GreeterClient interface {
	SayHello(ctx context.Context, in *HelloRequest, opts ...grpc.CallOption) (*HelloReply, error)
	SayHelloStream(ctx context.Context, in *HelloRequest, opts ...grpc.CallOption) (Greeter_SayHelloStreamClient, error)
}

type greeterClient struct {
	cc grpc.ClientConnInterface
}

func NewGreeterClient(cc grpc.ClientConnInterface) GreeterClient {
	return &greeterClient{cc}
}

func (c *greeterClient) SayHello(ctx context.Context, in *HelloRequest, opts ...grpc.CallOption) (*HelloReply, error) {
	out := new(HelloReply)
	err := c.cc.Invoke(ctx, "/proto.Greeter/SayHello", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *greeterClient) SayHelloStream(ctx context.Context, in *HelloRequest, opts ...grpc.CallOption) (Greeter_SayHelloStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &Greeter_ServiceDesc.Streams[0], "/proto.Greeter/SayHelloStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &greeterSayHelloStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Greeter_SayHelloStreamClient interface {
	Recv() (*HelloReply, error)
	grpc.ClientStream
}

type greeterSayHelloStreamClient struct {
	grpc.ClientStream
}

func (x *greeterSayHelloStreamClient) Recv() (*HelloReply, error) {
	m := new(HelloReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// GreeterServer is the server API for Greeter service
type GreeterServer interface {
	SayHello(context.Context, *HelloRequest) (*HelloReply, error)
	SayHelloStream(*HelloRequest, Greeter_SayHelloStreamServer) error
	mustEmbedUnimplementedGreeterServer()
}

// UnimplementedGreeterServer must be embedded to have forward compatible implementations
type UnimplementedGreeterServer struct{}

func (UnimplementedGreeterServer) SayHello(context.Context, *HelloRequest) (*HelloReply, error) {
	return nil, nil
}

func (UnimplementedGreeterServer) SayHelloStream(*HelloRequest, Greeter_SayHelloStreamServer) error {
	return nil
}

func (UnimplementedGreeterServer) mustEmbedUnimplementedGreeterServer() {}

type Greeter_SayHelloStreamServer interface {
	Send(*HelloReply) error
	grpc.ServerStream
}

type greeterSayHelloStreamServer struct {
	grpc.ServerStream
}

func (x *greeterSayHelloStreamServer) Send(m *HelloReply) error {
	return x.ServerStream.SendMsg(m)
}

func RegisterGreeterServer(s grpc.ServiceRegistrar, srv GreeterServer) {
	s.RegisterService(&Greeter_ServiceDesc, srv)
}

var Greeter_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.Greeter",
	HandlerType: (*GreeterServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SayHello",
			Handler:    _Greeter_SayHello_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SayHelloStream",
			Handler:       _Greeter_SayHelloStream_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "proto/greeter.proto",
}

func _Greeter_SayHello_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HelloRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GreeterServer).SayHello(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Greeter/SayHello",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GreeterServer).SayHello(ctx, req.(*HelloRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Greeter_SayHelloStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(HelloRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(GreeterServer).SayHelloStream(m, &greeterSayHelloStreamServer{stream})
}
{{/if}}
`],
  ["frontend/qwik/package.json.hbs", `{
  "name": "web",
  "private": true,
  "type": "module",
  "scripts": {
    "build": "qwik build",
    "build.client": "vite build",
    "build.preview": "vite build --ssr src/entry.preview.tsx",
    "build.types": "tsc --incremental --noEmit",
    "dev": "vite --mode ssr",
    "dev.debug": "node --inspect-brk ./node_modules/vite/bin/vite.js --mode ssr --force",
    "preview": "qwik build preview && vite preview --open",
    "start": "vite --open --mode ssr",
    "qwik": "qwik"
  },
  "dependencies": {
    "@builder.io/qwik": "^1.14.1",
    "@builder.io/qwik-city": "^1.14.1"
  },
  "devDependencies": {
    "@types/node": "^22.13.14",
    "typescript": "^5.7.3",
    "vite": "^6.3.5",
    "vite-tsconfig-paths": "^5.1.4"
  }
}
`],
  ["frontend/qwik/tsconfig.json.hbs", `{
  "compilerOptions": {
    "allowJs": true,
    "target": "ES2021",
    "module": "ES2020",
    "lib": ["ES2021", "DOM", "DOM.Iterable"],
    "jsx": "react-jsx",
    "jsxImportSource": "@builder.io/qwik",
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "moduleResolution": "Bundler",
    "esModuleInterop": true,
    "skipLibCheck": true,
    "incremental": true,
    "isolatedModules": true,
    "outDir": "tmp",
    "noEmit": true,
    "types": ["node", "vite/client"],
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["src/**/*.ts", "src/**/*.tsx"]
}
`],
  ["frontend/qwik/vite.config.ts.hbs", `import { qwikVite } from "@builder.io/qwik/optimizer";
import { qwikCity } from "@builder.io/qwik-city/vite";
import { defineConfig } from "vite";
import tsconfigPaths from "vite-tsconfig-paths";

export default defineConfig(() => {
  return {
    plugins: [qwikCity(), qwikVite(), tsconfigPaths()],
    server: {
      port: 3001,
    },
    preview: {
      headers: {
        "Cache-Control": "public, max-age=600",
      },
    },
  };
});
`],
  ["frontend/qwik/_gitignore", `# Dependencies
node_modules

# Build outputs
dist
server
tmp

# Logs
*.log

# Editor directories and files
.idea
.vscode
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

# Local env files
.env
.env.local
.env.*.local

# Qwik specific
.vercel
.netlify
`],
  ["frontend/solid/package.json.hbs", `{
  "name": "web",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "vite dev",
    "build": "vite build",
    "serve": "vite preview",
    "test": "vitest run"
  },
  "dependencies": {
    "@tailwindcss/vite": "^4.1.13",
    "@tanstack/router-plugin": "^1.154.3",
    "@tanstack/solid-form": "^1.23.5",
    "@tanstack/solid-router": "^1.154.3",
    "lucide-solid": "^0.544.0",
    "solid-js": "^1.9.9",
    "tailwindcss": "^4.1.13"
  },
  "devDependencies": {
    "vite": "^7.1.5",
    "vite-plugin-solid": "^2.11.8"
  }
}
`],
  ["frontend/solid/index.html", `<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" href="/favicon.ico" />
    <meta name="theme-color" content="#000000" />
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
`],
  ["frontend/solid/tsconfig.json.hbs", `{
  "include": ["**/*.ts", "**/*.tsx"],
  "compilerOptions": {
    "target": "ES2022",
    "jsx": "preserve",
    "jsxImportSource": "solid-js",
    "module": "ESNext",
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "types": ["vite/client"],

    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "noEmit": true,

    "skipLibCheck": true,
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true,

    "rootDirs": ["."],
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  }
}
`],
  ["frontend/solid/vite.config.ts.hbs", `import { defineConfig } from "vite";
import { tanstackRouter } from "@tanstack/router-plugin/vite";
import solidPlugin from "vite-plugin-solid";
import tailwindcss from "@tailwindcss/vite";
import path from "node:path";

export default defineConfig({
  plugins: [
    tanstackRouter({ target: "solid", autoCodeSplitting: true }),
    solidPlugin(),
    tailwindcss(),
  ],
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "./src"),
    },
  },
  server: {
    port: 3001,
  },
});`],
  ["frontend/solid/_gitignore", `node_modules
.DS_Store
dist
dist-ssr
*.local
.env
.env.*

.wrangler
.alchemy
.dev.vars*`],
  ["frontend/redwood/graphql.config.js", `const { getPaths } = require("@redwoodjs/project-config");

const redwoodPaths = getPaths();

module.exports = {
  schema: redwoodPaths.generated.schema,
  documents: "./web/src/**/!(*.d).{ts,tsx,js,jsx}",
};
`],
  ["frontend/redwood/package.json.hbs", `{
  "name": "{{projectName}}",
  "private": true,
  "workspaces": {
    "packages": [
      "api",
      "web"
    ]
  },
  "devDependencies": {
    "@redwoodjs/core": "^8.8.0"
  },
  "eslintConfig": {
    "extends": "@redwoodjs/eslint-config",
    "root": true
  },
  "engines": {
    "node": ">=20.x"
  },
  "packageManager": "{{packageManager}}@latest"
}
`],
  ["frontend/redwood/redwood.toml.hbs", `# Redwood Configuration
# https://redwoodjs.com/docs/app-configuration-redwood-toml

[web]
  title = "{{projectName}}"
  port = 8910
  apiUrl = "/.redwood/functions"
  includeEnvironmentVariables = []

[api]
  port = 8911

[browser]
  open = true

[notifications]
  versionUpdates = ["latest"]
`],
  ["frontend/redwood/_gitignore", `# RedwoodJS
.redwood/
.netlify/
.vercel/
dist/
node_modules/
*.log

# Prisma
api/db/dev.db
api/db/dev.db-journal
api/db/migrations/

# Environment
.env
.env.local
.env.*.local

# IDE
.idea/
.vscode/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db

# Build
web/dist/
api/dist/
`],
  ["frontend/svelte/svelte.config.js.hbs", `import adapter from '@sveltejs/adapter-auto';
import { vitePreprocess } from '@sveltejs/vite-plugin-svelte';

/** @type {import('@sveltejs/kit').Config} */
const config = {
	// Consult https://svelte.dev/docs/kit/integrations
	// for more information about preprocessors
	preprocess: vitePreprocess(),

	kit: {
		// adapter-auto only supports some environments, see https://svelte.dev/docs/kit/adapter-auto for a list.
		// If your environment is not supported, or you settled on a specific environment, switch out the adapter.
		// See https://svelte.dev/docs/kit/adapters for more information about adapters.
		adapter: adapter()
	}
};

export default config;
`],
  ["frontend/svelte/package.json.hbs", `{
	"name": "web",
	"private": true,
	"version": "0.0.1",
	"type": "module",
	"scripts": {
		"dev": "vite dev",
		"build": "vite build",
		"preview": "vite preview",
		"prepare": "svelte-kit sync || echo ''",
		"check": "svelte-kit sync && svelte-check --tsconfig ./tsconfig.json",
		"check:watch": "svelte-kit sync && svelte-check --tsconfig ./tsconfig.json --watch"
	},
	"devDependencies": {
		"@sveltejs/adapter-auto": "^6.1.0",
		"@sveltejs/kit": "^2.31.1",
		"@sveltejs/vite-plugin-svelte": "^6.1.2",
		"@tailwindcss/vite": "^4.1.12",
		"svelte": "^5.38.1",
		"svelte-check": "^4.3.1",
		"tailwindcss": "^4.1.12",
		"vite": "^7.1.2"
	},
	"dependencies": {
		"@tanstack/svelte-form": "^1.19.2"
	}
}
`],
  ["frontend/svelte/_npmrc", `engine-strict=true
`],
  ["frontend/svelte/tsconfig.json.hbs", `{
	"extends": "./.svelte-kit/tsconfig.json",
	"compilerOptions": {
		"allowJs": true,
		"checkJs": true,
		"esModuleInterop": true,
		"forceConsistentCasingInFileNames": true,
		"resolveJsonModule": true,
		"skipLibCheck": true,
		"sourceMap": true,
		"strict": true,
		"moduleResolution": "bundler"
	}
	// Path aliases are handled by https://svelte.dev/docs/kit/configuration#alias
	// except $lib which is handled by https://svelte.dev/docs/kit/configuration#files
	//
	// If you want to overwrite includes/excludes, make sure to copy over the relevant includes/excludes
	// from the referenced tsconfig.json - TypeScript does not merge them in
}
`],
  ["frontend/svelte/vite.config.ts.hbs", `import tailwindcss from "@tailwindcss/vite";
import { sveltekit } from "@sveltejs/kit/vite";
import { defineConfig } from "vite";

export default defineConfig({
  plugins: [tailwindcss(), sveltekit()],
});
`],
  ["frontend/svelte/_gitignore", `node_modules

# Output
.output
.vercel
.netlify
.wrangler
.alchemy
/.svelte-kit
/build

# OS
.DS_Store
Thumbs.db

# Env
.env
.env.*
!.env.example
!.env.test

# Vite
vite.config.js.timestamp-*
vite.config.ts.timestamp-*
`],
  ["frontend/angular/package.json.hbs", `{
  "name": "web",
  "private": true,
  "type": "module",
  "scripts": {
    "ng": "ng",
    "dev": "ng serve --port 3001",
    "start": "ng serve --port 3001",
    "build": "ng build",
    "watch": "ng build --watch --configuration development"
  },
  "dependencies": {
    "@angular/animations": "^19.2.0",
    "@angular/common": "^19.2.0",
    "@angular/compiler": "^19.2.0",
    "@angular/core": "^19.2.0",
    "@angular/forms": "^19.2.0",
    "@angular/platform-browser": "^19.2.0",
    "@angular/platform-browser-dynamic": "^19.2.0",
    "@angular/router": "^19.2.0",
    "rxjs": "^7.8.1",
    "tslib": "^2.8.1",
    "zone.js": "^0.15.0"
  },
  "devDependencies": {
    "@angular-devkit/build-angular": "^19.2.0",
    "@angular/cli": "^19.2.0",
    "@angular/compiler-cli": "^19.2.0",
    "typescript": "~5.7.0"
  }
}
`],
  ["frontend/angular/tsconfig.app.json", `{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "outDir": "./out-tsc/app",
    "types": []
  },
  "files": ["src/main.ts"],
  "include": ["src/**/*.d.ts"]
}
`],
  ["frontend/angular/angular.json.hbs", `{
  "$schema": "./node_modules/@angular/cli/lib/config/schema.json",
  "version": 1,
  "newProjectRoot": "projects",
  "projects": {
    "web": {
      "projectType": "application",
      "schematics": {
        "@schematics/angular:component": {
          "style": "{{#if (eq cssFramework "scss")}}scss{{else if (eq cssFramework "less")}}less{{else}}css{{/if}}",
          "standalone": true
        }
      },
      "root": "",
      "sourceRoot": "src",
      "prefix": "app",
      "architect": {
        "build": {
          "builder": "@angular-devkit/build-angular:application",
          "options": {
            "outputPath": "dist/web",
            "index": "src/index.html",
            "browser": "src/main.ts",
            "polyfills": ["zone.js"],
            "tsConfig": "tsconfig.app.json",
            {{#if (eq cssFramework "tailwind")}}
            "styles": ["src/styles.css"],
            {{else if (eq cssFramework "scss")}}
            "styles": ["src/styles.scss"],
            {{else if (eq cssFramework "less")}}
            "styles": ["src/styles.less"],
            {{else}}
            "styles": ["src/styles.css"],
            {{/if}}
            "scripts": [],
            "assets": [
              {
                "glob": "**/*",
                "input": "public"
              }
            ]
          },
          "configurations": {
            "production": {
              "budgets": [
                {
                  "type": "initial",
                  "maximumWarning": "500kB",
                  "maximumError": "1MB"
                },
                {
                  "type": "anyComponentStyle",
                  "maximumWarning": "4kB",
                  "maximumError": "8kB"
                }
              ],
              "outputHashing": "all"
            },
            "development": {
              "optimization": false,
              "extractLicenses": false,
              "sourceMap": true
            }
          },
          "defaultConfiguration": "production"
        },
        "serve": {
          "builder": "@angular-devkit/build-angular:dev-server",
          "configurations": {
            "production": {
              "buildTarget": "web:build:production"
            },
            "development": {
              "buildTarget": "web:build:development"
            }
          },
          "defaultConfiguration": "development"
        }
      }
    }
  }
}
`],
  ["frontend/angular/tsconfig.json.hbs", `{
  "compileOnSave": false,
  "compilerOptions": {
    "outDir": "./dist/out-tsc",
    "strict": true,
    "noImplicitOverride": true,
    "noPropertyAccessFromIndexSignature": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "skipLibCheck": true,
    "isolatedModules": true,
    "esModuleInterop": true,
    "sourceMap": true,
    "declaration": false,
    "experimentalDecorators": true,
    "moduleResolution": "bundler",
    "importHelpers": true,
    "target": "ES2022",
    "module": "ES2022",
    "lib": ["ES2022", "dom"],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "angularCompilerOptions": {
    "enableI18nLegacyMessageIdFormat": false,
    "strictInjectionParameters": true,
    "strictInputAccessModifiers": true,
    "strictTemplates": true
  }
}
`],
  ["frontend/angular/_gitignore", `# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# Compiled output
/dist
/tmp
/out-tsc
/bazel-out

# Node
/node_modules
npm-debug.log
yarn-error.log

# IDEs and editors
.idea/
.project
.classpath
.c9/
*.launch
.settings/
*.sublime-workspace

# Visual Studio Code
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json
.history/*

# Miscellaneous
/.angular/cache
.sass-cache/
/connect.lock
/coverage
/libpeerconnection.log
testem.log
/typings

# System files
.DS_Store
Thumbs.db

# Environment
.env
.env.local
`],
  ["frontend/fresh/dev.ts", `#!/usr/bin/env -S deno run -A --watch=static/,routes/

import dev from "$fresh/dev.ts";

import config from "./fresh.config.ts";

await dev(import.meta.url, "./main.ts", config);
`],
  ["frontend/fresh/utils.ts", `import { createDefine } from "$fresh/server.ts";

export interface State {
  // Add your state properties here
  title?: string;
}

export const define = createDefine<State>();
`],
  ["frontend/fresh/main.ts", `/// <reference lib="deno.ns" />

import { App, staticFiles } from "$fresh/server.ts";

export const app = new App({ root: import.meta.url }).use(staticFiles());

// To add custom routes, import { define } from "./utils.ts"
// app.get("/api/example", define.handlers(() => new Response("Hello!")));

if (import.meta.main) {
  await app.listen();
}
`],
  ["frontend/fresh/tailwind.config.ts.hbs", `{{#if (eq cssFramework "tailwind")}}
import type { Config } from "tailwindcss";
{{#if (eq uiLibrary "daisyui")}}
import daisyui from "daisyui";
{{/if}}

export default {
  content: [
    "{routes,islands,components}/**/*.{ts,tsx}",
    "src/**/*.{ts,tsx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [{{#if (eq uiLibrary "daisyui")}}daisyui{{/if}}],
{{#if (eq uiLibrary "daisyui")}}
  daisyui: {
    themes: ["dark", "light"],
  },
{{/if}}
} satisfies Config;
{{/if}}
`],
  ["frontend/fresh/fresh.config.ts.hbs", `import { defineConfig } from "$fresh/server.ts";
{{#if (eq cssFramework "tailwind")}}
import tailwind from "$fresh/plugins/tailwind.ts";

export default defineConfig({
  plugins: [tailwind()],
});
{{else}}
export default defineConfig({});
{{/if}}
`],
  ["frontend/fresh/deno.json.hbs", `{
  "lock": false,
  "tasks": {
    "check": "deno fmt --check && deno lint && deno check **/*.ts && deno check **/*.tsx",
    "cli": "echo \\"import '\\\\$fresh/src/dev/cli.ts'\\" | deno run --unstable -A -",
    "manifest": "deno task cli manifest $(pwd)",
    "dev": "deno run -A --watch=static/,routes/ dev.ts",
    "build": "deno run -A dev.ts build",
    "preview": "deno run -A main.ts",
    "update": "deno run -A -r jsr:@fresh/update ."
  },
  "lint": {
    "rules": {
      "tags": [
        "fresh",
        "recommended"
      ]
    }
  },
  "exclude": [
    "**/_fresh/*"
  ],
  "imports": {
    "$fresh/": "jsr:@fresh/core@^2.0.0-alpha/",
    "preact": "npm:preact@^10.25.4",
    "preact/": "npm:preact@^10.25.4/",
    "@preact/signals": "npm:@preact/signals@^2.0.0",
    "@preact/signals-core": "npm:@preact/signals-core@^2.0.0"{{#if (eq cssFramework "tailwind")}},
    "tailwindcss": "npm:tailwindcss@^3.4.17",
    "tailwindcss/plugin": "npm:tailwindcss@^3.4.17/plugin.js"{{/if}}
  },
  "compilerOptions": {
    "lib": [
      "dom",
      "dom.asynciterable",
      "deno.ns"
    ],
    "jsx": "react-jsx",
    "jsxImportSource": "preact"
  },
  "nodeModulesDir": "auto"
}
`],
  ["frontend/fresh/_gitignore", `# Fresh build output
_fresh/

# Deno
.deno/

# Editor directories
.idea/
.vscode/

# OS generated files
.DS_Store
Thumbs.db

# Environment files
.env
.env.local
.env.*.local

# Logs
logs
*.log
`],
  ["frontend/nuxt/package.json.hbs", `{
  "name": "web",
  "private": true,
  "type": "module",
  "scripts": {
    "build": "nuxt build",
    "dev": "nuxt dev",
    "generate": "nuxt generate",
    "preview": "nuxt preview",
    "postinstall": "nuxt prepare"
  },
  "dependencies": {
    "@nuxt/ui": "4.2.1",
    "@nuxt/content": "^3.7.1",
    "@nuxtjs/mdc": "^0.17.4",
    "nuxt": "^4.1.2",
    "vue": "^3.5.21",
    "vue-router": "^4.5.1"
  },
  "devDependencies": {
    "tailwindcss": "^4.1.13",
    "@iconify-json/lucide": "^1.2.57"
  }
}
`],
  ["frontend/nuxt/nuxt.config.ts.hbs", `import "@{{projectName}}/env/web";

// https://nuxt.com/docs/api/configuration/nuxt-config
export default defineNuxtConfig({
  compatibilityDate: 'latest',
  devtools: { enabled: true },
  modules: [
    '@nuxt/ui'
    {{#if (eq backend "convex")}},
    'convex-nuxt'
    {{/if}}
  ],
  css: ['~/assets/css/main.css'],
  devServer: {
    port: 3001
  },
  ssr: true,
  {{#if (eq backend "convex")}}
  convex: {
    url: process.env.NUXT_PUBLIC_CONVEX_URL,
  },
  {{else}}
  runtimeConfig: {
    public: {
      serverUrl: process.env.NUXT_PUBLIC_SERVER_URL,
    }
  },
  {{/if}}
})
`],
  ["frontend/nuxt/tsconfig.json.hbs", `{
  // https://nuxt.com/docs/guide/concepts/typescript
  "files": [],
  "references": [
    {
      "path": "./.nuxt/tsconfig.app.json"
    },
    {
      "path": "./.nuxt/tsconfig.server.json"
    },
    {
      "path": "./.nuxt/tsconfig.shared.json"
    },
    {
      "path": "./.nuxt/tsconfig.node.json"
    }
  ]
}
`],
  ["frontend/nuxt/_gitignore", `# Nuxt dev/build outputs
.output
.data
.nuxt
.nitro
.cache
dist
.wrangler
.alchemy

# Node dependencies
node_modules

# Logs
logs
*.log

# Misc
.DS_Store
.fleet
.idea

# Local env files
.env
.env.*
!.env.example

`],
  ["frontend/astro/astro.config.mjs.hbs", `import { defineConfig } from 'astro/config';
import tailwindcss from '@tailwindcss/vite';
{{#if (eq astroIntegration "react")}}
import react from '@astrojs/react';
{{/if}}
{{#if (eq astroIntegration "vue")}}
import vue from '@astrojs/vue';
{{/if}}
{{#if (eq astroIntegration "svelte")}}
import svelte from '@astrojs/svelte';
{{/if}}
{{#if (eq astroIntegration "solid")}}
import solidJs from '@astrojs/solid-js';
{{/if}}
{{#if (eq backend "self")}}
import node from '@astrojs/node';
{{/if}}
{{#if (eq runtime "workers")}}
import cloudflare from '@astrojs/cloudflare';
{{/if}}

export default defineConfig({
	integrations: [
{{#if (eq astroIntegration "react")}}
		react(),
{{/if}}
{{#if (eq astroIntegration "vue")}}
		vue(),
{{/if}}
{{#if (eq astroIntegration "svelte")}}
		svelte(),
{{/if}}
{{#if (eq astroIntegration "solid")}}
		solidJs(),
{{/if}}
	],
	vite: {
		plugins: [tailwindcss()],
	},
{{#if (or (eq backend "self") (eq runtime "workers"))}}
	output: 'server',
{{#if (eq backend "self")}}
	adapter: node({ mode: 'standalone' }),
{{else if (eq runtime "workers")}}
	adapter: cloudflare(),
{{/if}}
{{/if}}
});
`],
  ["frontend/astro/package.json.hbs", `{
	"name": "web",
	"private": true,
	"version": "0.0.1",
	"type": "module",
	"scripts": {
		"dev": "astro dev",
		"build": "astro build",
		"preview": "astro preview",
		"astro": "astro"
	},
	"dependencies": {
		"astro": "^5.7.10"
{{#if (eq astroIntegration "react")}}
		,"@astrojs/react": "^4.2.1"
		,"react": "^19.1.0"
		,"react-dom": "^19.1.0"
{{#if (eq uiLibrary "shadcn-ui")}}
		,"clsx": "^2.1.1"
		,"tailwind-merge": "^3.3.1"
		,"lucide-react": "^0.511.0"
		,"class-variance-authority": "^0.7.1"
{{/if}}
{{/if}}
{{#if (eq astroIntegration "vue")}}
		,"@astrojs/vue": "^5.0.6"
		,"vue": "^3.5.17"
{{/if}}
{{#if (eq astroIntegration "svelte")}}
		,"@astrojs/svelte": "^7.0.8"
		,"svelte": "^5.33.0"
{{/if}}
{{#if (eq astroIntegration "solid")}}
		,"@astrojs/solid-js": "^5.0.6"
		,"solid-js": "^1.9.5"
{{/if}}
{{#if (eq backend "self")}}
		,"@astrojs/node": "^9.1.3"
{{/if}}
{{#if (eq runtime "workers")}}
		,"@astrojs/cloudflare": "^12.3.1"
{{/if}}
	},
	"devDependencies": {
		"@tailwindcss/vite": "^4.1.12",
		"tailwindcss": "^4.1.12"
{{#if (eq astroIntegration "react")}}
		,"@types/react": "^19.1.6"
		,"@types/react-dom": "^19.1.5"
{{/if}}
	}
}
`],
  ["frontend/astro/_npmrc", `shamefully-hoist=true
`],
  ["frontend/astro/tsconfig.json.hbs", `{
	"extends": "astro/tsconfigs/strict",
	"compilerOptions": {
		"baseUrl": ".",
		"paths": {
			"@/*": ["./src/*"]
		}
{{#if (eq astroIntegration "react")}}
		,"jsx": "react-jsx",
		"jsxImportSource": "react"
{{/if}}
{{#if (eq astroIntegration "solid")}}
		,"jsx": "preserve",
		"jsxImportSource": "solid-js"
{{/if}}
	},
	"include": ["src/**/*", "env.d.ts"]
}
`],
  ["frontend/astro/_gitignore", `# build output
dist/
.output/

# generated types
.astro/

# dependencies
node_modules/

# logs
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*

# environment variables
.env
.env.production
.env.local

# macOS-specific files
.DS_Store
`],
  ["packages/infra/alchemy.run.ts.hbs", `import alchemy from "alchemy";
{{#if (eq webDeploy "cloudflare")}}
{{#if (includes frontend "next")}}
import { Nextjs } from "alchemy/cloudflare";
{{else if (includes frontend "nuxt")}}
import { Nuxt } from "alchemy/cloudflare";
{{else if (includes frontend "svelte")}}
import { SvelteKit } from "alchemy/cloudflare";
{{else if (includes frontend "tanstack-start")}}
import { TanStackStart } from "alchemy/cloudflare";
{{else if (includes frontend "tanstack-router")}}
import { Vite } from "alchemy/cloudflare";
{{else if (includes frontend "react-router")}}
import { ReactRouter } from "alchemy/cloudflare";
{{else if (includes frontend "solid")}}
import { Vite } from "alchemy/cloudflare";
{{/if}}
{{/if}}
{{#if (eq serverDeploy "cloudflare")}}
import { Worker } from "alchemy/cloudflare";
{{/if}}
{{#if (and (or (eq serverDeploy "cloudflare") (and (eq webDeploy "cloudflare") (eq backend "self"))) (eq dbSetup "d1"))}}
import { D1Database } from "alchemy/cloudflare";
{{/if}}
import { config } from "dotenv";

{{#if (and (eq webDeploy "cloudflare") (eq serverDeploy "cloudflare"))}}
config({ path: "./.env" });
config({ path: "../../apps/web/.env" });
config({ path: "../../apps/server/.env" });
{{else if (eq webDeploy "cloudflare")}}
config({ path: "./.env" });
config({ path: "../../apps/web/.env" });
{{else if (eq serverDeploy "cloudflare")}}
config({ path: "./.env" });
config({ path: "../../apps/server/.env" });
{{/if}}

const app = await alchemy("{{projectName}}");

{{#if (and (or (eq serverDeploy "cloudflare") (and (eq webDeploy "cloudflare") (eq backend "self"))) (eq dbSetup "d1"))}}
const db = await D1Database("database", {
	{{#if (eq orm "prisma")}}
	migrationsDir: "../../packages/db/prisma/migrations",
	{{else if (eq orm "drizzle")}}
	migrationsDir: "../../packages/db/src/migrations",
	{{/if}}
});
{{/if}}

{{#if (eq webDeploy "cloudflare")}}
{{#if (includes frontend "next")}}
export const web = await Nextjs("web", {
  cwd: "../../apps/web",
  bindings: {
    {{#if (eq backend "convex")}}
    NEXT_PUBLIC_CONVEX_URL: alchemy.env.NEXT_PUBLIC_CONVEX_URL!,
    {{#if (eq auth "better-auth")}}
    NEXT_PUBLIC_CONVEX_SITE_URL: alchemy.env.NEXT_PUBLIC_CONVEX_SITE_URL!,
    {{/if}}
    {{else if (ne backend "self")}}
    NEXT_PUBLIC_SERVER_URL: alchemy.env.NEXT_PUBLIC_SERVER_URL!,
    {{/if}}
    {{#if (eq dbSetup "d1")}}
    DB: db,
    {{else if (ne database "none")}}
    DATABASE_URL: alchemy.secret.env.DATABASE_URL!,
    {{/if}}
    {{#if (ne backend "convex")}}
    CORS_ORIGIN: alchemy.env.CORS_ORIGIN!,
    {{#if (eq auth "better-auth")}}
    BETTER_AUTH_SECRET: alchemy.secret.env.BETTER_AUTH_SECRET!,
    BETTER_AUTH_URL: alchemy.env.BETTER_AUTH_URL!,
    {{/if}}
    {{/if}}
    {{#if (eq auth "clerk")}}
    CLERK_SECRET_KEY: alchemy.secret.env.CLERK_SECRET_KEY!,
    {{/if}}
    {{#if (and (includes examples "ai") (ne backend "convex"))}}
    GOOGLE_GENERATIVE_AI_API_KEY: alchemy.secret.env.GOOGLE_GENERATIVE_AI_API_KEY!,
    {{/if}}
    {{#if (eq payments "polar")}}
    POLAR_ACCESS_TOKEN: alchemy.secret.env.POLAR_ACCESS_TOKEN!,
    POLAR_SUCCESS_URL: alchemy.env.POLAR_SUCCESS_URL!,
    {{/if}}
    {{#if (eq dbSetup "turso")}}
    DATABASE_AUTH_TOKEN: alchemy.secret.env.DATABASE_AUTH_TOKEN!,
    {{/if}}
    {{#if (eq database "mysql")}}
    {{#if (eq orm "drizzle")}}
    DATABASE_HOST: alchemy.env.DATABASE_HOST!,
    DATABASE_USERNAME: alchemy.env.DATABASE_USERNAME!,
    DATABASE_PASSWORD: alchemy.secret.env.DATABASE_PASSWORD!,
    {{/if}}
    {{/if}}
  }
});
{{else if (includes frontend "nuxt")}}
export const web = await Nuxt("web", {
  cwd: "../../apps/web",
  bindings: {
    {{#if (eq backend "convex")}}
    NUXT_PUBLIC_CONVEX_URL: alchemy.env.NUXT_PUBLIC_CONVEX_URL!,
    {{#if (eq auth "better-auth")}}
    NUXT_PUBLIC_CONVEX_SITE_URL: alchemy.env.NUXT_PUBLIC_CONVEX_SITE_URL!,
    {{/if}}
    {{else if (ne backend "self")}}
    NUXT_PUBLIC_SERVER_URL: alchemy.env.NUXT_PUBLIC_SERVER_URL!,
    {{/if}}
  }
});
{{else if (includes frontend "svelte")}}
export const web = await SvelteKit("web", {
  cwd: "../../apps/web",
  bindings: {
    {{#if (eq backend "convex")}}
    PUBLIC_CONVEX_URL: alchemy.env.PUBLIC_CONVEX_URL!,
    {{#if (eq auth "better-auth")}}
    PUBLIC_CONVEX_SITE_URL: alchemy.env.PUBLIC_CONVEX_SITE_URL!,
    {{/if}}
    {{else if (ne backend "self")}}
    PUBLIC_SERVER_URL: alchemy.env.PUBLIC_SERVER_URL!,
    {{/if}}
  }
});
{{else if (includes frontend "tanstack-start")}}
export const web = await TanStackStart("web", {
  cwd: "../../apps/web",
  bindings: {
    {{#if (eq backend "convex")}}
    VITE_CONVEX_URL: alchemy.env.VITE_CONVEX_URL!,
    {{#if (eq auth "better-auth")}}
    VITE_CONVEX_SITE_URL: alchemy.env.VITE_CONVEX_SITE_URL!,
    {{/if}}
    {{else if (ne backend "self")}}
    VITE_SERVER_URL: alchemy.env.VITE_SERVER_URL!,
    {{/if}}
    {{#if (eq dbSetup "d1")}}
    DB: db,
    {{else if (ne database "none")}}
    DATABASE_URL: alchemy.secret.env.DATABASE_URL!,
    {{/if}}
    {{#if (ne backend "convex")}}
    CORS_ORIGIN: alchemy.env.CORS_ORIGIN!,
    {{#if (eq auth "better-auth")}}
    BETTER_AUTH_SECRET: alchemy.secret.env.BETTER_AUTH_SECRET!,
    BETTER_AUTH_URL: alchemy.env.BETTER_AUTH_URL!,
    {{/if}}
    {{/if}}
    {{#if (eq auth "clerk")}}
    CLERK_SECRET_KEY: alchemy.secret.env.CLERK_SECRET_KEY!,
    {{/if}}
    {{#if (and (includes examples "ai") (ne backend "convex"))}}
    GOOGLE_GENERATIVE_AI_API_KEY: alchemy.secret.env.GOOGLE_GENERATIVE_AI_API_KEY!,
    {{/if}}
    {{#if (eq payments "polar")}}
    POLAR_ACCESS_TOKEN: alchemy.secret.env.POLAR_ACCESS_TOKEN!,
    POLAR_SUCCESS_URL: alchemy.env.POLAR_SUCCESS_URL!,
    {{/if}}
    {{#if (eq dbSetup "turso")}}
    DATABASE_AUTH_TOKEN: alchemy.secret.env.DATABASE_AUTH_TOKEN!,
    {{/if}}
    {{#if (eq database "mysql")}}
    {{#if (eq orm "drizzle")}}
    DATABASE_HOST: alchemy.env.DATABASE_HOST!,
    DATABASE_USERNAME: alchemy.env.DATABASE_USERNAME!,
    DATABASE_PASSWORD: alchemy.secret.env.DATABASE_PASSWORD!,
    {{/if}}
    {{/if}}
  }
});
{{else if (includes frontend "tanstack-router")}}
export const web = await Vite("web", {
  cwd: "../../apps/web",
  assets: "dist",
  bindings: {
    {{#if (eq backend "convex")}}
    VITE_CONVEX_URL: alchemy.env.VITE_CONVEX_URL!,
    {{#if (eq auth "better-auth")}}
    VITE_CONVEX_SITE_URL: alchemy.env.VITE_CONVEX_SITE_URL!,
    {{/if}}
    {{else if (ne backend "self")}}
    VITE_SERVER_URL: alchemy.env.VITE_SERVER_URL!,
    {{/if}}
  }
});
{{else if (includes frontend "react-router")}}
export const web = await ReactRouter("web", {
  cwd: "../../apps/web",
  bindings: {
    {{#if (eq backend "convex")}}
    VITE_CONVEX_URL: alchemy.env.VITE_CONVEX_URL!,
    {{#if (eq auth "better-auth")}}
    VITE_CONVEX_SITE_URL: alchemy.env.VITE_CONVEX_SITE_URL!,
    {{/if}}
    {{else if (ne backend "self")}}
    VITE_SERVER_URL: alchemy.env.VITE_SERVER_URL!,
    {{/if}}
  }
});
{{else if (includes frontend "solid")}}
export const web = await Vite("web", {
  cwd: "../../apps/web",
  assets: "dist",
  bindings: {
    {{#if (eq backend "convex")}}
    VITE_CONVEX_URL: alchemy.env.VITE_CONVEX_URL!,
    {{#if (eq auth "better-auth")}}
    VITE_CONVEX_SITE_URL: alchemy.env.VITE_CONVEX_SITE_URL!,
    {{/if}}
    {{else if (ne backend "self")}}
    VITE_SERVER_URL: alchemy.env.VITE_SERVER_URL!,
    {{/if}}
  }
});
{{/if}}
{{/if}}

{{#if (eq serverDeploy "cloudflare")}}
export const server = await Worker("server", {
  cwd: "../../apps/server",
  entrypoint: "src/index.ts",
  compatibility: "node",
  bindings: {
    {{#if (eq dbSetup "d1")}}
    DB: db,
    {{else if (ne database "none")}}
    DATABASE_URL: alchemy.secret.env.DATABASE_URL!,
    {{/if}}
    CORS_ORIGIN: alchemy.env.CORS_ORIGIN!,
    {{#if (eq auth "better-auth")}}
    BETTER_AUTH_SECRET: alchemy.secret.env.BETTER_AUTH_SECRET!,
    BETTER_AUTH_URL: alchemy.env.BETTER_AUTH_URL!,
    {{/if}}
    {{#if (eq auth "clerk")}}
    CLERK_SECRET_KEY: alchemy.secret.env.CLERK_SECRET_KEY!,
    {{/if}}
    {{#if (includes examples "ai")}}
    GOOGLE_GENERATIVE_AI_API_KEY: alchemy.secret.env.GOOGLE_GENERATIVE_AI_API_KEY!,
    {{/if}}
    {{#if (eq payments "polar")}}
    POLAR_ACCESS_TOKEN: alchemy.secret.env.POLAR_ACCESS_TOKEN!,
    POLAR_SUCCESS_URL: alchemy.env.POLAR_SUCCESS_URL!,
    {{/if}}
    {{#if (eq dbSetup "turso")}}
    DATABASE_AUTH_TOKEN: alchemy.secret.env.DATABASE_AUTH_TOKEN!,
    {{/if}}
    {{#if (eq database "mysql")}}
    {{#if (eq orm "drizzle")}}
    DATABASE_HOST: alchemy.env.DATABASE_HOST!,
    DATABASE_USERNAME: alchemy.env.DATABASE_USERNAME!,
    DATABASE_PASSWORD: alchemy.secret.env.DATABASE_PASSWORD!,
    {{/if}}
    {{/if}}
  },
  dev: {
		port: 3000,
	},
});
{{/if}}

{{#if (and (eq webDeploy "cloudflare") (eq serverDeploy "cloudflare"))}}
console.log(\`Web    -> \${web.url}\`);
console.log(\`Server -> \${server.url}\`);
{{else if (eq webDeploy "cloudflare")}}
console.log(\`Web    -> \${web.url}\`);
{{else if (eq serverDeploy "cloudflare")}}
console.log(\`Server -> \${server.url}\`);
{{/if}}

await app.finalize();
`],
  ["packages/infra/package.json.hbs", `{
  "name": "@{{projectName}}/infra",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "alchemy dev",
    "deploy": "alchemy deploy",
    "destroy": "alchemy destroy"
  }
}
`],
  ["packages/env/package.json.hbs", `{
	"name": "@{{projectName}}/env",
	"version": "0.0.0",
	"private": true,
	"type": "module",
	"exports": {}
}`],
  ["packages/env/tsconfig.json.hbs", `{
  "extends": "@{{projectName}}/config/tsconfig.base.json",
}
`],
  ["packages/config/package.json.hbs", `{
  "name": "@{{projectName}}/config",
  "version": "0.0.0",
  "private": true
}
`],
  ["packages/config/tsconfig.base.json.hbs", `{
  "$schema": "https://json.schemastore.org/tsconfig",
  "compilerOptions": {
    "target": "ESNext",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "lib": ["ESNext"],
    "verbatimModuleSyntax": true,
    "strict": true,
    "skipLibCheck": true,
    "resolveJsonModule": true,
    "allowSyntheticDefaultImports": true,
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "isolatedModules": true,
    "noUncheckedIndexedAccess": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "types": [
      {{#if (eq runtime "node")}}
        "node"
      {{else if (eq runtime "bun")}}
        "bun"
      {{else if (eq runtime "workers")}}
        "node"
      {{else}}
        "node"
      {{/if}}{{#if (or (eq serverDeploy "cloudflare") (eq webDeploy "cloudflare"))}},
      "@cloudflare/workers-types"{{/if}}
    ]
  }
}`],
  ["db/base/package.json.hbs", `{
  "name": "@{{projectName}}/db",
  "type": "module",
  "exports": {
    ".": {
      "default": "./src/index.ts"
    },
    "./*": {
      "default": "./src/*.ts"
    }
  },
  "scripts": {},
  "devDependencies": {}
}`],
  ["db/base/tsconfig.json.hbs", `{
  "extends": "@{{projectName}}/config/tsconfig.base.json",
  "compilerOptions": {
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "outDir": "dist",
    "composite": true
  }
}`],
  ["db/base/_gitignore", `# dependencies (bun install)
node_modules

# output
out
dist
*.tgz
/prisma/generated

# code coverage
coverage
*.lcov

# logs
logs
_.log
report.[0-9]_.[0-9]_.[0-9]_.[0-9]_.json

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# caches
.eslintcache
.cache
*.tsbuildinfo

# IntelliJ based IDEs
.idea

# Finder (MacOS) folder config
.DS_Store
`],
  ["python-base/src/app/settings.py.hbs", `{{#if (eq pythonValidation "pydantic")}}
"""Application settings using pydantic-settings."""

from functools import lru_cache

from pydantic_settings import BaseSettings, SettingsConfigDict


class Settings(BaseSettings):
    """Application settings loaded from environment variables."""

    model_config = SettingsConfigDict(
        env_file=".env",
        env_file_encoding="utf-8",
        case_sensitive=False,
    )

    # Application settings
    app_name: str = "{{projectName}}"
    debug: bool = False
    host: str = "0.0.0.0"
    port: int = 8000

    # API settings
    api_prefix: str = "/api"
    api_version: str = "v1"

{{#if (or (eq pythonOrm "sqlalchemy") (eq pythonOrm "sqlmodel"))}}
    # Database settings
    database_url: str = "sqlite:///./app.db"
{{/if}}
{{#if (includes pythonAi "openai-sdk")}}
    # OpenAI settings
    openai_api_key: str = ""
    openai_default_model: str = "gpt-4o-mini"
    openai_default_temperature: float = 0.7
{{/if}}
{{#if (includes pythonAi "anthropic-sdk")}}
    # Anthropic settings
    anthropic_api_key: str = ""
    anthropic_default_model: str = "claude-sonnet-4-20250514"
    anthropic_default_max_tokens: int = 4096
    anthropic_default_temperature: float = 0.7
{{/if}}
{{#if (includes pythonAi "langchain")}}
    # LangChain settings
    openai_api_key: str = ""
    langchain_default_model: str = "gpt-4o-mini"
    langchain_default_temperature: float = 0.7
{{/if}}
{{#if (includes pythonAi "llamaindex")}}
    # LlamaIndex settings
    openai_api_key: str = ""
    llamaindex_default_model: str = "gpt-4o-mini"
    llamaindex_default_temperature: float = 0.7
    llamaindex_embed_model: str = "text-embedding-3-small"
{{/if}}
{{#if (includes pythonAi "langgraph")}}
    # LangGraph settings
    openai_api_key: str = ""
    langgraph_default_model: str = "gpt-4o-mini"
    langgraph_default_temperature: float = 0.7
    langgraph_max_iterations: int = 10
{{/if}}
{{#if (includes pythonAi "crewai")}}
    # CrewAI settings
    openai_api_key: str = ""
    crewai_verbose: bool = True
{{/if}}
{{#if (eq pythonTaskQueue "celery")}}
    # Celery settings
    celery_broker_url: str = "redis://localhost:6379/0"
    celery_result_backend: str = "redis://localhost:6379/0"
{{/if}}


@lru_cache
def get_settings() -> Settings:
    """Get cached settings instance."""
    return Settings()
{{/if}}
`],
  ["python-base/src/app/database.py.hbs", `{{#if (ne pythonOrm "none")}}
{{#if (eq pythonOrm "sqlalchemy")}}
"""Database configuration and session management."""

import os
from collections.abc import Generator

from sqlalchemy import create_engine
from sqlalchemy.orm import Session, sessionmaker

from app.models import Base

DATABASE_URL = os.getenv("DATABASE_URL", "sqlite:///./app.db")

# For SQLite, we need check_same_thread=False for async usage
connect_args = {"check_same_thread": False} if DATABASE_URL.startswith("sqlite") else {}

engine = create_engine(DATABASE_URL, connect_args=connect_args, echo=False)

SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)


def get_db() -> Generator[Session, None, None]:
    """Get database session dependency."""
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


def init_db() -> None:
    """Initialize database tables."""
    Base.metadata.create_all(bind=engine)
{{/if}}
{{#if (eq pythonOrm "sqlmodel")}}
"""Database configuration and session management."""

import os
from collections.abc import Generator

from sqlmodel import Session, SQLModel, create_engine

DATABASE_URL = os.getenv("DATABASE_URL", "sqlite:///./app.db")

# For SQLite, we need check_same_thread=False for async usage
connect_args = {"check_same_thread": False} if DATABASE_URL.startswith("sqlite") else {}

engine = create_engine(DATABASE_URL, connect_args=connect_args, echo=False)


def get_db() -> Generator[Session, None, None]:
    """Get database session dependency."""
    with Session(engine) as session:
        yield session


def init_db() -> None:
    """Initialize database tables."""
    # Import models to ensure they are registered with SQLModel
    from app import models  # noqa: F401

    SQLModel.metadata.create_all(engine)
{{/if}}
{{/if}}
`],
  ["python-base/src/app/openai_client.py.hbs", `{{#if (includes pythonAi "openai-sdk")}}
"""OpenAI client for direct API interactions."""

import os
from typing import AsyncIterator

from openai import AsyncOpenAI
from openai.types.chat import ChatCompletionMessageParam


def get_client() -> AsyncOpenAI:
    """Get a configured OpenAI client instance.

    Returns:
        A configured AsyncOpenAI instance.

    Raises:
        ValueError: If OPENAI_API_KEY is not set.
    """
    api_key = os.getenv("OPENAI_API_KEY")
    if not api_key:
        raise ValueError("OPENAI_API_KEY environment variable is not set")

    return AsyncOpenAI(api_key=api_key)


async def chat(
    message: str,
    history: list[dict] | None = None,
    system_prompt: str = "You are a helpful assistant.",
    model: str = "gpt-4o-mini",
    temperature: float = 0.7,
) -> str:
    """Send a message and get a response.

    Args:
        message: The user's message.
        history: Optional conversation history as list of {"role": str, "content": str}.
        system_prompt: The system prompt to set context.
        model: The model to use.
        temperature: The temperature for generation.

    Returns:
        The assistant's response.
    """
    client = get_client()

    messages: list[ChatCompletionMessageParam] = [
        {"role": "system", "content": system_prompt}
    ]

    if history:
        for msg in history:
            messages.append({"role": msg["role"], "content": msg["content"]})

    messages.append({"role": "user", "content": message})

    response = await client.chat.completions.create(
        model=model,
        messages=messages,
        temperature=temperature,
    )

    return response.choices[0].message.content or ""


async def chat_stream(
    message: str,
    history: list[dict] | None = None,
    system_prompt: str = "You are a helpful assistant.",
    model: str = "gpt-4o-mini",
    temperature: float = 0.7,
) -> AsyncIterator[str]:
    """Send a message and stream the response.

    Args:
        message: The user's message.
        history: Optional conversation history.
        system_prompt: The system prompt to set context.
        model: The model to use.
        temperature: The temperature for generation.

    Yields:
        Chunks of the assistant's response.
    """
    client = get_client()

    messages: list[ChatCompletionMessageParam] = [
        {"role": "system", "content": system_prompt}
    ]

    if history:
        for msg in history:
            messages.append({"role": msg["role"], "content": msg["content"]})

    messages.append({"role": "user", "content": message})

    stream = await client.chat.completions.create(
        model=model,
        messages=messages,
        temperature=temperature,
        stream=True,
    )

    async for chunk in stream:
        if chunk.choices[0].delta.content:
            yield chunk.choices[0].delta.content


async def simple_completion(
    prompt: str,
    model: str = "gpt-4o-mini",
    temperature: float = 0.7,
) -> str:
    """Get a simple completion without conversation history.

    Args:
        prompt: The prompt to complete.
        model: The model to use.
        temperature: The temperature for generation.

    Returns:
        The completion response.
    """
    client = get_client()

    response = await client.chat.completions.create(
        model=model,
        messages=[{"role": "user", "content": prompt}],
        temperature=temperature,
    )

    return response.choices[0].message.content or ""
{{/if}}
`],
  ["python-base/src/app/crud.py.hbs", `{{#if (ne pythonOrm "none")}}
{{#if (eq pythonOrm "sqlalchemy")}}
"""CRUD operations for database models."""

from sqlalchemy import select
from sqlalchemy.orm import Session

from app.models import Post, User
{{#if (eq pythonValidation "pydantic")}}
from app.schemas import PostCreate, PostUpdate, UserCreate, UserUpdate
{{/if}}


# User CRUD operations
def get_user(db: Session, user_id: int) -> User | None:
    """Get a user by ID."""
    return db.get(User, user_id)


def get_user_by_email(db: Session, email: str) -> User | None:
    """Get a user by email."""
    stmt = select(User).where(User.email == email)
    return db.execute(stmt).scalar_one_or_none()


def get_users(db: Session, skip: int = 0, limit: int = 100) -> list[User]:
    """Get a list of users with pagination."""
    stmt = select(User).offset(skip).limit(limit)
    return list(db.execute(stmt).scalars().all())


{{#if (eq pythonValidation "pydantic")}}
def create_user(db: Session, user: UserCreate) -> User:
    """Create a new user."""
    db_user = User(email=user.email, name=user.name)
    db.add(db_user)
    db.commit()
    db.refresh(db_user)
    return db_user


def update_user(db: Session, user_id: int, user: UserUpdate) -> User | None:
    """Update a user."""
    db_user = get_user(db, user_id)
    if db_user is None:
        return None

    update_data = user.model_dump(exclude_unset=True)
    for field, value in update_data.items():
        setattr(db_user, field, value)

    db.commit()
    db.refresh(db_user)
    return db_user
{{else}}
def create_user(db: Session, email: str, name: str | None = None) -> User:
    """Create a new user."""
    db_user = User(email=email, name=name)
    db.add(db_user)
    db.commit()
    db.refresh(db_user)
    return db_user


def update_user(db: Session, user_id: int, email: str | None = None, name: str | None = None) -> User | None:
    """Update a user."""
    db_user = get_user(db, user_id)
    if db_user is None:
        return None

    if email is not None:
        db_user.email = email
    if name is not None:
        db_user.name = name

    db.commit()
    db.refresh(db_user)
    return db_user
{{/if}}


def delete_user(db: Session, user_id: int) -> bool:
    """Delete a user."""
    db_user = get_user(db, user_id)
    if db_user is None:
        return False

    db.delete(db_user)
    db.commit()
    return True


# Post CRUD operations
def get_post(db: Session, post_id: int) -> Post | None:
    """Get a post by ID."""
    return db.get(Post, post_id)


def get_posts(db: Session, skip: int = 0, limit: int = 100) -> list[Post]:
    """Get a list of posts with pagination."""
    stmt = select(Post).offset(skip).limit(limit)
    return list(db.execute(stmt).scalars().all())


def get_posts_by_author(db: Session, author_id: int) -> list[Post]:
    """Get all posts by an author."""
    stmt = select(Post).where(Post.author_id == author_id)
    return list(db.execute(stmt).scalars().all())


{{#if (eq pythonValidation "pydantic")}}
def create_post(db: Session, post: PostCreate) -> Post:
    """Create a new post."""
    db_post = Post(title=post.title, content=post.content, author_id=post.author_id)
    db.add(db_post)
    db.commit()
    db.refresh(db_post)
    return db_post


def update_post(db: Session, post_id: int, post: PostUpdate) -> Post | None:
    """Update a post."""
    db_post = get_post(db, post_id)
    if db_post is None:
        return None

    update_data = post.model_dump(exclude_unset=True)
    for field, value in update_data.items():
        setattr(db_post, field, value)

    db.commit()
    db.refresh(db_post)
    return db_post
{{else}}
def create_post(db: Session, title: str, author_id: int, content: str | None = None) -> Post:
    """Create a new post."""
    db_post = Post(title=title, content=content, author_id=author_id)
    db.add(db_post)
    db.commit()
    db.refresh(db_post)
    return db_post


def update_post(db: Session, post_id: int, title: str | None = None, content: str | None = None) -> Post | None:
    """Update a post."""
    db_post = get_post(db, post_id)
    if db_post is None:
        return None

    if title is not None:
        db_post.title = title
    if content is not None:
        db_post.content = content

    db.commit()
    db.refresh(db_post)
    return db_post
{{/if}}


def delete_post(db: Session, post_id: int) -> bool:
    """Delete a post."""
    db_post = get_post(db, post_id)
    if db_post is None:
        return False

    db.delete(db_post)
    db.commit()
    return True
{{/if}}
{{#if (eq pythonOrm "sqlmodel")}}
"""CRUD operations for database models."""

from datetime import datetime

from sqlmodel import Session, select

from app.models import Post, PostCreate, PostUpdate, User, UserCreate, UserUpdate


# User CRUD operations
def get_user(db: Session, user_id: int) -> User | None:
    """Get a user by ID."""
    return db.get(User, user_id)


def get_user_by_email(db: Session, email: str) -> User | None:
    """Get a user by email."""
    stmt = select(User).where(User.email == email)
    return db.exec(stmt).first()


def get_users(db: Session, skip: int = 0, limit: int = 100) -> list[User]:
    """Get a list of users with pagination."""
    stmt = select(User).offset(skip).limit(limit)
    return list(db.exec(stmt).all())


def create_user(db: Session, user: UserCreate) -> User:
    """Create a new user."""
    db_user = User.model_validate(user)
    db.add(db_user)
    db.commit()
    db.refresh(db_user)
    return db_user


def update_user(db: Session, user_id: int, user: UserUpdate) -> User | None:
    """Update a user."""
    db_user = get_user(db, user_id)
    if db_user is None:
        return None

    update_data = user.model_dump(exclude_unset=True)
    for field, value in update_data.items():
        setattr(db_user, field, value)
    db_user.updated_at = datetime.utcnow()

    db.add(db_user)
    db.commit()
    db.refresh(db_user)
    return db_user


def delete_user(db: Session, user_id: int) -> bool:
    """Delete a user."""
    db_user = get_user(db, user_id)
    if db_user is None:
        return False

    db.delete(db_user)
    db.commit()
    return True


# Post CRUD operations
def get_post(db: Session, post_id: int) -> Post | None:
    """Get a post by ID."""
    return db.get(Post, post_id)


def get_posts(db: Session, skip: int = 0, limit: int = 100) -> list[Post]:
    """Get a list of posts with pagination."""
    stmt = select(Post).offset(skip).limit(limit)
    return list(db.exec(stmt).all())


def get_posts_by_author(db: Session, author_id: int) -> list[Post]:
    """Get all posts by an author."""
    stmt = select(Post).where(Post.author_id == author_id)
    return list(db.exec(stmt).all())


def create_post(db: Session, post: PostCreate) -> Post:
    """Create a new post."""
    db_post = Post.model_validate(post)
    db.add(db_post)
    db.commit()
    db.refresh(db_post)
    return db_post


def update_post(db: Session, post_id: int, post: PostUpdate) -> Post | None:
    """Update a post."""
    db_post = get_post(db, post_id)
    if db_post is None:
        return None

    update_data = post.model_dump(exclude_unset=True)
    for field, value in update_data.items():
        setattr(db_post, field, value)
    db_post.updated_at = datetime.utcnow()

    db.add(db_post)
    db.commit()
    db.refresh(db_post)
    return db_post


def delete_post(db: Session, post_id: int) -> bool:
    """Delete a post."""
    db_post = get_post(db, post_id)
    if db_post is None:
        return False

    db.delete(db_post)
    db.commit()
    return True
{{/if}}
{{/if}}
`],
  ["python-base/src/app/models.py.hbs", `{{#if (ne pythonOrm "none")}}
{{#if (eq pythonOrm "sqlalchemy")}}
"""SQLAlchemy models."""

from datetime import datetime

from sqlalchemy import DateTime, Integer, String, Text, func
from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column


class Base(DeclarativeBase):
    """Base class for all models."""

    pass


class User(Base):
    """User model."""

    __tablename__ = "users"

    id: Mapped[int] = mapped_column(Integer, primary_key=True, index=True)
    email: Mapped[str] = mapped_column(String(255), unique=True, index=True, nullable=False)
    name: Mapped[str | None] = mapped_column(String(255), nullable=True)
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), server_default=func.now(), nullable=False
    )
    updated_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), server_default=func.now(), onupdate=func.now(), nullable=False
    )

    def __repr__(self) -> str:
        return f"<User(id={self.id}, email={self.email})>"


class Post(Base):
    """Post model - example model for reference."""

    __tablename__ = "posts"

    id: Mapped[int] = mapped_column(Integer, primary_key=True, index=True)
    title: Mapped[str] = mapped_column(String(255), nullable=False)
    content: Mapped[str | None] = mapped_column(Text, nullable=True)
    author_id: Mapped[int] = mapped_column(Integer, index=True, nullable=False)
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), server_default=func.now(), nullable=False
    )
    updated_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), server_default=func.now(), onupdate=func.now(), nullable=False
    )

    def __repr__(self) -> str:
        return f"<Post(id={self.id}, title={self.title})>"
{{/if}}
{{#if (eq pythonOrm "sqlmodel")}}
"""SQLModel models - combined database models and Pydantic schemas."""

from datetime import datetime

from pydantic import EmailStr
from sqlmodel import Field, SQLModel


# Base models for creation/update (without id and timestamps)
class UserBase(SQLModel):
    """Base user model for creation and updates."""

    email: EmailStr = Field(index=True, unique=True)
    name: str | None = Field(default=None, max_length=255)


class PostBase(SQLModel):
    """Base post model for creation and updates."""

    title: str = Field(max_length=255)
    content: str | None = Field(default=None)


# Database table models
class User(UserBase, table=True):
    """User database model."""

    __tablename__ = "users"

    id: int | None = Field(default=None, primary_key=True)
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)


class Post(PostBase, table=True):
    """Post database model."""

    __tablename__ = "posts"

    id: int | None = Field(default=None, primary_key=True)
    author_id: int = Field(index=True)
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)


# Create/Update schemas (for API input)
class UserCreate(UserBase):
    """Schema for creating a user."""

    pass


class UserUpdate(SQLModel):
    """Schema for updating a user."""

    email: EmailStr | None = None
    name: str | None = None


class PostCreate(PostBase):
    """Schema for creating a post."""

    author_id: int


class PostUpdate(SQLModel):
    """Schema for updating a post."""

    title: str | None = None
    content: str | None = None


# Response schemas (for API output)
class UserResponse(UserBase):
    """Schema for user response."""

    id: int
    created_at: datetime
    updated_at: datetime


class PostResponse(PostBase):
    """Schema for post response."""

    id: int
    author_id: int
    created_at: datetime
    updated_at: datetime
{{/if}}
{{/if}}
`],
  ["python-base/src/app/langchain_client.py.hbs", `{{#if (includes pythonAi "langchain")}}
"""LangChain client for LLM interactions."""

import os
from typing import AsyncIterator

from langchain_core.messages import AIMessage, HumanMessage, SystemMessage
from langchain_core.output_parsers import StrOutputParser
from langchain_core.prompts import ChatPromptTemplate, MessagesPlaceholder
from langchain_openai import ChatOpenAI


def get_llm(
    model: str = "gpt-4o-mini",
    temperature: float = 0.7,
    streaming: bool = False,
) -> ChatOpenAI:
    """Get a configured LangChain LLM instance.

    Args:
        model: The model to use (default: gpt-4o-mini).
        temperature: The temperature for generation (0.0-2.0).
        streaming: Whether to enable streaming responses.

    Returns:
        A configured ChatOpenAI instance.

    Raises:
        ValueError: If OPENAI_API_KEY is not set.
    """
    api_key = os.getenv("OPENAI_API_KEY")
    if not api_key:
        raise ValueError("OPENAI_API_KEY environment variable is not set")

    return ChatOpenAI(
        model=model,
        temperature=temperature,
        streaming=streaming,
        api_key=api_key,
    )


def create_chat_chain(
    system_prompt: str = "You are a helpful assistant.",
    model: str = "gpt-4o-mini",
    temperature: float = 0.7,
):
    """Create a chat chain with conversation history support.

    Args:
        system_prompt: The system prompt to set context.
        model: The model to use.
        temperature: The temperature for generation.

    Returns:
        A runnable chain that accepts messages and returns responses.
    """
    llm = get_llm(model=model, temperature=temperature)

    prompt = ChatPromptTemplate.from_messages([
        ("system", system_prompt),
        MessagesPlaceholder(variable_name="history"),
        ("human", "{input}"),
    ])

    chain = prompt | llm | StrOutputParser()
    return chain


async def chat(
    message: str,
    history: list[dict] | None = None,
    system_prompt: str = "You are a helpful assistant.",
    model: str = "gpt-4o-mini",
    temperature: float = 0.7,
) -> str:
    """Send a message and get a response.

    Args:
        message: The user's message.
        history: Optional conversation history as list of {"role": str, "content": str}.
        system_prompt: The system prompt to set context.
        model: The model to use.
        temperature: The temperature for generation.

    Returns:
        The assistant's response.
    """
    chain = create_chat_chain(
        system_prompt=system_prompt,
        model=model,
        temperature=temperature,
    )

    # Convert history to LangChain message format
    messages = []
    if history:
        for msg in history:
            if msg["role"] == "user":
                messages.append(HumanMessage(content=msg["content"]))
            elif msg["role"] == "assistant":
                messages.append(AIMessage(content=msg["content"]))
            elif msg["role"] == "system":
                messages.append(SystemMessage(content=msg["content"]))

    response = await chain.ainvoke({"input": message, "history": messages})
    return response


async def chat_stream(
    message: str,
    history: list[dict] | None = None,
    system_prompt: str = "You are a helpful assistant.",
    model: str = "gpt-4o-mini",
    temperature: float = 0.7,
) -> AsyncIterator[str]:
    """Send a message and stream the response.

    Args:
        message: The user's message.
        history: Optional conversation history.
        system_prompt: The system prompt to set context.
        model: The model to use.
        temperature: The temperature for generation.

    Yields:
        Chunks of the assistant's response.
    """
    llm = get_llm(model=model, temperature=temperature, streaming=True)

    prompt = ChatPromptTemplate.from_messages([
        ("system", system_prompt),
        MessagesPlaceholder(variable_name="history"),
        ("human", "{input}"),
    ])

    chain = prompt | llm | StrOutputParser()

    # Convert history to LangChain message format
    messages = []
    if history:
        for msg in history:
            if msg["role"] == "user":
                messages.append(HumanMessage(content=msg["content"]))
            elif msg["role"] == "assistant":
                messages.append(AIMessage(content=msg["content"]))

    async for chunk in chain.astream({"input": message, "history": messages}):
        yield chunk


def simple_completion(
    prompt: str,
    model: str = "gpt-4o-mini",
    temperature: float = 0.7,
) -> str:
    """Get a simple completion without conversation history.

    Args:
        prompt: The prompt to complete.
        model: The model to use.
        temperature: The temperature for generation.

    Returns:
        The completion response.
    """
    llm = get_llm(model=model, temperature=temperature)
    response = llm.invoke(prompt)
    return response.content
{{/if}}
`],
  ["python-base/src/app/schemas.py.hbs", `{{#if (eq pythonValidation "pydantic")}}
{{#if (eq pythonOrm "none")}}
"""Pydantic schemas for request/response validation."""

from pydantic import BaseModel, EmailStr, Field


# Example request/response schemas
class ItemCreate(BaseModel):
    """Schema for creating an item."""

    name: str = Field(..., min_length=1, max_length=100, description="Item name")
    description: str | None = Field(None, max_length=500, description="Item description")
    price: float = Field(..., gt=0, description="Item price (must be positive)")
    quantity: int = Field(default=1, ge=0, description="Item quantity")


class ItemResponse(BaseModel):
    """Schema for item response."""

    id: int
    name: str
    description: str | None
    price: float
    quantity: int


class MessageCreate(BaseModel):
    """Schema for creating a message."""

    email: EmailStr = Field(..., description="Sender email address")
    subject: str = Field(..., min_length=1, max_length=200, description="Message subject")
    content: str = Field(..., min_length=1, description="Message content")


class MessageResponse(BaseModel):
    """Schema for message response."""

    success: bool
    message: str
{{/if}}
{{#if (eq pythonOrm "sqlalchemy")}}
"""Pydantic schemas for request/response validation."""

from datetime import datetime

from pydantic import BaseModel, ConfigDict, EmailStr


# User schemas
class UserBase(BaseModel):
    """Base user schema."""

    email: EmailStr
    name: str | None = None


class UserCreate(UserBase):
    """Schema for creating a user."""

    pass


class UserUpdate(BaseModel):
    """Schema for updating a user."""

    email: EmailStr | None = None
    name: str | None = None


class UserResponse(UserBase):
    """Schema for user response."""

    model_config = ConfigDict(from_attributes=True)

    id: int
    created_at: datetime
    updated_at: datetime


# Post schemas
class PostBase(BaseModel):
    """Base post schema."""

    title: str
    content: str | None = None


class PostCreate(PostBase):
    """Schema for creating a post."""

    author_id: int


class PostUpdate(BaseModel):
    """Schema for updating a post."""

    title: str | None = None
    content: str | None = None


class PostResponse(PostBase):
    """Schema for post response."""

    model_config = ConfigDict(from_attributes=True)

    id: int
    author_id: int
    created_at: datetime
    updated_at: datetime
{{/if}}
{{/if}}
`],
  ["python-base/src/app/main.py.hbs", `"""Main application entry point."""

import os

from dotenv import load_dotenv

load_dotenv()

{{#if (eq pythonWebFramework "fastapi")}}
from contextlib import asynccontextmanager

from fastapi import FastAPI{{#if (or (eq pythonOrm "sqlalchemy") (eq pythonOrm "sqlmodel"))}}, Depends, HTTPException{{/if}}{{#if (and (eq pythonOrm "none") (eq pythonValidation "pydantic"))}}, HTTPException{{/if}}
from fastapi.middleware.cors import CORSMiddleware
{{#if (eq pythonValidation "pydantic")}}
from app.settings import get_settings
{{#if (eq pythonOrm "none")}}
from app.schemas import ItemCreate, ItemResponse, MessageCreate, MessageResponse
{{/if}}
{{/if}}
{{#if (eq pythonOrm "sqlalchemy")}}
from sqlalchemy.orm import Session

from app import crud
from app.database import get_db, init_db
{{#if (eq pythonValidation "pydantic")}}
from app.schemas import PostCreate, PostResponse, PostUpdate, UserCreate, UserResponse, UserUpdate
{{/if}}
{{/if}}
{{#if (eq pythonOrm "sqlmodel")}}
from sqlmodel import Session

from app import crud
from app.database import get_db, init_db
from app.models import (
    PostCreate,
    PostResponse,
    PostUpdate,
    UserCreate,
    UserResponse,
    UserUpdate,
)
{{/if}}
{{#if (includes pythonAi "langchain")}}
from fastapi.responses import StreamingResponse

from app.langchain_client import chat, chat_stream, simple_completion
from app.langchain_schemas import (
    ChatRequest,
    ChatResponse,
    CompletionRequest,
    CompletionResponse,
)
{{/if}}
{{#if (includes pythonAi "llamaindex")}}
from fastapi.responses import StreamingResponse

from app.llamaindex_client import (
    chat as llamaindex_chat,
    chat_stream as llamaindex_chat_stream,
    simple_completion as llamaindex_completion,
)
from app.llamaindex_schemas import (
    ChatRequest as LlamaIndexChatRequest,
    ChatResponse as LlamaIndexChatResponse,
    CompletionRequest as LlamaIndexCompletionRequest,
    CompletionResponse as LlamaIndexCompletionResponse,
)
{{/if}}
{{#if (includes pythonAi "openai-sdk")}}
from fastapi.responses import StreamingResponse

from app.openai_client import (
    chat as openai_chat,
    chat_stream as openai_chat_stream,
    simple_completion as openai_completion,
)
from app.openai_schemas import (
    OpenAIChatRequest,
    OpenAIChatResponse,
    OpenAICompletionRequest,
    OpenAICompletionResponse,
)
{{/if}}
{{#if (includes pythonAi "anthropic-sdk")}}
from fastapi.responses import StreamingResponse

from app.anthropic_client import (
    chat as anthropic_chat,
    chat_stream as anthropic_chat_stream,
    simple_completion as anthropic_completion,
)
from app.anthropic_schemas import (
    AnthropicChatRequest,
    AnthropicChatResponse,
    AnthropicCompletionRequest,
    AnthropicCompletionResponse,
)
{{/if}}
{{#if (includes pythonAi "langgraph")}}
from fastapi.responses import StreamingResponse

from app.langgraph_client import (
    chat as langgraph_chat,
    chat_stream as langgraph_chat_stream,
    run_agent as langgraph_agent,
    simple_completion as langgraph_completion,
)
from app.langgraph_schemas import (
    LangGraphAgentRequest,
    LangGraphAgentResponse,
    LangGraphChatRequest,
    LangGraphChatResponse,
    LangGraphCompletionRequest,
    LangGraphCompletionResponse,
)
{{/if}}
{{#if (includes pythonAi "crewai")}}
from app.crewai_client import (
    run_research_crew as crewai_research,
    run_analysis_crew as crewai_analysis,
    run_custom_crew as crewai_custom,
    simple_completion as crewai_completion,
)
from app.crewai_schemas import (
    CrewAIResearchRequest,
    CrewAIResearchResponse,
    CrewAIAnalysisRequest,
    CrewAIAnalysisResponse,
    CrewAICustomRequest,
    CrewAICustomResponse,
    CrewAICompletionRequest,
    CrewAICompletionResponse,
)
{{/if}}
{{#if (eq pythonTaskQueue "celery")}}
from celery.result import AsyncResult

from app.celery_app import celery_app
from app.tasks import (
    example_task,
    send_email_task,
    process_data_task,
)
from app.celery_schemas import (
    TaskSubmitRequest,
    TaskSubmitResponse,
    TaskStatusResponse,
    EmailTaskRequest,
    DataProcessRequest,
    TaskRevokeRequest,
    TaskRevokeResponse,
)
{{/if}}


@asynccontextmanager
async def lifespan(app: FastAPI):
    """Application lifespan handler."""
{{#if (or (eq pythonOrm "sqlalchemy") (eq pythonOrm "sqlmodel"))}}
    # Initialize database tables on startup
    init_db()
{{/if}}
    yield


{{#if (eq pythonValidation "pydantic")}}
settings = get_settings()

app = FastAPI(
    title=settings.app_name,
    description="A Python API built with Better Fullstack",
    version="0.1.0",
    lifespan=lifespan,
)
{{else}}
app = FastAPI(
    title="{{projectName}}",
    description="A Python API built with Better Fullstack",
    version="0.1.0",
    lifespan=lifespan,
)
{{/if}}

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


@app.get("/")
async def root():
    """Root endpoint."""
    return {"message": "Welcome to {{projectName}}!"}


@app.get("/health")
async def health():
    """Health check endpoint."""
    return {"status": "healthy"}

{{#if (includes pythonAi "langchain")}}

# LangChain AI endpoints
@app.post("/ai/chat", response_model=ChatResponse)
async def langchain_chat(request: ChatRequest):
    """Chat with an AI assistant using LangChain.

    Supports conversation history for multi-turn conversations.
    """
    history = None
    if request.history:
        history = [{"role": msg.role, "content": msg.content} for msg in request.history]

    response = await chat(
        message=request.message,
        history=history,
        system_prompt=request.system_prompt or "You are a helpful assistant.",
        model=request.model or "gpt-4o-mini",
        temperature=request.temperature or 0.7,
    )
    return ChatResponse(response=response)


@app.post("/ai/chat/stream")
async def langchain_chat_stream(request: ChatRequest):
    """Chat with an AI assistant using LangChain with streaming response.

    Returns a Server-Sent Events stream of the response.
    """
    history = None
    if request.history:
        history = [{"role": msg.role, "content": msg.content} for msg in request.history]

    async def generate():
        async for chunk in chat_stream(
            message=request.message,
            history=history,
            system_prompt=request.system_prompt or "You are a helpful assistant.",
            model=request.model or "gpt-4o-mini",
            temperature=request.temperature or 0.7,
        ):
            yield f"data: {chunk}\\n\\n"
        yield "data: [DONE]\\n\\n"

    return StreamingResponse(generate(), media_type="text/event-stream")


@app.post("/ai/completion", response_model=CompletionResponse)
async def langchain_completion(request: CompletionRequest):
    """Get a simple completion from the AI without conversation history."""
    completion = simple_completion(
        prompt=request.prompt,
        model=request.model or "gpt-4o-mini",
        temperature=request.temperature or 0.7,
    )
    return CompletionResponse(completion=completion)
{{/if}}
{{#if (includes pythonAi "llamaindex")}}

# LlamaIndex AI endpoints
@app.post("/ai/llamaindex/chat", response_model=LlamaIndexChatResponse)
async def llamaindex_chat_endpoint(request: LlamaIndexChatRequest):
    """Chat with an AI assistant using LlamaIndex.

    Supports conversation history for multi-turn conversations.
    """
    history = None
    if request.history:
        history = [{"role": msg.role, "content": msg.content} for msg in request.history]

    response = await llamaindex_chat(
        message=request.message,
        history=history,
        system_prompt=request.system_prompt or "You are a helpful assistant.",
        model=request.model or "gpt-4o-mini",
        temperature=request.temperature or 0.7,
    )
    return LlamaIndexChatResponse(response=response)


@app.post("/ai/llamaindex/chat/stream")
async def llamaindex_chat_stream_endpoint(request: LlamaIndexChatRequest):
    """Chat with an AI assistant using LlamaIndex with streaming response.

    Returns a Server-Sent Events stream of the response.
    """
    history = None
    if request.history:
        history = [{"role": msg.role, "content": msg.content} for msg in request.history]

    async def generate():
        async for chunk in llamaindex_chat_stream(
            message=request.message,
            history=history,
            system_prompt=request.system_prompt or "You are a helpful assistant.",
            model=request.model or "gpt-4o-mini",
            temperature=request.temperature or 0.7,
        ):
            yield f"data: {chunk}\\n\\n"
        yield "data: [DONE]\\n\\n"

    return StreamingResponse(generate(), media_type="text/event-stream")


@app.post("/ai/llamaindex/completion", response_model=LlamaIndexCompletionResponse)
async def llamaindex_completion_endpoint(request: LlamaIndexCompletionRequest):
    """Get a simple completion from the AI without conversation history."""
    completion = llamaindex_completion(
        prompt=request.prompt,
        model=request.model or "gpt-4o-mini",
        temperature=request.temperature or 0.7,
    )
    return LlamaIndexCompletionResponse(completion=completion)
{{/if}}
{{#if (includes pythonAi "openai-sdk")}}

# OpenAI SDK endpoints
@app.post("/ai/openai/chat", response_model=OpenAIChatResponse)
async def openai_chat_endpoint(request: OpenAIChatRequest):
    """Chat with OpenAI's API directly.

    Supports conversation history for multi-turn conversations.
    """
    history = None
    if request.history:
        history = [{"role": msg.role, "content": msg.content} for msg in request.history]

    response = await openai_chat(
        message=request.message,
        history=history,
        system_prompt=request.system_prompt or "You are a helpful assistant.",
        model=request.model or "gpt-4o-mini",
        temperature=request.temperature or 0.7,
    )
    return OpenAIChatResponse(response=response)


@app.post("/ai/openai/chat/stream")
async def openai_chat_stream_endpoint(request: OpenAIChatRequest):
    """Chat with OpenAI's API with streaming response.

    Returns a Server-Sent Events stream of the response.
    """
    history = None
    if request.history:
        history = [{"role": msg.role, "content": msg.content} for msg in request.history]

    async def generate():
        async for chunk in openai_chat_stream(
            message=request.message,
            history=history,
            system_prompt=request.system_prompt or "You are a helpful assistant.",
            model=request.model or "gpt-4o-mini",
            temperature=request.temperature or 0.7,
        ):
            yield f"data: {chunk}\\n\\n"
        yield "data: [DONE]\\n\\n"

    return StreamingResponse(generate(), media_type="text/event-stream")


@app.post("/ai/openai/completion", response_model=OpenAICompletionResponse)
async def openai_completion_endpoint(request: OpenAICompletionRequest):
    """Get a simple completion from OpenAI without conversation history."""
    completion = await openai_completion(
        prompt=request.prompt,
        model=request.model or "gpt-4o-mini",
        temperature=request.temperature or 0.7,
    )
    return OpenAICompletionResponse(completion=completion)
{{/if}}
{{#if (includes pythonAi "anthropic-sdk")}}

# Anthropic SDK endpoints
@app.post("/ai/anthropic/chat", response_model=AnthropicChatResponse)
async def anthropic_chat_endpoint(request: AnthropicChatRequest):
    """Chat with Anthropic's Claude API directly.

    Supports conversation history for multi-turn conversations.
    """
    history = None
    if request.history:
        history = [{"role": msg.role, "content": msg.content} for msg in request.history]

    response = await anthropic_chat(
        message=request.message,
        history=history,
        system_prompt=request.system_prompt or "You are a helpful assistant.",
        model=request.model or "claude-sonnet-4-20250514",
        max_tokens=request.max_tokens or 4096,
        temperature=request.temperature or 0.7,
    )
    return AnthropicChatResponse(response=response)


@app.post("/ai/anthropic/chat/stream")
async def anthropic_chat_stream_endpoint(request: AnthropicChatRequest):
    """Chat with Anthropic's Claude API with streaming response.

    Returns a Server-Sent Events stream of the response.
    """
    history = None
    if request.history:
        history = [{"role": msg.role, "content": msg.content} for msg in request.history]

    async def generate():
        async for chunk in anthropic_chat_stream(
            message=request.message,
            history=history,
            system_prompt=request.system_prompt or "You are a helpful assistant.",
            model=request.model or "claude-sonnet-4-20250514",
            max_tokens=request.max_tokens or 4096,
            temperature=request.temperature or 0.7,
        ):
            yield f"data: {chunk}\\n\\n"
        yield "data: [DONE]\\n\\n"

    return StreamingResponse(generate(), media_type="text/event-stream")


@app.post("/ai/anthropic/completion", response_model=AnthropicCompletionResponse)
async def anthropic_completion_endpoint(request: AnthropicCompletionRequest):
    """Get a simple completion from Anthropic without conversation history."""
    completion = await anthropic_completion(
        prompt=request.prompt,
        model=request.model or "claude-sonnet-4-20250514",
        max_tokens=request.max_tokens or 4096,
        temperature=request.temperature or 0.7,
    )
    return AnthropicCompletionResponse(completion=completion)
{{/if}}
{{#if (includes pythonAi "langgraph")}}

# LangGraph AI endpoints
@app.post("/ai/langgraph/chat", response_model=LangGraphChatResponse)
async def langgraph_chat_endpoint(request: LangGraphChatRequest):
    """Chat with an AI assistant using LangGraph.

    Supports conversation history for multi-turn conversations.
    """
    history = None
    if request.history:
        history = [{"role": msg.role, "content": msg.content} for msg in request.history]

    response = await langgraph_chat(
        message=request.message,
        history=history,
        system_prompt=request.system_prompt or "You are a helpful assistant.",
        model=request.model or "gpt-4o-mini",
        temperature=request.temperature or 0.7,
    )
    return LangGraphChatResponse(response=response)


@app.post("/ai/langgraph/chat/stream")
async def langgraph_chat_stream_endpoint(request: LangGraphChatRequest):
    """Chat with an AI assistant using LangGraph with streaming response.

    Returns a Server-Sent Events stream of the response.
    """
    history = None
    if request.history:
        history = [{"role": msg.role, "content": msg.content} for msg in request.history]

    async def generate():
        async for chunk in langgraph_chat_stream(
            message=request.message,
            history=history,
            system_prompt=request.system_prompt or "You are a helpful assistant.",
            model=request.model or "gpt-4o-mini",
            temperature=request.temperature or 0.7,
        ):
            yield f"data: {chunk}\\n\\n"
        yield "data: [DONE]\\n\\n"

    return StreamingResponse(generate(), media_type="text/event-stream")


@app.post("/ai/langgraph/agent", response_model=LangGraphAgentResponse)
async def langgraph_agent_endpoint(request: LangGraphAgentRequest):
    """Run a LangGraph agent that can perform multi-step reasoning.

    The agent can loop through multiple reasoning steps before providing
    a final answer. Useful for complex tasks that require planning.
    """
    history = None
    if request.history:
        history = [{"role": msg.role, "content": msg.content} for msg in request.history]

    response = await langgraph_agent(
        message=request.message,
        history=history,
        system_prompt=request.system_prompt or "You are a helpful assistant. Think step by step.",
        model=request.model or "gpt-4o-mini",
        temperature=request.temperature or 0.7,
        max_iterations=request.max_iterations or 10,
    )
    return LangGraphAgentResponse(response=response)


@app.post("/ai/langgraph/completion", response_model=LangGraphCompletionResponse)
async def langgraph_completion_endpoint(request: LangGraphCompletionRequest):
    """Get a simple completion using LangGraph without conversation history."""
    completion = langgraph_completion(
        prompt=request.prompt,
        model=request.model or "gpt-4o-mini",
        temperature=request.temperature or 0.7,
    )
    return LangGraphCompletionResponse(completion=completion)
{{/if}}
{{#if (includes pythonAi "crewai")}}

# CrewAI endpoints
@app.post("/ai/crewai/research", response_model=CrewAIResearchResponse)
async def crewai_research_endpoint(request: CrewAIResearchRequest):
    """Run a research crew that analyzes a topic.

    Creates a crew with researcher and writer agents to analyze
    a given topic and produce a comprehensive summary.
    """
    result = await crewai_research(
        topic=request.topic,
        verbose=request.verbose if request.verbose is not None else True,
    )
    return CrewAIResearchResponse(result=result)


@app.post("/ai/crewai/analysis", response_model=CrewAIAnalysisResponse)
async def crewai_analysis_endpoint(request: CrewAIAnalysisRequest):
    """Run an analysis crew that analyzes data.

    Creates a crew with an analyst agent to examine
    the provided data and generate insights.
    """
    result = await crewai_analysis(
        data=request.data,
        analysis_type=request.analysis_type or "general",
        verbose=request.verbose if request.verbose is not None else True,
    )
    return CrewAIAnalysisResponse(result=result)


@app.post("/ai/crewai/custom", response_model=CrewAICustomResponse)
async def crewai_custom_endpoint(request: CrewAICustomRequest):
    """Run a custom crew with a single agent and task.

    Provides a flexible way to create and run a crew with
    custom agent and task configurations.
    """
    result = await crewai_custom(
        task_description=request.task_description,
        expected_output=request.expected_output,
        agent_role=request.agent_role or "Assistant",
        agent_goal=request.agent_goal or "Complete the assigned task efficiently",
        agent_backstory=request.agent_backstory or "You are a helpful assistant capable of handling various tasks.",
        verbose=request.verbose if request.verbose is not None else True,
    )
    return CrewAICustomResponse(result=result)


@app.post("/ai/crewai/completion", response_model=CrewAICompletionResponse)
async def crewai_completion_endpoint(request: CrewAICompletionRequest):
    """Get a simple completion using CrewAI."""
    completion = crewai_completion(
        prompt=request.prompt,
        verbose=request.verbose if request.verbose is not None else False,
    )
    return CrewAICompletionResponse(completion=completion)
{{/if}}
{{#if (eq pythonTaskQueue "celery")}}

# Celery task endpoints
@app.post("/tasks/submit", response_model=TaskSubmitResponse)
async def submit_task(request: TaskSubmitRequest):
    """Submit a background task for processing.

    Returns immediately with a task ID that can be used
    to check the task status.
    """
    result = example_task.delay(request.message)
    return TaskSubmitResponse(
        task_id=result.id,
        status="PENDING",
    )


@app.get("/tasks/{task_id}", response_model=TaskStatusResponse)
async def get_task_status(task_id: str):
    """Get the status of a submitted task.

    Returns the current status and result if completed.
    """
    result = AsyncResult(task_id, app=celery_app)

    response = TaskStatusResponse(
        task_id=task_id,
        status=result.status,
    )

    if result.ready():
        if result.successful():
            response.result = result.result
        else:
            response.error = str(result.result)
    elif result.status == "PROCESSING":
        # Get progress info from task meta
        meta = result.info
        if meta and isinstance(meta, dict):
            response.progress = meta.get("progress")

    return response


@app.post("/tasks/{task_id}/revoke", response_model=TaskRevokeResponse)
async def revoke_task(task_id: str, request: TaskRevokeRequest):
    """Revoke a pending or running task.

    If terminate is True, the task will be terminated even
    if it's currently running.
    """
    celery_app.control.revoke(task_id, terminate=request.terminate)
    return TaskRevokeResponse(
        task_id=task_id,
        revoked=True,
    )


@app.post("/tasks/email", response_model=TaskSubmitResponse)
async def submit_email_task(request: EmailTaskRequest):
    """Submit an email sending task.

    The email will be sent asynchronously in the background.
    """
    result = send_email_task.delay(
        to_email=request.to_email,
        subject=request.subject,
        body=request.body,
    )
    return TaskSubmitResponse(
        task_id=result.id,
        status="PENDING",
    )


@app.post("/tasks/process-data", response_model=TaskSubmitResponse)
async def submit_data_processing_task(request: DataProcessRequest):
    """Submit a data processing task.

    The data will be processed asynchronously. Check task
    status for progress updates.
    """
    result = process_data_task.delay(
        data=request.data,
        operation=request.operation or "default",
    )
    return TaskSubmitResponse(
        task_id=result.id,
        status="PENDING",
    )
{{/if}}
{{#if (and (eq pythonOrm "none") (eq pythonValidation "pydantic"))}}

# In-memory storage for demo (replace with database in production)
_items: dict[int, ItemResponse] = {}
_next_id = 1


@app.post("/items", response_model=ItemResponse, status_code=201)
async def create_item(item: ItemCreate):
    """Create a new item with validated data."""
    global _next_id
    item_response = ItemResponse(
        id=_next_id,
        name=item.name,
        description=item.description,
        price=item.price,
        quantity=item.quantity,
    )
    _items[_next_id] = item_response
    _next_id += 1
    return item_response


@app.get("/items", response_model=list[ItemResponse])
async def list_items():
    """List all items."""
    return list(_items.values())


@app.get("/items/{item_id}", response_model=ItemResponse)
async def get_item(item_id: int):
    """Get an item by ID."""
    if item_id not in _items:
        raise HTTPException(status_code=404, detail="Item not found")
    return _items[item_id]


@app.post("/contact", response_model=MessageResponse)
async def send_message(message: MessageCreate):
    """Send a contact message with validated email."""
    # In a real app, this would send an email or store the message
    return MessageResponse(
        success=True,
        message=f"Message received from {message.email}",
    )
{{/if}}
{{#if (eq pythonOrm "sqlalchemy")}}

# User endpoints
{{#if (eq pythonValidation "pydantic")}}
@app.post("/users", response_model=UserResponse, status_code=201)
async def create_user(user: UserCreate, db: Session = Depends(get_db)):
    """Create a new user."""
    existing = crud.get_user_by_email(db, user.email)
    if existing:
        raise HTTPException(status_code=400, detail="Email already registered")
    return crud.create_user(db, user)


@app.get("/users", response_model=list[UserResponse])
async def list_users(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):
    """List all users."""
    return crud.get_users(db, skip=skip, limit=limit)


@app.get("/users/{user_id}", response_model=UserResponse)
async def get_user(user_id: int, db: Session = Depends(get_db)):
    """Get a user by ID."""
    user = crud.get_user(db, user_id)
    if user is None:
        raise HTTPException(status_code=404, detail="User not found")
    return user


@app.patch("/users/{user_id}", response_model=UserResponse)
async def update_user(user_id: int, user: UserUpdate, db: Session = Depends(get_db)):
    """Update a user."""
    updated = crud.update_user(db, user_id, user)
    if updated is None:
        raise HTTPException(status_code=404, detail="User not found")
    return updated


@app.delete("/users/{user_id}", status_code=204)
async def delete_user(user_id: int, db: Session = Depends(get_db)):
    """Delete a user."""
    if not crud.delete_user(db, user_id):
        raise HTTPException(status_code=404, detail="User not found")


# Post endpoints
@app.post("/posts", response_model=PostResponse, status_code=201)
async def create_post(post: PostCreate, db: Session = Depends(get_db)):
    """Create a new post."""
    # Verify author exists
    if crud.get_user(db, post.author_id) is None:
        raise HTTPException(status_code=400, detail="Author not found")
    return crud.create_post(db, post)


@app.get("/posts", response_model=list[PostResponse])
async def list_posts(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):
    """List all posts."""
    return crud.get_posts(db, skip=skip, limit=limit)


@app.get("/posts/{post_id}", response_model=PostResponse)
async def get_post(post_id: int, db: Session = Depends(get_db)):
    """Get a post by ID."""
    post = crud.get_post(db, post_id)
    if post is None:
        raise HTTPException(status_code=404, detail="Post not found")
    return post


@app.patch("/posts/{post_id}", response_model=PostResponse)
async def update_post(post_id: int, post: PostUpdate, db: Session = Depends(get_db)):
    """Update a post."""
    updated = crud.update_post(db, post_id, post)
    if updated is None:
        raise HTTPException(status_code=404, detail="Post not found")
    return updated


@app.delete("/posts/{post_id}", status_code=204)
async def delete_post(post_id: int, db: Session = Depends(get_db)):
    """Delete a post."""
    if not crud.delete_post(db, post_id):
        raise HTTPException(status_code=404, detail="Post not found")
{{/if}}
{{/if}}
{{#if (eq pythonOrm "sqlmodel")}}

# User endpoints
@app.post("/users", response_model=UserResponse, status_code=201)
async def create_user(user: UserCreate, db: Session = Depends(get_db)):
    """Create a new user."""
    existing = crud.get_user_by_email(db, user.email)
    if existing:
        raise HTTPException(status_code=400, detail="Email already registered")
    return crud.create_user(db, user)


@app.get("/users", response_model=list[UserResponse])
async def list_users(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):
    """List all users."""
    return crud.get_users(db, skip=skip, limit=limit)


@app.get("/users/{user_id}", response_model=UserResponse)
async def get_user(user_id: int, db: Session = Depends(get_db)):
    """Get a user by ID."""
    user = crud.get_user(db, user_id)
    if user is None:
        raise HTTPException(status_code=404, detail="User not found")
    return user


@app.patch("/users/{user_id}", response_model=UserResponse)
async def update_user(user_id: int, user: UserUpdate, db: Session = Depends(get_db)):
    """Update a user."""
    updated = crud.update_user(db, user_id, user)
    if updated is None:
        raise HTTPException(status_code=404, detail="User not found")
    return updated


@app.delete("/users/{user_id}", status_code=204)
async def delete_user(user_id: int, db: Session = Depends(get_db)):
    """Delete a user."""
    if not crud.delete_user(db, user_id):
        raise HTTPException(status_code=404, detail="User not found")


# Post endpoints
@app.post("/posts", response_model=PostResponse, status_code=201)
async def create_post(post: PostCreate, db: Session = Depends(get_db)):
    """Create a new post."""
    # Verify author exists
    if crud.get_user(db, post.author_id) is None:
        raise HTTPException(status_code=400, detail="Author not found")
    return crud.create_post(db, post)


@app.get("/posts", response_model=list[PostResponse])
async def list_posts(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):
    """List all posts."""
    return crud.get_posts(db, skip=skip, limit=limit)


@app.get("/posts/{post_id}", response_model=PostResponse)
async def get_post(post_id: int, db: Session = Depends(get_db)):
    """Get a post by ID."""
    post = crud.get_post(db, post_id)
    if post is None:
        raise HTTPException(status_code=404, detail="Post not found")
    return post


@app.patch("/posts/{post_id}", response_model=PostResponse)
async def update_post(post_id: int, post: PostUpdate, db: Session = Depends(get_db)):
    """Update a post."""
    updated = crud.update_post(db, post_id, post)
    if updated is None:
        raise HTTPException(status_code=404, detail="Post not found")
    return updated


@app.delete("/posts/{post_id}", status_code=204)
async def delete_post(post_id: int, db: Session = Depends(get_db)):
    """Delete a post."""
    if not crud.delete_post(db, post_id):
        raise HTTPException(status_code=404, detail="Post not found")
{{/if}}


if __name__ == "__main__":
    import uvicorn

    uvicorn.run(
        "app.main:app",
        host=os.getenv("HOST", "0.0.0.0"),
        port=int(os.getenv("PORT", "8000")),
        reload=True,
    )
{{/if}}
{{#if (eq pythonWebFramework "django")}}
import django
from django.conf import settings
from django.http import JsonResponse
from django.urls import path

if not settings.configured:
    settings.configure(
        DEBUG=os.getenv("DEBUG", "true").lower() == "true",
        ROOT_URLCONF=__name__,
        SECRET_KEY=os.getenv("SECRET_KEY", "change-me-in-production"),
        ALLOWED_HOSTS=["*"],
        INSTALLED_APPS=[
            "django.contrib.contenttypes",
            "django.contrib.auth",
            "corsheaders",
        ],
        MIDDLEWARE=[
            "corsheaders.middleware.CorsMiddleware",
            "django.middleware.common.CommonMiddleware",
        ],
        CORS_ALLOW_ALL_ORIGINS=True,
    )
    django.setup()


def root(request):
    """Root endpoint."""
    return JsonResponse({"message": "Welcome to {{projectName}}!"})


def health(request):
    """Health check endpoint."""
    return JsonResponse({"status": "healthy"})


urlpatterns = [
    path("", root),
    path("health", health),
]


if __name__ == "__main__":
    from django.core.management import execute_from_command_line
    import sys

    sys.argv = ["manage.py", "runserver", f"{os.getenv('HOST', '0.0.0.0')}:{os.getenv('PORT', '8000')}"]
    execute_from_command_line(sys.argv)
{{/if}}
{{#if (eq pythonWebFramework "none")}}
def main():
    """Main entry point."""
    print("Welcome to {{projectName}}!")
    print("Add your application logic here.")


if __name__ == "__main__":
    main()
{{/if}}
`],
  ["python-base/src/app/crewai_schemas.py.hbs", `{{#if (includes pythonAi "crewai")}}
"""Pydantic schemas for CrewAI API endpoints."""

from pydantic import BaseModel, Field


class CrewAIResearchRequest(BaseModel):
    """Request body for CrewAI research endpoint."""

    topic: str = Field(..., description="The topic to research", min_length=1)
    verbose: bool | None = Field(
        default=None, description="Whether to enable verbose output"
    )


class CrewAIResearchResponse(BaseModel):
    """Response body for CrewAI research endpoint."""

    result: str = Field(..., description="The research results")


class CrewAIAnalysisRequest(BaseModel):
    """Request body for CrewAI analysis endpoint."""

    data: str = Field(..., description="The data to analyze", min_length=1)
    analysis_type: str | None = Field(
        default=None, description="The type of analysis to perform"
    )
    verbose: bool | None = Field(
        default=None, description="Whether to enable verbose output"
    )


class CrewAIAnalysisResponse(BaseModel):
    """Response body for CrewAI analysis endpoint."""

    result: str = Field(..., description="The analysis results")


class CrewAICustomRequest(BaseModel):
    """Request body for CrewAI custom crew endpoint."""

    task_description: str = Field(
        ..., description="Description of the task to perform", min_length=1
    )
    expected_output: str = Field(
        ..., description="Expected output from the task", min_length=1
    )
    agent_role: str | None = Field(
        default=None, description="The role of the agent"
    )
    agent_goal: str | None = Field(
        default=None, description="The goal of the agent"
    )
    agent_backstory: str | None = Field(
        default=None, description="The backstory of the agent"
    )
    verbose: bool | None = Field(
        default=None, description="Whether to enable verbose output"
    )


class CrewAICustomResponse(BaseModel):
    """Response body for CrewAI custom crew endpoint."""

    result: str = Field(..., description="The task result")


class CrewAICompletionRequest(BaseModel):
    """Request body for simple completion endpoint."""

    prompt: str = Field(..., description="The prompt to complete", min_length=1)
    verbose: bool | None = Field(
        default=None, description="Whether to enable verbose output"
    )


class CrewAICompletionResponse(BaseModel):
    """Response body for completion endpoint."""

    completion: str = Field(..., description="The completion response")
{{/if}}
`],
  ["python-base/src/app/openai_schemas.py.hbs", `{{#if (includes pythonAi "openai-sdk")}}
"""Pydantic schemas for OpenAI API endpoints."""

from pydantic import BaseModel, Field


class ChatMessage(BaseModel):
    """A single message in a conversation."""

    role: str = Field(..., description="The role of the message sender (user, assistant, system)")
    content: str = Field(..., description="The content of the message")


class OpenAIChatRequest(BaseModel):
    """Request body for OpenAI chat endpoint."""

    message: str = Field(..., description="The user's message", min_length=1)
    history: list[ChatMessage] | None = Field(
        default=None, description="Optional conversation history"
    )
    system_prompt: str | None = Field(
        default=None, description="Optional system prompt to override default"
    )
    model: str | None = Field(default=None, description="Optional model override")
    temperature: float | None = Field(
        default=None, ge=0.0, le=2.0, description="Optional temperature override"
    )


class OpenAIChatResponse(BaseModel):
    """Response body for OpenAI chat endpoint."""

    response: str = Field(..., description="The assistant's response")


class OpenAICompletionRequest(BaseModel):
    """Request body for OpenAI completion endpoint."""

    prompt: str = Field(..., description="The prompt to complete", min_length=1)
    model: str | None = Field(default=None, description="Optional model override")
    temperature: float | None = Field(
        default=None, ge=0.0, le=2.0, description="Optional temperature override"
    )


class OpenAICompletionResponse(BaseModel):
    """Response body for OpenAI completion endpoint."""

    completion: str = Field(..., description="The completion response")
{{/if}}
`],
  ["python-base/src/app/celery_schemas.py.hbs", `{{#if (eq pythonTaskQueue "celery")}}
"""Pydantic schemas for Celery task API endpoints."""

from typing import Any

from pydantic import BaseModel, Field


class TaskSubmitRequest(BaseModel):
    """Request body for submitting a task."""

    message: str = Field(
        ...,
        description="Message to process",
        min_length=1,
        max_length=1000,
    )


class TaskSubmitResponse(BaseModel):
    """Response body after submitting a task."""

    task_id: str = Field(..., description="The unique task ID")
    status: str = Field(..., description="Initial task status")


class TaskStatusResponse(BaseModel):
    """Response body for task status check."""

    task_id: str = Field(..., description="The task ID")
    status: str = Field(..., description="Current task status")
    result: dict[str, Any] | None = Field(
        default=None, description="Task result if completed"
    )
    progress: float | None = Field(
        default=None, description="Task progress percentage"
    )
    error: str | None = Field(
        default=None, description="Error message if failed"
    )


class EmailTaskRequest(BaseModel):
    """Request body for email task."""

    to_email: str = Field(..., description="Recipient email address")
    subject: str = Field(..., description="Email subject", min_length=1, max_length=200)
    body: str = Field(..., description="Email body content", min_length=1)


class DataProcessRequest(BaseModel):
    """Request body for data processing task."""

    data: dict[str, Any] = Field(..., description="Data to process")
    operation: str | None = Field(
        default="default",
        description="Type of operation to perform",
    )


class TaskRevokeRequest(BaseModel):
    """Request body for revoking a task."""

    terminate: bool = Field(
        default=False,
        description="Whether to terminate the task if running",
    )


class TaskRevokeResponse(BaseModel):
    """Response body after revoking a task."""

    task_id: str = Field(..., description="The task ID")
    revoked: bool = Field(..., description="Whether the task was revoked")
{{/if}}
`],
  ["python-base/src/app/__init__.py", `"""{{projectName}} - A Python project created with Better Fullstack."""

__version__ = "0.1.0"
`],
  ["python-base/src/app/langgraph_schemas.py.hbs", `{{#if (includes pythonAi "langgraph")}}
"""Pydantic schemas for LangGraph API endpoints."""

from pydantic import BaseModel, Field


class ChatMessage(BaseModel):
    """A single message in a conversation."""

    role: str = Field(..., description="The role of the message sender (user, assistant, system)")
    content: str = Field(..., description="The content of the message")


class LangGraphChatRequest(BaseModel):
    """Request body for LangGraph chat endpoint."""

    message: str = Field(..., description="The user's message", min_length=1)
    history: list[ChatMessage] | None = Field(
        default=None, description="Optional conversation history"
    )
    system_prompt: str | None = Field(
        default=None, description="Optional system prompt to override default"
    )
    model: str | None = Field(default=None, description="Optional model override")
    temperature: float | None = Field(
        default=None, ge=0.0, le=2.0, description="Optional temperature override"
    )


class LangGraphChatResponse(BaseModel):
    """Response body for LangGraph chat endpoint."""

    response: str = Field(..., description="The assistant's response")


class LangGraphAgentRequest(BaseModel):
    """Request body for LangGraph agent endpoint."""

    message: str = Field(..., description="The user's message", min_length=1)
    history: list[ChatMessage] | None = Field(
        default=None, description="Optional conversation history"
    )
    system_prompt: str | None = Field(
        default=None, description="Optional system prompt to override default"
    )
    model: str | None = Field(default=None, description="Optional model override")
    temperature: float | None = Field(
        default=None, ge=0.0, le=2.0, description="Optional temperature override"
    )
    max_iterations: int | None = Field(
        default=None, ge=1, le=50, description="Maximum reasoning iterations"
    )


class LangGraphAgentResponse(BaseModel):
    """Response body for LangGraph agent endpoint."""

    response: str = Field(..., description="The agent's final response")


class LangGraphCompletionRequest(BaseModel):
    """Request body for simple completion endpoint."""

    prompt: str = Field(..., description="The prompt to complete", min_length=1)
    model: str | None = Field(default=None, description="Optional model override")
    temperature: float | None = Field(
        default=None, ge=0.0, le=2.0, description="Optional temperature override"
    )


class LangGraphCompletionResponse(BaseModel):
    """Response body for completion endpoint."""

    completion: str = Field(..., description="The completion response")
{{/if}}
`],
  ["python-base/src/app/tasks.py.hbs", `{{#if (eq pythonTaskQueue "celery")}}
"""Celery task definitions for background job processing."""

import time
from typing import Any

from celery import shared_task
from celery.utils.log import get_task_logger

from app.celery_app import celery_app

# Task logger
logger = get_task_logger(__name__)


@celery_app.task(bind=True, name="app.tasks.example_task")
def example_task(self, message: str) -> dict[str, Any]:
    """Example task that demonstrates basic Celery task structure.

    Args:
        self: The task instance (bound task).
        message: A message to process.

    Returns:
        A dictionary containing the task result.
    """
    logger.info(f"Processing example task with message: {message}")

    # Simulate some work
    time.sleep(2)

    return {
        "status": "completed",
        "message": f"Processed: {message}",
        "task_id": self.request.id,
    }


@celery_app.task(
    bind=True,
    name="app.tasks.send_email_task",
    autoretry_for=(Exception,),
    retry_backoff=True,
    retry_backoff_max=600,
    max_retries=3,
)
def send_email_task(
    self,
    to_email: str,
    subject: str,
    body: str,
) -> dict[str, Any]:
    """Task to send an email asynchronously.

    This task includes automatic retry with exponential backoff
    for handling transient failures.

    Args:
        self: The task instance (bound task).
        to_email: The recipient email address.
        subject: The email subject.
        body: The email body content.

    Returns:
        A dictionary containing the send status.
    """
    logger.info(f"Sending email to {to_email}: {subject}")

    try:
        # TODO: Implement actual email sending logic here
        # For example, using smtplib, SendGrid, or another email service

        # Simulate email sending
        time.sleep(1)

        logger.info(f"Email sent successfully to {to_email}")
        return {
            "status": "sent",
            "to": to_email,
            "subject": subject,
            "task_id": self.request.id,
        }
    except Exception as exc:
        logger.error(f"Failed to send email to {to_email}: {exc}")
        raise self.retry(exc=exc)


@celery_app.task(
    bind=True,
    name="app.tasks.process_data_task",
    autoretry_for=(Exception,),
    retry_backoff=True,
    max_retries=3,
)
def process_data_task(
    self,
    data: dict[str, Any],
    operation: str = "default",
) -> dict[str, Any]:
    """Task to process data asynchronously.

    Useful for heavy data processing that shouldn't block
    the main application.

    Args:
        self: The task instance (bound task).
        data: The data to process.
        operation: The type of operation to perform.

    Returns:
        A dictionary containing the processing result.
    """
    logger.info(f"Processing data with operation: {operation}")

    try:
        # Update task state to show progress
        self.update_state(
            state="PROCESSING",
            meta={"progress": 0, "operation": operation},
        )

        # Simulate data processing
        total_items = len(data) if isinstance(data, (list, dict)) else 1
        processed_items = 0

        # Simulate processing each item
        for i in range(total_items):
            time.sleep(0.5)  # Simulate work
            processed_items += 1
            self.update_state(
                state="PROCESSING",
                meta={
                    "progress": (processed_items / total_items) * 100,
                    "operation": operation,
                    "processed": processed_items,
                    "total": total_items,
                },
            )

        logger.info(f"Data processing completed: {processed_items} items")
        return {
            "status": "completed",
            "operation": operation,
            "processed_items": processed_items,
            "task_id": self.request.id,
        }
    except Exception as exc:
        logger.error(f"Data processing failed: {exc}")
        raise self.retry(exc=exc)


@celery_app.task(bind=True, name="app.tasks.scheduled_cleanup_task")
def scheduled_cleanup_task(self) -> dict[str, Any]:
    """Periodic task for cleanup operations.

    This task is designed to be run on a schedule using Celery Beat.
    Configure in celeryconfig.py or through the beat schedule.

    Returns:
        A dictionary containing the cleanup status.
    """
    logger.info("Running scheduled cleanup task")

    # TODO: Implement actual cleanup logic here
    # For example:
    # - Clean up expired sessions
    # - Remove temporary files
    # - Archive old records

    time.sleep(1)  # Simulate cleanup work

    return {
        "status": "completed",
        "task_id": self.request.id,
        "message": "Cleanup completed successfully",
    }


@shared_task(name="app.tasks.add_numbers")
def add_numbers(x: int, y: int) -> int:
    """Simple task example using shared_task decorator.

    The shared_task decorator allows the task to be used
    without a specific Celery app instance.

    Args:
        x: First number.
        y: Second number.

    Returns:
        The sum of x and y.
    """
    logger.info(f"Adding numbers: {x} + {y}")
    return x + y
{{/if}}
`],
  ["python-base/src/app/llamaindex_client.py.hbs", `{{#if (includes pythonAi "llamaindex")}}
"""LlamaIndex client for RAG-based LLM interactions."""

import os
from typing import AsyncIterator

from llama_index.core import Settings, VectorStoreIndex, Document
from llama_index.core.chat_engine import SimpleChatEngine
from llama_index.core.chat_engine.types import ChatMode
from llama_index.llms.openai import OpenAI
from llama_index.embeddings.openai import OpenAIEmbedding


def configure_settings(
    model: str = "gpt-4o-mini",
    temperature: float = 0.7,
    embed_model: str = "text-embedding-3-small",
) -> None:
    """Configure global LlamaIndex settings.

    Args:
        model: The LLM model to use (default: gpt-4o-mini).
        temperature: The temperature for generation (0.0-2.0).
        embed_model: The embedding model to use.

    Raises:
        ValueError: If OPENAI_API_KEY is not set.
    """
    api_key = os.getenv("OPENAI_API_KEY")
    if not api_key:
        raise ValueError("OPENAI_API_KEY environment variable is not set")

    Settings.llm = OpenAI(model=model, temperature=temperature, api_key=api_key)
    Settings.embed_model = OpenAIEmbedding(model=embed_model, api_key=api_key)


def get_llm(
    model: str = "gpt-4o-mini",
    temperature: float = 0.7,
) -> OpenAI:
    """Get a configured LlamaIndex LLM instance.

    Args:
        model: The model to use (default: gpt-4o-mini).
        temperature: The temperature for generation (0.0-2.0).

    Returns:
        A configured OpenAI LLM instance.

    Raises:
        ValueError: If OPENAI_API_KEY is not set.
    """
    api_key = os.getenv("OPENAI_API_KEY")
    if not api_key:
        raise ValueError("OPENAI_API_KEY environment variable is not set")

    return OpenAI(model=model, temperature=temperature, api_key=api_key)


def create_index_from_texts(
    texts: list[str],
    model: str = "gpt-4o-mini",
    temperature: float = 0.7,
    embed_model: str = "text-embedding-3-small",
) -> VectorStoreIndex:
    """Create a VectorStoreIndex from a list of text strings.

    Args:
        texts: List of text strings to index.
        model: The LLM model to use.
        temperature: The temperature for generation.
        embed_model: The embedding model to use.

    Returns:
        A VectorStoreIndex containing the indexed documents.
    """
    configure_settings(model=model, temperature=temperature, embed_model=embed_model)

    documents = [Document(text=text) for text in texts]
    index = VectorStoreIndex.from_documents(documents)
    return index


async def query_index(
    index: VectorStoreIndex,
    query: str,
    similarity_top_k: int = 3,
) -> str:
    """Query an index and return the response.

    Args:
        index: The VectorStoreIndex to query.
        query: The query string.
        similarity_top_k: Number of similar documents to retrieve.

    Returns:
        The query response as a string.
    """
    query_engine = index.as_query_engine(similarity_top_k=similarity_top_k)
    response = await query_engine.aquery(query)
    return str(response)


async def query_index_stream(
    index: VectorStoreIndex,
    query: str,
    similarity_top_k: int = 3,
) -> AsyncIterator[str]:
    """Query an index and stream the response.

    Args:
        index: The VectorStoreIndex to query.
        query: The query string.
        similarity_top_k: Number of similar documents to retrieve.

    Yields:
        Chunks of the query response.
    """
    query_engine = index.as_query_engine(
        similarity_top_k=similarity_top_k,
        streaming=True,
    )
    response = await query_engine.aquery(query)

    for token in response.response_gen:
        yield token


async def chat(
    message: str,
    history: list[dict] | None = None,
    system_prompt: str = "You are a helpful assistant.",
    model: str = "gpt-4o-mini",
    temperature: float = 0.7,
) -> str:
    """Send a message and get a response using LlamaIndex chat engine.

    Args:
        message: The user's message.
        history: Optional conversation history as list of {"role": str, "content": str}.
        system_prompt: The system prompt to set context.
        model: The model to use.
        temperature: The temperature for generation.

    Returns:
        The assistant's response.
    """
    llm = get_llm(model=model, temperature=temperature)

    chat_engine = SimpleChatEngine.from_defaults(
        llm=llm,
        system_prompt=system_prompt,
    )

    # If we have history, replay it to build context
    if history:
        for msg in history:
            if msg["role"] == "user":
                # Use non-streaming chat for history replay
                await chat_engine.achat(msg["content"])

    response = await chat_engine.achat(message)
    return str(response)


async def chat_stream(
    message: str,
    history: list[dict] | None = None,
    system_prompt: str = "You are a helpful assistant.",
    model: str = "gpt-4o-mini",
    temperature: float = 0.7,
) -> AsyncIterator[str]:
    """Send a message and stream the response.

    Args:
        message: The user's message.
        history: Optional conversation history.
        system_prompt: The system prompt to set context.
        model: The model to use.
        temperature: The temperature for generation.

    Yields:
        Chunks of the assistant's response.
    """
    llm = get_llm(model=model, temperature=temperature)

    chat_engine = SimpleChatEngine.from_defaults(
        llm=llm,
        system_prompt=system_prompt,
    )

    # If we have history, replay it to build context
    if history:
        for msg in history:
            if msg["role"] == "user":
                await chat_engine.achat(msg["content"])

    response = await chat_engine.astream_chat(message)

    async for token in response.async_response_gen():
        yield token


def simple_completion(
    prompt: str,
    model: str = "gpt-4o-mini",
    temperature: float = 0.7,
) -> str:
    """Get a simple completion without conversation history.

    Args:
        prompt: The prompt to complete.
        model: The model to use.
        temperature: The temperature for generation.

    Returns:
        The completion response.
    """
    llm = get_llm(model=model, temperature=temperature)
    response = llm.complete(prompt)
    return str(response)
{{/if}}
`],
  ["python-base/src/app/crewai_client.py.hbs", `{{#if (includes pythonAi "crewai")}}
"""CrewAI client for building multi-agent orchestration systems."""

import os
from typing import AsyncIterator

from crewai import Agent, Crew, Process, Task


def get_openai_api_key() -> str:
    """Get the OpenAI API key from environment.

    Returns:
        The OpenAI API key.

    Raises:
        ValueError: If OPENAI_API_KEY is not set.
    """
    api_key = os.getenv("OPENAI_API_KEY")
    if not api_key:
        raise ValueError("OPENAI_API_KEY environment variable is not set")
    return api_key


def create_agent(
    role: str,
    goal: str,
    backstory: str,
    verbose: bool = True,
    allow_delegation: bool = False,
) -> Agent:
    """Create a CrewAI agent.

    Args:
        role: The role of the agent.
        goal: The goal the agent aims to achieve.
        backstory: The backstory of the agent.
        verbose: Whether to enable verbose output.
        allow_delegation: Whether the agent can delegate tasks.

    Returns:
        A configured CrewAI Agent.
    """
    # Ensure API key is set
    get_openai_api_key()

    return Agent(
        role=role,
        goal=goal,
        backstory=backstory,
        verbose=verbose,
        allow_delegation=allow_delegation,
    )


def create_task(
    description: str,
    expected_output: str,
    agent: Agent,
) -> Task:
    """Create a CrewAI task.

    Args:
        description: The description of the task.
        expected_output: The expected output of the task.
        agent: The agent assigned to this task.

    Returns:
        A configured CrewAI Task.
    """
    return Task(
        description=description,
        expected_output=expected_output,
        agent=agent,
    )


def create_crew(
    agents: list[Agent],
    tasks: list[Task],
    process: Process = Process.sequential,
    verbose: bool = True,
) -> Crew:
    """Create a CrewAI crew.

    Args:
        agents: List of agents in the crew.
        tasks: List of tasks for the crew.
        process: The process type (sequential or hierarchical).
        verbose: Whether to enable verbose output.

    Returns:
        A configured CrewAI Crew.
    """
    return Crew(
        agents=agents,
        tasks=tasks,
        process=process,
        verbose=verbose,
    )


async def run_research_crew(
    topic: str,
    verbose: bool = True,
) -> str:
    """Run a research crew that analyzes a topic.

    This creates a simple research crew with a researcher and writer
    to analyze a given topic and produce a summary.

    Args:
        topic: The topic to research.
        verbose: Whether to enable verbose output.

    Returns:
        The research summary.
    """
    # Create researcher agent
    researcher = create_agent(
        role="Senior Researcher",
        goal=f"Research and analyze {topic} thoroughly",
        backstory="You are an expert researcher with a keen eye for detail. "
        "You specialize in finding accurate and comprehensive information.",
        verbose=verbose,
        allow_delegation=False,
    )

    # Create writer agent
    writer = create_agent(
        role="Content Writer",
        goal="Create clear and engaging content based on research",
        backstory="You are a skilled writer who excels at making complex topics "
        "accessible to a general audience.",
        verbose=verbose,
        allow_delegation=False,
    )

    # Create research task
    research_task = create_task(
        description=f"Research the topic: {topic}. "
        "Find key information, trends, and insights.",
        expected_output="A comprehensive research summary with key findings.",
        agent=researcher,
    )

    # Create writing task
    writing_task = create_task(
        description="Based on the research findings, write a clear and engaging summary.",
        expected_output="A well-structured summary suitable for a general audience.",
        agent=writer,
    )

    # Create and run the crew
    crew = create_crew(
        agents=[researcher, writer],
        tasks=[research_task, writing_task],
        process=Process.sequential,
        verbose=verbose,
    )

    result = crew.kickoff()
    return str(result)


async def run_analysis_crew(
    data: str,
    analysis_type: str = "general",
    verbose: bool = True,
) -> str:
    """Run an analysis crew that analyzes data.

    This creates an analysis crew with an analyst to examine
    the provided data and generate insights.

    Args:
        data: The data to analyze.
        analysis_type: The type of analysis to perform.
        verbose: Whether to enable verbose output.

    Returns:
        The analysis results.
    """
    # Create analyst agent
    analyst = create_agent(
        role="Data Analyst",
        goal=f"Perform {analysis_type} analysis and provide actionable insights",
        backstory="You are an experienced data analyst with expertise in "
        "identifying patterns, trends, and actionable insights from data.",
        verbose=verbose,
        allow_delegation=False,
    )

    # Create analysis task
    analysis_task = create_task(
        description=f"Analyze the following data and provide {analysis_type} insights:\\n{data}",
        expected_output="A detailed analysis report with key findings and recommendations.",
        agent=analyst,
    )

    # Create and run the crew
    crew = create_crew(
        agents=[analyst],
        tasks=[analysis_task],
        process=Process.sequential,
        verbose=verbose,
    )

    result = crew.kickoff()
    return str(result)


async def run_custom_crew(
    task_description: str,
    expected_output: str,
    agent_role: str = "Assistant",
    agent_goal: str = "Complete the assigned task efficiently",
    agent_backstory: str = "You are a helpful assistant capable of handling various tasks.",
    verbose: bool = True,
) -> str:
    """Run a custom crew with a single agent and task.

    This provides a flexible way to create and run a crew with
    custom agent and task configurations.

    Args:
        task_description: Description of the task to perform.
        expected_output: Expected output from the task.
        agent_role: The role of the agent.
        agent_goal: The goal of the agent.
        agent_backstory: The backstory of the agent.
        verbose: Whether to enable verbose output.

    Returns:
        The task result.
    """
    # Create custom agent
    agent = create_agent(
        role=agent_role,
        goal=agent_goal,
        backstory=agent_backstory,
        verbose=verbose,
        allow_delegation=False,
    )

    # Create custom task
    task = create_task(
        description=task_description,
        expected_output=expected_output,
        agent=agent,
    )

    # Create and run the crew
    crew = create_crew(
        agents=[agent],
        tasks=[task],
        process=Process.sequential,
        verbose=verbose,
    )

    result = crew.kickoff()
    return str(result)


def simple_completion(
    prompt: str,
    verbose: bool = False,
) -> str:
    """Get a simple completion using CrewAI.

    Args:
        prompt: The prompt to complete.
        verbose: Whether to enable verbose output.

    Returns:
        The completion response.
    """
    # Create a simple assistant agent
    assistant = create_agent(
        role="Assistant",
        goal="Provide helpful and accurate responses",
        backstory="You are a helpful AI assistant.",
        verbose=verbose,
        allow_delegation=False,
    )

    # Create completion task
    task = create_task(
        description=prompt,
        expected_output="A helpful response to the request.",
        agent=assistant,
    )

    # Create and run the crew
    crew = create_crew(
        agents=[assistant],
        tasks=[task],
        process=Process.sequential,
        verbose=verbose,
    )

    result = crew.kickoff()
    return str(result)
{{/if}}
`],
  ["python-base/src/app/llamaindex_schemas.py.hbs", `{{#if (includes pythonAi "llamaindex")}}
"""Pydantic schemas for LlamaIndex API endpoints."""

from pydantic import BaseModel, Field


class ChatMessage(BaseModel):
    """A single message in a conversation."""

    role: str = Field(..., description="The role of the message sender (user, assistant, system)")
    content: str = Field(..., description="The content of the message")


class ChatRequest(BaseModel):
    """Request body for chat endpoint."""

    message: str = Field(..., description="The user's message", min_length=1)
    history: list[ChatMessage] | None = Field(
        default=None, description="Optional conversation history"
    )
    system_prompt: str | None = Field(
        default=None, description="Optional system prompt to override default"
    )
    model: str | None = Field(default=None, description="Optional model override")
    temperature: float | None = Field(
        default=None, ge=0.0, le=2.0, description="Optional temperature override"
    )


class ChatResponse(BaseModel):
    """Response body for chat endpoint."""

    response: str = Field(..., description="The assistant's response")


class CompletionRequest(BaseModel):
    """Request body for simple completion endpoint."""

    prompt: str = Field(..., description="The prompt to complete", min_length=1)
    model: str | None = Field(default=None, description="Optional model override")
    temperature: float | None = Field(
        default=None, ge=0.0, le=2.0, description="Optional temperature override"
    )


class CompletionResponse(BaseModel):
    """Response body for completion endpoint."""

    completion: str = Field(..., description="The completion response")


class IndexBuildRequest(BaseModel):
    """Request body for building an index from texts."""

    texts: list[str] = Field(
        ..., description="List of text strings to index", min_length=1
    )
    model: str | None = Field(default=None, description="Optional LLM model override")
    embed_model: str | None = Field(
        default=None, description="Optional embedding model override"
    )


class IndexBuildResponse(BaseModel):
    """Response body for index build endpoint."""

    success: bool = Field(..., description="Whether the index was built successfully")
    document_count: int = Field(..., description="Number of documents indexed")
    message: str = Field(..., description="Status message")


class IndexQueryRequest(BaseModel):
    """Request body for querying an index."""

    query: str = Field(..., description="The query string", min_length=1)
    similarity_top_k: int | None = Field(
        default=3, ge=1, le=20, description="Number of similar documents to retrieve"
    )


class IndexQueryResponse(BaseModel):
    """Response body for index query endpoint."""

    response: str = Field(..., description="The query response")
{{/if}}
`],
  ["python-base/src/app/langgraph_client.py.hbs", `{{#if (includes pythonAi "langgraph")}}
"""LangGraph client for building stateful AI agent workflows."""

import os
from typing import AsyncIterator, Literal

from langchain_core.messages import AIMessage, HumanMessage, SystemMessage
from langchain_openai import ChatOpenAI
from langgraph.graph import END, MessagesState, StateGraph


def get_llm(
    model: str = "gpt-4o-mini",
    temperature: float = 0.7,
    streaming: bool = False,
) -> ChatOpenAI:
    """Get a configured LangChain LLM instance for use with LangGraph.

    Args:
        model: The model to use (default: gpt-4o-mini).
        temperature: The temperature for generation (0.0-2.0).
        streaming: Whether to enable streaming responses.

    Returns:
        A configured ChatOpenAI instance.

    Raises:
        ValueError: If OPENAI_API_KEY is not set.
    """
    api_key = os.getenv("OPENAI_API_KEY")
    if not api_key:
        raise ValueError("OPENAI_API_KEY environment variable is not set")

    return ChatOpenAI(
        model=model,
        temperature=temperature,
        streaming=streaming,
        api_key=api_key,
    )


def create_chat_graph(
    system_prompt: str = "You are a helpful assistant.",
    model: str = "gpt-4o-mini",
    temperature: float = 0.7,
):
    """Create a simple chat graph using LangGraph.

    This creates a basic conversational agent that processes messages
    and returns responses using the configured LLM.

    Args:
        system_prompt: The system prompt to set context.
        model: The model to use.
        temperature: The temperature for generation.

    Returns:
        A compiled LangGraph that accepts messages and returns responses.
    """
    llm = get_llm(model=model, temperature=temperature)

    async def chat_node(state: MessagesState) -> dict:
        """Process messages and generate a response."""
        messages = state["messages"]

        # Prepend system message if not already present
        if not messages or not isinstance(messages[0], SystemMessage):
            messages = [SystemMessage(content=system_prompt)] + list(messages)

        response = await llm.ainvoke(messages)
        return {"messages": [response]}

    # Build the graph
    builder = StateGraph(MessagesState)
    builder.add_node("chat", chat_node)
    builder.set_entry_point("chat")
    builder.add_edge("chat", END)

    return builder.compile()


def create_agent_graph(
    system_prompt: str = "You are a helpful assistant.",
    model: str = "gpt-4o-mini",
    temperature: float = 0.7,
    max_iterations: int = 10,
):
    """Create an agent graph that can reason and take multiple steps.

    This creates an agent that can loop through multiple reasoning steps
    before providing a final answer.

    Args:
        system_prompt: The system prompt to set context.
        model: The model to use.
        temperature: The temperature for generation.
        max_iterations: Maximum number of iterations before stopping.

    Returns:
        A compiled LangGraph agent.
    """
    llm = get_llm(model=model, temperature=temperature)

    async def reasoning_node(state: MessagesState) -> dict:
        """Perform a reasoning step."""
        messages = state["messages"]

        # Prepend system message if not already present
        if not messages or not isinstance(messages[0], SystemMessage):
            messages = [SystemMessage(content=system_prompt)] + list(messages)

        response = await llm.ainvoke(messages)
        return {"messages": [response]}

    def should_continue(state: MessagesState) -> Literal["reasoning", "__end__"]:
        """Determine if we should continue reasoning or end."""
        messages = state["messages"]

        # End if we have too many messages (prevent infinite loops)
        if len(messages) > max_iterations * 2:
            return END

        # Check if the last message indicates completion
        if messages:
            last_message = messages[-1]
            if isinstance(last_message, AIMessage):
                content = last_message.content.lower()
                # Simple heuristic: end if response seems complete
                if any(
                    phrase in content
                    for phrase in ["final answer", "in conclusion", "to summarize"]
                ):
                    return END

        return END  # Default to ending after one response for simple chat

    # Build the graph
    builder = StateGraph(MessagesState)
    builder.add_node("reasoning", reasoning_node)
    builder.set_entry_point("reasoning")
    builder.add_conditional_edges("reasoning", should_continue, {"reasoning": "reasoning", END: END})

    return builder.compile()


async def chat(
    message: str,
    history: list[dict] | None = None,
    system_prompt: str = "You are a helpful assistant.",
    model: str = "gpt-4o-mini",
    temperature: float = 0.7,
) -> str:
    """Send a message and get a response using LangGraph.

    Args:
        message: The user's message.
        history: Optional conversation history as list of {"role": str, "content": str}.
        system_prompt: The system prompt to set context.
        model: The model to use.
        temperature: The temperature for generation.

    Returns:
        The assistant's response.
    """
    graph = create_chat_graph(
        system_prompt=system_prompt,
        model=model,
        temperature=temperature,
    )

    # Build message list from history
    messages = []
    if history:
        for msg in history:
            if msg["role"] == "user":
                messages.append(HumanMessage(content=msg["content"]))
            elif msg["role"] == "assistant":
                messages.append(AIMessage(content=msg["content"]))
            elif msg["role"] == "system":
                messages.append(SystemMessage(content=msg["content"]))

    # Add the current message
    messages.append(HumanMessage(content=message))

    # Invoke the graph
    result = await graph.ainvoke({"messages": messages})

    # Extract the last AI message
    for msg in reversed(result["messages"]):
        if isinstance(msg, AIMessage):
            return msg.content

    return ""


async def chat_stream(
    message: str,
    history: list[dict] | None = None,
    system_prompt: str = "You are a helpful assistant.",
    model: str = "gpt-4o-mini",
    temperature: float = 0.7,
) -> AsyncIterator[str]:
    """Send a message and stream the response using LangGraph.

    Args:
        message: The user's message.
        history: Optional conversation history.
        system_prompt: The system prompt to set context.
        model: The model to use.
        temperature: The temperature for generation.

    Yields:
        Chunks of the assistant's response.
    """
    llm = get_llm(model=model, temperature=temperature, streaming=True)

    # Build message list from history
    messages = [SystemMessage(content=system_prompt)]
    if history:
        for msg in history:
            if msg["role"] == "user":
                messages.append(HumanMessage(content=msg["content"]))
            elif msg["role"] == "assistant":
                messages.append(AIMessage(content=msg["content"]))

    messages.append(HumanMessage(content=message))

    # Stream directly from the LLM for simplicity
    async for chunk in llm.astream(messages):
        if chunk.content:
            yield chunk.content


async def run_agent(
    message: str,
    history: list[dict] | None = None,
    system_prompt: str = "You are a helpful assistant. Think step by step.",
    model: str = "gpt-4o-mini",
    temperature: float = 0.7,
    max_iterations: int = 10,
) -> str:
    """Run an agent that can perform multi-step reasoning.

    Args:
        message: The user's message.
        history: Optional conversation history.
        system_prompt: The system prompt to set context.
        model: The model to use.
        temperature: The temperature for generation.
        max_iterations: Maximum reasoning iterations.

    Returns:
        The agent's final response.
    """
    graph = create_agent_graph(
        system_prompt=system_prompt,
        model=model,
        temperature=temperature,
        max_iterations=max_iterations,
    )

    # Build message list from history
    messages = []
    if history:
        for msg in history:
            if msg["role"] == "user":
                messages.append(HumanMessage(content=msg["content"]))
            elif msg["role"] == "assistant":
                messages.append(AIMessage(content=msg["content"]))
            elif msg["role"] == "system":
                messages.append(SystemMessage(content=msg["content"]))

    # Add the current message
    messages.append(HumanMessage(content=message))

    # Invoke the graph
    result = await graph.ainvoke({"messages": messages})

    # Extract the last AI message
    for msg in reversed(result["messages"]):
        if isinstance(msg, AIMessage):
            return msg.content

    return ""


def simple_completion(
    prompt: str,
    model: str = "gpt-4o-mini",
    temperature: float = 0.7,
) -> str:
    """Get a simple completion without conversation history.

    Args:
        prompt: The prompt to complete.
        model: The model to use.
        temperature: The temperature for generation.

    Returns:
        The completion response.
    """
    llm = get_llm(model=model, temperature=temperature)
    response = llm.invoke(prompt)
    return response.content
{{/if}}
`],
  ["python-base/src/app/celery_app.py.hbs", `{{#if (eq pythonTaskQueue "celery")}}
"""Celery application configuration for distributed task processing."""

import os

from celery import Celery

# Get broker and backend URLs from environment
broker_url = os.getenv("CELERY_BROKER_URL", "redis://localhost:6379/0")
result_backend = os.getenv("CELERY_RESULT_BACKEND", "redis://localhost:6379/0")

# Create the Celery application
celery_app = Celery(
    "{{projectName}}",
    broker=broker_url,
    backend=result_backend,
    include=["app.tasks"],
)

# Celery configuration
celery_app.conf.update(
    # Task settings
    task_serializer="json",
    accept_content=["json"],
    result_serializer="json",
    timezone="UTC",
    enable_utc=True,
    # Task execution settings
    task_track_started=True,
    task_time_limit=30 * 60,  # 30 minutes
    task_soft_time_limit=25 * 60,  # 25 minutes
    # Result settings
    result_expires=3600,  # 1 hour
    # Worker settings
    worker_prefetch_multiplier=1,
    worker_concurrency=4,
    # Task routing (optional - customize as needed)
    task_routes={
        "app.tasks.send_email_task": {"queue": "email"},
        "app.tasks.process_data_task": {"queue": "data"},
    },
    # Retry settings
    task_default_retry_delay=60,  # 1 minute
    task_max_retries=3,
)


def get_celery_app() -> Celery:
    """Get the configured Celery application instance.

    Returns:
        The Celery application instance.
    """
    return celery_app
{{/if}}
`],
  ["python-base/src/app/anthropic_client.py.hbs", `{{#if (includes pythonAi "anthropic-sdk")}}
"""Anthropic client for Claude API interactions."""

import os
from typing import AsyncIterator

import anthropic


def get_client() -> anthropic.AsyncAnthropic:
    """Get a configured Anthropic client instance.

    Returns:
        A configured AsyncAnthropic instance.

    Raises:
        ValueError: If ANTHROPIC_API_KEY is not set.
    """
    api_key = os.getenv("ANTHROPIC_API_KEY")
    if not api_key:
        raise ValueError("ANTHROPIC_API_KEY environment variable is not set")

    return anthropic.AsyncAnthropic(api_key=api_key)


async def chat(
    message: str,
    history: list[dict] | None = None,
    system_prompt: str = "You are a helpful assistant.",
    model: str = "claude-sonnet-4-20250514",
    max_tokens: int = 4096,
    temperature: float = 0.7,
) -> str:
    """Send a message and get a response from Claude.

    Args:
        message: The user's message.
        history: Optional conversation history as list of {"role": str, "content": str}.
        system_prompt: The system prompt to set context.
        model: The model to use.
        max_tokens: Maximum number of tokens in the response.
        temperature: The temperature for generation.

    Returns:
        The assistant's response.
    """
    client = get_client()

    messages: list[anthropic.types.MessageParam] = []

    if history:
        for msg in history:
            messages.append({"role": msg["role"], "content": msg["content"]})

    messages.append({"role": "user", "content": message})

    response = await client.messages.create(
        model=model,
        max_tokens=max_tokens,
        system=system_prompt,
        messages=messages,
        temperature=temperature,
    )

    # Extract text from content blocks
    text_content = ""
    for block in response.content:
        if block.type == "text":
            text_content += block.text

    return text_content


async def chat_stream(
    message: str,
    history: list[dict] | None = None,
    system_prompt: str = "You are a helpful assistant.",
    model: str = "claude-sonnet-4-20250514",
    max_tokens: int = 4096,
    temperature: float = 0.7,
) -> AsyncIterator[str]:
    """Send a message and stream the response from Claude.

    Args:
        message: The user's message.
        history: Optional conversation history.
        system_prompt: The system prompt to set context.
        model: The model to use.
        max_tokens: Maximum number of tokens in the response.
        temperature: The temperature for generation.

    Yields:
        Chunks of the assistant's response.
    """
    client = get_client()

    messages: list[anthropic.types.MessageParam] = []

    if history:
        for msg in history:
            messages.append({"role": msg["role"], "content": msg["content"]})

    messages.append({"role": "user", "content": message})

    async with client.messages.stream(
        model=model,
        max_tokens=max_tokens,
        system=system_prompt,
        messages=messages,
        temperature=temperature,
    ) as stream:
        async for text in stream.text_stream:
            yield text


async def simple_completion(
    prompt: str,
    model: str = "claude-sonnet-4-20250514",
    max_tokens: int = 4096,
    temperature: float = 0.7,
) -> str:
    """Get a simple completion without conversation history.

    Args:
        prompt: The prompt to complete.
        model: The model to use.
        max_tokens: Maximum number of tokens in the response.
        temperature: The temperature for generation.

    Returns:
        The completion response.
    """
    client = get_client()

    response = await client.messages.create(
        model=model,
        max_tokens=max_tokens,
        messages=[{"role": "user", "content": prompt}],
        temperature=temperature,
    )

    # Extract text from content blocks
    text_content = ""
    for block in response.content:
        if block.type == "text":
            text_content += block.text

    return text_content
{{/if}}
`],
  ["python-base/src/app/anthropic_schemas.py.hbs", `{{#if (includes pythonAi "anthropic-sdk")}}
"""Pydantic schemas for Anthropic API endpoints."""

from pydantic import BaseModel, Field


class ChatMessage(BaseModel):
    """A single message in a conversation."""

    role: str = Field(..., description="The role of the message sender (user, assistant)")
    content: str = Field(..., description="The content of the message")


class AnthropicChatRequest(BaseModel):
    """Request body for Anthropic chat endpoint."""

    message: str = Field(..., description="The user's message", min_length=1)
    history: list[ChatMessage] | None = Field(
        default=None, description="Optional conversation history"
    )
    system_prompt: str | None = Field(
        default=None, description="Optional system prompt to override default"
    )
    model: str | None = Field(default=None, description="Optional model override")
    max_tokens: int | None = Field(
        default=None, ge=1, le=200000, description="Optional max tokens override"
    )
    temperature: float | None = Field(
        default=None, ge=0.0, le=1.0, description="Optional temperature override"
    )


class AnthropicChatResponse(BaseModel):
    """Response body for Anthropic chat endpoint."""

    response: str = Field(..., description="The assistant's response")


class AnthropicCompletionRequest(BaseModel):
    """Request body for Anthropic completion endpoint."""

    prompt: str = Field(..., description="The prompt to complete", min_length=1)
    model: str | None = Field(default=None, description="Optional model override")
    max_tokens: int | None = Field(
        default=None, ge=1, le=200000, description="Optional max tokens override"
    )
    temperature: float | None = Field(
        default=None, ge=0.0, le=1.0, description="Optional temperature override"
    )


class AnthropicCompletionResponse(BaseModel):
    """Response body for Anthropic completion endpoint."""

    completion: str = Field(..., description="The completion response")
{{/if}}
`],
  ["python-base/src/app/langchain_schemas.py.hbs", `{{#if (includes pythonAi "langchain")}}
"""Pydantic schemas for LangChain API endpoints."""

from pydantic import BaseModel, Field


class ChatMessage(BaseModel):
    """A single message in a conversation."""

    role: str = Field(..., description="The role of the message sender (user, assistant, system)")
    content: str = Field(..., description="The content of the message")


class ChatRequest(BaseModel):
    """Request body for chat endpoint."""

    message: str = Field(..., description="The user's message", min_length=1)
    history: list[ChatMessage] | None = Field(
        default=None, description="Optional conversation history"
    )
    system_prompt: str | None = Field(
        default=None, description="Optional system prompt to override default"
    )
    model: str | None = Field(default=None, description="Optional model override")
    temperature: float | None = Field(
        default=None, ge=0.0, le=2.0, description="Optional temperature override"
    )


class ChatResponse(BaseModel):
    """Response body for chat endpoint."""

    response: str = Field(..., description="The assistant's response")


class CompletionRequest(BaseModel):
    """Request body for simple completion endpoint."""

    prompt: str = Field(..., description="The prompt to complete", min_length=1)
    model: str | None = Field(default=None, description="Optional model override")
    temperature: float | None = Field(
        default=None, ge=0.0, le=2.0, description="Optional temperature override"
    )


class CompletionResponse(BaseModel):
    """Response body for completion endpoint."""

    completion: str = Field(..., description="The completion response")
{{/if}}
`],
  ["python-base/migrations/versions/_gitkeep", ``],
  ["addons/husky/.husky/pre-commit", `lint-staged
`],
  ["addons/ruler/.ruler/ruler.toml.hbs", `# Ruler Configuration File
# See https://okigu.com/ruler for documentation.

# Default agents to run when --agents is not specified
default_agents = []

# --- Global MCP Server Configuration ---
[mcp]
# Enable/disable MCP propagation globally (default: true)
enabled = true
# Global merge strategy: 'merge' or 'overwrite' (default: 'merge')
merge_strategy = "merge"

# --- MCP Server Definitions ---
[mcp_servers.context7]
command = "npx"
args = ["-y", "@upstash/context7-mcp"]

{{#if (or (eq runtime "workers") (eq webDeploy "wrangler"))}}
[mcp_servers.cloudflare]
command = "npx"
args = ["mcp-remote", "https://docs.mcp.cloudflare.com/sse"]
{{/if}}

{{#if (eq backend "convex")}}
[mcp_servers.convex]
command = "npx"
args = ["-y", "convex@latest", "mcp", "start"]
{{/if}}

{{#if (or (includes frontend "tanstack-router") (includes frontend "react-router") (includes frontend "tanstack-start") (includes frontend "next"))}}
[mcp_servers.shadcn]
command = "npx"
args = ["shadcn@latest", "mcp"]
{{/if}}

{{#if (eq dbSetup "planetscale")}}
[mcp_servers.planetscale]
command = "pscale"
args = ["mcp", "server"]
{{/if}}

{{#if (eq dbSetup "prisma-postgres")}}
[mcp_servers.prisma]
command = "npx"
args = ["-y", "prisma", "mcp"]
{{/if}}

{{#if (eq dbSetup "neon")}}
[mcp_servers.neon]
command = "npx"
args = ["-y", "mcp-remote@latest", "https://mcp.neon.tech/mcp"]
{{/if}}

{{#if (eq dbSetup "mongodb-atlas")}}
[mcp_servers.mongodb]
command = "npx"
args = ["-y", "mongodb-mcp-server", "--connectionString", "mongodb://localhost:27017/myDatabase", "--readOnly"]
{{/if}}

{{#if (eq auth "better-auth")}}
[mcp_servers.better-auth]
url = "https://mcp.chonkie.ai/better-auth/better-auth-builder/mcp"
{{/if}}

{{#if (includes frontend "nuxt")}}
[mcp_servers.nuxt-ui]
url = "https://ui.nuxt.com/mcp"
{{/if}}

{{#if (includes frontend "next")}}
[mcp_servers.next-devtools]
command = "npx"
args = ["-y", "next-devtools-mcp@latest"]
{{/if}}

# --- Global .gitignore Configuration ---
[gitignore]
# Enable/disable automatic .gitignore updates (default: true)
enabled = true`],
  ["addons/ruler/.ruler/bts.md.hbs", `# Better Fullstack Project Rules

This is a {{projectName}} project created with Better Fullstack CLI.

## Project Structure

This is a monorepo with the following structure:

{{#if (or (includes frontend "tanstack-router") (includes frontend "react-router") (includes frontend "tanstack-start")
(includes frontend "next") (includes frontend "nuxt") (includes frontend "svelte") (includes frontend "solid"))}}
- **\`apps/web/\`** - {{#if (eq backend "self")}}Fullstack application{{else}}Frontend application{{/if}}{{#if (includes frontend "tanstack-router")}} (React with TanStack Router){{else if (includes frontend "react-router")}} (React with React Router){{else if (includes frontend "tanstack-start")}} (TanStack Start){{else if (includes frontend "next")}} (Next.js){{else if (includes frontend "nuxt")}} (Nuxt.js){{else if (includes frontend "svelte")}} (SvelteKit){{else if (includes frontend "solid")}} (SolidStart){{/if}}
{{/if}}

{{#if (ne backend "convex")}}
{{#if (and (ne backend "none") (ne backend "self"))}}
- **\`apps/server/\`** - Backend server{{#if (eq backend "hono")}} (Hono){{else if (eq backend "express")}} (Express){{else if (eq backend "fastify")}} (Fastify){{else if (eq backend "elysia")}} (Elysia){{/if}}
{{/if}}
{{else}}
- **\`packages/backend/\`** - Convex backend functions
{{/if}}

{{#if (or (includes frontend "native-bare") (includes frontend "native-uniwind") (includes frontend "native-unistyles"))}}
- **\`apps/native/\`** - React Native mobile app{{#if (includes frontend "native-uniwind")}} (with NativeWind){{else if (includes frontend "native-unistyles")}} (with Unistyles){{else if (includes frontend "native-bare")}} (bare styling){{/if}}
{{/if}}

{{#if (ne backend "convex")}}
{{#if (ne api "none")}}
- **\`packages/api/\`** - Shared API logic and types
{{/if}}
{{#if (and (ne auth "none") (ne backend "convex"))}}
- **\`packages/auth/\`** - Authentication logic and utilities
{{/if}}
{{#if (and (ne database "none") (ne orm "none"))}}
- **\`packages/db/\`** - Database schema and utilities
{{/if}}
- **\`packages/env/\`** - Shared environment variables and validation
- **\`packages/config/\`** - Shared TypeScript configuration
{{#if (or (eq webDeploy "cloudflare") (eq serverDeploy "cloudflare"))}}
- **\`packages/infra/\`** - Infrastructure as code (Alchemy for Cloudflare)
{{/if}}
{{/if}}

## Available Scripts

- \`{{packageManager}} run dev\` - Start all apps in development mode
{{#if (and (or (includes frontend "tanstack-router") (includes frontend "react-router") (includes frontend "tanstack-start")
(includes frontend "next") (includes frontend "nuxt") (includes frontend "svelte") (includes frontend "solid")) (ne backend "self"))}}
- \`{{packageManager}} run dev:web\` - Start only the web app
{{/if}}
{{#if (and (ne backend "none") (ne backend "convex") (ne backend "self"))}}
- \`{{packageManager}} run dev:server\` - Start only the server
{{/if}}
{{#if (or (includes frontend "native-bare") (includes frontend "native-uniwind") (includes frontend "native-unistyles"))}}
- \`{{packageManager}} run dev:native\` - Start only the native app
{{/if}}
- \`{{packageManager}} run build\` - Build all apps
- \`{{packageManager}} run lint\` - Lint all packages
- \`{{packageManager}} run typecheck\` - Type check all packages

{{#if (and (ne database "none") (ne orm "none") (ne backend "convex"))}}
## Database Commands

All database operations should be run from the {{#if (eq backend "self")}}web{{else}}server{{/if}} workspace:

- \`{{packageManager}} run db:push\` - Push schema changes to database
- \`{{packageManager}} run db:studio\` - Open database studio
- \`{{packageManager}} run db:generate\` - Generate {{#if (eq orm "drizzle")}}Drizzle{{else if (eq orm "prisma")}}Prisma{{else}}{{orm}}{{/if}} files
- \`{{packageManager}} run db:migrate\` - Run database migrations

{{#if (eq orm "drizzle")}}
Database schema files are located in {{#if (eq backend "self")}}\`apps/web/src/db/schema/\`{{else}}\`packages/db/src/schema/\`{{/if}}
{{else if (eq orm "prisma")}}
Database schema is located in {{#if (eq backend "self")}}\`apps/web/prisma/schema.prisma\`{{else}}\`packages/db/prisma/schema.prisma\`{{/if}}
{{else if (eq orm "mongoose")}}
Database models are located in {{#if (eq backend "self")}}\`apps/web/src/db/models/\`{{else}}\`packages/db/src/models/\`{{/if}}
{{/if}}
{{/if}}

{{#if (ne api "none")}}
## API Structure

{{#if (eq api "trpc")}}
- tRPC routers are in \`packages/api/src/routers/\`
- Client-side tRPC utils are in \`apps/web/src/utils/trpc.ts\`
{{else if (eq api "orpc")}}
- oRPC contracts and routers are in \`packages/api/src/\`
- Client-side oRPC client is in \`apps/web/src/utils/orpc.ts\`
{{/if}}
{{/if}}

{{#if (eq auth "better-auth")}}
## Authentication

Authentication is powered by Better Auth:
- Auth configuration is in \`packages/auth/src/\`
{{#if (or (includes frontend "tanstack-router") (includes frontend "react-router") (includes frontend "tanstack-start")
(includes frontend "next") (includes frontend "nuxt") (includes frontend "svelte") (includes frontend "solid"))}}
- Web app auth client is in \`apps/web/src/lib/auth-client.ts\`
{{/if}}
{{#if (or (includes frontend "native-bare") (includes frontend "native-uniwind") (includes frontend "native-unistyles"))}}
- Native app auth client is in \`apps/native/src/lib/auth-client.ts\`
{{/if}}
{{/if}}

## Project Configuration

This project includes a \`bts.jsonc\` configuration file that stores your Better Fullstack settings:

- Contains your selected stack configuration (database, ORM, backend, frontend, etc.)
- Used by the CLI to understand your project structure
- Safe to delete if not needed

## Key Points

- This is a {{#if (includes addons "turborepo")}}Turborepo {{/if}}monorepo using {{packageManager}} workspaces
- Each app has its own \`package.json\` and dependencies
- Run commands from the root to execute across all workspaces
- Run workspace-specific commands with \`{{packageManager}} run command-name\`
{{#if (includes addons "turborepo")}}
- Turborepo handles build caching and parallel execution
{{/if}}
{{#if (or (includes addons "husky") (includes addons "lefthook"))}}
- Git hooks are configured with {{#if (includes addons "husky")}}Husky{{else}}Lefthook{{/if}} for pre-commit checks
{{/if}}
`],
  ["db-setup/docker-compose/mysql/docker-compose.yml.hbs", `name: {{projectName}}

services:
  mysql:
    image: mysql
    container_name: {{projectName}}-mysql
    environment:
      MYSQL_ROOT_PASSWORD: password
      MYSQL_DATABASE: {{projectName}}
      MYSQL_USER: user
      MYSQL_PASSWORD: password
    ports:
      - "3306:3306"
    volumes:
      - {{projectName}}_mysql_data:/var/lib/mysql
    healthcheck:
      test: ["CMD", "mysqladmin", "ping", "-h", "localhost"]
      interval: 10s
      timeout: 5s
      retries: 5
    restart: unless-stopped

volumes:
  {{projectName}}_mysql_data:`],
  ["db-setup/docker-compose/postgres/docker-compose.yml.hbs", `name: {{projectName}}

services:
  postgres:
    image: postgres
    container_name: {{projectName}}-postgres
    environment:
      POSTGRES_DB: {{projectName}}
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: password
    ports:
      - "5432:5432"
    volumes:
      - {{projectName}}_postgres_data:/var/lib/postgresql
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 10s
      timeout: 5s
      retries: 5
    restart: unless-stopped

volumes:
  {{projectName}}_postgres_data:`],
  ["db-setup/docker-compose/mongodb/docker-compose.yml.hbs", `name: {{projectName}}

services:
  mongodb:
    image: mongo
    container_name: {{projectName}}-mongodb
    environment:
      MONGO_INITDB_ROOT_USERNAME: root
      MONGO_INITDB_ROOT_PASSWORD: password
      MONGO_INITDB_DATABASE: {{projectName}}
    ports:
      - "27017:27017"
    volumes:
      - {{projectName}}_mongodb_data:/data/db
    healthcheck:
      test: ["CMD", "mongosh", "--eval", "db.adminCommand('ping')"]
      interval: 10s
      timeout: 5s
      retries: 5
    restart: unless-stopped

volumes:
  {{projectName}}_mongodb_data:`],
  ["db-setup/docker-compose/redis/docker-compose.yml.hbs", `name: {{projectName}}

services:
  redis:
    image: redis:alpine
    container_name: {{projectName}}-redis
    command: redis-server --appendonly yes
    ports:
      - "6379:6379"
    volumes:
      - {{projectName}}_redis_data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5
    restart: unless-stopped

volumes:
  {{projectName}}_redis_data:
`],
  ["go-base/sql/queries/users.sql.hbs", `{{#if (eq goOrm "sqlc")}}
-- name: GetUsers :many
SELECT * FROM users
ORDER BY id;

-- name: GetUser :one
SELECT * FROM users
WHERE id = $1;

-- name: GetUserByEmail :one
SELECT * FROM users
WHERE email = $1;

-- name: CreateUser :one
INSERT INTO users (name, email)
VALUES ($1, $2)
RETURNING *;

-- name: UpdateUser :one
UPDATE users
SET name = COALESCE($2, name),
    email = COALESCE($3, email),
    updated_at = NOW()
WHERE id = $1
RETURNING *;

-- name: DeleteUser :exec
DELETE FROM users
WHERE id = $1;
{{/if}}
`],
  ["go-base/sql/queries/posts.sql.hbs", `{{#if (eq goOrm "sqlc")}}
-- name: GetPosts :many
SELECT p.*, u.name as author_name, u.email as author_email
FROM posts p
JOIN users u ON p.author_id = u.id
ORDER BY p.id;

-- name: GetPost :one
SELECT p.*, u.name as author_name, u.email as author_email
FROM posts p
JOIN users u ON p.author_id = u.id
WHERE p.id = $1;

-- name: GetPostsByAuthor :many
SELECT p.*, u.name as author_name, u.email as author_email
FROM posts p
JOIN users u ON p.author_id = u.id
WHERE p.author_id = $1
ORDER BY p.id;

-- name: CreatePost :one
INSERT INTO posts (title, content, author_id)
VALUES ($1, $2, $3)
RETURNING *;

-- name: UpdatePost :one
UPDATE posts
SET title = COALESCE($2, title),
    content = COALESCE($3, content),
    published = COALESCE($4, published),
    updated_at = NOW()
WHERE id = $1
RETURNING *;

-- name: DeletePost :exec
DELETE FROM posts
WHERE id = $1;
{{/if}}
`],
  ["go-base/cmd/cli/main.go.hbs", `{{#if (eq goCli "cobra")}}
package main

import (
	"fmt"
	"os"

	"github.com/spf13/cobra"
)

var (
	version = "0.1.0"
	verbose bool
)

// rootCmd represents the base command
var rootCmd = &cobra.Command{
	Use:   "{{projectName}}",
	Short: "{{projectName}} CLI application",
	Long: \`{{projectName}} is a CLI application built with Cobra.

This tool provides various commands to interact with your application.\`,
	Version: version,
}

// helloCmd represents the hello command
var helloCmd = &cobra.Command{
	Use:   "hello [name]",
	Short: "Say hello",
	Long:  \`Print a greeting message. Optionally provide a name to personalize the greeting.\`,
	Args:  cobra.MaximumNArgs(1),
	Run: func(cmd *cobra.Command, args []string) {
		name := "World"
		if len(args) > 0 {
			name = args[0]
		}
		if verbose {
			fmt.Printf("Running hello command with name: %s\\n", name)
		}
		fmt.Printf("Hello, %s!\\n", name)
	},
}

// versionCmd represents the version command
var versionCmd = &cobra.Command{
	Use:   "version",
	Short: "Print the version number",
	Long:  \`Print the version number of {{projectName}}\`,
	Run: func(cmd *cobra.Command, args []string) {
		fmt.Printf("{{projectName}} v%s\\n", version)
	},
}

func init() {
	// Global flags
	rootCmd.PersistentFlags().BoolVarP(&verbose, "verbose", "v", false, "verbose output")

	// Add commands
	rootCmd.AddCommand(helloCmd)
	rootCmd.AddCommand(versionCmd)
}

func main() {
	if err := rootCmd.Execute(); err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
}
{{/if}}
`],
  ["go-base/sql/schema/001_schema.sql.hbs", `{{#if (eq goOrm "sqlc")}}
-- Users table
CREATE TABLE IF NOT EXISTS users (
    id BIGSERIAL PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    email VARCHAR(255) NOT NULL UNIQUE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Posts table
CREATE TABLE IF NOT EXISTS posts (
    id BIGSERIAL PRIMARY KEY,
    title VARCHAR(255) NOT NULL,
    content TEXT NOT NULL DEFAULT '',
    published BOOLEAN NOT NULL DEFAULT false,
    author_id BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Indexes
CREATE INDEX IF NOT EXISTS idx_posts_author_id ON posts(author_id);
CREATE INDEX IF NOT EXISTS idx_users_email ON users(email);
{{/if}}
`],
  ["go-base/cmd/server/main.go.hbs", `package main

import (
	"os"
{{#if (eq goWebFramework "gin")}}
	"net/http"

	"github.com/gin-gonic/gin"
{{/if}}
{{#if (eq goWebFramework "echo")}}
	"net/http"

	"github.com/labstack/echo/v4"
	"github.com/labstack/echo/v4/middleware"
{{/if}}
{{#if (or (eq goOrm "gorm") (eq goOrm "sqlc"))}}

	"{{projectName}}/internal/database"
{{/if}}
{{#if (eq goLogging "zap")}}

	"go.uber.org/zap"
{{/if}}
	"github.com/joho/godotenv"
{{#if (eq goApi "grpc-go")}}
	"net"
	"sync"

	"{{projectName}}/proto"
	"google.golang.org/grpc"
{{/if}}
)

{{#if (eq goLogging "zap")}}
var logger *zap.Logger

func initLogger() {
	var err error
	logLevel := os.Getenv("LOG_LEVEL")
	if logLevel == "production" {
		logger, err = zap.NewProduction()
	} else {
		logger, err = zap.NewDevelopment()
	}
	if err != nil {
		panic(err)
	}
}
{{/if}}

func main() {
	// Load environment variables
	godotenv.Load()

{{#if (eq goLogging "zap")}}
	// Initialize logger
	initLogger()
	defer logger.Sync()

	logger.Info("Starting {{projectName}} server")
{{/if}}

{{#if (eq goOrm "gorm")}}
	// Initialize database
	db, err := database.InitDB()
	if err != nil {
{{#if (eq goLogging "zap")}}
		logger.Fatal("Failed to connect to database", zap.Error(err))
{{else}}
		panic("Failed to connect to database: " + err.Error())
{{/if}}
	}
{{#if (eq goLogging "zap")}}
	logger.Info("Database connected successfully")
{{/if}}
	_ = db // Use db in your handlers
{{/if}}
{{#if (eq goOrm "sqlc")}}
	// Initialize database pool
	pool, err := database.InitDB()
	if err != nil {
{{#if (eq goLogging "zap")}}
		logger.Fatal("Failed to connect to database", zap.Error(err))
{{else}}
		panic("Failed to connect to database: " + err.Error())
{{/if}}
	}
	defer database.Close()
{{#if (eq goLogging "zap")}}
	logger.Info("Database pool connected successfully")
{{/if}}
	_ = pool // Use pool in your handlers
{{/if}}

	// Get host and port from environment
	host := os.Getenv("HOST")
	if host == "" {
		host = "0.0.0.0"
	}
	port := os.Getenv("PORT")
	if port == "" {
		port = "8080"
	}
	addr := host + ":" + port

{{#if (eq goApi "grpc-go")}}
	// Start gRPC and HTTP servers concurrently
	var wg sync.WaitGroup
	wg.Add(2)

	// Start gRPC server
	go func() {
		defer wg.Done()
		grpcPort := os.Getenv("GRPC_PORT")
		if grpcPort == "" {
			grpcPort = "50051"
		}
		grpcAddr := host + ":" + grpcPort
{{#if (eq goLogging "zap")}}
		logger.Info("Starting gRPC server", zap.String("address", grpcAddr))
{{/if}}

		lis, err := net.Listen("tcp", grpcAddr)
		if err != nil {
{{#if (eq goLogging "zap")}}
			logger.Fatal("Failed to listen for gRPC", zap.Error(err))
{{else}}
			panic("Failed to listen for gRPC: " + err.Error())
{{/if}}
		}

		grpcServer := grpc.NewServer()
		proto.RegisterGreeterServer(grpcServer, &proto.GreeterService{})
		if err := grpcServer.Serve(lis); err != nil {
{{#if (eq goLogging "zap")}}
			logger.Fatal("Failed to serve gRPC", zap.Error(err))
{{else}}
			panic("Failed to serve gRPC: " + err.Error())
{{/if}}
		}
	}()

	// Start HTTP server
	go func() {
		defer wg.Done()
{{/if}}
{{#if (eq goWebFramework "gin")}}
{{#if (eq goLogging "zap")}}
	logger.Info("Starting HTTP server", zap.String("address", addr))
{{/if}}

	// Create Gin router
	r := gin.Default()

	// Health check endpoint
	r.GET("/health", func(c *gin.Context) {
		c.JSON(http.StatusOK, gin.H{
			"status":  "ok",
			"message": "Server is running",
		})
	})

	// Root endpoint
	r.GET("/", func(c *gin.Context) {
		c.JSON(http.StatusOK, gin.H{
			"message": "Welcome to {{projectName}}!",
		})
	})

	// Start server
	if err := r.Run(addr); err != nil {
{{#if (eq goLogging "zap")}}
		logger.Fatal("Failed to start server", zap.Error(err))
{{else}}
		panic("Failed to start server: " + err.Error())
{{/if}}
	}
{{/if}}
{{#if (eq goWebFramework "echo")}}
{{#if (eq goLogging "zap")}}
	logger.Info("Starting HTTP server", zap.String("address", addr))
{{/if}}

	// Create Echo instance
	e := echo.New()

	// Middleware
	e.Use(middleware.Logger())
	e.Use(middleware.Recover())
	e.Use(middleware.CORS())

	// Health check endpoint
	e.GET("/health", func(c echo.Context) error {
		return c.JSON(http.StatusOK, map[string]string{
			"status":  "ok",
			"message": "Server is running",
		})
	})

	// Root endpoint
	e.GET("/", func(c echo.Context) error {
		return c.JSON(http.StatusOK, map[string]string{
			"message": "Welcome to {{projectName}}!",
		})
	})

	// Start server
	if err := e.Start(addr); err != nil && err != http.ErrServerClosed {
{{#if (eq goLogging "zap")}}
		logger.Fatal("Failed to start server", zap.Error(err))
{{else}}
		panic("Failed to start server: " + err.Error())
{{/if}}
	}
{{/if}}
{{#if (eq goWebFramework "none")}}
{{#if (eq goLogging "zap")}}
	logger.Info("{{projectName}} started")
	logger.Info("Add a web framework (gin or echo) to start building your API")
{{else}}
	println("{{projectName}} started")
	println("Add a web framework (gin or echo) to start building your API")
{{/if}}
{{/if}}
{{#if (eq goApi "grpc-go")}}
	}()

	wg.Wait()
{{/if}}
}
`],
  ["go-base/cmd/tui/main.go.hbs", `{{#if (eq goCli "bubbletea")}}
package main

import (
	"fmt"
	"os"

	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
)

var (
	titleStyle = lipgloss.NewStyle().
			Bold(true).
			Foreground(lipgloss.Color("205")).
			MarginBottom(1)

	itemStyle = lipgloss.NewStyle().
			PaddingLeft(2)

	selectedItemStyle = lipgloss.NewStyle().
				PaddingLeft(2).
				Foreground(lipgloss.Color("170"))

	helpStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("241")).
			MarginTop(1)
)

type model struct {
	choices  []string
	cursor   int
	selected map[int]struct{}
	quitting bool
}

func initialModel() model {
	return model{
		choices: []string{
			"Build project",
			"Run tests",
			"Deploy application",
			"View logs",
			"Exit",
		},
		selected: make(map[int]struct{}),
	}
}

func (m model) Init() tea.Cmd {
	return nil
}

func (m model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch msg := msg.(type) {
	case tea.KeyMsg:
		switch msg.String() {
		case "ctrl+c", "q":
			m.quitting = true
			return m, tea.Quit
		case "up", "k":
			if m.cursor > 0 {
				m.cursor--
			}
		case "down", "j":
			if m.cursor < len(m.choices)-1 {
				m.cursor++
			}
		case "enter", " ":
			if m.cursor == len(m.choices)-1 {
				// Exit option
				m.quitting = true
				return m, tea.Quit
			}
			if _, ok := m.selected[m.cursor]; ok {
				delete(m.selected, m.cursor)
			} else {
				m.selected[m.cursor] = struct{}{}
			}
		}
	}
	return m, nil
}

func (m model) View() string {
	if m.quitting {
		return "Goodbye!\\n"
	}

	s := titleStyle.Render("{{projectName}} TUI") + "\\n\\n"

	for i, choice := range m.choices {
		cursor := " "
		if m.cursor == i {
			cursor = ">"
		}

		checked := " "
		if _, ok := m.selected[i]; ok {
			checked = "x"
		}

		style := itemStyle
		if m.cursor == i {
			style = selectedItemStyle
		}

		if i == len(m.choices)-1 {
			// Exit option doesn't have a checkbox
			s += style.Render(fmt.Sprintf("%s %s", cursor, choice)) + "\\n"
		} else {
			s += style.Render(fmt.Sprintf("%s [%s] %s", cursor, checked, choice)) + "\\n"
		}
	}

	s += helpStyle.Render("\\nPress q to quit, space to select, enter to confirm")

	return s
}

func main() {
	p := tea.NewProgram(initialModel())
	if _, err := p.Run(); err != nil {
		fmt.Printf("Error running program: %v", err)
		os.Exit(1)
	}
}
{{/if}}
`],
  ["go-base/internal/handlers/handlers.go.hbs", `{{#if (or (eq goWebFramework "gin") (eq goWebFramework "echo"))}}
package handlers

{{#if (eq goWebFramework "gin")}}
import (
	"net/http"
	"strconv"

	"github.com/gin-gonic/gin"
{{#if (or (eq goOrm "gorm") (eq goOrm "sqlc"))}}

	"{{projectName}}/internal/database"
	"{{projectName}}/internal/models"
{{/if}}
)

{{#if (eq goOrm "gorm")}}
// GetUsers returns all users
func GetUsers(c *gin.Context) {
	var users []models.User
	if err := database.GetDB().Find(&users).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}
	c.JSON(http.StatusOK, users)
}

// GetUser returns a user by ID
func GetUser(c *gin.Context) {
	id, err := strconv.ParseUint(c.Param("id"), 10, 64)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid ID"})
		return
	}

	var user models.User
	if err := database.GetDB().First(&user, id).Error; err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "User not found"})
		return
	}
	c.JSON(http.StatusOK, user)
}

// CreateUser creates a new user
func CreateUser(c *gin.Context) {
	var input models.UserCreate
	if err := c.ShouldBindJSON(&input); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	user := models.User{
		Name:  input.Name,
		Email: input.Email,
	}

	if err := database.GetDB().Create(&user).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusCreated, user)
}

// UpdateUser updates a user
func UpdateUser(c *gin.Context) {
	id, err := strconv.ParseUint(c.Param("id"), 10, 64)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid ID"})
		return
	}

	var user models.User
	if err := database.GetDB().First(&user, id).Error; err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "User not found"})
		return
	}

	var input models.UserUpdate
	if err := c.ShouldBindJSON(&input); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	if input.Name != nil {
		user.Name = *input.Name
	}
	if input.Email != nil {
		user.Email = *input.Email
	}

	if err := database.GetDB().Save(&user).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, user)
}

// DeleteUser deletes a user
func DeleteUser(c *gin.Context) {
	id, err := strconv.ParseUint(c.Param("id"), 10, 64)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid ID"})
		return
	}

	if err := database.GetDB().Delete(&models.User{}, id).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusNoContent, nil)
}

// GetPosts returns all posts
func GetPosts(c *gin.Context) {
	var posts []models.Post
	if err := database.GetDB().Preload("Author").Find(&posts).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}
	c.JSON(http.StatusOK, posts)
}

// GetPost returns a post by ID
func GetPost(c *gin.Context) {
	id, err := strconv.ParseUint(c.Param("id"), 10, 64)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid ID"})
		return
	}

	var post models.Post
	if err := database.GetDB().Preload("Author").First(&post, id).Error; err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "Post not found"})
		return
	}
	c.JSON(http.StatusOK, post)
}

// CreatePost creates a new post
func CreatePost(c *gin.Context) {
	var input models.PostCreate
	if err := c.ShouldBindJSON(&input); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	post := models.Post{
		Title:    input.Title,
		Content:  input.Content,
		AuthorID: input.AuthorID,
	}

	if err := database.GetDB().Create(&post).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusCreated, post)
}

// UpdatePost updates a post
func UpdatePost(c *gin.Context) {
	id, err := strconv.ParseUint(c.Param("id"), 10, 64)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid ID"})
		return
	}

	var post models.Post
	if err := database.GetDB().First(&post, id).Error; err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "Post not found"})
		return
	}

	var input models.PostUpdate
	if err := c.ShouldBindJSON(&input); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	if input.Title != nil {
		post.Title = *input.Title
	}
	if input.Content != nil {
		post.Content = *input.Content
	}
	if input.Published != nil {
		post.Published = *input.Published
	}

	if err := database.GetDB().Save(&post).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, post)
}

// DeletePost deletes a post
func DeletePost(c *gin.Context) {
	id, err := strconv.ParseUint(c.Param("id"), 10, 64)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid ID"})
		return
	}

	if err := database.GetDB().Delete(&models.Post{}, id).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusNoContent, nil)
}
{{else if (eq goOrm "sqlc")}}
// GetUsers returns all users using raw SQL queries
// Note: After running \`sqlc generate\`, you can use the generated db.Queries instead
func GetUsers(c *gin.Context) {
	ctx := c.Request.Context()
	rows, err := database.GetPool().Query(ctx, "SELECT id, name, email, created_at, updated_at FROM users ORDER BY id")
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}
	defer rows.Close()

	var users []models.User
	for rows.Next() {
		var user models.User
		if err := rows.Scan(&user.ID, &user.Name, &user.Email, &user.CreatedAt, &user.UpdatedAt); err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
			return
		}
		users = append(users, user)
	}

	if users == nil {
		users = []models.User{}
	}
	c.JSON(http.StatusOK, users)
}

// GetUser returns a user by ID
func GetUser(c *gin.Context) {
	id, err := strconv.ParseInt(c.Param("id"), 10, 64)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid ID"})
		return
	}

	ctx := c.Request.Context()
	var user models.User
	err = database.GetPool().QueryRow(ctx,
		"SELECT id, name, email, created_at, updated_at FROM users WHERE id = $1", id,
	).Scan(&user.ID, &user.Name, &user.Email, &user.CreatedAt, &user.UpdatedAt)
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "User not found"})
		return
	}

	c.JSON(http.StatusOK, user)
}

// CreateUser creates a new user
func CreateUser(c *gin.Context) {
	var input models.UserCreate
	if err := c.ShouldBindJSON(&input); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	ctx := c.Request.Context()
	var user models.User
	err := database.GetPool().QueryRow(ctx,
		"INSERT INTO users (name, email) VALUES ($1, $2) RETURNING id, name, email, created_at, updated_at",
		input.Name, input.Email,
	).Scan(&user.ID, &user.Name, &user.Email, &user.CreatedAt, &user.UpdatedAt)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusCreated, user)
}

// UpdateUser updates a user
func UpdateUser(c *gin.Context) {
	id, err := strconv.ParseInt(c.Param("id"), 10, 64)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid ID"})
		return
	}

	var input models.UserUpdate
	if err := c.ShouldBindJSON(&input); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	ctx := c.Request.Context()
	var user models.User
	err = database.GetPool().QueryRow(ctx,
		"UPDATE users SET name = COALESCE($2, name), email = COALESCE($3, email), updated_at = NOW() WHERE id = $1 RETURNING id, name, email, created_at, updated_at",
		id, input.Name, input.Email,
	).Scan(&user.ID, &user.Name, &user.Email, &user.CreatedAt, &user.UpdatedAt)
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "User not found"})
		return
	}

	c.JSON(http.StatusOK, user)
}

// DeleteUser deletes a user
func DeleteUser(c *gin.Context) {
	id, err := strconv.ParseInt(c.Param("id"), 10, 64)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid ID"})
		return
	}

	ctx := c.Request.Context()
	result, err := database.GetPool().Exec(ctx, "DELETE FROM users WHERE id = $1", id)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	if result.RowsAffected() == 0 {
		c.JSON(http.StatusNotFound, gin.H{"error": "User not found"})
		return
	}

	c.JSON(http.StatusNoContent, nil)
}

// GetPosts returns all posts with author information
func GetPosts(c *gin.Context) {
	ctx := c.Request.Context()
	rows, err := database.GetPool().Query(ctx,
		"SELECT p.id, p.title, p.content, p.published, p.author_id, p.created_at, p.updated_at FROM posts p ORDER BY p.id",
	)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}
	defer rows.Close()

	var posts []models.Post
	for rows.Next() {
		var post models.Post
		if err := rows.Scan(&post.ID, &post.Title, &post.Content, &post.Published, &post.AuthorID, &post.CreatedAt, &post.UpdatedAt); err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
			return
		}
		posts = append(posts, post)
	}

	if posts == nil {
		posts = []models.Post{}
	}
	c.JSON(http.StatusOK, posts)
}

// GetPost returns a post by ID
func GetPost(c *gin.Context) {
	id, err := strconv.ParseInt(c.Param("id"), 10, 64)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid ID"})
		return
	}

	ctx := c.Request.Context()
	var post models.Post
	err = database.GetPool().QueryRow(ctx,
		"SELECT id, title, content, published, author_id, created_at, updated_at FROM posts WHERE id = $1", id,
	).Scan(&post.ID, &post.Title, &post.Content, &post.Published, &post.AuthorID, &post.CreatedAt, &post.UpdatedAt)
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "Post not found"})
		return
	}

	c.JSON(http.StatusOK, post)
}

// CreatePost creates a new post
func CreatePost(c *gin.Context) {
	var input models.PostCreate
	if err := c.ShouldBindJSON(&input); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	ctx := c.Request.Context()
	var post models.Post
	err := database.GetPool().QueryRow(ctx,
		"INSERT INTO posts (title, content, author_id) VALUES ($1, $2, $3) RETURNING id, title, content, published, author_id, created_at, updated_at",
		input.Title, input.Content, input.AuthorID,
	).Scan(&post.ID, &post.Title, &post.Content, &post.Published, &post.AuthorID, &post.CreatedAt, &post.UpdatedAt)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusCreated, post)
}

// UpdatePost updates a post
func UpdatePost(c *gin.Context) {
	id, err := strconv.ParseInt(c.Param("id"), 10, 64)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid ID"})
		return
	}

	var input models.PostUpdate
	if err := c.ShouldBindJSON(&input); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	ctx := c.Request.Context()
	var post models.Post
	err = database.GetPool().QueryRow(ctx,
		"UPDATE posts SET title = COALESCE($2, title), content = COALESCE($3, content), published = COALESCE($4, published), updated_at = NOW() WHERE id = $1 RETURNING id, title, content, published, author_id, created_at, updated_at",
		id, input.Title, input.Content, input.Published,
	).Scan(&post.ID, &post.Title, &post.Content, &post.Published, &post.AuthorID, &post.CreatedAt, &post.UpdatedAt)
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "Post not found"})
		return
	}

	c.JSON(http.StatusOK, post)
}

// DeletePost deletes a post
func DeletePost(c *gin.Context) {
	id, err := strconv.ParseInt(c.Param("id"), 10, 64)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid ID"})
		return
	}

	ctx := c.Request.Context()
	result, err := database.GetPool().Exec(ctx, "DELETE FROM posts WHERE id = $1", id)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	if result.RowsAffected() == 0 {
		c.JSON(http.StatusNotFound, gin.H{"error": "Post not found"})
		return
	}

	c.JSON(http.StatusNoContent, nil)
}
{{else}}
// HealthCheck returns server health status
func HealthCheck(c *gin.Context) {
	c.JSON(http.StatusOK, gin.H{
		"status":  "ok",
		"message": "Server is running",
	})
}
{{/if}}
{{/if}}
{{#if (eq goWebFramework "echo")}}
import (
	"net/http"
	"strconv"

	"github.com/labstack/echo/v4"
{{#if (or (eq goOrm "gorm") (eq goOrm "sqlc"))}}

	"{{projectName}}/internal/database"
	"{{projectName}}/internal/models"
{{/if}}
)

{{#if (eq goOrm "gorm")}}
// GetUsers returns all users
func GetUsers(c echo.Context) error {
	var users []models.User
	if err := database.GetDB().Find(&users).Error; err != nil {
		return c.JSON(http.StatusInternalServerError, map[string]string{"error": err.Error()})
	}
	return c.JSON(http.StatusOK, users)
}

// GetUser returns a user by ID
func GetUser(c echo.Context) error {
	id, err := strconv.ParseUint(c.Param("id"), 10, 64)
	if err != nil {
		return c.JSON(http.StatusBadRequest, map[string]string{"error": "Invalid ID"})
	}

	var user models.User
	if err := database.GetDB().First(&user, id).Error; err != nil {
		return c.JSON(http.StatusNotFound, map[string]string{"error": "User not found"})
	}
	return c.JSON(http.StatusOK, user)
}

// CreateUser creates a new user
func CreateUser(c echo.Context) error {
	var input models.UserCreate
	if err := c.Bind(&input); err != nil {
		return c.JSON(http.StatusBadRequest, map[string]string{"error": err.Error()})
	}

	user := models.User{
		Name:  input.Name,
		Email: input.Email,
	}

	if err := database.GetDB().Create(&user).Error; err != nil {
		return c.JSON(http.StatusInternalServerError, map[string]string{"error": err.Error()})
	}

	return c.JSON(http.StatusCreated, user)
}

// UpdateUser updates a user
func UpdateUser(c echo.Context) error {
	id, err := strconv.ParseUint(c.Param("id"), 10, 64)
	if err != nil {
		return c.JSON(http.StatusBadRequest, map[string]string{"error": "Invalid ID"})
	}

	var user models.User
	if err := database.GetDB().First(&user, id).Error; err != nil {
		return c.JSON(http.StatusNotFound, map[string]string{"error": "User not found"})
	}

	var input models.UserUpdate
	if err := c.Bind(&input); err != nil {
		return c.JSON(http.StatusBadRequest, map[string]string{"error": err.Error()})
	}

	if input.Name != nil {
		user.Name = *input.Name
	}
	if input.Email != nil {
		user.Email = *input.Email
	}

	if err := database.GetDB().Save(&user).Error; err != nil {
		return c.JSON(http.StatusInternalServerError, map[string]string{"error": err.Error()})
	}

	return c.JSON(http.StatusOK, user)
}

// DeleteUser deletes a user
func DeleteUser(c echo.Context) error {
	id, err := strconv.ParseUint(c.Param("id"), 10, 64)
	if err != nil {
		return c.JSON(http.StatusBadRequest, map[string]string{"error": "Invalid ID"})
	}

	if err := database.GetDB().Delete(&models.User{}, id).Error; err != nil {
		return c.JSON(http.StatusInternalServerError, map[string]string{"error": err.Error()})
	}

	return c.NoContent(http.StatusNoContent)
}

// GetPosts returns all posts
func GetPosts(c echo.Context) error {
	var posts []models.Post
	if err := database.GetDB().Preload("Author").Find(&posts).Error; err != nil {
		return c.JSON(http.StatusInternalServerError, map[string]string{"error": err.Error()})
	}
	return c.JSON(http.StatusOK, posts)
}

// GetPost returns a post by ID
func GetPost(c echo.Context) error {
	id, err := strconv.ParseUint(c.Param("id"), 10, 64)
	if err != nil {
		return c.JSON(http.StatusBadRequest, map[string]string{"error": "Invalid ID"})
	}

	var post models.Post
	if err := database.GetDB().Preload("Author").First(&post, id).Error; err != nil {
		return c.JSON(http.StatusNotFound, map[string]string{"error": "Post not found"})
	}
	return c.JSON(http.StatusOK, post)
}

// CreatePost creates a new post
func CreatePost(c echo.Context) error {
	var input models.PostCreate
	if err := c.Bind(&input); err != nil {
		return c.JSON(http.StatusBadRequest, map[string]string{"error": err.Error()})
	}

	post := models.Post{
		Title:    input.Title,
		Content:  input.Content,
		AuthorID: uint(input.AuthorID),
	}

	if err := database.GetDB().Create(&post).Error; err != nil {
		return c.JSON(http.StatusInternalServerError, map[string]string{"error": err.Error()})
	}

	return c.JSON(http.StatusCreated, post)
}

// UpdatePost updates a post
func UpdatePost(c echo.Context) error {
	id, err := strconv.ParseUint(c.Param("id"), 10, 64)
	if err != nil {
		return c.JSON(http.StatusBadRequest, map[string]string{"error": "Invalid ID"})
	}

	var post models.Post
	if err := database.GetDB().First(&post, id).Error; err != nil {
		return c.JSON(http.StatusNotFound, map[string]string{"error": "Post not found"})
	}

	var input models.PostUpdate
	if err := c.Bind(&input); err != nil {
		return c.JSON(http.StatusBadRequest, map[string]string{"error": err.Error()})
	}

	if input.Title != nil {
		post.Title = *input.Title
	}
	if input.Content != nil {
		post.Content = *input.Content
	}
	if input.Published != nil {
		post.Published = *input.Published
	}

	if err := database.GetDB().Save(&post).Error; err != nil {
		return c.JSON(http.StatusInternalServerError, map[string]string{"error": err.Error()})
	}

	return c.JSON(http.StatusOK, post)
}

// DeletePost deletes a post
func DeletePost(c echo.Context) error {
	id, err := strconv.ParseUint(c.Param("id"), 10, 64)
	if err != nil {
		return c.JSON(http.StatusBadRequest, map[string]string{"error": "Invalid ID"})
	}

	if err := database.GetDB().Delete(&models.Post{}, id).Error; err != nil {
		return c.JSON(http.StatusInternalServerError, map[string]string{"error": err.Error()})
	}

	return c.NoContent(http.StatusNoContent)
}
{{else if (eq goOrm "sqlc")}}
// GetUsers returns all users using raw SQL queries
// Note: After running \`sqlc generate\`, you can use the generated db.Queries instead
func GetUsers(c echo.Context) error {
	ctx := c.Request().Context()
	rows, err := database.GetPool().Query(ctx, "SELECT id, name, email, created_at, updated_at FROM users ORDER BY id")
	if err != nil {
		return c.JSON(http.StatusInternalServerError, map[string]string{"error": err.Error()})
	}
	defer rows.Close()

	var users []models.User
	for rows.Next() {
		var user models.User
		if err := rows.Scan(&user.ID, &user.Name, &user.Email, &user.CreatedAt, &user.UpdatedAt); err != nil {
			return c.JSON(http.StatusInternalServerError, map[string]string{"error": err.Error()})
		}
		users = append(users, user)
	}

	if users == nil {
		users = []models.User{}
	}
	return c.JSON(http.StatusOK, users)
}

// GetUser returns a user by ID
func GetUser(c echo.Context) error {
	id, err := strconv.ParseInt(c.Param("id"), 10, 64)
	if err != nil {
		return c.JSON(http.StatusBadRequest, map[string]string{"error": "Invalid ID"})
	}

	ctx := c.Request().Context()
	var user models.User
	err = database.GetPool().QueryRow(ctx,
		"SELECT id, name, email, created_at, updated_at FROM users WHERE id = $1", id,
	).Scan(&user.ID, &user.Name, &user.Email, &user.CreatedAt, &user.UpdatedAt)
	if err != nil {
		return c.JSON(http.StatusNotFound, map[string]string{"error": "User not found"})
	}

	return c.JSON(http.StatusOK, user)
}

// CreateUser creates a new user
func CreateUser(c echo.Context) error {
	var input models.UserCreate
	if err := c.Bind(&input); err != nil {
		return c.JSON(http.StatusBadRequest, map[string]string{"error": err.Error()})
	}

	ctx := c.Request().Context()
	var user models.User
	err := database.GetPool().QueryRow(ctx,
		"INSERT INTO users (name, email) VALUES ($1, $2) RETURNING id, name, email, created_at, updated_at",
		input.Name, input.Email,
	).Scan(&user.ID, &user.Name, &user.Email, &user.CreatedAt, &user.UpdatedAt)
	if err != nil {
		return c.JSON(http.StatusInternalServerError, map[string]string{"error": err.Error()})
	}

	return c.JSON(http.StatusCreated, user)
}

// UpdateUser updates a user
func UpdateUser(c echo.Context) error {
	id, err := strconv.ParseInt(c.Param("id"), 10, 64)
	if err != nil {
		return c.JSON(http.StatusBadRequest, map[string]string{"error": "Invalid ID"})
	}

	var input models.UserUpdate
	if err := c.Bind(&input); err != nil {
		return c.JSON(http.StatusBadRequest, map[string]string{"error": err.Error()})
	}

	ctx := c.Request().Context()
	var user models.User
	err = database.GetPool().QueryRow(ctx,
		"UPDATE users SET name = COALESCE($2, name), email = COALESCE($3, email), updated_at = NOW() WHERE id = $1 RETURNING id, name, email, created_at, updated_at",
		id, input.Name, input.Email,
	).Scan(&user.ID, &user.Name, &user.Email, &user.CreatedAt, &user.UpdatedAt)
	if err != nil {
		return c.JSON(http.StatusNotFound, map[string]string{"error": "User not found"})
	}

	return c.JSON(http.StatusOK, user)
}

// DeleteUser deletes a user
func DeleteUser(c echo.Context) error {
	id, err := strconv.ParseInt(c.Param("id"), 10, 64)
	if err != nil {
		return c.JSON(http.StatusBadRequest, map[string]string{"error": "Invalid ID"})
	}

	ctx := c.Request().Context()
	result, err := database.GetPool().Exec(ctx, "DELETE FROM users WHERE id = $1", id)
	if err != nil {
		return c.JSON(http.StatusInternalServerError, map[string]string{"error": err.Error()})
	}

	if result.RowsAffected() == 0 {
		return c.JSON(http.StatusNotFound, map[string]string{"error": "User not found"})
	}

	return c.NoContent(http.StatusNoContent)
}

// GetPosts returns all posts with author information
func GetPosts(c echo.Context) error {
	ctx := c.Request().Context()
	rows, err := database.GetPool().Query(ctx,
		"SELECT p.id, p.title, p.content, p.published, p.author_id, p.created_at, p.updated_at FROM posts p ORDER BY p.id",
	)
	if err != nil {
		return c.JSON(http.StatusInternalServerError, map[string]string{"error": err.Error()})
	}
	defer rows.Close()

	var posts []models.Post
	for rows.Next() {
		var post models.Post
		if err := rows.Scan(&post.ID, &post.Title, &post.Content, &post.Published, &post.AuthorID, &post.CreatedAt, &post.UpdatedAt); err != nil {
			return c.JSON(http.StatusInternalServerError, map[string]string{"error": err.Error()})
		}
		posts = append(posts, post)
	}

	if posts == nil {
		posts = []models.Post{}
	}
	return c.JSON(http.StatusOK, posts)
}

// GetPost returns a post by ID
func GetPost(c echo.Context) error {
	id, err := strconv.ParseInt(c.Param("id"), 10, 64)
	if err != nil {
		return c.JSON(http.StatusBadRequest, map[string]string{"error": "Invalid ID"})
	}

	ctx := c.Request().Context()
	var post models.Post
	err = database.GetPool().QueryRow(ctx,
		"SELECT id, title, content, published, author_id, created_at, updated_at FROM posts WHERE id = $1", id,
	).Scan(&post.ID, &post.Title, &post.Content, &post.Published, &post.AuthorID, &post.CreatedAt, &post.UpdatedAt)
	if err != nil {
		return c.JSON(http.StatusNotFound, map[string]string{"error": "Post not found"})
	}

	return c.JSON(http.StatusOK, post)
}

// CreatePost creates a new post
func CreatePost(c echo.Context) error {
	var input models.PostCreate
	if err := c.Bind(&input); err != nil {
		return c.JSON(http.StatusBadRequest, map[string]string{"error": err.Error()})
	}

	ctx := c.Request().Context()
	var post models.Post
	err := database.GetPool().QueryRow(ctx,
		"INSERT INTO posts (title, content, author_id) VALUES ($1, $2, $3) RETURNING id, title, content, published, author_id, created_at, updated_at",
		input.Title, input.Content, input.AuthorID,
	).Scan(&post.ID, &post.Title, &post.Content, &post.Published, &post.AuthorID, &post.CreatedAt, &post.UpdatedAt)
	if err != nil {
		return c.JSON(http.StatusInternalServerError, map[string]string{"error": err.Error()})
	}

	return c.JSON(http.StatusCreated, post)
}

// UpdatePost updates a post
func UpdatePost(c echo.Context) error {
	id, err := strconv.ParseInt(c.Param("id"), 10, 64)
	if err != nil {
		return c.JSON(http.StatusBadRequest, map[string]string{"error": "Invalid ID"})
	}

	var input models.PostUpdate
	if err := c.Bind(&input); err != nil {
		return c.JSON(http.StatusBadRequest, map[string]string{"error": err.Error()})
	}

	ctx := c.Request().Context()
	var post models.Post
	err = database.GetPool().QueryRow(ctx,
		"UPDATE posts SET title = COALESCE($2, title), content = COALESCE($3, content), published = COALESCE($4, published), updated_at = NOW() WHERE id = $1 RETURNING id, title, content, published, author_id, created_at, updated_at",
		id, input.Title, input.Content, input.Published,
	).Scan(&post.ID, &post.Title, &post.Content, &post.Published, &post.AuthorID, &post.CreatedAt, &post.UpdatedAt)
	if err != nil {
		return c.JSON(http.StatusNotFound, map[string]string{"error": "Post not found"})
	}

	return c.JSON(http.StatusOK, post)
}

// DeletePost deletes a post
func DeletePost(c echo.Context) error {
	id, err := strconv.ParseInt(c.Param("id"), 10, 64)
	if err != nil {
		return c.JSON(http.StatusBadRequest, map[string]string{"error": "Invalid ID"})
	}

	ctx := c.Request().Context()
	result, err := database.GetPool().Exec(ctx, "DELETE FROM posts WHERE id = $1", id)
	if err != nil {
		return c.JSON(http.StatusInternalServerError, map[string]string{"error": err.Error()})
	}

	if result.RowsAffected() == 0 {
		return c.JSON(http.StatusNotFound, map[string]string{"error": "Post not found"})
	}

	return c.NoContent(http.StatusNoContent)
}
{{else}}
// HealthCheck returns server health status
func HealthCheck(c echo.Context) error {
	return c.JSON(http.StatusOK, map[string]string{
		"status":  "ok",
		"message": "Server is running",
	})
}
{{/if}}
{{/if}}
{{/if}}
`],
  ["go-base/internal/models/models.go.hbs", `{{#if (eq goOrm "gorm")}}
package models

import (
	"time"

	"gorm.io/gorm"
)

// User represents a user in the system
type User struct {
	ID        uint           \`gorm:"primarykey" json:"id"\`
	CreatedAt time.Time      \`json:"created_at"\`
	UpdatedAt time.Time      \`json:"updated_at"\`
	DeletedAt gorm.DeletedAt \`gorm:"index" json:"-"\`
	Name      string         \`gorm:"size:255;not null" json:"name"\`
	Email     string         \`gorm:"size:255;uniqueIndex;not null" json:"email"\`
	Posts     []Post         \`gorm:"foreignKey:AuthorID" json:"posts,omitempty"\`
}

// Post represents a blog post
type Post struct {
	ID        uint           \`gorm:"primarykey" json:"id"\`
	CreatedAt time.Time      \`json:"created_at"\`
	UpdatedAt time.Time      \`json:"updated_at"\`
	DeletedAt gorm.DeletedAt \`gorm:"index" json:"-"\`
	Title     string         \`gorm:"size:255;not null" json:"title"\`
	Content   string         \`gorm:"type:text" json:"content"\`
	Published bool           \`gorm:"default:false" json:"published"\`
	AuthorID  uint           \`gorm:"not null" json:"author_id"\`
	Author    *User          \`gorm:"foreignKey:AuthorID" json:"author,omitempty"\`
}

// UserCreate is used for creating a new user
type UserCreate struct {
	Name  string \`json:"name" binding:"required"\`
	Email string \`json:"email" binding:"required,email"\`
}

// UserUpdate is used for updating a user
type UserUpdate struct {
	Name  *string \`json:"name,omitempty"\`
	Email *string \`json:"email,omitempty"\`
}

// PostCreate is used for creating a new post
type PostCreate struct {
	Title    string \`json:"title" binding:"required"\`
	Content  string \`json:"content"\`
	AuthorID uint   \`json:"author_id" binding:"required"\`
}

// PostUpdate is used for updating a post
type PostUpdate struct {
	Title     *string \`json:"title,omitempty"\`
	Content   *string \`json:"content,omitempty"\`
	Published *bool   \`json:"published,omitempty"\`
}
{{/if}}
{{#if (eq goOrm "sqlc")}}
package models

import (
	"time"
)

// User represents a user in the system
type User struct {
	ID        int64     \`json:"id"\`
	Name      string    \`json:"name"\`
	Email     string    \`json:"email"\`
	CreatedAt time.Time \`json:"created_at"\`
	UpdatedAt time.Time \`json:"updated_at"\`
}

// Post represents a blog post
type Post struct {
	ID        int64     \`json:"id"\`
	Title     string    \`json:"title"\`
	Content   string    \`json:"content"\`
	Published bool      \`json:"published"\`
	AuthorID  int64     \`json:"author_id"\`
	CreatedAt time.Time \`json:"created_at"\`
	UpdatedAt time.Time \`json:"updated_at"\`
}

// UserCreate is used for creating a new user
type UserCreate struct {
	Name  string \`json:"name"\`
	Email string \`json:"email"\`
}

// UserUpdate is used for updating a user
type UserUpdate struct {
	Name  *string \`json:"name,omitempty"\`
	Email *string \`json:"email,omitempty"\`
}

// PostCreate is used for creating a new post
type PostCreate struct {
	Title    string \`json:"title"\`
	Content  string \`json:"content"\`
	AuthorID int64  \`json:"author_id"\`
}

// PostUpdate is used for updating a post
type PostUpdate struct {
	Title     *string \`json:"title,omitempty"\`
	Content   *string \`json:"content,omitempty"\`
	Published *bool   \`json:"published,omitempty"\`
}
{{/if}}
`],
  ["go-base/internal/database/database.go.hbs", `{{#if (eq goOrm "gorm")}}
package database

import (
	"os"
	"strings"

	"gorm.io/driver/postgres"
	"gorm.io/driver/sqlite"
	"gorm.io/gorm"

	"{{projectName}}/internal/models"
)

var DB *gorm.DB

// InitDB initializes the database connection
func InitDB() (*gorm.DB, error) {
	var err error
	dsn := os.Getenv("DATABASE_URL")

	if dsn == "" {
		// Default to SQLite for development
		DB, err = gorm.Open(sqlite.Open("app.db"), &gorm.Config{})
	} else if strings.HasPrefix(dsn, "postgres") {
		DB, err = gorm.Open(postgres.Open(dsn), &gorm.Config{})
	} else {
		// Assume SQLite file path
		DB, err = gorm.Open(sqlite.Open(dsn), &gorm.Config{})
	}

	if err != nil {
		return nil, err
	}

	// Auto-migrate models
	err = DB.AutoMigrate(&models.User{}, &models.Post{})
	if err != nil {
		return nil, err
	}

	return DB, nil
}

// GetDB returns the database instance
func GetDB() *gorm.DB {
	return DB
}
{{/if}}
{{#if (eq goOrm "sqlc")}}
package database

import (
	"context"
	"os"

	"github.com/jackc/pgx/v5/pgxpool"
)

var Pool *pgxpool.Pool

// InitDB initializes the database connection pool
func InitDB() (*pgxpool.Pool, error) {
	dsn := os.Getenv("DATABASE_URL")
	if dsn == "" {
		dsn = "postgres://user:password@localhost:5432/dbname?sslmode=disable"
	}

	var err error
	Pool, err = pgxpool.New(context.Background(), dsn)
	if err != nil {
		return nil, err
	}

	// Verify connection
	if err := Pool.Ping(context.Background()); err != nil {
		return nil, err
	}

	return Pool, nil
}

// GetPool returns the database pool
func GetPool() *pgxpool.Pool {
	return Pool
}

// Close closes the database pool
func Close() {
	if Pool != nil {
		Pool.Close()
	}
}
{{/if}}
`],
  ["frontend/qwik/public/manifest.json", `{
  "short_name": "Better T Stack",
  "name": "Better T Stack - Qwik",
  "icons": [
    {
      "src": "/favicon.svg",
      "sizes": "any",
      "type": "image/svg+xml"
    }
  ],
  "start_url": "/",
  "background_color": "#0a0a0a",
  "display": "standalone",
  "scope": "/",
  "theme_color": "#AC7EF4"
}
`],
  ["frontend/qwik/public/robots.txt", `User-agent: *
Allow: /
`],
  ["frontend/qwik/public/favicon.svg", `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 200">
  <rect width="200" height="200" rx="20" fill="#AC7EF4"/>
  <text x="100" y="140" font-family="Arial Black, sans-serif" font-size="120" text-anchor="middle" fill="white">Q</text>
</svg>
`],
  ["frontend/qwik/src/entry.preview.tsx", `import { createQwikCity } from "@builder.io/qwik-city/middleware/node";
import qwikCityPlan from "@qwik-city-plan";

import render from "./entry.ssr";

const { router, notFound } = createQwikCity({ render, qwikCityPlan });

export { notFound, router };
`],
  ["frontend/qwik/src/root.tsx.hbs", `import { component$ } from "@builder.io/qwik";
import {
  QwikCityProvider,
  RouterOutlet,
  ServiceWorkerRegister,
} from "@builder.io/qwik-city";
import { RouterHead } from "./components/router-head/router-head";

import "./global.css";

export default component$(() => {
  return (
    <QwikCityProvider>
      <head>
        <meta charset="utf-8" />
        <link rel="manifest" href="/manifest.json" />
        <RouterHead />
        <ServiceWorkerRegister />
      </head>
      <body lang="en">
        <RouterOutlet />
      </body>
    </QwikCityProvider>
  );
});
`],
  ["frontend/qwik/src/entry.ssr.tsx", `import { renderToStream, type RenderToStreamOptions } from "@builder.io/qwik/server";
import { manifest } from "@qwik-client-manifest";

import Root from "./root";

export default function (opts: RenderToStreamOptions) {
  return renderToStream(<Root />, {
    manifest,
    ...opts,
    containerAttributes: {
      lang: "en-us",
      ...opts.containerAttributes,
    },
    serverData: {
      ...opts.serverData,
    },
  });
}
`],
  ["frontend/qwik/src/global.css.hbs", `{{#if (eq cssFramework "tailwind")}}
@import "tailwindcss";
{{else}}
:root {
  --bg-color: #ffffff;
  --text-color: #1a1a1a;
  --border-color: #e5e7eb;
  --muted-color: #6b7280;
}

@media (prefers-color-scheme: dark) {
  :root {
    --bg-color: #0a0a0a;
    --text-color: #fafafa;
    --border-color: #27272a;
    --muted-color: #a1a1aa;
  }
}

* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
  background-color: var(--bg-color);
  color: var(--text-color);
  line-height: 1.5;
}

a {
  color: inherit;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}
{{/if}}
`],
  ["frontend/solid/public/robots.txt", `# https://www.robotstxt.org/robotstxt.html
User-agent: *
Disallow:
`],
  ["frontend/solid/src/styles.css", `@import "tailwindcss";

body {
  @apply bg-neutral-950 text-neutral-100;
}
`],
  ["frontend/solid/src/main.tsx.hbs", `import { RouterProvider, createRouter } from "@tanstack/solid-router";
import { render } from "solid-js/web";
import { routeTree } from "./routeTree.gen";
import "./styles.css";
{{#if (eq api "orpc")}}
import { QueryClientProvider } from "@tanstack/solid-query";
import { orpc, queryClient } from "./utils/orpc";
{{/if}}

const router = createRouter({
  routeTree,
  defaultPreload: "intent",
  scrollRestoration: true,
  defaultPreloadStaleTime: 0,
  {{#if (eq api "orpc")}}
  context: { orpc, queryClient },
  {{/if}}
});

declare module "@tanstack/solid-router" {
  interface Register {
    router: typeof router;
  }
}

function App() {
  return (
    {{#if (eq api "orpc")}}
    <QueryClientProvider client={queryClient}>
    {{/if}}
      <RouterProvider router={router} />
    {{#if (eq api "orpc")}}
    </QueryClientProvider>
    {{/if}}
  );
}

const rootElement = document.getElementById("app");
if (rootElement) {
  render(() => <App />, rootElement);
}
`],
  ["frontend/redwood/web/package.json.hbs", `{
  "name": "web",
  "private": true,
  "type": "module",
  "dependencies": {
    "@redwoodjs/forms": "^8.6.1",
    "@redwoodjs/router": "^8.6.1",
    "@redwoodjs/web": "^8.6.1",
    "react": "^19.1.0",
    "react-dom": "^19.1.0"
  },
  "devDependencies": {
    "@redwoodjs/vite": "^8.6.1",
    "@types/react": "^19.1.6",
    "@types/react-dom": "^19.1.5",
    "typescript": "^5.7.3"
  }
}
`],
  ["frontend/redwood/web/tsconfig.json", `{
  "compilerOptions": {
    "noEmit": true,
    "allowJs": true,
    "esModuleInterop": true,
    "target": "esnext",
    "module": "esnext",
    "moduleResolution": "bundler",
    "baseUrl": "./",
    "strict": true,
    "skipLibCheck": true,
    "jsx": "preserve",
    "rootDirs": [
      "./src",
      "../.redwood/types/mirror/web/src",
      "../api/src",
      "../.redwood/types/mirror/api/src"
    ],
    "paths": {
      "src/*": ["./src/*", "../.redwood/types/mirror/web/src/*"],
      "$api/*": ["../api/src/*", "../.redwood/types/mirror/api/src/*"],
      "types/*": ["./types/*", "../.redwood/types/mirror/web/types/*"],
      "@redwoodjs/testing": ["../node_modules/@redwoodjs/testing/web"]
    },
    "typeRoots": ["../node_modules/@types", "./node_modules/@types"],
    "types": ["node"],
    "lib": ["esnext", "dom"]
  },
  "include": [
    "src",
    "../.redwood/types/includes/all-*",
    "../.redwood/types/includes/web-*",
    "./types"
  ]
}
`],
  ["frontend/redwood/scripts/seed.ts", `import type { Prisma } from "@prisma/client";

import { db } from "api/src/lib/db";

export default async () => {
  try {
    // If using dbAuth, you can seed users here.
    // If you're using a different auth provider, you can seed users there.

    // Example seeding posts
    const posts: Prisma.PostCreateInput[] = [
      {
        title: "Welcome to RedwoodJS",
        body: "RedwoodJS is a full-stack web framework that brings together the best parts of React, GraphQL, Prisma, and serverless.",
      },
      {
        title: "Getting Started",
        body: "Run \`yarn rw dev\` to start the development server. Your app will be available at http://localhost:8910.",
      },
    ];

    for (const post of posts) {
      await db.post.create({ data: post });
    }

    console.log("Database has been seeded. ");
  } catch (error) {
    console.warn("Please define your seed data.");
    console.error(error);
  }
};
`],
  ["frontend/redwood/api/package.json.hbs", `{
  "name": "api",
  "private": true,
  "type": "module",
  "dependencies": {
    "@redwoodjs/api": "^8.6.1",
    "@redwoodjs/graphql-server": "^8.6.1"
  }
}
`],
  ["frontend/redwood/api/tsconfig.json", `{
  "compilerOptions": {
    "noEmit": true,
    "allowJs": true,
    "esModuleInterop": true,
    "target": "esnext",
    "module": "esnext",
    "moduleResolution": "bundler",
    "baseUrl": "./",
    "strict": true,
    "skipLibCheck": true,
    "rootDirs": ["./src", "../.redwood/types/mirror/api/src"],
    "paths": {
      "src/*": ["./src/*", "../.redwood/types/mirror/api/src/*"],
      "$api/*": ["./src/*", "../.redwood/types/mirror/api/src/*"],
      "types/*": ["./types/*", "../.redwood/types/mirror/api/types/*"],
      "@redwoodjs/testing": ["../node_modules/@redwoodjs/testing/api"]
    },
    "typeRoots": ["../node_modules/@types", "./node_modules/@types"],
    "types": ["node"]
  },
  "include": [
    "src",
    "../.redwood/types/includes/all-*",
    "../.redwood/types/includes/api-*",
    "./types"
  ]
}
`],
  ["frontend/svelte/src/app.d.ts", `// See https://svelte.dev/docs/kit/types#app.d.ts
// for information about these interfaces
declare global {
  namespace App {
    // interface Error {}
    // interface Locals {}
    // interface PageData {}
    // interface PageState {}
    // interface Platform {}
  }
}

export {};
`],
  ["frontend/svelte/src/app.html", `<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%sveltekit.assets%/favicon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    %sveltekit.head%
  </head>
  <body data-sveltekit-preload-data="hover">
    <div style="display: contents">%sveltekit.body%</div>
  </body>
</html>
`],
  ["frontend/svelte/src/app.css", `@import "tailwindcss";

body {
  @apply bg-neutral-950 text-neutral-100;
}
`],
  ["frontend/svelte/static/favicon.png", `[Binary file]`],
  ["frontend/angular/src/styles.css.hbs", `{{#if (eq cssFramework "tailwind")}}
@import "tailwindcss";
{{/if}}

:root {
  --background: #ffffff;
  --foreground: #0a0a0a;
  --muted-color: #6b7280;
  --border-color: #e5e7eb;
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
    --muted-color: #9ca3af;
    --border-color: #374151;
  }
}

* {
  box-sizing: border-box;
  padding: 0;
  margin: 0;
}

html,
body {
  max-width: 100vw;
  overflow-x: hidden;
}

body {
  color: var(--foreground);
  background: var(--background);
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen,
    Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

a {
  color: inherit;
  text-decoration: none;
}
`],
  ["frontend/angular/src/main.ts", `import { bootstrapApplication } from "@angular/platform-browser";

import { AppComponent } from "./app/app.component";
import { appConfig } from "./app/app.config";

bootstrapApplication(AppComponent, appConfig).catch((err) => console.error(err));
`],
  ["frontend/angular/src/index.html", `<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Better T Stack - Angular</title>
    <base href="/" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="icon" type="image/svg+xml" href="favicon.svg" />
  </head>
  <body>
    <app-root></app-root>
  </body>
</html>
`],
  ["frontend/angular/public/favicon.svg", `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 256">
  <rect width="256" height="256" fill="#0f0f0f" rx="32"/>
  <text x="128" y="170" text-anchor="middle" font-family="monospace" font-size="140" font-weight="bold" fill="#fafafa">T</text>
</svg>
`],
  ["frontend/fresh/static/styles.css.hbs", `{{#if (eq cssFramework "tailwind")}}
@tailwind base;
@tailwind components;
@tailwind utilities;
{{else}}
/* Base styles */
*,
*::before,
*::after {
  box-sizing: border-box;
}

body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
  background: linear-gradient(to bottom right, #0f172a, #581c87, #0f172a);
  min-height: 100vh;
  color: #e2e8f0;
}

header {
  background: rgba(0, 0, 0, 0.2);
  backdrop-filter: blur(12px);
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

nav {
  max-width: 1200px;
  margin: 0 auto;
  padding: 1rem;
  display: flex;
  align-items: center;
  justify-content: space-between;
}

a {
  color: inherit;
  text-decoration: none;
}

main {
  max-width: 1200px;
  margin: 0 auto;
  padding: 4rem 1rem;
}

h1 {
  font-size: 3rem;
  font-weight: bold;
  margin-bottom: 1.5rem;
}

button {
  cursor: pointer;
  border: none;
  padding: 0.5rem 1rem;
  border-radius: 0.5rem;
  font-weight: 600;
  background: #06b6d4;
  color: white;
}

button:hover {
  background: #0891b2;
}
{{/if}}
`],
  ["frontend/fresh/static/favicon.svg", `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100">
  <defs>
    <linearGradient id="freshGradient" x1="0%" y1="0%" x2="100%" y2="100%">
      <stop offset="0%" style="stop-color:#06b6d4"/>
      <stop offset="100%" style="stop-color:#8b5cf6"/>
    </linearGradient>
  </defs>
  <circle cx="50" cy="50" r="45" fill="url(#freshGradient)"/>
  <text x="50" y="62" font-family="Arial, sans-serif" font-size="40" font-weight="bold" fill="white" text-anchor="middle">F</text>
</svg>
`],
  ["frontend/nuxt/public/favicon.ico", `[Binary file]`],
  ["frontend/nuxt/public/robots.txt", `User-Agent: *
Disallow:
`],
  ["frontend/nuxt/app/app.vue.hbs", `<script setup lang="ts">
{{#if (eq api "orpc")}}
import { VueQueryDevtools } from '@tanstack/vue-query-devtools'
{{/if}}
</script>

<template>
    <NuxtLoadingIndicator />
    <UApp>
        <NuxtLayout>
            <NuxtPage />
        </NuxtLayout>
    </UApp>
    {{#if (eq api "orpc")}}
    <VueQueryDevtools />
    {{/if}}
</template>
`],
  ["frontend/nuxt/app/app.config.ts.hbs", `export default defineAppConfig({
  // https://ui.nuxt.com/getting-started/theme#design-system
  ui: {
    colors: {
      primary: 'emerald',
      neutral: 'neutral',
    },
    button: {
      defaultVariants: {
        // Set default button color to neutral
        // color: 'neutral'
      }
    }
  }
})
`],
  ["frontend/nuxt/server/tsconfig.json", `{
  "extends": "../.nuxt/tsconfig.server.json"
}
`],
  ["frontend/astro/public/favicon.svg", `<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32" fill="none">
  <rect width="32" height="32" rx="8" fill="#7C3AED"/>
  <path d="M16 6L8 26h4l2-5h4l2 5h4L16 6zm0 8l2 5h-4l2-5z" fill="white"/>
</svg>
`],
  ["frontend/native/unistyles/index.js.hbs", `import 'expo-router/entry';
import './unistyles';
`],
  ["frontend/native/unistyles/metro.config.js.hbs", `const { getDefaultConfig } = require("expo/metro-config");

const config = getDefaultConfig(__dirname);

module.exports = config;
`],
  ["frontend/native/unistyles/breakpoints.ts.hbs", `export const breakpoints = {
  xs: 0,
  sm: 576,
  md: 768,
  lg: 992,
  xl: 1200,
  superLarge: 2000,
  tvLike: 4000,
} as const;
`],
  ["frontend/native/unistyles/package.json.hbs", `{
  "name": "native",
  "version": "1.0.0",
  "private": true,
  "main": "index.js",
  "scripts": {
    "dev": "expo start --clear",
    "android": "expo run:android",
    "ios": "expo run:ios",
    "web": "expo start --web"
  },
  "dependencies": {
    "@expo/vector-icons": "^15.0.2",
    "@react-navigation/bottom-tabs": "^7.3.10",
    "@react-navigation/drawer": "^7.3.9",
    "@react-navigation/native": "^7.1.6",
    {{#if (includes examples "ai")}}
    "@stardazed/streams-text-encoding": "^1.0.2",
    "@ungap/structured-clone": "^1.3.0",
    {{/if}}
    "@tanstack/react-form": "^1.0.5",
    "expo": "^54.0.0",
    "expo-constants": "~18.0.8",
    "expo-crypto": "~15.0.6",
    "expo-linking": "~8.0.7",
    "expo-router": "~6.0.0",
    "expo-secure-store": "~15.0.6",
    "expo-splash-screen": "~31.0.8",
		"expo-status-bar": "^3.0.7",
    "expo-system-ui": "~6.0.7",
		"expo-dev-client": "~6.0.11",
    "expo-web-browser": "~15.0.6",
    "react": "19.1.0",
    "react-dom": "19.1.0",
    "react-native": "0.81.4",
		"react-native-edge-to-edge": "^1.7.0",
    "react-native-gesture-handler": "~2.28.0",
		"react-native-nitro-modules": "^0.29.4",
    "react-native-reanimated": "~4.1.0",
    "react-native-safe-area-context": "~5.6.0",
    "react-native-screens": "~4.16.0",
		"react-native-unistyles": "^3.0.12",
    "react-native-web": "^0.21.0",
    "react-native-worklets": "^0.5.1"
  },
  "devDependencies": {
    "ajv": "^8.17.1",
    "@babel/core": "^7.28.0",
    "@types/react": "~19.1.10"
  }
}
`],
  ["frontend/native/unistyles/theme.ts.hbs", `const sharedColors = {
  success: "#22C55E",
  destructive: "#EF4444",
  warning: "#F59E0B",
  info: "#3B82F6",
} as const;

export const lightTheme = {
  colors: {
    ...sharedColors,
    typography: "hsl(0 0% 0%)",
    background: "hsl(0 0% 100%)",
    foreground: "hsl(0 0% 0%)",
    card: "hsl(0 0% 98%)",
    cardForeground: "hsl(0 0% 0%)",
    primary: "hsl(0 0% 10%)",
    primaryForeground: "hsl(0 0% 100%)",
    secondary: "hsl(0 0% 95%)",
    secondaryForeground: "hsl(0 0% 0%)",
    muted: "hsl(0 0% 96%)",
    mutedForeground: "hsl(0 0% 45%)",
    accent: "hsl(0 0% 96%)",
    accentForeground: "hsl(0 0% 0%)",
    border: "hsl(0 0% 90%)",
    input: "hsl(0 0% 90%)",
    ring: "hsl(0 0% 20%)",
  },
  spacing: {
    xs: 4,
    sm: 8,
    md: 16,
    lg: 24,
    xl: 32,
    xxl: 48,
  },
  borderRadius: {
    sm: 6,
    md: 8,
    lg: 12,
    xl: 16,
  },
  fontSize: {
    xs: 12,
    sm: 14,
    base: 16,
    lg: 18,
    xl: 20,
    "2xl": 24,
    "3xl": 30,
    "4xl": 36,
  },
} as const;

export const darkTheme = {
  colors: {
    ...sharedColors,
    typography: "hsl(0 0% 100%)",
    background: "hsl(0 0% 0%)",
    foreground: "hsl(0 0% 100%)",
    card: "hsl(0 0% 2%)",
    cardForeground: "hsl(0 0% 100%)",
    primary: "hsl(0 0% 90%)",
    primaryForeground: "hsl(0 0% 0%)",
    secondary: "hsl(0 0% 10%)",
    secondaryForeground: "hsl(0 0% 100%)",
    muted: "hsl(0 0% 8%)",
    mutedForeground: "hsl(0 0% 65%)",
    accent: "hsl(0 0% 8%)",
    accentForeground: "hsl(0 0% 100%)",
    border: "hsl(0 0% 15%)",
    input: "hsl(0 0% 15%)",
    ring: "hsl(0 0% 80%)",
  },
  spacing: {
    xs: 4,
    sm: 8,
    md: 16,
    lg: 24,
    xl: 32,
    xxl: 48,
  },
  borderRadius: {
    sm: 6,
    md: 8,
    lg: 12,
    xl: 16,
  },
  fontSize: {
    xs: 12,
    sm: 14,
    base: 16,
    lg: 18,
    xl: 20,
    "2xl": 24,
    "3xl": 30,
    "4xl": 36,
  },
} as const;
`],
  ["frontend/native/unistyles/app.json.hbs", `{
  "expo": {
    "name": "{{projectName}}",
    "slug": "{{projectName}}",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/images/icon.png",
    "scheme": "mybettertapp",
    "userInterfaceStyle": "automatic",
    "newArchEnabled": true,
    "ios": {
      "supportsTablet": true
    },
    "android": {
      "adaptiveIcon": {
        "backgroundColor": "#E6F4FE",
        "foregroundImage": "./assets/images/android-icon-foreground.png",
        "backgroundImage": "./assets/images/android-icon-background.png",
        "monochromeImage": "./assets/images/android-icon-monochrome.png"
      },
      "edgeToEdgeEnabled": true,
      "predictiveBackGestureEnabled": false,
      "package": "com.anonymous.mybettertapp"
    },
    "web": {
      "output": "static",
      "favicon": "./assets/images/favicon.png"
    },
    "plugins": [
      "expo-router",
      [
        "expo-splash-screen",
        {
          "image": "./assets/images/splash-icon.png",
          "imageWidth": 200,
          "resizeMode": "contain",
          "backgroundColor": "#ffffff",
          "dark": {
            "backgroundColor": "#000000"
          }
        }
      ]
    ],
    "experiments": {
      "typedRoutes": true,
      "reactCompiler": true
    }
  }
}
`],
  ["frontend/native/unistyles/babel.config.js.hbs", `module.exports = (api) => {
	api.cache(true);
	const plugins = [];

	plugins.push([
		"react-native-unistyles/plugin",
		{
			root: "src",
			autoProcessRoot: "app",
			autoProcessImports: ["@/components"],
		},
	]);

	plugins.push("react-native-worklets/plugin");

	return {
		presets: ["babel-preset-expo"],

		plugins,
	};
};
`],
  ["frontend/native/unistyles/tsconfig.json.hbs", `{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "strict": true,
    "jsx": "react-jsx",
    "baseUrl": ".",
    "paths": {
      "@/*": ["*"]
    }
  },
  "include": ["**/*.ts", "**/*.tsx", ".expo/types/**/*.ts", "expo-env.d.ts"]
}
`],
  ["frontend/native/unistyles/unistyles.ts.hbs", `import { StyleSheet } from "react-native-unistyles";

import { breakpoints } from "./breakpoints";
import { darkTheme, lightTheme } from "./theme";

type AppBreakpoints = typeof breakpoints;

type AppThemes = {
  light: typeof lightTheme;
  dark: typeof darkTheme;
};

declare module "react-native-unistyles" {
  export interface UnistylesBreakpoints extends AppBreakpoints {}
  export interface UnistylesThemes extends AppThemes {}
}

StyleSheet.configure({
  breakpoints,
  themes: {
    light: lightTheme,
    dark: darkTheme,
  },
  settings: {
    adaptiveThemes: true,
  },
});
`],
  ["frontend/native/unistyles/_gitignore", `node_modules/
.expo/
dist/
npm-debug.*
*.jks
*.p8
*.p12
*.key
*.mobileprovision
*.orig.*
web-build/
# expo router
expo-env.d.ts

.env

ios
android

# macOS
.DS_Store

# Temporary files created by Metro to check the health of the file watcher
.metro-health-check*`],
  ["frontend/native/bare/metro.config.js.hbs", `// Learn more https://docs.expo.io/guides/customizing-metro
const { getDefaultConfig } = require("expo/metro-config");

const config = getDefaultConfig(__dirname);

config.resolver.unstable_enablePackageExports = true;

module.exports = config;

`],
  ["frontend/native/bare/package.json.hbs", `{
  "name": "native",
  "version": "1.0.0",
  "main": "expo-router/entry",
  "scripts": {
    "dev": "expo start --clear",
    "android": "expo run:android",
    "ios": "expo run:ios",
    "prebuild": "expo prebuild",
    "web": "expo start --web"
  },
  "dependencies": {
    "@expo/vector-icons": "^15.0.2",
    "@react-navigation/bottom-tabs": "^7.2.0",
    "@react-navigation/drawer": "^7.1.1",
    "@react-navigation/native": "^7.0.14",
    "@tanstack/react-form": "^1.0.5",
    "@tanstack/react-query": "^5.85.5",
    {{#if (includes examples "ai")}}
    "@stardazed/streams-text-encoding": "^1.0.2",
    "@ungap/structured-clone": "^1.3.0",
    {{/if}}
		"expo": "^54.0.1",
    "expo-constants": "~18.0.8",
    "expo-crypto": "~15.0.6",
    "expo-linking": "~8.0.7",
    "expo-navigation-bar": "~5.0.8",
    "expo-network": "~8.0.7",
    "expo-router": "~6.0.0",
    "expo-secure-store": "~15.0.6",
    "expo-splash-screen": "~31.0.8",
    "expo-status-bar": "~3.0.7",
    "expo-system-ui": "~6.0.7",
    "expo-web-browser": "~15.0.6",
    "react": "19.1.0",
    "react-dom": "19.1.0",
    "react-native": "0.81.4",
    "react-native-gesture-handler": "~2.28.0",
    "react-native-reanimated": "~4.1.0",
    "react-native-safe-area-context": "~5.6.0",
    "react-native-screens": "~4.16.0",
    "react-native-web": "^0.21.0",
    "react-native-worklets": "^0.5.1"
  },
  "devDependencies": {
    "@babel/core": "^7.26.10",
    "@types/react": "~19.1.10"
  },
  "private": true
}

`],
  ["frontend/native/bare/app.json.hbs", `{
	"expo": {
		"name": "{{projectName}}",
		"slug": "{{projectName}}",
		"version": "1.0.0",
		"orientation": "portrait",
		"icon": "./assets/images/icon.png",
		"scheme": "mybettertapp",
		"userInterfaceStyle": "automatic",
		"newArchEnabled": true,
		"ios": {
			"supportsTablet": true
		},
		"android": {
			"adaptiveIcon": {
				"backgroundColor": "#E6F4FE",
				"foregroundImage": "./assets/images/android-icon-foreground.png",
				"backgroundImage": "./assets/images/android-icon-background.png",
				"monochromeImage": "./assets/images/android-icon-monochrome.png"
			},
			"edgeToEdgeEnabled": true,
			"predictiveBackGestureEnabled": false,
			"package": "com.anonymous.mybettertapp"
		},
		"web": {
			"output": "static",
			"favicon": "./assets/images/favicon.png"
		},
		"plugins": [
			"expo-router",
			[
				"expo-splash-screen",
				{
					"image": "./assets/images/splash-icon.png",
					"imageWidth": 200,
					"resizeMode": "contain",
					"backgroundColor": "#ffffff",
					"dark": {
						"backgroundColor": "#000000"
					}
				}
			]
		],
		"experiments": {
			"typedRoutes": true,
			"reactCompiler": true
		}
	}
}

`],
  ["frontend/native/bare/tsconfig.json.hbs", `{
	"extends": "expo/tsconfig.base",
	"compilerOptions": {
		"strict": true,
		"paths": {
			"@/*": ["./*"]
		}
	},
	"include": ["**/*.ts", "**/*.tsx", ".expo/types/**/*.ts", "expo-env.d.ts"]
}

`],
  ["frontend/native/bare/_gitignore", `node_modules/
.expo/
dist/
npm-debug.*
*.jks
*.p8
*.p12
*.key
*.mobileprovision
*.orig.*
web-build/

# macOS
.DS_Store

# Temporary files created by Metro to check the health of the file watcher
.metro-health-check*

`],
  ["frontend/astro/src/env.d.ts", `/// <reference path="../.astro/types.d.ts" />
`],
  ["frontend/native/uniwind/metro.config.js.hbs", `const { getDefaultConfig } = require("expo/metro-config");
const { withUniwindConfig } = require("uniwind/metro");

/** @type {import('expo/metro-config').MetroConfig} */
const config = getDefaultConfig(__dirname);

const uniwindConfig = withUniwindConfig(config, {
  cssEntryFile: "./global.css",
  dtsFile: "./uniwind-types.d.ts",
});

module.exports = uniwindConfig;

`],
  ["frontend/native/uniwind/global.css", `@import "tailwindcss";
@import "uniwind";
@import "heroui-native/styles";

@source './node_modules/heroui-native/lib';
`],
  ["frontend/native/uniwind/package.json.hbs", `{
  "name": "native",
  "version": "1.0.0",
  "private": true,
  "main": "expo-router/entry",
  "scripts": {
    "start": "expo start",
    "dev": "expo start --clear",
    "android": "expo run:android",
    "ios": "expo run:ios",
    "prebuild": "expo prebuild",
    "web": "expo start --web"
  },
  "dependencies": {
    "@expo/metro-runtime": "~6.1.2",
    "@expo/vector-icons": "^15.0.3",
    "@gorhom/bottom-sheet": "^5",
    "@react-navigation/drawer": "^7.3.9",
    "@react-navigation/elements": "^2.8.1",
    {{#if (includes examples "ai")}}
    "@stardazed/streams-text-encoding": "^1.0.2",
    "@ungap/structured-clone": "^1.3.0",
    {{/if}}
    "expo": "^54.0.23",
    "expo-constants": "~18.0.10",
    "expo-font": "~14.0.9",
    "expo-haptics": "^15.0.7",
    "expo-linking": "~8.0.8",
    "expo-network": "~8.0.7",
    "expo-router": "~6.0.14",
    "expo-secure-store": "~15.0.7",
    "expo-status-bar": "~3.0.8",
    "heroui-native": "^1.0.0-beta.9",
    "react": "19.1.0",
    "react-dom": "19.1.0",
    "react-native": "0.81.5",
    "react-native-gesture-handler": "^2.28.0",
    "react-native-keyboard-controller": "1.18.5",
    "react-native-reanimated": "~4.1.1",
    "react-native-safe-area-context": "~5.6.0",
    "react-native-screens": "~4.16.0",
    "react-native-svg": "15.12.1",
    "react-native-web": "^0.21.0",
    "react-native-worklets": "0.5.1",
    "tailwind-merge": "^3.4.0",
    "tailwind-variants": "^3.2.2",
    "tailwindcss": "^4.1.18",
    "uniwind": "^1.2.2"
  },
  "devDependencies": {
    "@types/node": "^24.10.0",
    "@types/react": "~19.1.0"
  }
}`],
  ["frontend/native/uniwind/app.json.hbs", `{
  "expo": {
    "scheme": "{{projectName}}",
    "userInterfaceStyle": "automatic",
    "orientation": "default",
    "web": {
      "bundler": "metro"
    },
    "name": "{{projectName}}",
    "slug": "{{projectName}}",
    "plugins": [
      "expo-font"
    ],
    "experiments": {
      "typedRoutes": true,
      "reactCompiler": true
    }
  }
}
`],
  ["frontend/native/uniwind/tsconfig.json.hbs", `{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "strict": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": [
    "**/*.ts",
    "**/*.tsx"
  ]
}`],
  ["frontend/native/uniwind/_gitignore", `node_modules/
.expo/
dist/
npm-debug.*
*.jks
*.p8
*.p12
*.key
*.mobileprovision
*.orig.*
web-build/

# macOS
.DS_Store

# Temporary files created by Metro to check the health of the file watcher
.metro-health-check*

# UniWind generated types
uniwind-types.d.ts

`],
  ["rust-base/crates/tui/Cargo.toml.hbs", `[package]
name = "{{projectName}}-tui"
version.workspace = true
edition.workspace = true
authors.workspace = true
license.workspace = true
description = "Terminal user interface for {{projectName}}"

[dependencies]
# TUI framework
ratatui.workspace = true
crossterm.workspace = true

# Async runtime
tokio.workspace = true

# Serialization
serde.workspace = true
serde_json.workspace = true

# Error handling
anyhow.workspace = true

# Logging
tracing.workspace = true
tracing-subscriber.workspace = true
tracing-appender.workspace = true

# Environment
dotenvy.workspace = true

[[bin]]
name = "tui"
path = "src/main.rs"
`],
  ["rust-base/crates/server/Cargo.toml.hbs", `[package]
name = "{{projectName}}-server"
version.workspace = true
edition.workspace = true
authors.workspace = true
license.workspace = true

[dependencies]
# Async runtime
tokio.workspace = true

# Serialization
serde.workspace = true
serde_json.workspace = true

# Error handling
thiserror.workspace = true
anyhow.workspace = true

# Logging
tracing.workspace = true
tracing-subscriber.workspace = true

# Environment
dotenvy.workspace = true

{{#if (eq rustWebFramework "axum")}}
# Web framework
axum.workspace = true
tower.workspace = true
tower-http.workspace = true
{{/if}}
{{#if (eq rustWebFramework "actix-web")}}
# Web framework
actix-web.workspace = true
actix-rt.workspace = true
actix-cors.workspace = true
{{/if}}

{{#if (eq rustOrm "sqlx")}}
# Database
sqlx.workspace = true
{{/if}}
{{#if (eq rustOrm "sea-orm")}}
# Database
sea-orm.workspace = true
{{/if}}

{{#if (eq rustApi "tonic")}}
# gRPC
tonic.workspace = true
prost.workspace = true
{{projectName}}-proto = { path = "../proto" }
tokio-stream = "0.1"
{{/if}}
{{#if (eq rustApi "async-graphql")}}
# GraphQL
async-graphql.workspace = true
{{#if (eq rustWebFramework "axum")}}
async-graphql-axum.workspace = true
{{/if}}
{{#if (eq rustWebFramework "actix-web")}}
async-graphql-actix-web.workspace = true
{{/if}}
{{/if}}

{{#if (includes rustLibraries "validator")}}
validator.workspace = true
{{/if}}
{{#if (includes rustLibraries "jsonwebtoken")}}
jsonwebtoken.workspace = true
{{/if}}
{{#if (includes rustLibraries "argon2")}}
argon2.workspace = true
{{/if}}
{{#if (eq rustCli "clap")}}

# CLI
clap.workspace = true
{{/if}}

[[bin]]
name = "server"
path = "src/main.rs"

{{#if (or (includes rustLibraries "tokio-test") (includes rustLibraries "mockall"))}}
[dev-dependencies]
{{#if (includes rustLibraries "tokio-test")}}
tokio-test.workspace = true
{{/if}}
{{#if (includes rustLibraries "mockall")}}
mockall.workspace = true
{{/if}}
{{/if}}
`],
  ["rust-base/crates/proto/build.rs.hbs", `fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Compile the protobuf definitions
    tonic_build::configure()
        .build_server(true)
        .build_client(true)
        .out_dir("src/generated")
        .compile_protos(&["proto/greeter.proto"], &["proto"])?;

    // Tell Cargo to rerun this build script if the proto files change
    println!("cargo:rerun-if-changed=proto/greeter.proto");

    Ok(())
}
`],
  ["rust-base/crates/proto/Cargo.toml.hbs", `[package]
name = "{{projectName}}-proto"
version.workspace = true
edition.workspace = true
authors.workspace = true
license.workspace = true

[dependencies]
tonic.workspace = true
prost.workspace = true

[build-dependencies]
tonic-build.workspace = true
`],
  ["rust-base/crates/cli/Cargo.toml.hbs", `[package]
name = "{{projectName}}-cli"
version.workspace = true
edition.workspace = true
authors.workspace = true
license.workspace = true
description = "Command-line interface for {{projectName}}"

[dependencies]
# CLI argument parsing
clap.workspace = true

# Async runtime
tokio.workspace = true

# Serialization
serde.workspace = true
serde_json.workspace = true

# Error handling
anyhow.workspace = true

# Logging
tracing.workspace = true
tracing-subscriber.workspace = true

# Environment
dotenvy.workspace = true

[[bin]]
name = "cli"
path = "src/main.rs"
`],
  ["rust-base/crates/client/Trunk.toml.hbs", `[build]
target = "index.html"
dist = "dist"

[watch]
watch = ["src", "style", "index.html"]
ignore = ["dist"]

[serve]
address = "127.0.0.1"
port = 8080
open = false

[clean]
dist = "dist"
`],
  ["rust-base/crates/client/Cargo.toml.hbs", `[package]
name = "{{projectName}}-client"
version.workspace = true
edition.workspace = true
authors.workspace = true
license.workspace = true

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
# Leptos framework
leptos.workspace = true
leptos_router.workspace = true
leptos_meta.workspace = true

# Logging
log.workspace = true
console_log.workspace = true

# WASM utilities
wasm-bindgen.workspace = true
wasm-bindgen-futures.workspace = true
web-sys.workspace = true
console_error_panic_hook.workspace = true

# Serialization
serde.workspace = true
serde_json.workspace = true

[features]
default = []
hydrate = ["leptos/hydrate", "leptos_router/hydrate", "leptos_meta/hydrate"]
ssr = ["leptos/ssr", "leptos_router/ssr", "leptos_meta/ssr"]
`],
  ["rust-base/crates/client/index.html.hbs", `<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="description" content="{{projectName}} - A Rust WASM application built with Leptos" />
    <title>{{projectName}}</title>
    <link data-trunk rel="css" href="style/main.css" />
    <link data-trunk rel="rust" href="Cargo.toml" data-wasm-opt="z" />
  </head>
  <body></body>
</html>
`],
  ["rust-base/crates/dioxus-client/Dioxus.toml.hbs", `[application]
name = "{{projectName}}"
default_platform = "web"

[web.app]
title = "{{projectName}}"

[web.watcher]
reload_html = true
watch_path = ["src", "assets"]

[web.resource]
dev_serve_crate = true
style = ["assets/main.css"]

[web.https]
enabled = false
`],
  ["rust-base/crates/dioxus-client/Cargo.toml.hbs", `[package]
name = "{{projectName}}-client"
version.workspace = true
edition.workspace = true
authors.workspace = true
license.workspace = true

[[bin]]
name = "{{projectName}}-client"
path = "src/main.rs"

[dependencies]
# Dioxus framework
dioxus.workspace = true
dioxus-router.workspace = true

# Logging
tracing.workspace = true
dioxus-logger.workspace = true

# WASM utilities
wasm-bindgen.workspace = true
console_error_panic_hook.workspace = true

# Serialization
serde.workspace = true
serde_json.workspace = true

[features]
default = ["web"]
web = ["dioxus/web"]
desktop = ["dioxus/desktop"]
`],
  ["api/garph/server/package.json.hbs", `{
  "name": "@{{projectName}}/api",
  "exports": {
    ".": {
      "default": "./src/index.ts"
    },
    "./*": {
      "default": "./src/*.ts"
    }
  },
  "type": "module",
  "scripts": {},
  "devDependencies": {}
}
`],
  ["api/garph/server/tsconfig.json.hbs", `{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "./dist",
    "rootDir": "./src"
  },
  "include": ["src/**/*"]
}
`],
  ["api/garph/server/_gitignore", `dist
node_modules
`],
  ["api/ts-rest/server/package.json.hbs", `{
  "name": "@{{projectName}}/api",
  "exports": {
    ".": {
      "default": "./src/index.ts"
    },
    "./*": {
      "default": "./src/*.ts"
    }
  },
  "type": "module",
  "scripts": {},
  "devDependencies": {}
}
`],
  ["api/ts-rest/server/tsconfig.json.hbs", `{
  "extends": "../../tooling/typescript/base.json",
  "compilerOptions": {
    "outDir": "./dist",
    "rootDir": "./src"
  },
  "include": ["src/**/*.ts"]
}
`],
  ["api/ts-rest/server/_gitignore", `dist
`],
  ["frontend/react/tanstack-start/package.json.hbs", `{
  "name": "web",
  "private": true,
  "type": "module",
  "scripts": {
    "build": "vite build",
    "serve": "vite preview",
    "dev": "vite dev"
  },
  "dependencies": {
{{#if (eq uiLibrary "shadcn-ui")}}
    "@base-ui/react": "^1.0.0",
    "shadcn": "^3.6.2",
    "@tanstack/react-form": "^1.23.5",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "lucide-react": "^0.525.0",
    "next-themes": "^0.4.6",
    "sonner": "^2.0.3",
    "tailwind-merge": "^3.3.1",
{{/if}}
{{#if (eq cssFramework "tailwind")}}
    "@tailwindcss/vite": "^4.1.8",
    "tailwindcss": "^4.1.3",
    "tw-animate-css": "^1.2.5",
{{/if}}
    "@tanstack/react-query": "^5.80.6",
    "@tanstack/react-router": "^1.154.3",
    "@tanstack/react-router-with-query": "^1.130.17",
    "@tanstack/react-start": "^1.154.3",
    "@tanstack/router-plugin": "^1.154.3",
    "react": "19.2.3",
    "react-dom": "19.2.3",
    "vite-tsconfig-paths": "^5.1.4"
  },
  "devDependencies": {
    "@tanstack/react-router-devtools": "^1.154.3",
    "@testing-library/dom": "^10.4.0",
    "@testing-library/react": "^16.2.0",
    "@types/react": "19.2.7",
    "@types/react-dom": "19.2.3",
    "@vitejs/plugin-react": "^5.0.4",
    "jsdom": "^26.0.0",
    "vite": "^7.0.2",
    "web-vitals": "^5.0.3"
  }
}
`],
  ["frontend/react/tanstack-start/tsconfig.json.hbs", `{
  "include": ["**/*.ts", "**/*.tsx"],
  "compilerOptions": {
    "target": "ES2022",
    "jsx": "react-jsx",
    "module": "ESNext",
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "types": ["vite/client"],

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "noEmit": true,

    /* Linting */
    "skipLibCheck": true,
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  }
}
`],
  ["frontend/react/tanstack-start/vite.config.ts.hbs", `import { defineConfig } from "vite";
import tsconfigPaths from "vite-tsconfig-paths";
import { tanstackStart } from "@tanstack/react-start/plugin/vite";
import tailwindcss from "@tailwindcss/vite";
import viteReact from "@vitejs/plugin-react";

export default defineConfig({
  plugins: [
    tsconfigPaths(),
    tailwindcss(),
    tanstackStart(),
    viteReact(),
  ],
  server: {
    port: 3001,
  },
{{#if (and (eq backend "convex") (eq auth "better-auth"))}}
  ssr: {
    noExternal: ["@convex-dev/better-auth"],
  },
{{/if}}
});
`],
  ["frontend/react/web-base/components.json.hbs", `{{#if (eq uiLibrary "shadcn-ui")}}
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "base-lyra",
  "rsc": false,
  "tsx": true,
  "tailwind": {
    "config": "",
    "css": "src/index.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "iconLibrary": "lucide",
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "menuColor": "default",
  "menuAccent": "subtle",
  "registries": {}
}
{{/if}}
`],
  ["frontend/react/web-base/_gitignore", `# Dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# Testing
/coverage

# Build outputs
/.next/
/out/
/build/
/dist/
.vinxi
.output
.react-router/
.tanstack/
.nitro/

# Deployment
.vercel
.netlify
.wrangler
.alchemy

# Environment & local files
.env*
!.env.example
.DS_Store
*.pem
*.local

# Logs
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*
*.log*

# TypeScript
*.tsbuildinfo
next-env.d.ts

# IDE
.vscode/*
!.vscode/extensions.json
.idea

# Other
dev-dist

.wrangler
.dev.vars*

.open-next
`],
  ["frontend/react/react-router/react-router.config.ts", `import type { Config } from "@react-router/dev/config";

export default {
  ssr: false,
  appDirectory: "src",
} satisfies Config;
`],
  ["frontend/react/react-router/package.json.hbs", `{
  "name": "web",
  "private": true,
  "type": "module",
  "scripts": {
    "build": "react-router build",
    "dev": "react-router dev",
    "start": "react-router-serve ./build/server/index.js",
    "typecheck": "react-router typegen && tsc"
  },
  "dependencies": {
{{#if (eq uiLibrary "shadcn-ui")}}
    "@base-ui/react": "^1.0.0",
    "shadcn": "^3.6.2",
    "@tanstack/react-form": "^1.27.3",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "lucide-react": "^0.511.0",
    "next-themes": "^0.4.6",
    "sonner": "^2.0.3",
    "tailwind-merge": "^3.3.0",
{{/if}}
{{#if (eq cssFramework "tailwind")}}
    "tw-animate-css": "^1.3.2",
{{/if}}
    "@react-router/fs-routes": "^7.10.1",
    "@react-router/node": "^7.10.1",
    "@react-router/serve": "^7.10.1",
    "isbot": "^5.1.28",
    "react": "19.2.3",
    "react-dom": "19.2.3",
    "react-router": "^7.10.1"
  },
  "devDependencies": {
    "@react-router/dev": "^7.10.1",
{{#if (eq cssFramework "tailwind")}}
    "@tailwindcss/vite": "^4.1.18",
    "tailwindcss": "^4.1.18",
{{/if}}
    "@types/node": "^20",
    "@types/react": "~19.2.7",
    "@types/react-dom": "^19.2.3",
    "react-router-devtools": "^1.1.0",
    "typescript": "^5.8.3",
    "vite": "^7.2.7",
    "vite-tsconfig-paths": "^5.1.4"
  }
}
`],
  ["frontend/react/react-router/tsconfig.json.hbs", `{
  "include": [
    "**/*",
    "**/.server/**/*",
    "**/.client/**/*",
    ".react-router/types/**/*"
  ],
  "compilerOptions": {
    "lib": ["DOM", "DOM.Iterable", "ES2022"],
    "types": ["node", "vite/client"],
    "target": "ES2022",
    "module": "ES2022",
    "moduleResolution": "bundler",
    "jsx": "react-jsx",
    "rootDirs": [".", "./.react-router/types"],
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    },
    "esModuleInterop": true,
    "verbatimModuleSyntax": true,
    "noEmit": true,
    "resolveJsonModule": true,
    "skipLibCheck": true,
    "strict": true
  }
}
`],
  ["frontend/react/react-router/vite.config.ts.hbs", `import { reactRouter } from "@react-router/dev/vite";
import tailwindcss from "@tailwindcss/vite";
import { defineConfig } from "vite";
import tsconfigPaths from "vite-tsconfig-paths";

export default defineConfig({
  plugins: [
    tailwindcss(),
    reactRouter(),
    tsconfigPaths(),
  ],
});`],
  ["frontend/react/next/package.json.hbs", `{
  "name": "web",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --port 3001",
    "build": "next build",
    "start": "next start"
  },
  "dependencies": {
{{#if (eq uiLibrary "shadcn-ui")}}
    "@base-ui/react": "^1.0.0",
    "shadcn": "^3.6.2",
    "@tanstack/react-form": "^1.27.3",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "lucide-react": "^0.546.0",
    "next-themes": "^0.4.6",
    "sonner": "^2.0.5",
    "tailwind-merge": "^3.3.1",
{{/if}}
{{#if (eq cssFramework "tailwind")}}
    "tw-animate-css": "^1.3.4",
{{/if}}
    "next": "^16.1.1",
    "react": "^19.2.3",
    "react-dom": "^19.2.3",
    "babel-plugin-react-compiler": "^1.0.0"
  },
  "devDependencies": {
{{#if (eq cssFramework "tailwind")}}
    "@tailwindcss/postcss": "^4.1.10",
    "tailwindcss": "^4.1.10",
{{/if}}
    "@types/node": "^20",
    "@types/react": "^19.2.7",
    "@types/react-dom": "^19.2.3",
    "typescript": "^5"
  }
}
`],
  ["frontend/react/next/next-env.d.ts.hbs", `/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.
`],
  ["frontend/react/next/next.config.ts.hbs", `import "@{{projectName}}/env/web";
{{#if (eq webDeploy "cloudflare")}}
import { initOpenNextCloudflareForDev } from "@opennextjs/cloudflare";
{{/if}}
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
	typedRoutes: true,
	reactCompiler: true,
	{{#if (eq webDeploy "fly")}}
	output: "standalone",
	{{/if}}
	{{#if (includes examples "ai")}}
	transpilePackages: ["shiki"],
	{{/if}}
	{{#if (eq dbSetup "turso")}}
	serverExternalPackages: ["libsql", "@libsql/client"],
	{{/if}}
};

export default nextConfig;

{{#if (eq webDeploy "cloudflare")}}
initOpenNextCloudflareForDev();
{{/if}}
`],
  ["frontend/react/next/postcss.config.mjs.hbs", `const config = {
  plugins: ["@tailwindcss/postcss"],
};

export default config;
`],
  ["frontend/react/next/tsconfig.json.hbs", `{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "verbatimModuleSyntax": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }{{#if (or (eq serverDeploy "cloudflare") (eq webDeploy "cloudflare"))}},
    "types": [
      "@cloudflare/workers-types"
    ]{{/if}}
  },
  "include": [
    {{#if (eq serverDeploy "cloudflare")}}
    "../server/env.d.ts",
    {{/if}}
    "./next-env.d.ts",
    "./**/*.ts",
    "./**/*.tsx",
    "./.next/types/**/*.ts"
  ],
  "exclude": [
    "./node_modules"
  ]
}
`],
  ["frontend/react/tanstack-router/package.json.hbs", `{
	"name": "web",
	"version": "0.0.0",
	"private": true,
	"type": "module",
	"scripts": {
		"dev": "vite dev",
		"build": "vite build",
		"serve": "vite preview",
		"start": "vite",
		"check-types": "tsc --noEmit"
	},
	"dependencies": {
{{#if (eq uiLibrary "shadcn-ui")}}
        "@hookform/resolvers": "^5.1.1",
        "@base-ui/react": "^1.0.0",
        "shadcn": "^3.6.2",
        "@tanstack/react-form": "^1.12.3",
		"class-variance-authority": "^0.7.1",
		"clsx": "^2.1.1",
		"lucide-react": "^0.473.0",
        "next-themes": "^0.4.6",
        "sonner": "^2.0.5",
		"tailwind-merge": "^3.3.1",
{{/if}}
{{#if (eq cssFramework "tailwind")}}
		"@tailwindcss/vite": "^4.0.15",
		"tw-animate-css": "^1.2.5",
{{/if}}
		"@tanstack/react-router": "^1.154.3",
		"react": "19.2.3",
		"react-dom": "19.2.3"
	},
	"devDependencies": {
		"@tanstack/react-router-devtools": "^1.154.3",
		"@tanstack/router-plugin": "^1.154.3",
		"@types/node": "^22.13.14",
		"@types/react": "19.2.7",
		"@types/react-dom": "19.2.3",
		"@vitejs/plugin-react": "^4.3.4",
{{#if (eq cssFramework "tailwind")}}
		"postcss": "^8.5.3",
		"tailwindcss": "^4.0.15",
{{/if}}
		"vite": "^6.2.2"
	}
}
`],
  ["frontend/react/tanstack-router/index.html.hbs", `<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>{{projectName}}</title>
  </head>

  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
`],
  ["frontend/react/tanstack-router/tsconfig.json.hbs", `{
  "compilerOptions": {
    "strict": true,
    "esModuleInterop": true,
    "jsx": "react-jsx",
    "target": "ESNext",
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "verbatimModuleSyntax": true,
    "skipLibCheck": true,
    "types": ["vite/client"],
    "rootDirs": ["."],
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  }
}
`],
  ["frontend/react/tanstack-router/vite.config.ts.hbs", `import tailwindcss from "@tailwindcss/vite";
import { tanstackRouter } from "@tanstack/router-plugin/vite";
import react from "@vitejs/plugin-react";
import path from "node:path";
import { defineConfig } from "vite";

export default defineConfig({
  plugins: [
    tailwindcss(),
    tanstackRouter({}),
    react(),
  ],
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "./src"),
    },
  },
  server: {
    port: 3001,
  },
});`],
  ["api/orpc/server/package.json.hbs", `{
  "name": "@{{projectName}}/api",
  "exports": {
    ".": {
      "default": "./src/index.ts"
    },
    "./*": {
      "default": "./src/*.ts"
    }
  },
  "type": "module",
  "scripts": {},
  "devDependencies": {},
  "dependencies": {}
}`],
  ["api/orpc/server/tsconfig.json.hbs", `{
  "extends": "@{{projectName}}/config/tsconfig.base.json",
  "compilerOptions": {
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "outDir": "dist",
    "composite": true
  }
}`],
  ["api/orpc/server/_gitignore", `# dependencies (bun install)
node_modules

# output
out
dist
*.tgz

# code coverage
coverage
*.lcov

# logs
logs
_.log
report.[0-9]_.[0-9]_.[0-9]_.[0-9]_.json

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# caches
.eslintcache
.cache
*.tsbuildinfo

# IntelliJ based IDEs
.idea

# Finder (MacOS) folder config
.DS_Store
`],
  ["api/trpc/server/package.json.hbs", `{
  "name": "@{{projectName}}/api",
  "exports": {
    ".": {
      "default": "./src/index.ts"
    },
    "./*": {
      "default": "./src/*.ts"
    }
  },
  "type": "module",
  "scripts": {},
  "devDependencies": {}
}`],
  ["api/trpc/server/tsconfig.json.hbs", `{
  "extends": "@{{projectName}}/config/tsconfig.base.json",
  "compilerOptions": {
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "outDir": "dist",
    "composite": true
  }
}`],
  ["api/trpc/server/_gitignore", `# dependencies (bun install)
node_modules

# output
out
dist
*.tgz

# code coverage
coverage
*.lcov

# logs
logs
_.log
report.[0-9]_.[0-9]_.[0-9]_.[0-9]_.json

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# caches
.eslintcache
.cache
*.tsbuildinfo

# IntelliJ based IDEs
.idea

# Finder (MacOS) folder config
.DS_Store
`],
  ["backend/server/encore/package.json.hbs", `{
	"name": "server",
	"main": "src/index.ts",
	"type": "module",
	"scripts": {
		"dev": "encore run",
		"build": "encore build",
		"check-types": "tsc -b",
		"test": "encore test"
	},
	"dependencies": {},
	"devDependencies": {}
}
`],
  ["backend/server/encore/encore.app.hbs", `{
	"id": "{{projectName}}-server"
}
`],
  ["backend/server/encore/encore.service.ts.hbs", `import { Service } from "encore.dev/service";

export default new Service("api");
`],
  ["backend/server/encore/tsconfig.json.hbs", `{
	"compilerOptions": {
		"target": "ESNext",
		"module": "ESNext",
		"moduleResolution": "bundler",
		"strict": true,
		"esModuleInterop": true,
		"skipLibCheck": true,
		"forceConsistentCasingInFileNames": true,
		"resolveJsonModule": true,
		"declaration": true,
		"declarationMap": true,
		"noEmit": true,
		"paths": {
			"~encore/*": ["./encore.gen/*"]
		}
	},
	"include": ["**/*.ts"],
	"exclude": ["node_modules"]
}
`],
  ["backend/server/encore/_gitignore", `# Encore.ts generated files
encore.gen/
.encore/

# Dependencies
node_modules/

# Build outputs
dist/

# Environment files
.env
.env.local
.env.*.local

# IDE
.vscode/
.idea/
*.swp
*.swo
`],
  ["backend/server/nitro/package.json.hbs", `{
	"name": "server",
	"type": "module",
	"scripts": {
		"dev": "nitro dev",
		"build": "nitro build",
		"start": "node .output/server/index.mjs",
		"check-types": "tsc --noEmit"
	},
	"dependencies": {},
	"devDependencies": {}
}
`],
  ["backend/server/nitro/nitro.config.ts.hbs", `import { defineNitroConfig } from "nitropack/config";

export default defineNitroConfig({
	// Server configuration
	compatibilityDate: "2025-01-01",
{{#if (eq runtime "node")}}
	preset: "node-server",
{{/if}}
{{#if (eq runtime "bun")}}
	preset: "bun",
{{/if}}
{{#if (eq runtime "workers")}}
	preset: "cloudflare-module",
{{/if}}
	// Enable source maps for debugging
	sourcemap: true,
	// Route rules
	routeRules: {
		"/**": {
			cors: true,
			headers: {
				"Access-Control-Allow-Origin": "*",
				"Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, OPTIONS",
{{#if (eq auth "better-auth")}}
				"Access-Control-Allow-Headers": "Content-Type, Authorization",
				"Access-Control-Allow-Credentials": "true",
{{else}}
				"Access-Control-Allow-Headers": "Content-Type",
{{/if}}
			},
		},
	},
});
`],
  ["backend/server/nitro/tsconfig.json.hbs", `{
	"compilerOptions": {
		"target": "ESNext",
		"module": "ESNext",
		"moduleResolution": "bundler",
		"strict": true,
		"skipLibCheck": true,
		"esModuleInterop": true,
		"resolveJsonModule": true,
		"isolatedModules": true,
		"noEmit": true,
		"types": ["nitropack"]
	},
	"include": ["**/*.ts", "nitro.config.ts"],
	"exclude": ["node_modules", ".output", ".nitro"]
}
`],
  ["backend/server/nitro/_gitignore", `# Nitro output
.output
.nitro

# Dependencies
node_modules

# Environment
.env
.env.local
.env.*.local

# IDE
.idea
.vscode

# OS
.DS_Store
Thumbs.db
`],
  ["backend/server/base/tsdown.config.ts.hbs", `import { defineConfig } from 'tsdown';

export default defineConfig({
    entry: './src/index.ts',
    format: 'esm',
    outDir: './dist',
    clean: true,
    noExternal: [/@{{projectName}}\\/.*/]
});
`],
  ["backend/server/base/package.json.hbs", `{
	"name": "server",
	"main": "src/index.ts",
	"type": "module",
	"scripts": {
		"build": "tsdown",
		"check-types": "tsc -b",
		"compile": "bun build --compile --minify --sourcemap --bytecode ./src/index.ts --outfile server"
	},
	"dependencies": {},
	{{#if (eq dbSetup 'supabase')}}
	"trustedDependencies": [
        "supabase"
    ],
    {{/if}}
	"devDependencies": {}
}
`],
  ["backend/server/base/tsconfig.json.hbs", `{
  "extends": "@{{projectName}}/config/tsconfig.base.json",
  "compilerOptions": {
    "composite": true,
		"outDir": "dist",
		"baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    },
    "jsx": "react-jsx"{{#if (eq backend "hono")}},
    "jsxImportSource": "hono/jsx"{{/if}}
  }
}
`],
  ["backend/server/base/_gitignore", `# prod
dist/
/build
/out/

# dev
.yarn/
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions
.vscode/*
!.vscode/launch.json
!.vscode/*.code-snippets
.idea/workspace.xml
.idea/usage.statistics.xml
.idea/shelf
.wrangler
.alchemy
/.next/
.vercel
prisma/generated/


# deps
node_modules/
/node_modules
/.pnp
.pnp.*

# env
.env*
.env.production
!.env.example
.dev.vars

# logs
logs/
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

# misc
.DS_Store
*.pem

# local db
*.db*

# typescript
*.tsbuildinfo
next-env.d.ts
`],
  ["backend/server/adonisjs/package.json.hbs", `{
	"name": "server",
	"main": "bin/server.js",
	"type": "module",
	"scripts": {
		"dev": "node ace serve --watch",
		"build": "node ace build",
		"start": "node bin/server.js",
		"check-types": "tsc -b",
		"test": "node ace test"
	},
	"dependencies": {},
	"devDependencies": {}
}
`],
  ["backend/server/adonisjs/adonisrc.ts.hbs", `import { defineConfig } from "@adonisjs/core/app";

export default defineConfig({
	commands: [],
	providers: [
		() => import("@adonisjs/core/providers/app_provider"),
		() => import("@adonisjs/core/providers/hash_provider"),
		{
			file: () => import("@adonisjs/core/providers/repl_provider"),
			environment: ["repl", "test"],
		},
	],
	preloads: [() => import("#start/routes")],
	directories: {
		config: "config",
		start: "start",
		tmp: "tmp",
	},
	metaFiles: [
		{
			pattern: "public/**",
			reloadServer: false,
		},
	],
});
`],
  ["backend/server/adonisjs/tsconfig.json.hbs", `{
	"extends": "@adonisjs/tsconfig/tsconfig.app.json",
	"compilerOptions": {
		"outDir": "./build",
		"rootDir": ".",
		"paths": {
			"#controllers/*": ["./app/controllers/*.js"],
			"#middleware/*": ["./app/middleware/*.js"],
			"#start/*": ["./start/*.js"],
			"#config/*": ["./config/*.js"]
		}
	},
	"include": ["**/*.ts"],
	"exclude": ["node_modules", "build"]
}
`],
  ["backend/server/adonisjs/_gitignore", `build
tmp
node_modules
.env
`],
  ["packages/env/src/web.ts.hbs", `{{#if (includes frontend "next")}}
import { createEnv } from "@t3-oss/env-nextjs";
{{else if (includes frontend "nuxt")}}
import { createEnv } from "@t3-oss/env-nuxt";
{{else}}
import { createEnv } from "@t3-oss/env-core";
{{/if}}
import { z } from "zod";

{{#if (includes frontend "nuxt")}}
/**
 * Nuxt env validation - validates at build time when imported in nuxt.config.ts
 * For runtime access in components/plugins, use useRuntimeConfig() instead:
 *   const config = useRuntimeConfig()
 *   config.public.serverUrl (NUXT_PUBLIC_SERVER_URL maps to serverUrl)
 */
{{/if}}
export const env = createEnv({
{{#if (eq backend "convex")}}
{{#if (includes frontend "next")}}
	client: {
		NEXT_PUBLIC_CONVEX_URL: z.url(),
{{#if (eq auth "better-auth")}}
		NEXT_PUBLIC_CONVEX_SITE_URL: z.url(),
{{/if}}
{{#if (eq auth "clerk")}}
		NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY: z.string().min(1),
{{/if}}
	},
	runtimeEnv: {
		NEXT_PUBLIC_CONVEX_URL: process.env.NEXT_PUBLIC_CONVEX_URL,
{{#if (eq auth "better-auth")}}
		NEXT_PUBLIC_CONVEX_SITE_URL: process.env.NEXT_PUBLIC_CONVEX_SITE_URL,
{{/if}}
{{#if (eq auth "clerk")}}
		NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY: process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY,
{{/if}}
	},
{{else if (includes frontend "nuxt")}}
	client: {
		NUXT_PUBLIC_CONVEX_URL: z.url(),
	},
{{else if (includes frontend "svelte")}}
	clientPrefix: "PUBLIC_",
	client: {
		PUBLIC_CONVEX_URL: z.url(),
	},
	runtimeEnv: (import.meta as any).env,
{{else}}
	clientPrefix: "VITE_",
	client: {
		VITE_CONVEX_URL: z.url(),
{{#if (eq auth "better-auth")}}
		VITE_CONVEX_SITE_URL: z.url(),
{{/if}}
{{#if (eq auth "clerk")}}
		VITE_CLERK_PUBLISHABLE_KEY: z.string().min(1),
{{/if}}
	},
	runtimeEnv: (import.meta as any).env,
{{/if}}
{{else if (eq backend "self")}}
{{#if (includes frontend "next")}}
	client: {},
	runtimeEnv: {},
{{else}}
	clientPrefix: "VITE_",
	client: {},
	runtimeEnv: (import.meta as any).env,
{{/if}}
{{else if (ne backend "none")}}
{{#if (includes frontend "next")}}
	client: {
		NEXT_PUBLIC_SERVER_URL: z.url(),
	},
	runtimeEnv: {
		NEXT_PUBLIC_SERVER_URL: process.env.NEXT_PUBLIC_SERVER_URL,
	},
{{else if (includes frontend "nuxt")}}
	client: {
		NUXT_PUBLIC_SERVER_URL: z.url(),
	},
{{else if (includes frontend "svelte")}}
	clientPrefix: "PUBLIC_",
	client: {
		PUBLIC_SERVER_URL: z.url(),
	},
	runtimeEnv: (import.meta as any).env,
{{else}}
	clientPrefix: "VITE_",
	client: {
		VITE_SERVER_URL: z.url(),
	},
	runtimeEnv: (import.meta as any).env,
{{/if}}
{{/if}}
	emptyStringAsUndefined: true,
});`],
  ["packages/env/src/server.ts.hbs", `{{#if (eq serverDeploy "cloudflare")}}
/// <reference path="../env.d.ts" />
// For Cloudflare Workers, env is accessed via cloudflare:workers module
// Types are defined in env.d.ts based on your alchemy.run.ts bindings
export { env } from "cloudflare:workers";
{{else}}
import "dotenv/config";
import { createEnv } from "@t3-oss/env-core";
import { z } from "zod";

export const env = createEnv({
	server: {
{{#if (ne database "none")}}
{{#if (eq dbSetup "planetscale")}}
		DATABASE_HOST: z.string().min(1),
		DATABASE_USERNAME: z.string().min(1),
		DATABASE_PASSWORD: z.string().min(1),
{{else}}
		DATABASE_URL: z.string().min(1),
{{#if (eq dbSetup "turso")}}
		DATABASE_AUTH_TOKEN: z.string().min(1),
{{/if}}
{{/if}}
{{/if}}
{{#if (eq auth "better-auth")}}
		BETTER_AUTH_SECRET: z.string().min(32),
		BETTER_AUTH_URL: z.url(),
{{/if}}
{{#if (eq payments "polar")}}
		POLAR_ACCESS_TOKEN: z.string().min(1),
		POLAR_SUCCESS_URL: z.url(),
{{/if}}
		CORS_ORIGIN: z.url(),
		NODE_ENV: z.enum(["development", "production", "test"]).default("development"),
	},
	runtimeEnv: process.env,
	emptyStringAsUndefined: true,
});
{{/if}}`],
  ["packages/env/src/native.ts.hbs", `import { createEnv } from "@t3-oss/env-core";
import { z } from "zod";

export const env = createEnv({
	clientPrefix: "EXPO_PUBLIC_",
	client: {
{{#if (eq backend "convex")}}
		EXPO_PUBLIC_CONVEX_URL: z.url(),
{{#if (eq auth "better-auth")}}
		EXPO_PUBLIC_CONVEX_SITE_URL: z.url(),
{{/if}}
{{#if (eq auth "clerk")}}
		EXPO_PUBLIC_CLERK_PUBLISHABLE_KEY: z.string().min(1),
{{/if}}
{{else}}
		EXPO_PUBLIC_SERVER_URL: z.url(),
{{/if}}
	},
	runtimeEnv: process.env,
	emptyStringAsUndefined: true,
});`],
  ["db/edgedb/base/edgedb.toml.hbs", `[edgedb]
server-version = "6"
`],
  ["db/drizzle/sqlite/drizzle.config.ts.hbs", `import { defineConfig } from "drizzle-kit";
import dotenv from "dotenv";

dotenv.config({
    {{#if (eq backend "self")}}
    path: "../../apps/web/.env",
    {{else}}
    path: "../../apps/server/.env",
    {{/if}}
});

export default defineConfig({
  schema: "./src/schema",
  out: "./src/migrations",
  {{#if (eq dbSetup "d1")}}
  // DOCS: https://orm.drizzle.team/docs/guides/d1-http-with-drizzle-kit
  dialect: "sqlite",
  driver: "d1-http",
  {{else}}
  dialect: "turso",
  dbCredentials: {
    url: process.env.DATABASE_URL || "",
    {{#if (eq dbSetup "turso")}}
    authToken: process.env.DATABASE_AUTH_TOKEN,
    {{/if}}
  },
  {{/if}}
});
`],
  ["db/drizzle/postgres/drizzle.config.ts.hbs", `import { defineConfig } from "drizzle-kit";
import dotenv from "dotenv";

dotenv.config({
    {{#if (eq backend "self")}}
    path: "../../apps/web/.env",
    {{else}}
    path: "../../apps/server/.env",
    {{/if}}
});

export default defineConfig({
  schema: "./src/schema",
  out: "./src/migrations",
  dialect: "postgresql",
  dbCredentials: {
    url: process.env.DATABASE_URL || "",
  },
});
`],
  ["db/prisma/postgres/prisma.config.ts.hbs", `import path from "node:path";
import { defineConfig, env } from 'prisma/config'
import dotenv from 'dotenv'

dotenv.config({
    {{#if (eq backend "self")}}
    path: "../../apps/web/.env",
    {{else}}
    path: "../../apps/server/.env",
    {{/if}}
})

export default defineConfig({
  schema: path.join("prisma", "schema"),
  migrations: {
    path: path.join("prisma", "migrations"),
    },
    datasource: {
        url: env('DATABASE_URL'),
    },
})
`],
  ["db/prisma/sqlite/prisma.config.ts.hbs", `import path from "node:path";
import { defineConfig, env } from "prisma/config";
import dotenv from "dotenv";

dotenv.config({
  {{#if (eq backend "self")}}
  path: "../../apps/web/.env",
  {{else}}
  path: "../../apps/server/.env",
  {{/if}}
});

export default defineConfig({
  schema: path.join("prisma", "schema"),
  migrations: {
    path: path.join("prisma", "migrations"),
  },
  datasource: {
    {{#if (eq dbSetup "turso")}}
    url: "file:./dev.db",
    {{else}}
    url: env("DATABASE_URL"),
    {{/if}}
  },
});`],
  ["db/prisma/mongodb/prisma.config.ts.hbs", `import path from "node:path";
import type { PrismaConfig } from "prisma";
import dotenv from "dotenv";

dotenv.config({
    {{#if (eq backend "self")}}
    path: "../../apps/web/.env",
    {{else}}
    path: "../../apps/server/.env",
    {{/if}}
});

export default {
  schema: path.join("prisma", "schema"),
  migrations: {
    path: path.join("prisma", "migrations"),
  }
} satisfies PrismaConfig;
`],
  ["db/prisma/mysql/prisma.config.ts.hbs", `import path from "node:path";
import { defineConfig, env } from "prisma/config";
import dotenv from "dotenv";

dotenv.config({
  {{#if (eq backend "self")}}
  path: "../../apps/web/.env",
  {{else}}
  path: "../../apps/server/.env",
  {{/if}}
});

export default defineConfig({
  schema: path.join("prisma", "schema"),
  migrations: {
    path: path.join("prisma", "migrations"),
  },
  datasource: {
    url: env("DATABASE_URL"),
  },
});`],
  ["deploy/fly/server/fly.toml.hbs", `# Fly.io configuration for {{projectName}} server
# See https://fly.io/docs/reference/configuration/ for all options

app = "{{projectName}}-server"
primary_region = "iad"

[build]
  dockerfile = "Dockerfile"

[env]
  NODE_ENV = "production"
  PORT = "3000"

[http_service]
  internal_port = 3000
  force_https = true
  auto_stop_machines = "stop"
  auto_start_machines = true
  min_machines_running = 0
  processes = ["app"]

  [http_service.concurrency]
    type = "requests"
    soft_limit = 200
    hard_limit = 250

[[http_service.checks]]
  grace_period = "10s"
  interval = "30s"
  method = "GET"
  timeout = "5s"
  path = "/health"

[[vm]]
  size = "shared-cpu-1x"
  memory = "512mb"
  processes = ["app"]
`],
  ["deploy/fly/server/Dockerfile.hbs", `# Dockerfile for {{projectName}} server
# Optimized multi-stage build for Fly.io deployment

{{#if (eq packageManager "bun")}}
# Build stage
FROM oven/bun:1 AS builder

WORKDIR /app

# Copy package files
COPY package.json bun.lock* ./
{{#if (includes addons "turborepo")}}
COPY apps/server/package.json ./apps/server/
COPY packages/db/package.json ./packages/db/
{{/if}}

# Install dependencies
RUN bun install --frozen-lockfile

# Copy source code
COPY . .

# Build the application
{{#if (includes addons "turborepo")}}
RUN bun run build --filter=@{{projectName}}/server
{{else}}
RUN bun run build
{{/if}}

# Production stage
FROM oven/bun:1-slim AS runner

WORKDIR /app

ENV NODE_ENV=production
ENV PORT=3000

# Copy built application
{{#if (includes addons "turborepo")}}
COPY --from=builder /app/apps/server/dist ./dist
COPY --from=builder /app/apps/server/package.json ./
{{else}}
COPY --from=builder /app/dist ./dist
COPY --from=builder /app/package.json ./
{{/if}}

# Install production dependencies only
RUN bun install --production --frozen-lockfile

EXPOSE 3000

CMD ["bun", "run", "dist/index.js"]
{{else}}
# Build stage
FROM node:20-alpine AS builder

WORKDIR /app

# Install pnpm if needed
{{#if (eq packageManager "pnpm")}}
RUN corepack enable && corepack prepare pnpm@latest --activate
{{/if}}

# Copy package files
COPY package.json {{#if (eq packageManager "pnpm")}}pnpm-lock.yaml{{else}}package-lock.json{{/if}} ./
{{#if (includes addons "turborepo")}}
COPY apps/server/package.json ./apps/server/
COPY packages/db/package.json ./packages/db/
{{/if}}

# Install dependencies
{{#if (eq packageManager "pnpm")}}
RUN pnpm install --frozen-lockfile
{{else}}
RUN npm ci
{{/if}}

# Copy source code
COPY . .

# Build the application
{{#if (includes addons "turborepo")}}
{{#if (eq packageManager "pnpm")}}
RUN pnpm run build --filter=@{{projectName}}/server
{{else}}
RUN npm run build --workspace=apps/server
{{/if}}
{{else}}
{{#if (eq packageManager "pnpm")}}
RUN pnpm run build
{{else}}
RUN npm run build
{{/if}}
{{/if}}

# Production stage
FROM node:20-alpine AS runner

WORKDIR /app

ENV NODE_ENV=production
ENV PORT=3000

{{#if (eq packageManager "pnpm")}}
RUN corepack enable && corepack prepare pnpm@latest --activate
{{/if}}

# Copy built application
{{#if (includes addons "turborepo")}}
COPY --from=builder /app/apps/server/dist ./dist
COPY --from=builder /app/apps/server/package.json ./
{{else}}
COPY --from=builder /app/dist ./dist
COPY --from=builder /app/package.json ./
{{/if}}

# Install production dependencies only
{{#if (eq packageManager "pnpm")}}
RUN pnpm install --prod --frozen-lockfile
{{else}}
RUN npm ci --omit=dev
{{/if}}

EXPOSE 3000

CMD ["node", "dist/index.js"]
{{/if}}
`],
  ["deploy/fly/server/.dockerignore.hbs", `# Dependencies
node_modules
.pnpm-store

# Build outputs
dist
build

# Development
.env*.local
.env.development*
*.log

# Testing
coverage
.nyc_output

# IDE
.idea
.vscode
*.swp
*.swo

# OS
.DS_Store
Thumbs.db

# Git
.git
.gitignore

# Docker
Dockerfile*
.dockerignore
docker-compose*

# Misc
README.md
*.md
.turbo
`],
  ["deploy/sst/infra/sst.config.ts.hbs", `/// <reference path="./.sst/platform/config.d.ts" />

/**
 * SST Configuration for {{projectName}}
 * @see https://sst.dev/docs/reference/config
 */
export default $config({
  app(input) {
    return {
      name: "{{projectName}}",
      removal: input?.stage === "production" ? "retain" : "remove",
      protect: ["production"].includes(input?.stage),
      home: "aws",
    };
  },
  async run() {
{{#if (ne serverDeploy "sst")}}
{{#if (eq webDeploy "sst")}}
    // Frontend deployment
{{#if (includes frontend "next")}}
    const web = new sst.aws.Nextjs("Web", {
      path: "apps/web",
    });

    return {
      web: web.url,
    };
{{else if (includes frontend "tanstack-start")}}
    const web = new sst.aws.TanStackStart("Web", {
      path: "apps/web",
    });

    return {
      web: web.url,
    };
{{else if (includes frontend "svelte")}}
    const web = new sst.aws.SvelteKit("Web", {
      path: "apps/web",
    });

    return {
      web: web.url,
    };
{{else if (includes frontend "solid")}}
    const web = new sst.aws.SolidStart("Web", {
      path: "apps/web",
    });

    return {
      web: web.url,
    };
{{else if (includes frontend "nuxt")}}
    // Static site for Nuxt (SSR not directly supported, use static generation)
    const web = new sst.aws.StaticSite("Web", {
      path: "apps/web",
      build: {
        command: "{{#if (eq packageManager "bun")}}bun run generate{{else if (eq packageManager "pnpm")}}pnpm run generate{{else}}npm run generate{{/if}}",
        output: ".output/public",
      },
    });

    return {
      web: web.url,
    };
{{else}}
    // Static site deployment for SPA
    const web = new sst.aws.StaticSite("Web", {
      path: "apps/web",
      build: {
        command: "{{#if (eq packageManager "bun")}}bun run build{{else if (eq packageManager "pnpm")}}pnpm run build{{else}}npm run build{{/if}}",
        output: "dist",
      },
    });

    return {
      web: web.url,
    };
{{/if}}
{{/if}}
{{else if (ne webDeploy "sst")}}
    // Server deployment only
    const api = new sst.aws.Function("Api", {
      handler: "apps/server/dist/index.handler",
      url: true,
{{#if (ne database "none")}}
      environment: {
        DATABASE_URL: process.env.DATABASE_URL || "",
      },
{{/if}}
    });

    return {
      api: api.url,
    };
{{else}}
    // Full-stack deployment
{{#if (includes frontend "next")}}
    const web = new sst.aws.Nextjs("Web", {
      path: "apps/web",
    });
{{else if (includes frontend "tanstack-start")}}
    const web = new sst.aws.TanStackStart("Web", {
      path: "apps/web",
    });
{{else if (includes frontend "svelte")}}
    const web = new sst.aws.SvelteKit("Web", {
      path: "apps/web",
    });
{{else if (includes frontend "solid")}}
    const web = new sst.aws.SolidStart("Web", {
      path: "apps/web",
    });
{{else if (includes frontend "nuxt")}}
    // Static site for Nuxt
    const web = new sst.aws.StaticSite("Web", {
      path: "apps/web",
      build: {
        command: "{{#if (eq packageManager "bun")}}bun run generate{{else if (eq packageManager "pnpm")}}pnpm run generate{{else}}npm run generate{{/if}}",
        output: ".output/public",
      },
    });
{{else}}
    // Static site deployment for SPA
    const web = new sst.aws.StaticSite("Web", {
      path: "apps/web",
      build: {
        command: "{{#if (eq packageManager "bun")}}bun run build{{else if (eq packageManager "pnpm")}}pnpm run build{{else}}npm run build{{/if}}",
        output: "dist",
      },
    });
{{/if}}

    const api = new sst.aws.Function("Api", {
      handler: "apps/server/dist/index.handler",
      url: true,
{{#if (ne database "none")}}
      environment: {
        DATABASE_URL: process.env.DATABASE_URL || "",
      },
{{/if}}
    });

    return {
      web: web.url,
      api: api.url,
    };
{{/if}}
  },
});
`],
  ["deploy/docker/compose/docker-compose.yml.hbs", `# Docker Compose for {{projectName}}
# Full-stack container orchestration

name: {{projectName}}

services:
{{#if (ne webDeploy "none")}}
{{#if (eq webDeploy "docker")}}
  web:
    build:
      context: ./apps/web
      dockerfile: Dockerfile
    container_name: {{projectName}}-web
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
{{#if (ne serverDeploy "none")}}
{{#if (eq serverDeploy "docker")}}
      - VITE_API_URL=http://server:3001
{{/if}}
{{/if}}
    restart: unless-stopped
{{#if (ne serverDeploy "none")}}
{{#if (eq serverDeploy "docker")}}
    depends_on:
      - server
{{/if}}
{{/if}}
    networks:
      - {{projectName}}-network

{{/if}}
{{/if}}
{{#if (ne serverDeploy "none")}}
{{#if (eq serverDeploy "docker")}}
  server:
    build:
      context: ./apps/server
      dockerfile: Dockerfile
    container_name: {{projectName}}-server
    ports:
      - "3001:3000"
    environment:
      - NODE_ENV=production
      - PORT=3000
{{#if (ne database "none")}}
{{#if (eq database "postgres")}}
      - DATABASE_URL=postgresql://postgres:password@db:5432/{{projectName}}
{{else if (eq database "mysql")}}
      - DATABASE_URL=mysql://root:password@db:3306/{{projectName}}
{{else if (eq database "mongodb")}}
      - DATABASE_URL=mongodb://db:27017/{{projectName}}
{{else if (eq database "redis")}}
      - REDIS_URL=redis://redis:6379
{{/if}}
{{/if}}
    restart: unless-stopped
{{#if (ne database "none")}}
{{#if (or (eq database "postgres") (eq database "mysql") (eq database "mongodb"))}}
    depends_on:
      - db
{{else if (eq database "redis")}}
    depends_on:
      - redis
{{/if}}
{{/if}}
    networks:
      - {{projectName}}-network

{{/if}}
{{/if}}
{{#if (ne database "none")}}
{{#if (eq database "postgres")}}
  db:
    image: postgres:16-alpine
    container_name: {{projectName}}-postgres
    environment:
      POSTGRES_DB: {{projectName}}
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: password
    ports:
      - "5432:5432"
    volumes:
      - {{projectName}}_postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 10s
      timeout: 5s
      retries: 5
    restart: unless-stopped
    networks:
      - {{projectName}}-network

{{else if (eq database "mysql")}}
  db:
    image: mysql:8
    container_name: {{projectName}}-mysql
    environment:
      MYSQL_ROOT_PASSWORD: password
      MYSQL_DATABASE: {{projectName}}
    ports:
      - "3306:3306"
    volumes:
      - {{projectName}}_mysql_data:/var/lib/mysql
    healthcheck:
      test: ["CMD", "mysqladmin", "ping", "-h", "localhost"]
      interval: 10s
      timeout: 5s
      retries: 5
    restart: unless-stopped
    networks:
      - {{projectName}}-network

{{else if (eq database "mongodb")}}
  db:
    image: mongo:7
    container_name: {{projectName}}-mongodb
    ports:
      - "27017:27017"
    volumes:
      - {{projectName}}_mongodb_data:/data/db
    healthcheck:
      test: ["CMD", "mongosh", "--eval", "db.adminCommand('ping')"]
      interval: 10s
      timeout: 5s
      retries: 5
    restart: unless-stopped
    networks:
      - {{projectName}}-network

{{else if (eq database "redis")}}
  redis:
    image: redis:7-alpine
    container_name: {{projectName}}-redis
    ports:
      - "6379:6379"
    volumes:
      - {{projectName}}_redis_data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5
    restart: unless-stopped
    networks:
      - {{projectName}}-network

{{/if}}
{{/if}}
networks:
  {{projectName}}-network:
    driver: bridge

{{#if (ne database "none")}}
volumes:
{{#if (eq database "postgres")}}
  {{projectName}}_postgres_data:
{{else if (eq database "mysql")}}
  {{projectName}}_mysql_data:
{{else if (eq database "mongodb")}}
  {{projectName}}_mongodb_data:
{{else if (eq database "redis")}}
  {{projectName}}_redis_data:
{{/if}}
{{/if}}
`],
  ["deploy/sst/server/handler.ts.hbs", `/**
 * AWS Lambda handler for {{projectName}} server
 * This file wraps your server for deployment with SST
 */
import { handle } from "hono/aws-lambda";
import app from "./index";

export const handler = handle(app);
`],
  ["deploy/docker/server/Dockerfile.hbs", `# Dockerfile for {{projectName}} server
# Optimized multi-stage build for Docker deployment

{{#if (eq packageManager "bun")}}
# Build stage
FROM oven/bun:1 AS builder

WORKDIR /app

# Copy package files
COPY package.json bun.lock* ./
{{#if (includes addons "turborepo")}}
COPY apps/server/package.json ./apps/server/
COPY packages/db/package.json ./packages/db/
{{/if}}

# Install dependencies
RUN bun install --frozen-lockfile

# Copy source code
COPY . .

# Build the application
{{#if (includes addons "turborepo")}}
RUN bun run build --filter=@{{projectName}}/server
{{else}}
RUN bun run build
{{/if}}

# Production stage
FROM oven/bun:1-slim AS runner

WORKDIR /app

ENV NODE_ENV=production
ENV PORT=3000

# Copy built application
{{#if (includes addons "turborepo")}}
COPY --from=builder /app/apps/server/dist ./dist
COPY --from=builder /app/apps/server/package.json ./
{{else}}
COPY --from=builder /app/dist ./dist
COPY --from=builder /app/package.json ./
{{/if}}

# Install production dependencies only
RUN bun install --production --frozen-lockfile

EXPOSE 3000

CMD ["bun", "run", "dist/index.js"]
{{else}}
# Build stage
FROM node:20-alpine AS builder

WORKDIR /app

# Install pnpm if needed
{{#if (eq packageManager "pnpm")}}
RUN corepack enable && corepack prepare pnpm@latest --activate
{{/if}}

# Copy package files
COPY package.json {{#if (eq packageManager "pnpm")}}pnpm-lock.yaml{{else}}package-lock.json{{/if}} ./
{{#if (includes addons "turborepo")}}
COPY apps/server/package.json ./apps/server/
COPY packages/db/package.json ./packages/db/
{{/if}}

# Install dependencies
{{#if (eq packageManager "pnpm")}}
RUN pnpm install --frozen-lockfile
{{else}}
RUN npm ci
{{/if}}

# Copy source code
COPY . .

# Build the application
{{#if (includes addons "turborepo")}}
{{#if (eq packageManager "pnpm")}}
RUN pnpm run build --filter=@{{projectName}}/server
{{else}}
RUN npm run build --workspace=apps/server
{{/if}}
{{else}}
{{#if (eq packageManager "pnpm")}}
RUN pnpm run build
{{else}}
RUN npm run build
{{/if}}
{{/if}}

# Production stage
FROM node:20-alpine AS runner

WORKDIR /app

ENV NODE_ENV=production
ENV PORT=3000

{{#if (eq packageManager "pnpm")}}
RUN corepack enable && corepack prepare pnpm@latest --activate
{{/if}}

# Copy built application
{{#if (includes addons "turborepo")}}
COPY --from=builder /app/apps/server/dist ./dist
COPY --from=builder /app/apps/server/package.json ./
{{else}}
COPY --from=builder /app/dist ./dist
COPY --from=builder /app/package.json ./
{{/if}}

# Install production dependencies only
{{#if (eq packageManager "pnpm")}}
RUN pnpm install --prod --frozen-lockfile
{{else}}
RUN npm ci --omit=dev
{{/if}}

EXPOSE 3000

CMD ["node", "dist/index.js"]
{{/if}}
`],
  ["deploy/docker/server/.dockerignore.hbs", `# Dependencies
node_modules
.pnpm-store

# Build outputs
dist

# Development
.env*.local
.env.development*
*.log

# Testing
coverage
.nyc_output

# IDE
.idea
.vscode
*.swp
*.swo

# OS
.DS_Store
Thumbs.db

# Git
.git
.gitignore

# Docker
Dockerfile*
.dockerignore
docker-compose*

# Misc
README.md
*.md
.turbo
`],
  ["deploy/railway/server/Dockerfile.hbs", `# Dockerfile for {{projectName}} server
# Optimized multi-stage build for Railway deployment

{{#if (eq packageManager "bun")}}
# Build stage
FROM oven/bun:1 AS builder

WORKDIR /app

# Copy package files
COPY package.json bun.lock* ./
{{#if (includes addons "turborepo")}}
COPY apps/server/package.json ./apps/server/
COPY packages/db/package.json ./packages/db/
{{/if}}

# Install dependencies
RUN bun install --frozen-lockfile

# Copy source code
COPY . .

# Build the application
{{#if (includes addons "turborepo")}}
RUN bun run build --filter=@{{projectName}}/server
{{else}}
RUN bun run build
{{/if}}

# Production stage
FROM oven/bun:1-slim AS runner

WORKDIR /app

ENV NODE_ENV=production
ENV PORT=3000

# Copy built application
{{#if (includes addons "turborepo")}}
COPY --from=builder /app/apps/server/dist ./dist
COPY --from=builder /app/apps/server/package.json ./
{{else}}
COPY --from=builder /app/dist ./dist
COPY --from=builder /app/package.json ./
{{/if}}

# Install production dependencies only
RUN bun install --production --frozen-lockfile

EXPOSE 3000

CMD ["bun", "run", "dist/index.js"]
{{else}}
# Build stage
FROM node:20-alpine AS builder

WORKDIR /app

# Install pnpm if needed
{{#if (eq packageManager "pnpm")}}
RUN corepack enable && corepack prepare pnpm@latest --activate
{{/if}}

# Copy package files
COPY package.json {{#if (eq packageManager "pnpm")}}pnpm-lock.yaml{{else}}package-lock.json{{/if}} ./
{{#if (includes addons "turborepo")}}
COPY apps/server/package.json ./apps/server/
COPY packages/db/package.json ./packages/db/
{{/if}}

# Install dependencies
{{#if (eq packageManager "pnpm")}}
RUN pnpm install --frozen-lockfile
{{else}}
RUN npm ci
{{/if}}

# Copy source code
COPY . .

# Build the application
{{#if (includes addons "turborepo")}}
{{#if (eq packageManager "pnpm")}}
RUN pnpm run build --filter=@{{projectName}}/server
{{else}}
RUN npm run build --workspace=apps/server
{{/if}}
{{else}}
{{#if (eq packageManager "pnpm")}}
RUN pnpm run build
{{else}}
RUN npm run build
{{/if}}
{{/if}}

# Production stage
FROM node:20-alpine AS runner

WORKDIR /app

ENV NODE_ENV=production
ENV PORT=3000

{{#if (eq packageManager "pnpm")}}
RUN corepack enable && corepack prepare pnpm@latest --activate
{{/if}}

# Copy built application
{{#if (includes addons "turborepo")}}
COPY --from=builder /app/apps/server/dist ./dist
COPY --from=builder /app/apps/server/package.json ./
{{else}}
COPY --from=builder /app/dist ./dist
COPY --from=builder /app/package.json ./
{{/if}}

# Install production dependencies only
{{#if (eq packageManager "pnpm")}}
RUN pnpm install --prod --frozen-lockfile
{{else}}
RUN npm ci --omit=dev
{{/if}}

EXPOSE 3000

CMD ["node", "dist/index.js"]
{{/if}}
`],
  ["deploy/railway/server/.dockerignore.hbs", `# Dependencies
node_modules
.pnpm-store

# Build outputs
dist
build

# Development
.env*.local
.env.development*
*.log

# Testing
coverage
.nyc_output

# IDE
.idea
.vscode
*.swp
*.swo

# OS
.DS_Store
Thumbs.db

# Git
.git
.gitignore

# Docker
Dockerfile*
.dockerignore
docker-compose*

# Misc
README.md
*.md
.turbo
`],
  ["deploy/railway/server/railway.toml.hbs", `# Railway configuration for {{projectName}} server
# See https://docs.railway.app/reference/config-as-code for all options

[build]
builder = "dockerfile"
dockerfilePath = "Dockerfile"

[deploy]
startCommand = "{{#if (eq packageManager "bun")}}bun run dist/index.js{{else}}node dist/index.js{{/if}}"
healthcheckPath = "/health"
healthcheckTimeout = 300
restartPolicyType = "on_failure"
restartPolicyMaxRetries = 3
`],
  ["db/drizzle/mysql/drizzle.config.ts.hbs", `import { defineConfig } from "drizzle-kit";
import dotenv from "dotenv";

dotenv.config({
    {{#if (eq backend "self")}}
    path: "../../apps/web/.env",
    {{else}}
    path: "../../apps/server/.env",
    {{/if}}
});

export default defineConfig({
  schema: "./src/schema",
  out: "./src/migrations",
  dialect: "mysql",
  dbCredentials: {
    url: process.env.DATABASE_URL || "",
  },
});
`],
  ["examples/ai/native/uniwind/polyfills.js", `import structuredClone from "@ungap/structured-clone";
import { Platform } from "react-native";

if (Platform.OS !== "web") {
  const setupPolyfills = async () => {
    const { polyfillGlobal } = await import("react-native/Libraries/Utilities/PolyfillFunctions");

    const { TextEncoderStream, TextDecoderStream } =
      await import("@stardazed/streams-text-encoding");

    if (!("structuredClone" in global)) {
      polyfillGlobal("structuredClone", () => structuredClone);
    }

    polyfillGlobal("TextEncoderStream", () => TextEncoderStream);
    polyfillGlobal("TextDecoderStream", () => TextDecoderStream);
  };

  setupPolyfills();
}

export {};
`],
  ["examples/ai/native/bare/polyfills.js", `import structuredClone from "@ungap/structured-clone";
import { Platform } from "react-native";

if (Platform.OS !== "web") {
  const setupPolyfills = async () => {
    const { polyfillGlobal } = await import("react-native/Libraries/Utilities/PolyfillFunctions");

    const { TextEncoderStream, TextDecoderStream } =
      await import("@stardazed/streams-text-encoding");

    if (!("structuredClone" in global)) {
      polyfillGlobal("structuredClone", () => structuredClone);
    }

    polyfillGlobal("TextEncoderStream", () => TextEncoderStream);
    polyfillGlobal("TextDecoderStream", () => TextDecoderStream);
  };

  setupPolyfills();
}

export {};
`],
  ["examples/ai/native/unistyles/polyfills.js", `import structuredClone from "@ungap/structured-clone";
import { Platform } from "react-native";

if (Platform.OS !== "web") {
  const setupPolyfills = async () => {
    const { polyfillGlobal } = await import("react-native/Libraries/Utilities/PolyfillFunctions");

    const { TextEncoderStream, TextDecoderStream } =
      await import("@stardazed/streams-text-encoding");

    if (!("structuredClone" in global)) {
      polyfillGlobal("structuredClone", () => structuredClone);
    }

    polyfillGlobal("TextEncoderStream", () => TextEncoderStream);
    polyfillGlobal("TextDecoderStream", () => TextDecoderStream);
  };

  setupPolyfills();
}

export {};
`],
  ["auth/better-auth/server/base/package.json.hbs", `{
  "name": "@{{projectName}}/auth",
  "exports": {
    ".": {
      "default": "./src/index.ts"
    },
    "./*": {
      "default": "./src/*.ts"
    }
  },
  "type": "module",
  "scripts": {},
  "devDependencies": {}
}`],
  ["auth/better-auth/server/base/tsconfig.json.hbs", `{
  "extends": "@{{projectName}}/config/tsconfig.base.json",
  "compilerOptions": {
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "outDir": "dist",
    "composite": true
  }
}`],
  ["auth/better-auth/server/base/_gitignore", `# dependencies (bun install)
node_modules

# output
out
dist
*.tgz

# code coverage
coverage
*.lcov

# logs
logs
_.log
report.[0-9]_.[0-9]_.[0-9]_.[0-9]_.json

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# caches
.eslintcache
.cache
*.tsbuildinfo

# IntelliJ based IDEs
.idea

# Finder (MacOS) folder config
.DS_Store
`],
  ["job-queue/trigger-dev/server/base/trigger.config.ts.hbs", `import { defineConfig } from "@trigger.dev/sdk/v3";

/**
 * Trigger.dev configuration
 * @see https://trigger.dev/docs/config/config-file
 */
export default defineConfig({
  // Your project ref from the Trigger.dev dashboard
  // Get this from: https://cloud.trigger.dev/
  project: process.env.TRIGGER_PROJECT_ID || "<your-project-ref>",

  // Directories containing your task definitions
  dirs: ["./src/trigger"],

  // Retry configuration for all tasks (can be overridden per task)
  retries: {
    // Enable retries during development
    enabledInDev: true,
    // Default retry settings
    default: {
      maxAttempts: 3,
      minTimeoutInMs: 1000,
      maxTimeoutInMs: 10000,
      factor: 2,
      randomize: true,
    },
  },

  // Maximum duration for tasks in seconds (can be overridden per task)
  maxDuration: 300, // 5 minutes

  // Runtime configuration
  runtime: "node",

  // Log level for debugging
  logLevel: "info",

  // Build configuration
  build: {
    // Automatically detect external packages
    autoDetectExternal: true,
    // Keep function names for better debugging
    keepNames: true,
  },

  // Global lifecycle hooks (optional)
  // onStart: async ({ payload, ctx }) => {
  //   console.log("Task started:", ctx.task.id);
  // },
  // onSuccess: async ({ payload, output, ctx }) => {
  //   console.log("Task completed:", ctx.task.id);
  // },
  // onFailure: async ({ payload, error, ctx }) => {
  //   console.error("Task failed:", ctx.task.id, error);
  // },
});
`],
  ["frontend/qwik/src/routes/index.tsx.hbs", `import { component$ } from "@builder.io/qwik";
import type { DocumentHead } from "@builder.io/qwik-city";

const TITLE_TEXT = \`
  
 
                 
                 
               
                

          
      
                      
                      
                     
                      
\`;

export default component$(() => {
  return (
    {{#if (eq cssFramework "tailwind")}}
    <div class="container mx-auto max-w-3xl px-4 py-2">
      <pre class="overflow-x-auto font-mono text-sm whitespace-pre">{TITLE_TEXT}</pre>
      <div class="grid gap-6 mt-6">
        <section class="rounded-lg border border-gray-200 dark:border-gray-800 p-4">
          <h2 class="mb-2 font-medium">Welcome to Qwik</h2>
          <p class="text-sm text-gray-600 dark:text-gray-400">
            Qwik is a resumable framework that delivers instant apps at scale.
            It achieves this by serializing the application state and resuming
            execution on the client without re-running the entire application.
          </p>
        </section>
        <section class="rounded-lg border border-gray-200 dark:border-gray-800 p-4">
          <h2 class="mb-2 font-medium">Key Features</h2>
          <ul class="list-disc list-inside text-sm text-gray-600 dark:text-gray-400 space-y-1">
            <li>Resumability - No hydration overhead</li>
            <li>Lazy loading by default</li>
            <li>Familiar JSX syntax</li>
            <li>Built-in optimizations</li>
          </ul>
        </section>
      </div>
    </div>
    {{else}}
    <div style=\\{{ maxWidth: "48rem", margin: "0 auto", padding: "0.5rem 1rem" }}>
      <pre style=\\{{ overflow: "auto", fontFamily: "monospace", fontSize: "0.875rem", whiteSpace: "pre" }}>{TITLE_TEXT}</pre>
      <div style=\\{{ display: "grid", gap: "1.5rem", marginTop: "1.5rem" }}>
        <section style=\\{{ borderRadius: "0.5rem", border: "1px solid var(--border-color)", padding: "1rem" }}>
          <h2 style=\\{{ marginBottom: "0.5rem", fontWeight: 500 }}>Welcome to Qwik</h2>
          <p style=\\{{ fontSize: "0.875rem", color: "var(--muted-color)" }}>
            Qwik is a resumable framework that delivers instant apps at scale.
            It achieves this by serializing the application state and resuming
            execution on the client without re-running the entire application.
          </p>
        </section>
        <section style=\\{{ borderRadius: "0.5rem", border: "1px solid var(--border-color)", padding: "1rem" }}>
          <h2 style=\\{{ marginBottom: "0.5rem", fontWeight: 500 }}>Key Features</h2>
          <ul style=\\{{ fontSize: "0.875rem", color: "var(--muted-color)", listStyleType: "disc", paddingLeft: "1.5rem" }}>
            <li>Resumability - No hydration overhead</li>
            <li>Lazy loading by default</li>
            <li>Familiar JSX syntax</li>
            <li>Built-in optimizations</li>
          </ul>
        </section>
      </div>
    </div>
    {{/if}}
  );
});

export const head: DocumentHead = {
  title: "Better T Stack - Qwik",
  meta: [
    {
      name: "description",
      content: "Better T Stack with Qwik - Resumable framework with instant load times",
    },
  ],
};
`],
  ["frontend/qwik/src/routes/layout.tsx.hbs", `import { component$, Slot } from "@builder.io/qwik";
import type { RequestHandler } from "@builder.io/qwik-city";
import Header from "@/components/header";

export const onGet: RequestHandler = async ({ cacheControl }) => {
  cacheControl({
    staleWhileRevalidate: 60 * 60 * 24 * 7,
    maxAge: 5,
  });
};

export default component$(() => {
  return (
    {{#if (eq cssFramework "tailwind")}}
    <div class="grid grid-rows-[auto_1fr] min-h-screen">
      <Header />
      <main>
        <Slot />
      </main>
    </div>
    {{else}}
    <div style=\\{{ display: "grid", gridTemplateRows: "auto 1fr", minHeight: "100vh" }}>
      <Header />
      <main>
        <Slot />
      </main>
    </div>
    {{/if}}
  );
});
`],
  ["frontend/redwood/web/public/robots.txt", `User-agent: *
Disallow:
`],
  ["frontend/redwood/web/public/favicon.svg", `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100">
  <rect width="100" height="100" rx="10" fill="#bf4722"/>
  <path d="M25 75V25h15l10 25 10-25h15v50h-12V45l-8 20h-10l-8-20v30H25z" fill="white"/>
</svg>
`],
  ["frontend/solid/src/components/loader.tsx", `import { Loader2 } from "lucide-solid";

export default function Loader() {
  return (
    <div class="flex h-full items-center justify-center pt-8">
      <Loader2 class="animate-spin" />
    </div>
  );
}
`],
  ["frontend/solid/src/components/header.tsx.hbs", `import { Link } from "@tanstack/solid-router";
{{#if (eq auth "better-auth")}}
import UserMenu from "./user-menu";
{{/if}}
import { For } from "solid-js";

export default function Header() {
  const links = [
    { to: "/", label: "Home" },
    {{#if (eq auth "better-auth")}}
    { to: "/dashboard", label: "Dashboard" },
    {{/if}}
    {{#if (includes examples "todo")}}
    { to: "/todos", label: "Todos" },
    {{/if}}
    {{#if (includes examples "ai")}}
    { to: "/ai", label: "AI Chat" },
    {{/if}}
  ];

  return (
    <div>
      <div class="flex flex-row items-center justify-between px-2 py-1">
        <nav class="flex gap-4 text-lg">
          <For each={links}>
            {(link) => <Link to={link.to}>{link.label}</Link>}
          </For>
        </nav>
        <div class="flex items-center gap-2">
          {{#if (eq auth "better-auth")}}
          <UserMenu />
          {{/if}}
        </div>
      </div>
      <hr />
    </div>
  );
}
`],
  ["frontend/qwik/src/components/header.tsx.hbs", `import { component$ } from "@builder.io/qwik";
import { Link } from "@builder.io/qwik-city";

export default component$(() => {
  const links = [
    { href: "/", label: "Home" },
    {{#if (eq auth "better-auth")}}
    { href: "/dashboard", label: "Dashboard" },
    {{/if}}
    {{#if (includes examples "todo")}}
    { href: "/todos", label: "Todos" },
    {{/if}}
    {{#if (includes examples "ai")}}
    { href: "/ai", label: "AI Chat" },
    {{/if}}
  ];

  return (
    <header>
      {{#if (eq cssFramework "tailwind")}}
      <div class="flex flex-row items-center justify-between px-4 py-2">
        <nav class="flex gap-4 text-lg">
          {links.map((link) => (
            <Link key={link.href} href={link.href} class="hover:underline">
              {link.label}
            </Link>
          ))}
        </nav>
        <div class="flex items-center gap-2">
          {{#if (eq auth "better-auth")}}
          {/* User menu component would go here */}
          {{/if}}
        </div>
      </div>
      <hr class="border-gray-200 dark:border-gray-800" />
      {{else}}
      <div style=\\{{ display: "flex", justifyContent: "space-between", alignItems: "center", padding: "0.5rem 1rem" }}>
        <nav style=\\{{ display: "flex", gap: "1rem", fontSize: "1.125rem" }}>
          {links.map((link) => (
            <Link key={link.href} href={link.href}>
              {link.label}
            </Link>
          ))}
        </nav>
        <div style=\\{{ display: "flex", alignItems: "center", gap: "0.5rem" }}>
          {{#if (eq auth "better-auth")}}
          {/* User menu component would go here */}
          {{/if}}
        </div>
      </div>
      <hr style=\\{{ borderColor: "var(--border-color)" }} />
      {{/if}}
    </header>
  );
});
`],
  ["frontend/solid/src/routes/__root.tsx.hbs", `import Header from "@/components/header";
import { Outlet, createRootRouteWithContext } from "@tanstack/solid-router";
import { TanStackRouterDevtools } from "@tanstack/solid-router-devtools";
{{#if (eq api "orpc")}}
import { SolidQueryDevtools } from "@tanstack/solid-query-devtools";
import type { QueryClient } from "@tanstack/solid-query";
import type { orpc } from "../utils/orpc";

export interface RouterContext {
  orpc: typeof orpc;
  queryClient: QueryClient;
}
{{else}}
export interface RouterContext {}
{{/if}}

export const Route = createRootRouteWithContext<RouterContext>()({
  component: RootComponent,
});

function RootComponent() {
  return (
    <>
      <div class="grid grid-rows-[auto_1fr] h-svh">
        <Header />
        <Outlet />
      </div>
      {{#if (eq api "orpc")}}
      <SolidQueryDevtools />
      {{/if}}
      <TanStackRouterDevtools />
    </>
  );
}
`],
  ["frontend/solid/src/routes/index.tsx.hbs", `import { createFileRoute } from "@tanstack/solid-router";
{{#if (eq api "orpc")}}
import { useQuery } from "@tanstack/solid-query";
import { orpc } from "../utils/orpc";
import { Match, Switch } from "solid-js";
{{else}}
{{/if}}

export const Route = createFileRoute("/")({
  component: App,
});

const TITLE_TEXT = \`
  
 
                 
                 
               
                

          
      
                      
                      
                     
                      
 \`;

function App() {
  {{#if (eq api "orpc")}}
  const healthCheck = useQuery(() => orpc.healthCheck.queryOptions());
  {{/if}}

  return (
    <div class="container mx-auto max-w-3xl px-4 py-2">
      <pre class="overflow-x-auto font-mono text-sm">{TITLE_TEXT}</pre>
      <div class="grid gap-6">
        {{#if (eq api "orpc")}}
        <section class="rounded-lg border p-4">
          <h2 class="mb-2 font-medium">API Status</h2>
          <Switch>
            <Match when={healthCheck.isPending}>
              <div class="flex items-center gap-2">
                <div class="h-2 w-2 rounded-full bg-gray-500 animate-pulse" />{" "}
                <span class="text-sm text-muted-foreground">Checking...</span>
              </div>
            </Match>
            <Match when={healthCheck.isError}>
              <div class="flex items-center gap-2">
                <div class="h-2 w-2 rounded-full bg-red-500" />
                <span class="text-sm text-muted-foreground">Disconnected</span>
              </div>
            </Match>
            <Match when={healthCheck.isSuccess}>
              <div class="flex items-center gap-2">
                <div
                  class={\`h-2 w-2 rounded-full \${healthCheck.data ? "bg-green-500" : "bg-red-500"}\`}
                />
                <span class="text-sm text-muted-foreground">
                  {healthCheck.data
                    ? "Connected"
                    : "Disconnected"}
                </span>
              </div>
            </Match>
          </Switch>
        </section>
        {{/if}}
      </div>
    </div>
  );
}
`],
  ["frontend/redwood/web/src/index.css.hbs", `{{#if (eq cssFramework "tailwind")}}
@tailwind base;
@tailwind components;
@tailwind utilities;
{{else}}
* {
  box-sizing: border-box;
}

body {
  margin: 0;
  padding: 0;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", "Oxygen", "Ubuntu", "Cantarell", "Fira Sans", "Droid Sans", "Helvetica Neue", sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  background-color: #0f172a;
  color: #f8fafc;
  min-height: 100vh;
}

a {
  color: #38bdf8;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}
{{/if}}
`],
  ["frontend/redwood/web/src/App.tsx", `import { FatalErrorBoundary, RedwoodProvider } from "@redwoodjs/web";
import { RedwoodApolloProvider } from "@redwoodjs/web/apollo";
import FatalErrorPage from "src/pages/FatalErrorPage/FatalErrorPage";
import Routes from "src/Routes";

import "./index.css";

const App = () => (
  <FatalErrorBoundary page={FatalErrorPage}>
    <RedwoodProvider titleTemplate="%PageTitle | %AppTitle">
      <RedwoodApolloProvider>
        <Routes />
      </RedwoodApolloProvider>
    </RedwoodProvider>
  </FatalErrorBoundary>
);

export default App;
`],
  ["frontend/redwood/web/src/index.html", `<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
  </head>
  <body>
    <div id="redwood-app">
      <!-- content -->
    </div>
  </body>
</html>
`],
  ["frontend/redwood/web/src/entry.client.tsx", `import { hydrateRoot, createRoot } from "react-dom/client";

import App from "./App";

/**
 * When \`#redwood-app\` isn't empty then it's very likely that you're using
 * prerendering. So React attaches event listeners to the existing markup
 * rather than replacing it.
 * https://reactjs.org/docs/react-dom-client.html#hydrateroot
 */
const redwoodAppElement = document.getElementById("redwood-app");

if (redwoodAppElement!.children?.length > 0) {
  hydrateRoot(redwoodAppElement!, <App />);
} else {
  const root = createRoot(redwoodAppElement!);
  root.render(<App />);
}
`],
  ["frontend/redwood/web/src/Routes.tsx", `// In this file, all Page components from 'src/pages\` are auto-imported. Nested
// directories are supported, and should be uppercase. Each subdirectory will be
// prepended onto the component name.
//
// Examples:
//
// 'src/pages/HomePage/HomePage.js'         -> HomePage
// 'src/pages/Admin/BooksPage/BooksPage.js' -> AdminBooksPage

import { Router, Route } from "@redwoodjs/router";

const Routes = () => {
  return (
    <Router>
      <Route path="/" page={HomePage} name="home" />
      <Route notfound page={NotFoundPage} />
    </Router>
  );
};

export default Routes;
`],
  ["frontend/redwood/api/db/schema.prisma", `// Don't forget to tell Prisma about your database:
// https://www.prisma.io/docs/reference/database-reference/connection-urls

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

generator client {
  provider      = "prisma-client-js"
  binaryTargets = "native"
}

// Define your own datamodels here and run \`yarn rw prisma migrate dev\`
// to create migrations for them and apply to your dev DB.

model Post {
  id        Int      @id @default(autoincrement())
  title     String
  body      String
  createdAt DateTime @default(now())
}
`],
  ["frontend/svelte/src/routes/+page.svelte.hbs", `{{#if (eq backend "convex")}}
<script lang="ts">
import { useQuery } from 'convex-svelte';
import { api } from "@{{projectName}}/backend/convex/_generated/api";

const healthCheck = useQuery(api.healthCheck.get, {});

const TITLE_TEXT = \`
    
   
                   
                   
                 
                  

            
        
                        
                        
                       
                        
   \`;
</script>

<div class="container mx-auto max-w-3xl px-4 py-2">
	<pre class="overflow-x-auto font-mono text-sm">{TITLE_TEXT}</pre>
	<div class="grid gap-6">
		<section class="rounded-lg border p-4">
			<h2 class="mb-2 font-medium">API Status</h2>
			<div class="flex items-center gap-2">
				<div
					class={\`h-2 w-2 rounded-full \${healthCheck.data ? "bg-green-500" : "bg-red-500"}\`}
				></div>
				<span class="text-muted-foreground text-sm">
					{healthCheck.isLoading
						? "Checking..."
						: healthCheck.data
							? "Connected"
							: "Disconnected"}
				</span>
			</div>
		</section>
	</div>
</div>
{{else}}
<script lang="ts">
{{#if (eq api "orpc")}}
import { orpc } from "$lib/orpc";
import { createQuery } from "@tanstack/svelte-query";
const healthCheck = createQuery(orpc.healthCheck.queryOptions());
{{/if}}

const TITLE_TEXT = \`
    
   
                   
                   
                 
                  

            
        
                        
                        
                       
                        
   \`;
</script>

<div class="container mx-auto max-w-3xl px-4 py-2">
	<pre class="overflow-x-auto font-mono text-sm">{TITLE_TEXT}</pre>
	<div class="grid gap-6">
	    {{#if (eq api "orpc")}}
		<section class="rounded-lg border p-4">
			<h2 class="mb-2 font-medium">API Status</h2>
			<div class="flex items-center gap-2">
				<div
					class={\`h-2 w-2 rounded-full \${$healthCheck.data ? "bg-green-500" : "bg-red-500"}\`}
				></div>
				<span class="text-muted-foreground text-sm">
					{$healthCheck.isLoading
						? "Checking..."
						: $healthCheck.data
							? "Connected"
							: "Disconnected"}
				</span>
			</div>
		</section>
	    {{/if}}
	</div>
</div>
{{/if}}
`],
  ["frontend/svelte/src/routes/+layout.svelte.hbs", `{{#if (eq backend "convex")}}
<script lang="ts">
	import '../app.css';
    import Header from '../components/Header.svelte';
    import { PUBLIC_CONVEX_URL } from '$env/static/public';
	import { setupConvex } from 'convex-svelte';

	const { children } = $props();
	setupConvex(PUBLIC_CONVEX_URL);
</script>

<div class="grid h-svh grid-rows-[auto_1fr]">
	<Header />
	<main class="overflow-y-auto">
		{@render children()}
	</main>
</div>
{{else}}
  {{#if (eq api "orpc")}}
<script lang="ts">
    import { QueryClientProvider } from '@tanstack/svelte-query';
    import { SvelteQueryDevtools } from '@tanstack/svelte-query-devtools'
	import '../app.css';
    import { queryClient } from '$lib/orpc';
    import Header from '../components/Header.svelte';

	const { children } = $props();
</script>

<QueryClientProvider client={queryClient}>
    <div class="grid h-svh grid-rows-[auto_1fr]">
		<Header />
		<main class="overflow-y-auto">
			{@render children()}
		</main>
    </div>
    <SvelteQueryDevtools />
</QueryClientProvider>
  {{else}}
<script lang="ts">
	import '../app.css';
    import Header from '../components/Header.svelte';

	const { children } = $props();
</script>

<div class="grid h-svh grid-rows-[auto_1fr]">
	<Header />
	<main class="overflow-y-auto">
		{@render children()}
	</main>
</div>
  {{/if}}
{{/if}}
`],
  ["frontend/svelte/src/components/Header.svelte.hbs", `<script lang="ts">

    {{#if (eq auth "better-auth")}}
	import UserMenu from './UserMenu.svelte';
    {{/if}}
    const links = [
        { to: "/", label: "Home" },
        {{#if (eq auth "better-auth")}}
        { to: "/dashboard", label: "Dashboard" },
        {{/if}}
        {{#if (includes examples "todo")}}
        { to: "/todos", label: "Todos" },
        {{/if}}
        {{#if (includes examples "ai")}}
        { to: "/ai", label: "AI Chat" },
        {{/if}}
    ];

</script>

<div>
	<div class="flex flex-row items-center justify-between px-4 py-2 md:px-6">
		<nav class="flex gap-4 text-lg">
			{#each links as link (link.to)}
				<a
					href={link.to}
					class="hover:text-neutral-400 transition-colors"
				>
					{link.label}
				</a>
			{/each}
		</nav>
		<div class="flex items-center gap-2">
		    {{#if (eq auth "better-auth")}}
            <UserMenu />
             {{/if}}
		</div>
	</div>
	<hr class="border-neutral-800" />
</div>
`],
  ["frontend/angular/src/app/app.routes.ts", `import { Routes } from "@angular/router";

import { HomeComponent } from "./pages/home/home.component";

export const routes: Routes = [{ path: "", component: HomeComponent }];
`],
  ["frontend/angular/src/app/app.config.ts", `import { ApplicationConfig, provideZoneChangeDetection } from "@angular/core";
import { provideRouter } from "@angular/router";

import { routes } from "./app.routes";

export const appConfig: ApplicationConfig = {
  providers: [provideZoneChangeDetection({ eventCoalescing: true }), provideRouter(routes)],
};
`],
  ["frontend/angular/src/app/app.component.ts.hbs", `import { Component } from '@angular/core';
import { RouterOutlet } from '@angular/router';
import { HeaderComponent } from './components/header.component';

@Component({
  selector: 'app-root',
  standalone: true,
  imports: [RouterOutlet, HeaderComponent],
  template: \`
    {{#if (eq cssFramework "tailwind")}}
    <div class="grid grid-rows-[auto_1fr] min-h-screen">
      <app-header />
      <main>
        <router-outlet />
      </main>
    </div>
    {{else}}
    <div [style.display]="'grid'" [style.gridTemplateRows]="'auto 1fr'" [style.minHeight]="'100vh'">
      <app-header />
      <main>
        <router-outlet />
      </main>
    </div>
    {{/if}}
  \`,
})
export class AppComponent {
  title = 'Better T Stack';
}
`],
  ["frontend/svelte/src/lib/index.ts", `// place files you want to import through the \`$lib\` alias in this folder.
export {};
`],
  ["frontend/fresh/src/routes/_layout.tsx.hbs", `import type { PageProps } from "$fresh/server.ts";
import Header from "../components/Header.tsx";

export default function Layout({ Component, state }: PageProps) {
  return (
    <html lang="en">
      <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>{state.title ?? "{{projectName}}"}</title>
        <link rel="stylesheet" href="/styles.css" />
      </head>
      <body{{#if (eq cssFramework "tailwind")}} class="bg-gradient-to-br from-slate-900 via-purple-900 to-slate-900 min-h-screen"{{/if}}>
        <Header />
        <Component />
      </body>
    </html>
  );
}
`],
  ["frontend/fresh/src/routes/index.tsx.hbs", `import { define } from "../../utils.ts";
import Counter from "../islands/Counter.tsx";

export const handler = define.handlers({
  GET(ctx) {
    ctx.state.title = "Home | {{projectName}}";
    return ctx.render();
  },
});

export default define.page(function Home() {
  return (
    <main{{#if (eq cssFramework "tailwind")}} class="container mx-auto px-4 py-16"{{/if}}>
      <div{{#if (eq cssFramework "tailwind")}} class="flex flex-col items-center justify-center text-center"{{/if}}>
        <h1{{#if (eq cssFramework "tailwind")}} class="text-5xl font-bold text-white mb-6"{{/if}}>
          Welcome to <span{{#if (eq cssFramework "tailwind")}} class="text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-purple-500"{{/if}}>Fresh</span>
        </h1>
        <p{{#if (eq cssFramework "tailwind")}} class="text-xl text-gray-300 mb-8 max-w-2xl"{{/if}}>
          A Deno-native full-stack web framework with islands architecture for optimal performance.
        </p>

        <div{{#if (eq cssFramework "tailwind")}} class="bg-white/10 backdrop-blur-lg rounded-2xl p-8 border border-white/20"{{/if}}>
          <h2{{#if (eq cssFramework "tailwind")}} class="text-2xl font-semibold text-white mb-4"{{/if}}>Interactive Island</h2>
          <Counter start={0} />
        </div>

        <div{{#if (eq cssFramework "tailwind")}} class="mt-12 grid grid-cols-1 md:grid-cols-3 gap-6"{{/if}}>
          <FeatureCard
            title="Islands Architecture"
            description="Ship zero JavaScript by default, hydrate only interactive components."
          />
          <FeatureCard
            title="Deno Native"
            description="Built for Deno with first-class TypeScript support and modern APIs."
          />
          <FeatureCard
            title="Fast by Default"
            description="No build step for development, instant page loads with streaming."
          />
        </div>
      </div>
    </main>
  );
});

function FeatureCard({ title, description }: { title: string; description: string }) {
  return (
    <div{{#if (eq cssFramework "tailwind")}} class="bg-white/5 backdrop-blur rounded-xl p-6 border border-white/10 hover:border-cyan-500/50 transition-colors"{{/if}}>
      <h3{{#if (eq cssFramework "tailwind")}} class="text-lg font-semibold text-white mb-2"{{/if}}>{title}</h3>
      <p{{#if (eq cssFramework "tailwind")}} class="text-gray-400"{{/if}}>{description}</p>
    </div>
  );
}
`],
  ["frontend/fresh/src/components/Header.tsx.hbs", `export default function Header() {
  return (
    <header{{#if (eq cssFramework "tailwind")}} class="bg-black/20 backdrop-blur-md border-b border-white/10"{{/if}}>
      <nav{{#if (eq cssFramework "tailwind")}} class="container mx-auto px-4 py-4 flex items-center justify-between"{{/if}}>
        <a href="/"{{#if (eq cssFramework "tailwind")}} class="text-xl font-bold text-white hover:text-cyan-400 transition-colors"{{/if}}>
          {{projectName}}
        </a>
        <div{{#if (eq cssFramework "tailwind")}} class="flex items-center gap-6"{{/if}}>
          <a
            href="https://fresh.deno.dev/docs"
            target="_blank"
            rel="noopener noreferrer"
            {{#if (eq cssFramework "tailwind")}}class="text-gray-300 hover:text-white transition-colors"{{/if}}
          >
            Docs
          </a>
          <a
            href="https://github.com/denoland/fresh"
            target="_blank"
            rel="noopener noreferrer"
            {{#if (eq cssFramework "tailwind")}}class="text-gray-300 hover:text-white transition-colors"{{/if}}
          >
            GitHub
          </a>
        </div>
      </nav>
    </header>
  );
}
`],
  ["frontend/nuxt/app/pages/index.vue.hbs", `<script setup lang="ts">
{{#if (eq backend "convex")}}
import { api } from "@{{ projectName }}/backend/convex/_generated/api";
import { useConvexQuery } from "convex-vue";
{{else}}
  {{#unless (eq api "none")}}
const { $orpc } = useNuxtApp()
import { useQuery } from '@tanstack/vue-query'
  {{/unless}}
{{/if}}

const TITLE_TEXT = \`
  
 
                 
                 
               
                

          
      
                      
                      
                     
                      
 \`;

{{#if (eq backend "convex")}}
const healthCheck = useConvexQuery(api.healthCheck.get, {});
{{else}}
  {{#unless (eq api "none")}}
const healthCheck = useQuery($orpc.healthCheck.queryOptions())
  {{/unless}}
{{/if}}
</script>

<template>
  <UContainer class="py-8">
    <pre class="overflow-x-auto font-mono text-sm whitespace-pre-wrap">\\{{ TITLE_TEXT }}</pre>

    <div class="grid gap-6 mt-6">
      <UCard>
        <template #header>
          <div class="font-medium">API Status</div>
        </template>

        {{#if (eq backend "convex")}}
        <div class="flex items-center gap-2">
          <UIcon
            :name="healthCheck === undefined ? 'i-lucide-loader-2' : healthCheck.data.value === 'OK' ? 'i-lucide-check-circle' : 'i-lucide-x-circle'"
            :class="[
              healthCheck === undefined ? 'animate-spin text-muted' : '',
              healthCheck?.data.value === 'OK' ? 'text-success' : 'text-error'
            ]"
          />
          <span class="text-sm">
            \\{{
              healthCheck === undefined
                ? "Checking..."
                : healthCheck.data.value === "OK"
                  ? "Connected"
                  : "Error"
            }}
          </span>
        </div>
        {{else}}
        {{#unless (eq api "none")}}
        <div class="flex items-center gap-2">
          <UIcon
            :name="healthCheck.isLoading.value ? 'i-lucide-loader-2' : healthCheck.isSuccess.value ? 'i-lucide-check-circle' : 'i-lucide-x-circle'"
            :class="[
              healthCheck.isLoading.value ? 'animate-spin text-muted' : '',
              healthCheck.isSuccess.value ? 'text-success' : '',
              healthCheck.isError.value ? 'text-error' : ''
            ]"
          />
          <span class="text-sm">
            <template v-if="healthCheck.isLoading.value">
              Checking...
            </template>
            <template v-else-if="healthCheck.isSuccess.value">
              Connected (\\{{ healthCheck.data.value }})
            </template>
            <template v-else-if="healthCheck.isError.value">
              Error: \\{{ healthCheck.error.value?.message || 'Failed to connect' }}
            </template>
            <template v-else>
              Idle
            </template>
          </span>
        </div>
        {{/unless}}
        {{/if}}
      </UCard>
    </div>
  </UContainer>
</template>
`],
  ["frontend/fresh/src/islands/Counter.tsx.hbs", `import { useSignal } from "@preact/signals";

interface CounterProps {
  start: number;
}

export default function Counter({ start }: CounterProps) {
  const count = useSignal(start);

  return (
    <div{{#if (eq cssFramework "tailwind")}} class="flex items-center gap-4"{{/if}}>
      <button
        onClick={() => count.value--}
        {{#if (eq cssFramework "tailwind")}}class="px-4 py-2 bg-cyan-500 hover:bg-cyan-600 text-white rounded-lg font-semibold transition-colors"{{/if}}
      >
        -
      </button>
      <span{{#if (eq cssFramework "tailwind")}} class="text-3xl font-bold text-white min-w-[60px] text-center"{{/if}}>
        {count}
      </span>
      <button
        onClick={() => count.value++}
        {{#if (eq cssFramework "tailwind")}}class="px-4 py-2 bg-cyan-500 hover:bg-cyan-600 text-white rounded-lg font-semibold transition-colors"{{/if}}
      >
        +
      </button>
    </div>
  );
}
`],
  ["frontend/nuxt/app/components/Header.vue.hbs", `<script setup lang="ts">
import type { NavigationMenuItem } from '@nuxt/ui'
{{#if (eq auth "better-auth")}}
import UserMenu from './UserMenu.vue'
{{/if}}

const route = useRoute()

const items = computed<NavigationMenuItem[]>(() => [
    { label: "Home", to: "/", active: route.path === "/" },
    {{#if (or (eq auth "better-auth") (eq auth "clerk"))}}
    { label: "Dashboard", to: "/dashboard", active: route.path.startsWith("/dashboard") },
    {{/if}}
    {{#if (includes examples "todo")}}
    { label: "Todos", to: "/todos", active: route.path.startsWith("/todos") },
    {{/if}}
    {{#if (includes examples "ai")}}
    { label: "AI Chat", to: "/ai", active: route.path.startsWith("/ai") },
    {{/if}}
])
</script>

<template>
  <UHeader>
    <template #left>
      <UNavigationMenu :items="items" />
    </template>

    <template #right>
      <UColorModeButton />
      {{#if (eq auth "better-auth")}}
      <UserMenu />
      {{/if}}
    </template>

    <template #body>
      <UNavigationMenu :items="items" orientation="vertical" class="-mx-2.5" />
    </template>
  </UHeader>
</template>
`],
  ["frontend/nuxt/app/layouts/default.vue.hbs", `<script setup></script>

<template>
  <div class="grid grid-rows-[auto_1fr] h-svh">
    <Header />
    <UMain>
      <slot />
    </UMain>
  </div>
</template>
`],
  ["frontend/native/unistyles/app/+not-found.tsx.hbs", `import { Link, Stack } from "expo-router";
import { Text, View } from "react-native";
import { StyleSheet } from "react-native-unistyles";
import { Container } from "@/components/container";

export default function NotFoundScreen() {
  return (
    <>
      <Stack.Screen options=\\{{ title: "Oops!" }} />
      <Container>
        <View style={styles.container}>
          <View style={styles.content}>
            <Text style={styles.emoji}></Text>
            <Text style={styles.title}>Page Not Found</Text>
            <Text style={styles.description}>
              Sorry, the page you're looking for doesn't exist.
            </Text>
            <Link href="/" style={styles.button}>
              <Text style={styles.buttonText}>Go to Home</Text>
            </Link>
          </View>
        </View>
      </Container>
    </>
  );
}

const styles = StyleSheet.create((theme) => ({
  container: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    padding: theme.spacing.lg,
  },
  content: {
    alignItems: "center",
  },
  emoji: {
    fontSize: 64,
    marginBottom: theme.spacing.md,
  },
  title: {
    fontSize: theme.fontSize["2xl"],
    fontWeight: "bold",
    color: theme.colors.foreground,
    marginBottom: theme.spacing.sm,
    textAlign: "center",
  },
  description: {
    color: theme.colors.mutedForeground,
    textAlign: "center",
    marginBottom: theme.spacing.xl,
    maxWidth: 280,
  },
  button: {
    backgroundColor: \`\${theme.colors.primary}1A\`, // 10% opacity
    paddingHorizontal: theme.spacing.lg,
    paddingVertical: theme.spacing.sm + 4,
    borderRadius: theme.borderRadius.lg,
  },
  buttonText: {
    color: theme.colors.primary,
    fontWeight: "500",
  },
}));
`],
  ["frontend/native/unistyles/app/modal.tsx.hbs", `import { Container } from "@/components/container";
import { Text, View } from "react-native";
import { StyleSheet } from "react-native-unistyles";

export default function Modal() {
  return (
    <Container>
      <View style={styles.container}>
        <View style={styles.header}>
          <Text style={styles.title}>Modal</Text>
        </View>
      </View>
    </Container>
  );
}

const styles = StyleSheet.create((theme) => ({
  container: {
    flex: 1,
    padding: theme.spacing.lg,
  },
  header: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    marginBottom: theme.spacing.xl,
  },
  title: {
    fontSize: theme.fontSize["2xl"],
    fontWeight: "bold",
    color: theme.colors.foreground,
  },
}));
`],
  ["frontend/native/unistyles/app/_layout.tsx.hbs", `{{#if (includes examples "ai")}}
import "@/polyfills";
{{/if}}
{{#if (eq api "trpc")}}
import { queryClient } from "@/utils/trpc";
{{/if}}
{{#if (eq api "orpc")}}
import { queryClient } from "@/utils/orpc";
{{/if}}
{{#if (eq backend "convex")}}
{{#if (eq auth "better-auth")}}
import { ConvexReactClient } from "convex/react";
import { ConvexBetterAuthProvider } from "@convex-dev/better-auth/react";
import { authClient } from "@/lib/auth-client";
import { env } from "@{{projectName}}/env/native";
{{else}}
import { ConvexProvider, ConvexReactClient } from "convex/react";
import { env } from "@{{projectName}}/env/native";
{{/if}}
{{#if (eq auth "clerk")}}
import { ClerkProvider, useAuth } from "@clerk/clerk-expo";
import { ConvexProviderWithClerk } from "convex/react-clerk";
import { tokenCache } from "@clerk/clerk-expo/token-cache";
{{/if}}
{{else}}
  {{#unless (eq api "none")}}
import { QueryClientProvider } from "@tanstack/react-query";
  {{/unless}}
{{/if}}
import { Stack } from "expo-router";
import { GestureHandlerRootView } from "react-native-gesture-handler";
import { useUnistyles } from "react-native-unistyles";
import { StatusBar } from "expo-status-bar";

export const unstable_settings = {
  initialRouteName: "(drawer)",
};

{{#if (eq backend "convex")}}
const convex = new ConvexReactClient(env.EXPO_PUBLIC_CONVEX_URL, {
  unsavedChangesWarning: false,
});
{{/if}}

export default function RootLayout() {
  const { theme } = useUnistyles();

  return (
    {{#if (eq backend "convex")}}
    {{#if (eq auth "clerk")}}
    <ClerkProvider
      tokenCache={tokenCache}
      publishableKey={env.EXPO_PUBLIC_CLERK_PUBLISHABLE_KEY}
    >
      <ConvexProviderWithClerk client={convex} useAuth={useAuth}>
        <GestureHandlerRootView style=\\{{ flex: 1 }}>
          <Stack
            screenOptions=\\{{
              headerStyle: {
                backgroundColor: theme.colors.background,
              },
              headerTitleStyle: {
                color: theme.colors.foreground,
              },
              headerTintColor: theme.colors.foreground,
            }}
          >
            <Stack.Screen name="(drawer)" options=\\{{ headerShown: false }} />
            <Stack.Screen name="(auth)" options=\\{{ headerShown: false }} />
            <Stack.Screen
              name="modal"
              options=\\{{ title: "Modal", presentation: "modal" }}
            />
          </Stack>
        </GestureHandlerRootView>
      </ConvexProviderWithClerk>
    </ClerkProvider>
    {{else if (eq auth "better-auth")}}
    <ConvexBetterAuthProvider client={convex} authClient={authClient}>
      <GestureHandlerRootView style=\\{{ flex: 1 }}>
        <Stack
          screenOptions=\\{{
            headerStyle: {
              backgroundColor: theme.colors.background,
            },
            headerTitleStyle: {
              color: theme.colors.foreground,
            },
            headerTintColor: theme.colors.foreground,
          }}
        >
          <Stack.Screen name="(drawer)" options=\\{{ headerShown: false }} />
          <Stack.Screen
            name="modal"
            options=\\{{ title: "Modal", presentation: "modal" }}
          />
        </Stack>
      </GestureHandlerRootView>
    </ConvexBetterAuthProvider>
    {{else}}
    <ConvexProvider client={convex}>
      <GestureHandlerRootView style=\\{{ flex: 1 }}>
        <Stack
          screenOptions=\\{{
            headerStyle: {
              backgroundColor: theme.colors.background,
            },
            headerTitleStyle: {
              color: theme.colors.foreground,
            },
            headerTintColor: theme.colors.foreground,
          }}
        >
          <Stack.Screen name="(drawer)" options=\\{{ headerShown: false }} />
          <Stack.Screen
            name="modal"
            options=\\{{ title: "Modal", presentation: "modal" }}
          />
        </Stack>
      </GestureHandlerRootView>
    </ConvexProvider>
    {{/if}}
    {{else}}
      {{#unless (eq api "none")}}
    <QueryClientProvider client={queryClient}>
      <GestureHandlerRootView style=\\{{ flex: 1 }}>
        <Stack
          screenOptions=\\{{
            headerStyle: {
              backgroundColor: theme.colors.background,
            },
            headerTitleStyle: {
              color: theme.colors.foreground,
            },
            headerTintColor: theme.colors.foreground,
          }}
        >
          <Stack.Screen name="(drawer)" options=\\{{ headerShown: false }} />
          <Stack.Screen
            name="modal"
            options=\\{{ title: "Modal", presentation: "modal" }}
          />
        </Stack>
      </GestureHandlerRootView>
    </QueryClientProvider>
      {{else}}
      <GestureHandlerRootView style=\\{{ flex: 1 }}>
        <Stack
          screenOptions=\\{{
            headerStyle: {
              backgroundColor: theme.colors.background,
            },
            headerTitleStyle: {
              color: theme.colors.foreground,
            },
            headerTintColor: theme.colors.foreground,
          }}
        >
          <Stack.Screen name="(drawer)" options=\\{{ headerShown: false }} />
          <Stack.Screen
            name="modal"
            options=\\{{ title: "Modal", presentation: "modal" }}
          />
        </Stack>
      </GestureHandlerRootView>
      {{/unless}}
    {{/if}}
  );
}
`],
  ["frontend/native/unistyles/components/tabbar-icon.tsx.hbs", `import FontAwesome from "@expo/vector-icons/FontAwesome";

export const TabBarIcon = (props: {
  name: React.ComponentProps<typeof FontAwesome>["name"];
  color: string;
}) => {
  return <FontAwesome size={24} style=\\{{ marginBottom: -3 }} {...props} />;
};
`],
  ["frontend/native/unistyles/components/container.tsx.hbs", `import React from "react";
import { SafeAreaView } from "react-native-safe-area-context";
import { StyleSheet } from "react-native-unistyles";

export const Container = ({ children }: { children: React.ReactNode }) => {
  return <SafeAreaView style={styles.container}>{children}</SafeAreaView>;
};

const styles = StyleSheet.create((theme, rt) => ({
  container: {
    flex: 1,
    backgroundColor: theme.colors.background,
    paddingBottom: rt.insets.bottom,
  },
}));
`],
  ["frontend/native/unistyles/components/header-button.tsx.hbs", `import FontAwesome from "@expo/vector-icons/FontAwesome";
import { forwardRef } from "react";
import { Pressable } from "react-native";
import { StyleSheet } from "react-native-unistyles";

export const HeaderButton = forwardRef<
  typeof Pressable,
  { onPress?: () => void }
>(({ onPress }, ref) => {
  return (
    <Pressable onPress={onPress} style={styles.button}>
      {({ pressed }) => (
        <FontAwesome
          name="info-circle"
          size={20}
          color={styles.icon.color}
          style=\\{{
            opacity: pressed ? 0.7 : 1,
          }}
        />
      )}
    </Pressable>
  );
});

const styles = StyleSheet.create((theme) => ({
  button: {
    padding: theme.spacing.sm,
    marginRight: theme.spacing.sm,
    borderRadius: theme.borderRadius.lg,
    backgroundColor: \`\${theme.colors.secondary}80\`, // 50% opacity
  },
  icon: {
    color: theme.colors.secondaryForeground,
  },
}));
`],
  ["frontend/native/bare/app/+not-found.tsx.hbs", `import { Container } from "@/components/container";
import { Link, Stack } from "expo-router";
import { Text, View, StyleSheet } from "react-native";
import { useColorScheme } from "@/lib/use-color-scheme";
import { NAV_THEME } from "@/lib/constants";

export default function NotFoundScreen() {
  const { colorScheme } = useColorScheme();
  const theme = colorScheme === "dark" ? NAV_THEME.dark : NAV_THEME.light;

  return (
    <>
      <Stack.Screen options=\\{{ title: "Oops!" }} />
      <Container>
        <View style={styles.container}>
          <View style={styles.content}>
            <Text style={styles.emoji}></Text>
            <Text style={[styles.title, { color: theme.text }]}>
              Page Not Found
            </Text>
            <Text style={[styles.subtitle, { color: theme.text, opacity: 0.7 }]}>
              Sorry, the page you're looking for doesn't exist.
            </Text>
            <Link href="/" asChild>
              <Text style={[styles.link, { color: theme.primary, backgroundColor: \`\${theme.primary}1a\` }]}>
                Go to Home
              </Text>
            </Link>
          </View>
        </View>
      </Container>
    </>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    padding: 16,
  },
  content: {
    alignItems: "center",
  },
  emoji: {
    fontSize: 48,
    marginBottom: 16,
  },
  title: {
    fontSize: 20,
    fontWeight: "bold",
    marginBottom: 8,
    textAlign: "center",
  },
  subtitle: {
    fontSize: 14,
    textAlign: "center",
    marginBottom: 24,
  },
  link: {
    padding: 12,
  },
});

`],
  ["frontend/native/bare/app/modal.tsx.hbs", `import { Container } from "@/components/container";
import { Text, View, StyleSheet } from "react-native";
import { useColorScheme } from "@/lib/use-color-scheme";
import { NAV_THEME } from "@/lib/constants";

export default function Modal() {
  const { colorScheme } = useColorScheme();
  const theme = colorScheme === "dark" ? NAV_THEME.dark : NAV_THEME.light;

  return (
    <Container>
      <View style={styles.container}>
        <View style={styles.header}>
          <Text style={[styles.title, { color: theme.text }]}>Modal</Text>
        </View>
      </View>
    </Container>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16,
  },
  header: {
    marginBottom: 16,
  },
  title: {
    fontSize: 20,
    fontWeight: "bold",
  },
});

`],
  ["frontend/native/bare/app/_layout.tsx.hbs", `{{#if (includes examples "ai")}}
import "@/polyfills";
{{/if}}

{{#if (eq backend "convex")}}
  {{#if (eq auth "better-auth")}}
    import { ConvexReactClient } from "convex/react";
    import { ConvexBetterAuthProvider } from "@convex-dev/better-auth/react";
    import { authClient } from "@/lib/auth-client";
    import { env } from "@{{projectName}}/env/native";
  {{else}}
    import { ConvexProvider, ConvexReactClient } from "convex/react";
    import { env } from "@{{projectName}}/env/native";
  {{/if}}
  {{#if (eq auth "clerk")}}
    import { ClerkProvider, useAuth } from "@clerk/clerk-expo";
    import { ConvexProviderWithClerk } from "convex/react-clerk";
    import { tokenCache } from "@clerk/clerk-expo/token-cache";
  {{/if}}
{{else}}
  {{#unless (eq api "none")}}
    import { QueryClientProvider } from "@tanstack/react-query";
  {{/unless}}
{{/if}}

import { Stack } from "expo-router";
import {
  DarkTheme,
  DefaultTheme,
  type Theme,
  ThemeProvider,
} from "@react-navigation/native";
import { StatusBar } from "expo-status-bar";
import { GestureHandlerRootView } from "react-native-gesture-handler";
{{#if (eq api "trpc")}}
import { queryClient } from "@/utils/trpc";
{{/if}}
{{#if (eq api "orpc")}}
import { queryClient } from "@/utils/orpc";
{{/if}}
import { NAV_THEME } from "@/lib/constants";
import React, { useRef } from "react";
import { useColorScheme } from "@/lib/use-color-scheme";
import { Platform, StyleSheet } from "react-native";
import { setAndroidNavigationBar } from "@/lib/android-navigation-bar";

const LIGHT_THEME: Theme = {
  ...DefaultTheme,
  colors: NAV_THEME.light,
};
const DARK_THEME: Theme = {
  ...DarkTheme,
  colors: NAV_THEME.dark,
};

export const unstable_settings = {
  initialRouteName: "(drawer)",
};

{{#if (eq backend "convex")}}
const convex = new ConvexReactClient(env.EXPO_PUBLIC_CONVEX_URL, {
  unsavedChangesWarning: false,
});
{{/if}}

const useIsomorphicLayoutEffect =
  Platform.OS === "web" && typeof window === "undefined"
    ? React.useEffect
    : React.useLayoutEffect;

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
});

export default function RootLayout() {
  const hasMounted = useRef(false);
  const { colorScheme, isDarkColorScheme } = useColorScheme();
  const [isColorSchemeLoaded, setIsColorSchemeLoaded] = React.useState(false);

  useIsomorphicLayoutEffect(() => {
    if (hasMounted.current) {
      return;
    }
    setAndroidNavigationBar(colorScheme);
    setIsColorSchemeLoaded(true);
    hasMounted.current = true;
  }, []);

  if (!isColorSchemeLoaded) {
    return null;
  }

  return (
    <>
      {{#if (eq backend "convex")}}
        {{#if (eq auth "clerk")}}
          <ClerkProvider tokenCache={tokenCache} publishableKey={env.EXPO_PUBLIC_CLERK_PUBLISHABLE_KEY}>
            <ConvexProviderWithClerk client={convex} useAuth={useAuth}>
              <ThemeProvider value={isDarkColorScheme ? DARK_THEME : LIGHT_THEME}>
                <StatusBar style={isDarkColorScheme ? "light" : "dark"} />
                <GestureHandlerRootView style={styles.container}>
                  <Stack>
                    <Stack.Screen name="(drawer)" options=\\{{ headerShown: false }} />
                    <Stack.Screen name="(auth)" options=\\{{ headerShown: false }} />
                    <Stack.Screen name="modal" options=\\{{ title: "Modal", presentation: "modal" }} />
                  </Stack>
                </GestureHandlerRootView>
              </ThemeProvider>
            </ConvexProviderWithClerk>
          </ClerkProvider>
        {{else if (eq auth "better-auth")}}
          <ConvexBetterAuthProvider client={convex} authClient={authClient}>
            <ThemeProvider value={isDarkColorScheme ? DARK_THEME : LIGHT_THEME}>
              <StatusBar style={isDarkColorScheme ? "light" : "dark"} />
              <GestureHandlerRootView style={styles.container}>
                <Stack>
                  <Stack.Screen name="(drawer)" options=\\{{ headerShown: false }} />
                  <Stack.Screen name="modal" options=\\{{ title: "Modal", presentation: "modal" }} />
                </Stack>
              </GestureHandlerRootView>
            </ThemeProvider>
          </ConvexBetterAuthProvider>
        {{else}}
          <ConvexProvider client={convex}>
            <ThemeProvider value={isDarkColorScheme ? DARK_THEME : LIGHT_THEME}>
              <StatusBar style={isDarkColorScheme ? "light" : "dark"} />
              <GestureHandlerRootView style={styles.container}>
                <Stack>
                  <Stack.Screen name="(drawer)" options=\\{{ headerShown: false }} />
                  <Stack.Screen name="modal" options=\\{{ title: "Modal", presentation: "modal" }} />
                </Stack>
              </GestureHandlerRootView>
            </ThemeProvider>
          </ConvexProvider>
        {{/if}}
      {{else}}
        {{#unless (eq api "none")}}
          <QueryClientProvider client={queryClient}>
            <ThemeProvider value={isDarkColorScheme ? DARK_THEME : LIGHT_THEME}>
              <StatusBar style={isDarkColorScheme ? "light" : "dark"} />
              <GestureHandlerRootView style={styles.container}>
                <Stack>
                  <Stack.Screen name="(drawer)" options=\\{{ headerShown: false }} />
                  <Stack.Screen name="modal" options=\\{{ title: "Modal", presentation: "modal" }} />
                </Stack>
              </GestureHandlerRootView>
            </ThemeProvider>
          </QueryClientProvider>
        {{else}}
          <ThemeProvider value={isDarkColorScheme ? DARK_THEME : LIGHT_THEME}>
            <StatusBar style={isDarkColorScheme ? "light" : "dark"} />
            <GestureHandlerRootView style={styles.container}>
              <Stack>
                <Stack.Screen name="(drawer)" options=\\{{ headerShown: false }} />
                <Stack.Screen name="modal" options=\\{{ title: "Modal", presentation: "modal" }} />
              </Stack>
            </GestureHandlerRootView>
          </ThemeProvider>
        {{/unless}}
      {{/if}}
    </>
  );
}`],
  ["frontend/native/bare/components/tabbar-icon.tsx.hbs", `import FontAwesome from "@expo/vector-icons/FontAwesome";

export const TabBarIcon = (props: {
  name: React.ComponentProps<typeof FontAwesome>["name"];
  color: string;
}) => {
  return <FontAwesome size={24} style=\\{{ marginBottom: -3 }} {...props} />;
};

`],
  ["frontend/native/bare/components/container.tsx.hbs", `import React from "react";
import { SafeAreaView } from "react-native-safe-area-context";
import { useColorScheme } from "@/lib/use-color-scheme";
import { NAV_THEME } from "@/lib/constants";
import { StyleSheet } from "react-native";

export function Container({ children }: { children: React.ReactNode }) {
  const { colorScheme } = useColorScheme();
  const backgroundColor = colorScheme === "dark" 
    ? NAV_THEME.dark.background 
    : NAV_THEME.light.background;

  return (
    <SafeAreaView style={[styles.container, { backgroundColor }]}>
      {children}
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
});

`],
  ["frontend/native/bare/components/header-button.tsx.hbs", `import FontAwesome from "@expo/vector-icons/FontAwesome";
import { forwardRef } from "react";
import { Pressable, StyleSheet, View } from "react-native";
import { useColorScheme } from "@/lib/use-color-scheme";
import { NAV_THEME } from "@/lib/constants";

export const HeaderButton = forwardRef<
  View,
  { onPress?: () => void }
>(({ onPress }, ref) => {
  const { colorScheme } = useColorScheme();
  const theme = colorScheme === "dark" ? NAV_THEME.dark : NAV_THEME.light;

  return (
    <Pressable
      ref={ref}
      onPress={onPress}
      style={({ pressed }) => [
        styles.button,
        {
          backgroundColor: pressed 
            ? theme.background 
            : theme.card,
        },
      ]}
    >
      {({ pressed }) => (
        <FontAwesome
          name="info-circle"
          size={20}
          color={theme.text}
          style=\\{{
            opacity: pressed ? 0.7 : 1,
          }}
        />
      )}
    </Pressable>
  );
});

const styles = StyleSheet.create({
  button: {
    padding: 8,
    marginRight: 8,
  },
});

`],
  ["frontend/native/bare/lib/constants.ts.hbs", `export const NAV_THEME = {
  light: {
    background: "hsl(0 0% 100%)",
    border: "hsl(220 13% 91%)",
    card: "hsl(0 0% 100%)",
    notification: "hsl(0 84.2% 60.2%)",
    primary: "hsl(221.2 83.2% 53.3%)",
    text: "hsl(222.2 84% 4.9%)",
  },
  dark: {
    background: "hsl(222.2 84% 4.9%)",
    border: "hsl(217.2 32.6% 17.5%)",
    card: "hsl(222.2 84% 4.9%)",
    notification: "hsl(0 72% 51%)",
    primary: "hsl(217.2 91.2% 59.8%)",
    text: "hsl(210 40% 98%)",
  },
};

`],
  ["frontend/native/bare/lib/use-color-scheme.ts.hbs", `import { useColorScheme as useRNColorScheme } from "react-native";

export function useColorScheme() {
  const systemColorScheme = useRNColorScheme();
  const colorScheme = systemColorScheme ?? "light";
  
  return {
    colorScheme: colorScheme as "light" | "dark",
    isDarkColorScheme: colorScheme === "dark",
    setColorScheme: () => {
      // Color scheme is managed by the system in bare mode
      console.warn("setColorScheme is not available in bare mode. Color scheme is managed by the system.");
    },
    toggleColorScheme: () => {
      // Color scheme is managed by the system in bare mode
      console.warn("toggleColorScheme is not available in bare mode. Color scheme is managed by the system.");
    },
  };
}

`],
  ["frontend/native/bare/lib/android-navigation-bar.tsx.hbs", `import * as NavigationBar from "expo-navigation-bar";
import { Platform } from "react-native";
import { NAV_THEME } from "@/lib/constants";

export async function setAndroidNavigationBar(theme: "light" | "dark") {
  if (Platform.OS !== "android") return;
  await NavigationBar.setButtonStyleAsync(theme === "dark" ? "light" : "dark");
  await NavigationBar.setBackgroundColorAsync(
    theme === "dark" ? NAV_THEME.dark.background : NAV_THEME.light.background,
  );
}

`],
  ["frontend/astro/src/components/Header.astro.hbs", `---
{{#if (eq astroIntegration "react")}}
import ModeToggle from '@/components/ModeToggle';
{{/if}}
---

<header class="sticky top-0 z-50 w-full border-b border-border bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60">
	<div class="container mx-auto flex h-14 items-center justify-between px-4">
		<a href="/" class="flex items-center space-x-2">
			<span class="text-xl font-bold">{{projectName}}</span>
		</a>
		<nav class="flex items-center gap-4">
			<a
				href="https://github.com"
				target="_blank"
				rel="noopener noreferrer"
				class="text-sm font-medium text-muted-foreground transition-colors hover:text-foreground"
			>
				GitHub
			</a>
{{#if (eq astroIntegration "react")}}
			<ModeToggle client:load />
{{else}}
			<button
				id="theme-toggle"
				class="rounded-md p-2 hover:bg-accent"
				aria-label="Toggle theme"
			>
				<svg class="dark:hidden h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
					<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" />
				</svg>
				<svg class="hidden dark:block h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
					<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />
				</svg>
			</button>
			<script>
				const toggle = document.getElementById('theme-toggle');
				toggle?.addEventListener('click', () => {
					document.documentElement.classList.toggle('dark');
				});
			</script>
{{/if}}
		</nav>
	</div>
</header>
`],
  ["frontend/astro/src/styles/global.css.hbs", `@import "tailwindcss";

@theme {
	--color-background: oklch(100% 0 0);
	--color-foreground: oklch(14.08% 0.004 285.82);
	--color-card: oklch(100% 0 0);
	--color-card-foreground: oklch(14.08% 0.004 285.82);
	--color-primary: oklch(20.47% 0.006 285.88);
	--color-primary-foreground: oklch(98.51% 0.001 106.42);
	--color-secondary: oklch(96.76% 0.001 286.38);
	--color-secondary-foreground: oklch(20.47% 0.006 285.88);
	--color-muted: oklch(96.76% 0.001 286.38);
	--color-muted-foreground: oklch(55.19% 0.014 285.94);
	--color-accent: oklch(96.76% 0.001 286.38);
	--color-accent-foreground: oklch(20.47% 0.006 285.88);
	--color-border: oklch(91.97% 0.004 286.32);
	--color-input: oklch(91.97% 0.004 286.32);
	--color-ring: oklch(14.08% 0.004 285.82);

	--radius-sm: 0.25rem;
	--radius-md: 0.375rem;
	--radius-lg: 0.5rem;
}

.dark {
	--color-background: oklch(14.08% 0.004 285.82);
	--color-foreground: oklch(98.51% 0.001 106.42);
	--color-card: oklch(14.08% 0.004 285.82);
	--color-card-foreground: oklch(98.51% 0.001 106.42);
	--color-primary: oklch(98.51% 0.001 106.42);
	--color-primary-foreground: oklch(20.47% 0.006 285.88);
	--color-secondary: oklch(26.96% 0.005 286.03);
	--color-secondary-foreground: oklch(98.51% 0.001 106.42);
	--color-muted: oklch(26.96% 0.005 286.03);
	--color-muted-foreground: oklch(70.67% 0.01 286.07);
	--color-accent: oklch(26.96% 0.005 286.03);
	--color-accent-foreground: oklch(98.51% 0.001 106.42);
	--color-border: oklch(26.96% 0.005 286.03);
	--color-input: oklch(26.96% 0.005 286.03);
	--color-ring: oklch(83.53% 0.005 286.29);
}
`],
  ["frontend/native/uniwind/app/+not-found.tsx.hbs", `import { Link, Stack } from "expo-router";
import { Button, Surface } from "heroui-native";
import { Text, View } from "react-native";

import { Container } from "@/components/container";

export default function NotFoundScreen() {
	return (
		<>
			<Stack.Screen options=\\{{ title: "Not Found" }} />
			<Container>
				<View className="flex-1 justify-center items-center p-4">
					<Surface variant="secondary" className="items-center p-6 max-w-sm rounded-lg">
						<Text className="text-4xl mb-3"></Text>
						<Text className="text-foreground font-medium text-lg mb-1">Page Not Found</Text>
						<Text className="text-muted text-sm text-center mb-4">
							The page you're looking for doesn't exist.
						</Text>
						<Link href="/" asChild>
							<Button size="sm">Go Home</Button>
						</Link>
					</Surface>
				</View>
			</Container>
		</>
	);
}
`],
  ["frontend/native/uniwind/app/modal.tsx.hbs", `import { Ionicons } from "@expo/vector-icons";
import { router } from "expo-router";
import { Button, Surface, useThemeColor } from "heroui-native";
import { Text, View } from "react-native";

import { Container } from "@/components/container";

function Modal() {
	const accentForegroundColor = useThemeColor("accent-foreground");

	function handleClose() {
		router.back();
	}

	return (
		<Container>
			<View className="flex-1 justify-center items-center p-4">
				<Surface variant="secondary" className="p-5 w-full max-w-sm rounded-lg">
					<View className="items-center">
						<View className="w-12 h-12 bg-accent rounded-lg items-center justify-center mb-3">
							<Ionicons name="checkmark" size={24} color={accentForegroundColor} />
						</View>
						<Text className="text-foreground font-medium text-lg mb-1">Modal Screen</Text>
						<Text className="text-muted text-sm text-center mb-4">
							This is an example modal screen for dialogs and confirmations.
						</Text>
					</View>
					<Button onPress={handleClose} className="w-full" size="sm">
						<Button.Label>Close</Button.Label>
					</Button>
				</Surface>
			</View>
		</Container>
	);
}

export default Modal;
`],
  ["frontend/native/uniwind/app/_layout.tsx.hbs", `{{#if (includes examples "ai")}}
import "@/polyfills";
{{/if}}

import "@/global.css";

{{#if (eq backend "convex")}}
  {{#if (eq auth "better-auth")}}
    import { ConvexReactClient } from "convex/react";
    import { ConvexBetterAuthProvider } from "@convex-dev/better-auth/react";
    import { authClient } from "@/lib/auth-client";
    import { env } from "@{{projectName}}/env/native";
  {{else}}
    import { ConvexProvider, ConvexReactClient } from "convex/react";
    import { env } from "@{{projectName}}/env/native";
  {{/if}}

  {{#if (eq auth "clerk")}}
    import { ClerkProvider, useAuth } from "@clerk/clerk-expo";
    import { ConvexProviderWithClerk } from "convex/react-clerk";
    import { tokenCache } from "@clerk/clerk-expo/token-cache";
  {{/if}}
{{else}}
  {{#unless (eq api "none")}}
    import { QueryClientProvider } from "@tanstack/react-query";
  {{/unless}}
{{/if}}

import { Stack } from "expo-router";
import { HeroUINativeProvider } from "heroui-native";
import { GestureHandlerRootView } from "react-native-gesture-handler";
import { KeyboardProvider } from "react-native-keyboard-controller";
import { AppThemeProvider } from "@/contexts/app-theme-context";

{{#if (eq api "trpc")}}
  import { queryClient } from "@/utils/trpc";
{{/if}}
{{#if (eq api "orpc")}}
  import { queryClient } from "@/utils/orpc";
{{/if}}

export const unstable_settings = {
  initialRouteName: "(drawer)",
};

{{#if (eq backend "convex")}}
  const convex = new ConvexReactClient(env.EXPO_PUBLIC_CONVEX_URL, {
    unsavedChangesWarning: false,
  });
{{/if}}

function StackLayout() {
  return (
    <Stack screenOptions=\\{{}}>
      <Stack.Screen name="(drawer)" options=\\{{ headerShown: false }} />
      {{#if (eq auth "clerk")}}
        <Stack.Screen name="(auth)" options=\\{{ headerShown: false }} />
      {{/if}}
      <Stack.Screen name="modal" options=\\{{ title: "Modal", presentation: "modal" }} />
    </Stack>
  );
}

export default function Layout() {
  return (
    {{#if (eq backend "convex")}}
      {{#if (eq auth "clerk")}}
        <ClerkProvider tokenCache={tokenCache} publishableKey={env.EXPO_PUBLIC_CLERK_PUBLISHABLE_KEY}>
          <ConvexProviderWithClerk client={convex} useAuth={useAuth}>
            <GestureHandlerRootView style=\\{{ flex: 1 }}>
              <KeyboardProvider>
                <AppThemeProvider>
                  <HeroUINativeProvider>
                    <StackLayout />
                  </HeroUINativeProvider>
                </AppThemeProvider>
              </KeyboardProvider>
            </GestureHandlerRootView>
          </ConvexProviderWithClerk>
        </ClerkProvider>
      {{else if (eq auth "better-auth")}}
        <ConvexBetterAuthProvider client={convex} authClient={authClient}>
          <GestureHandlerRootView style=\\{{ flex: 1 }}>
            <KeyboardProvider>
              <AppThemeProvider>
                <HeroUINativeProvider>
                  <StackLayout />
                </HeroUINativeProvider>
              </AppThemeProvider>
            </KeyboardProvider>
          </GestureHandlerRootView>
        </ConvexBetterAuthProvider>
      {{else}}
        <ConvexProvider client={convex}>
          <GestureHandlerRootView style=\\{{ flex: 1 }}>
            <KeyboardProvider>
              <AppThemeProvider>
                <HeroUINativeProvider>
                  <StackLayout />
                </HeroUINativeProvider>
              </AppThemeProvider>
            </KeyboardProvider>
          </GestureHandlerRootView>
        </ConvexProvider>
      {{/if}}
    {{else}}
      {{#unless (eq api "none")}}
        <QueryClientProvider client={queryClient}>
          <GestureHandlerRootView style=\\{{ flex: 1 }}>
            <KeyboardProvider>
              <AppThemeProvider>
                <HeroUINativeProvider>
                  <StackLayout />
                </HeroUINativeProvider>
              </AppThemeProvider>
            </KeyboardProvider>
          </GestureHandlerRootView>
        </QueryClientProvider>
      {{else}}
        <GestureHandlerRootView style=\\{{ flex: 1 }}>
          <KeyboardProvider>
            <AppThemeProvider>
              <HeroUINativeProvider>
                <StackLayout />
              </HeroUINativeProvider>
            </AppThemeProvider>
          </KeyboardProvider>
        </GestureHandlerRootView>
      {{/unless}}
    {{/if}}
  );
}`],
  ["frontend/astro/src/layouts/Layout.astro.hbs", `---
import '@/styles/global.css';
import Header from '@/components/Header.astro';

interface Props {
	title: string;
}

const { title } = Astro.props;
---

<!doctype html>
<html lang="en" class="dark">
	<head>
		<meta charset="UTF-8" />
		<meta name="description" content="Astro website built with Better Fullstack" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<link rel="icon" type="image/svg+xml" href="/favicon.svg" />
		<meta name="generator" content={Astro.generator} />
		<title>{title}</title>
	</head>
	<body class="min-h-screen bg-background text-foreground antialiased">
		<Header />
		<main class="container mx-auto px-4 py-8">
			<slot />
		</main>
	</body>
</html>
`],
  ["frontend/native/uniwind/contexts/app-theme-context.tsx.hbs", `import React, { createContext, useCallback, useContext, useMemo } from 'react';
import { Uniwind, useUniwind } from 'uniwind';

type ThemeName = 'light' | 'dark';

type AppThemeContextType = {
    currentTheme: string;
    isLight: boolean;
    isDark: boolean;
    setTheme: (theme: ThemeName) => void;
    toggleTheme: () => void;
}

const AppThemeContext = createContext<AppThemeContextType | undefined>(
    undefined
);

export const AppThemeProvider = ({ children }: { children: React.ReactNode }) => {
    const { theme } = useUniwind();

    const isLight = useMemo(() => {
        return theme === 'light';
    }, [theme]);

    const isDark = useMemo(() => {
        return theme === 'dark';
    }, [theme]);

    const setTheme = useCallback((newTheme: ThemeName) => {
        Uniwind.setTheme(newTheme);
    }, []);

    const toggleTheme = useCallback(() => {
        Uniwind.setTheme(theme === 'light' ? 'dark' : 'light');
    }, [theme]);

    const value = useMemo(
        () => ({
            currentTheme: theme,
            isLight,
            isDark,
            setTheme,
            toggleTheme,
        }),
        [theme, isLight, isDark, setTheme, toggleTheme]
    );

    return (
        <AppThemeContext.Provider value={value}>
            {children}
        </AppThemeContext.Provider>
    );
};

export function useAppTheme() {
    const context = useContext(AppThemeContext);
    if (!context) {
        throw new Error('useAppTheme must be used within AppThemeProvider');
    }
    return context;
}

`],
  ["frontend/astro/src/pages/index.astro.hbs", `---
import Layout from '@/layouts/Layout.astro';
{{#if (ne astroIntegration "none")}}
{{#if (eq astroIntegration "react")}}
import Counter from '@/components/Counter';
{{/if}}
{{#if (eq astroIntegration "vue")}}
import Counter from '@/components/Counter.vue';
{{/if}}
{{#if (eq astroIntegration "svelte")}}
import Counter from '@/components/Counter.svelte';
{{/if}}
{{#if (eq astroIntegration "solid")}}
import Counter from '@/components/Counter';
{{/if}}
{{/if}}
---

<Layout title="{{projectName}}">
	<div class="flex flex-col items-center justify-center gap-8 py-12">
		<div class="text-center">
			<h1 class="mb-4 text-4xl font-bold tracking-tight sm:text-5xl">
				Welcome to <span class="text-primary">{{projectName}}</span>
			</h1>
			<p class="text-lg text-muted-foreground">
				Built with Astro and Better Fullstack
			</p>
		</div>

{{#if (ne astroIntegration "none")}}
		<div class="mt-8 rounded-lg border border-border bg-card p-6 shadow-sm">
			<h2 class="mb-4 text-xl font-semibold">Interactive Counter</h2>
			<p class="mb-4 text-sm text-muted-foreground">
				This is an island component using {{astroIntegration}} with client-side hydration.
			</p>
			<Counter client:load />
		</div>
{{else}}
		<div class="mt-8 rounded-lg border border-border bg-card p-6 shadow-sm">
			<h2 class="mb-4 text-xl font-semibold">Static Site</h2>
			<p class="text-sm text-muted-foreground">
				This is a static Astro site without client-side JavaScript framework.
			</p>
		</div>
{{/if}}

		<div class="mt-8 grid gap-4 sm:grid-cols-2 lg:grid-cols-3">
			<a
				href="https://docs.astro.build/"
				target="_blank"
				rel="noopener noreferrer"
				class="rounded-lg border border-border bg-card p-4 transition-colors hover:border-primary"
			>
				<h3 class="font-semibold">Astro Docs</h3>
				<p class="text-sm text-muted-foreground">Learn about Astro's features and API.</p>
			</a>
			<a
				href="https://better-fullstack-web.vercel.app"
				target="_blank"
				rel="noopener noreferrer"
				class="rounded-lg border border-border bg-card p-4 transition-colors hover:border-primary"
			>
				<h3 class="font-semibold">Better Fullstack</h3>
				<p class="text-sm text-muted-foreground">Full-stack TypeScript development.</p>
			</a>
			<a
				href="https://astro.build/integrations/"
				target="_blank"
				rel="noopener noreferrer"
				class="rounded-lg border border-border bg-card p-4 transition-colors hover:border-primary"
			>
				<h3 class="font-semibold">Integrations</h3>
				<p class="text-sm text-muted-foreground">Extend Astro with plugins and frameworks.</p>
			</a>
		</div>
	</div>
</Layout>
`],
  ["rust-base/crates/tui/src/main.rs.hbs", `use std::io;
use std::time::Duration;

use anyhow::Result;
use crossterm::{
    event::{self, DisableMouseCapture, EnableMouseCapture, Event, KeyCode, KeyEventKind},
    execute,
    terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},
};
use ratatui::{
    prelude::*,
    widgets::{Block, Borders, List, ListItem, ListState, Paragraph, Tabs},
};
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};

/// Application state
struct App {
    /// Current tab index
    tab_index: usize,
    /// Menu items for the sidebar
    menu_items: Vec<&'static str>,
    /// Current menu selection state
    menu_state: ListState,
    /// Counter value for demo
    counter: i32,
    /// Status messages
    status: String,
    /// Whether the app should quit
    should_quit: bool,
}

impl Default for App {
    fn default() -> Self {
        let mut menu_state = ListState::default();
        menu_state.select(Some(0));

        Self {
            tab_index: 0,
            menu_items: vec!["Dashboard", "Settings", "Logs", "Help"],
            menu_state,
            counter: 0,
            status: String::from("Ready"),
            should_quit: false,
        }
    }
}

impl App {
    /// Handle key events
    fn handle_key(&mut self, key: KeyCode) {
        match key {
            KeyCode::Char('q') | KeyCode::Esc => {
                self.should_quit = true;
            }
            KeyCode::Tab => {
                self.tab_index = (self.tab_index + 1) % 3;
            }
            KeyCode::BackTab => {
                self.tab_index = if self.tab_index == 0 { 2 } else { self.tab_index - 1 };
            }
            KeyCode::Up | KeyCode::Char('k') => {
                self.menu_previous();
            }
            KeyCode::Down | KeyCode::Char('j') => {
                self.menu_next();
            }
            KeyCode::Enter => {
                if let Some(selected) = self.menu_state.selected() {
                    self.status = format!("Selected: {}", self.menu_items[selected]);
                }
            }
            KeyCode::Char('+') | KeyCode::Char('=') => {
                self.counter += 1;
                self.status = format!("Counter incremented to {}", self.counter);
            }
            KeyCode::Char('-') => {
                self.counter -= 1;
                self.status = format!("Counter decremented to {}", self.counter);
            }
            _ => {}
        }
    }

    /// Select previous menu item
    fn menu_previous(&mut self) {
        let i = match self.menu_state.selected() {
            Some(i) => {
                if i == 0 {
                    self.menu_items.len() - 1
                } else {
                    i - 1
                }
            }
            None => 0,
        };
        self.menu_state.select(Some(i));
    }

    /// Select next menu item
    fn menu_next(&mut self) {
        let i = match self.menu_state.selected() {
            Some(i) => {
                if i >= self.menu_items.len() - 1 {
                    0
                } else {
                    i + 1
                }
            }
            None => 0,
        };
        self.menu_state.select(Some(i));
    }
}

fn main() -> Result<()> {
    // Load environment variables
    dotenvy::dotenv().ok();

    // Initialize tracing to a file (can't use terminal while TUI is running)
    let file_appender = tracing_appender::rolling::daily("logs", "tui.log");
    let (non_blocking, _guard) = tracing_appender::non_blocking(file_appender);
    tracing_subscriber::registry()
        .with(tracing_subscriber::EnvFilter::try_from_default_env().unwrap_or_else(|_| "info".into()))
        .with(tracing_subscriber::fmt::layer().with_writer(non_blocking))
        .init();

    tracing::info!("Starting {{projectName}} TUI");

    // Setup terminal
    enable_raw_mode()?;
    let mut stdout = io::stdout();
    execute!(stdout, EnterAlternateScreen, EnableMouseCapture)?;
    let backend = CrosstermBackend::new(stdout);
    let mut terminal = Terminal::new(backend)?;

    // Create app state
    let mut app = App::default();

    // Main loop
    let result = run_app(&mut terminal, &mut app);

    // Restore terminal
    disable_raw_mode()?;
    execute!(
        terminal.backend_mut(),
        LeaveAlternateScreen,
        DisableMouseCapture
    )?;
    terminal.show_cursor()?;

    if let Err(err) = result {
        tracing::error!("Application error: {:?}", err);
        eprintln!("Error: {:?}", err);
    }

    tracing::info!("{{projectName}} TUI exited");
    Ok(())
}

/// Run the application main loop
fn run_app<B: Backend>(terminal: &mut Terminal<B>, app: &mut App) -> Result<()> {
    loop {
        terminal.draw(|f| ui(f, app))?;

        // Poll for events with a timeout
        if event::poll(Duration::from_millis(100))? {
            if let Event::Key(key) = event::read()? {
                if key.kind == KeyEventKind::Press {
                    app.handle_key(key.code);
                }
            }
        }

        if app.should_quit {
            return Ok(());
        }
    }
}

/// Render the UI
fn ui(f: &mut Frame, app: &mut App) {
    let chunks = Layout::default()
        .direction(Direction::Vertical)
        .constraints([
            Constraint::Length(3), // Tabs
            Constraint::Min(0),    // Main content
            Constraint::Length(3), // Status bar
        ])
        .split(f.area());

    // Render tabs
    let tabs = Tabs::new(vec!["Main", "Stats", "Config"])
        .block(Block::default().borders(Borders::ALL).title(" {{projectName}} TUI "))
        .select(app.tab_index)
        .style(Style::default().fg(Color::White))
        .highlight_style(Style::default().fg(Color::Yellow).bold());
    f.render_widget(tabs, chunks[0]);

    // Render main content area
    let main_chunks = Layout::default()
        .direction(Direction::Horizontal)
        .constraints([Constraint::Percentage(30), Constraint::Percentage(70)])
        .split(chunks[1]);

    // Render sidebar menu
    let menu_items: Vec<ListItem> = app
        .menu_items
        .iter()
        .map(|i| ListItem::new(*i).style(Style::default().fg(Color::White)))
        .collect();
    let menu = List::new(menu_items)
        .block(Block::default().borders(Borders::ALL).title(" Menu "))
        .highlight_style(Style::default().bg(Color::Blue).fg(Color::White).bold())
        .highlight_symbol(" ");
    f.render_stateful_widget(menu, main_chunks[0], &mut app.menu_state);

    // Render content based on selected tab
    let content = match app.tab_index {
        0 => {
            let text = vec![
                Line::from("Welcome to {{projectName}} TUI!"),
                Line::from(""),
                Line::from(format!("Counter: {}", app.counter)),
                Line::from(""),
                Line::from("Keybindings:"),
                Line::from("  Tab / Shift+Tab  - Switch tabs"),
                Line::from("  j/k or /       - Navigate menu"),
                Line::from("  Enter            - Select item"),
                Line::from("  +/-              - Increment/Decrement counter"),
                Line::from("  q or Esc         - Quit"),
            ];
            Paragraph::new(text)
                .block(Block::default().borders(Borders::ALL).title(" Dashboard "))
                .style(Style::default().fg(Color::White))
        }
        1 => {
            let text = vec![
                Line::from("Statistics"),
                Line::from(""),
                Line::from(format!("Current counter value: {}", app.counter)),
                Line::from(format!("Menu items: {}", app.menu_items.len())),
                Line::from(format!(
                    "Selected menu item: {}",
                    app.menu_state
                        .selected()
                        .map(|i| app.menu_items[i])
                        .unwrap_or("None")
                )),
            ];
            Paragraph::new(text)
                .block(Block::default().borders(Borders::ALL).title(" Stats "))
                .style(Style::default().fg(Color::Cyan))
        }
        _ => {
            let text = vec![
                Line::from("Configuration"),
                Line::from(""),
                Line::from("This is where you would configure the application."),
                Line::from(""),
                Line::from("Environment variables:"),
                Line::from(format!("  RUST_LOG: {}", std::env::var("RUST_LOG").unwrap_or_else(|_| "not set".to_string()))),
            ];
            Paragraph::new(text)
                .block(Block::default().borders(Borders::ALL).title(" Config "))
                .style(Style::default().fg(Color::Green))
        }
    };
    f.render_widget(content, main_chunks[1]);

    // Render status bar
    let status = Paragraph::new(app.status.as_str())
        .block(Block::default().borders(Borders::ALL).title(" Status "))
        .style(Style::default().fg(Color::Gray));
    f.render_widget(status, chunks[2]);
}
`],
  ["frontend/astro/integrations/react/components.json.hbs", `{{#if (eq uiLibrary "shadcn-ui")}}
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "base-lyra",
  "rsc": false,
  "tsx": true,
  "tailwind": {
    "config": "",
    "css": "src/styles/global.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "iconLibrary": "lucide",
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "menuColor": "default",
  "menuAccent": "subtle",
  "registries": {}
}
{{/if}}
`],
  ["frontend/native/uniwind/components/container.tsx.hbs", `import { cn } from "heroui-native";
import { type PropsWithChildren } from "react";
import { ScrollView, View, type ViewProps } from "react-native";
import Animated, { type AnimatedProps } from "react-native-reanimated";
import { useSafeAreaInsets } from "react-native-safe-area-context";

const AnimatedView = Animated.createAnimatedComponent(View);

type Props = AnimatedProps<ViewProps> & {
	className?: string;
};

export function Container({
	children,
	className,
	...props
}: PropsWithChildren<Props>) {
	const insets = useSafeAreaInsets();

	return (
		<AnimatedView
			className={cn("flex-1 bg-background", className)}
			style=\\{{
				paddingBottom: insets.bottom,
			}}
			{...props}
		>
			<ScrollView contentContainerStyle=\\{{ flexGrow: 1 }}>
				{children}
			</ScrollView>
		</AnimatedView>
	);
}
`],
  ["frontend/native/uniwind/components/theme-toggle.tsx.hbs", `import { Ionicons } from '@expo/vector-icons';
import * as Haptics from 'expo-haptics';
import { Platform, Pressable } from 'react-native';
import Animated, { FadeOut, ZoomIn } from 'react-native-reanimated';
import { withUniwind } from 'uniwind';
import { useAppTheme } from '@/contexts/app-theme-context';

const StyledIonicons = withUniwind(Ionicons);

export function ThemeToggle() {
	const { toggleTheme, isLight } = useAppTheme();

	return (
		<Pressable
			onPress={() => {
				if (Platform.OS === 'ios') {
					Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
				}
				toggleTheme();
			}}
			className="px-2.5"
		>
			{isLight ? (
				<Animated.View key="moon" entering={ZoomIn} exiting={FadeOut}>
					<StyledIonicons name="moon" size={20} className="text-foreground" />
				</Animated.View>
			) : (
				<Animated.View key="sun" entering={ZoomIn} exiting={FadeOut}>
					<StyledIonicons name="sunny" size={20} className="text-foreground" />
				</Animated.View>
			)}
		</Pressable>
	);
}

`],
  ["rust-base/crates/proto/src/lib.rs.hbs", `//! Protocol buffer definitions for {{projectName}}.
//!
//! This crate contains the generated code from protobuf definitions.
//! The generated code is committed to version control to avoid requiring
//! protoc at build time.

/// Generated gRPC service definitions
pub mod greeter {
    include!("generated/greeter.rs");
}

pub use greeter::greeter_server::{Greeter, GreeterServer};
pub use greeter::greeter_client::GreeterClient;
pub use greeter::{HelloRequest, HelloReply};
`],
  ["rust-base/crates/server/src/main.rs.hbs", `{{#if (eq rustWebFramework "axum")}}
use axum::{routing::get, Json, Router};
use serde::Serialize;
use tower_http::cors::CorsLayer;
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};
{{#if (eq rustOrm "sea-orm")}}
use sea_orm::{Database, DatabaseConnection};
use std::sync::Arc;
{{/if}}
{{#if (eq rustOrm "sqlx")}}
use sqlx::postgres::PgPoolOptions;
use sqlx::PgPool;
{{/if}}
{{#if (eq rustApi "tonic")}}

mod grpc;
{{/if}}
{{#if (eq rustApi "async-graphql")}}
use async_graphql::http::GraphiQLSource;
use async_graphql_axum::GraphQL;
use axum::{
    response::{Html, IntoResponse},
    routing::post,
};

mod graphql;
{{/if}}

#[derive(Serialize)]
struct HealthResponse {
    status: &'static str,
    message: &'static str,
{{#if (or (eq rustOrm "sea-orm") (eq rustOrm "sqlx"))}}
    database: &'static str,
{{/if}}
}

{{#if (eq rustOrm "sea-orm")}}
#[derive(Clone)]
pub struct AppState {
    pub db: Arc<DatabaseConnection>,
}

async fn health(
    axum::extract::State(state): axum::extract::State<AppState>,
) -> Json<HealthResponse> {
    let db_status = if state.db.ping().await.is_ok() {
        "connected"
    } else {
        "disconnected"
    };
    Json(HealthResponse {
        status: "ok",
        message: "Server is running",
        database: db_status,
    })
}
{{else if (eq rustOrm "sqlx")}}
#[derive(Clone)]
pub struct AppState {
    pub db: PgPool,
}

async fn health(
    axum::extract::State(state): axum::extract::State<AppState>,
) -> Json<HealthResponse> {
    let db_status = if state.db.acquire().await.is_ok() {
        "connected"
    } else {
        "disconnected"
    };
    Json(HealthResponse {
        status: "ok",
        message: "Server is running",
        database: db_status,
    })
}
{{else}}
async fn health() -> Json<HealthResponse> {
    Json(HealthResponse {
        status: "ok",
        message: "Server is running",
    })
}
{{/if}}

{{#if (eq rustApi "async-graphql")}}
/// GraphiQL IDE handler
async fn graphiql() -> impl IntoResponse {
    Html(
        GraphiQLSource::build()
            .endpoint("/graphql")
            .finish(),
    )
}
{{/if}}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // Load environment variables
    dotenvy::dotenv().ok();

    // Initialize tracing
    tracing_subscriber::registry()
        .with(tracing_subscriber::EnvFilter::try_from_default_env().unwrap_or_else(|_| "debug".into()))
        .with(tracing_subscriber::fmt::layer())
        .init();

{{#if (eq rustOrm "sea-orm")}}
    // Initialize database connection
    let database_url = std::env::var("DATABASE_URL")
        .expect("DATABASE_URL must be set");

    tracing::info!("Connecting to database...");
    let db = Database::connect(&database_url).await?;
    tracing::info!("Database connected successfully");

    let state = AppState { db: Arc::new(db) };

{{#if (eq rustApi "async-graphql")}}
    // Build GraphQL schema with database connection
    let schema = graphql::build_schema(state.db.clone());

    // Build router with GraphQL and state
    let app = Router::new()
        .route("/health", get(health))
        .route("/graphql", post(GraphQL::new(schema)))
        .route("/graphiql", get(graphiql))
        .layer(CorsLayer::permissive())
        .with_state(state);

    tracing::info!("GraphQL endpoint: /graphql");
    tracing::info!("GraphiQL IDE: /graphiql");
{{else}}
    // Build router with state
    let app = Router::new()
        .route("/health", get(health))
        .layer(CorsLayer::permissive())
        .with_state(state);
{{/if}}
{{else if (eq rustOrm "sqlx")}}
    // Initialize database connection pool
    let database_url = std::env::var("DATABASE_URL")
        .expect("DATABASE_URL must be set");

    tracing::info!("Connecting to database...");
    let pool = PgPoolOptions::new()
        .max_connections(5)
        .connect(&database_url)
        .await?;
    tracing::info!("Database connected successfully");

    let state = AppState { db: pool.clone() };

{{#if (eq rustApi "async-graphql")}}
    // Build GraphQL schema with database pool
    let schema = graphql::build_schema(pool);

    // Build router with GraphQL and state
    let app = Router::new()
        .route("/health", get(health))
        .route("/graphql", post(GraphQL::new(schema)))
        .route("/graphiql", get(graphiql))
        .layer(CorsLayer::permissive())
        .with_state(state);

    tracing::info!("GraphQL endpoint: /graphql");
    tracing::info!("GraphiQL IDE: /graphiql");
{{else}}
    // Build router with state
    let app = Router::new()
        .route("/health", get(health))
        .layer(CorsLayer::permissive())
        .with_state(state);
{{/if}}
{{else}}
{{#if (eq rustApi "async-graphql")}}
    // Build GraphQL schema
    let schema = graphql::build_schema();

    // Build router with GraphQL
    let app = Router::new()
        .route("/health", get(health))
        .route("/graphql", post(GraphQL::new(schema)))
        .route("/graphiql", get(graphiql))
        .layer(CorsLayer::permissive());

    tracing::info!("GraphQL endpoint: /graphql");
    tracing::info!("GraphiQL IDE: /graphiql");
{{else}}
    // Build router
    let app = Router::new()
        .route("/health", get(health))
        .layer(CorsLayer::permissive());
{{/if}}
{{/if}}

    // Get host and port from environment
    let host = std::env::var("HOST").unwrap_or_else(|_| "127.0.0.1".to_string());
    let port = std::env::var("PORT").unwrap_or_else(|_| "3000".to_string());
    let addr = format!("{}:{}", host, port);

    tracing::info!("Starting HTTP server at http://{}", addr);

{{#if (eq rustApi "tonic")}}
    // Start gRPC server on a separate port
    let grpc_port = std::env::var("GRPC_PORT").unwrap_or_else(|_| "50051".to_string());
    let grpc_addr = format!("{}:{}", host, grpc_port).parse()?;

    tracing::info!("Starting gRPC server at {}", grpc_addr);

    let grpc_server = tonic::transport::Server::builder()
        .add_service(grpc::create_grpc_server())
        .serve(grpc_addr);

    // Start HTTP server
    let listener = tokio::net::TcpListener::bind(&addr).await?;
    let http_server = axum::serve(listener, app);

    // Run both servers concurrently
    tokio::select! {
        result = http_server => {
            if let Err(e) = result {
                tracing::error!("HTTP server error: {}", e);
            }
        }
        result = grpc_server => {
            if let Err(e) = result {
                tracing::error!("gRPC server error: {}", e);
            }
        }
    }
{{else}}
    // Start server
    let listener = tokio::net::TcpListener::bind(&addr).await?;
    axum::serve(listener, app).await?;
{{/if}}

    Ok(())
}
{{else if (eq rustWebFramework "actix-web")}}
use actix_cors::Cors;
use actix_web::{get, web, App, HttpResponse, HttpServer, Responder};
use serde::Serialize;
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};
{{#if (eq rustOrm "sea-orm")}}
use sea_orm::{Database, DatabaseConnection};
use std::sync::Arc;
{{/if}}
{{#if (eq rustOrm "sqlx")}}
use sqlx::postgres::PgPoolOptions;
use sqlx::PgPool;
{{/if}}
{{#if (eq rustApi "tonic")}}

mod grpc;
{{/if}}
{{#if (eq rustApi "async-graphql")}}
use async_graphql::http::GraphiQLSource;
use async_graphql_actix_web::{GraphQLRequest, GraphQLResponse};

mod graphql;
{{/if}}

#[derive(Serialize)]
struct HealthResponse {
    status: &'static str,
    message: &'static str,
{{#if (or (eq rustOrm "sea-orm") (eq rustOrm "sqlx"))}}
    database: &'static str,
{{/if}}
}

{{#if (eq rustOrm "sea-orm")}}
pub struct AppState {
    pub db: Arc<DatabaseConnection>,
}

#[get("/health")]
async fn health(data: web::Data<AppState>) -> impl Responder {
    let db_status = if data.db.ping().await.is_ok() {
        "connected"
    } else {
        "disconnected"
    };
    HttpResponse::Ok().json(HealthResponse {
        status: "ok",
        message: "Server is running",
        database: db_status,
    })
}
{{else if (eq rustOrm "sqlx")}}
pub struct AppState {
    pub db: PgPool,
}

#[get("/health")]
async fn health(data: web::Data<AppState>) -> impl Responder {
    let db_status = if data.db.acquire().await.is_ok() {
        "connected"
    } else {
        "disconnected"
    };
    HttpResponse::Ok().json(HealthResponse {
        status: "ok",
        message: "Server is running",
        database: db_status,
    })
}
{{else}}
#[get("/health")]
async fn health() -> impl Responder {
    HttpResponse::Ok().json(HealthResponse {
        status: "ok",
        message: "Server is running",
    })
}
{{/if}}

{{#if (eq rustApi "async-graphql")}}
/// GraphQL endpoint handler
async fn graphql_handler(
    schema: web::Data<graphql::GraphQLSchema>,
    req: GraphQLRequest,
) -> GraphQLResponse {
    schema.execute(req.into_inner()).await.into()
}

/// GraphiQL IDE handler
#[get("/graphiql")]
async fn graphiql() -> impl Responder {
    HttpResponse::Ok()
        .content_type("text/html; charset=utf-8")
        .body(
            GraphiQLSource::build()
                .endpoint("/graphql")
                .finish(),
        )
}
{{/if}}

#[actix_web::main]
async fn main() -> anyhow::Result<()> {
    // Load environment variables
    dotenvy::dotenv().ok();

    // Initialize tracing
    tracing_subscriber::registry()
        .with(tracing_subscriber::EnvFilter::try_from_default_env().unwrap_or_else(|_| "debug".into()))
        .with(tracing_subscriber::fmt::layer())
        .init();

{{#if (eq rustOrm "sea-orm")}}
    // Initialize database connection
    let database_url = std::env::var("DATABASE_URL")
        .expect("DATABASE_URL must be set");

    tracing::info!("Connecting to database...");
    let db = Database::connect(&database_url).await?;
    tracing::info!("Database connected successfully");

    let db_arc = Arc::new(db);
    let state = web::Data::new(AppState { db: db_arc.clone() });
{{#if (eq rustApi "async-graphql")}}

    // Build GraphQL schema with database
    let schema = web::Data::new(graphql::build_schema(db_arc));
    tracing::info!("GraphQL endpoint: /graphql");
    tracing::info!("GraphiQL IDE: /graphiql");
{{/if}}
{{/if}}
{{#if (eq rustOrm "sqlx")}}
    // Initialize database connection pool
    let database_url = std::env::var("DATABASE_URL")
        .expect("DATABASE_URL must be set");

    tracing::info!("Connecting to database...");
    let pool = PgPoolOptions::new()
        .max_connections(5)
        .connect(&database_url)
        .await?;
    tracing::info!("Database connected successfully");

    let state = web::Data::new(AppState { db: pool.clone() });
{{#if (eq rustApi "async-graphql")}}

    // Build GraphQL schema with database pool
    let schema = web::Data::new(graphql::build_schema(pool));
    tracing::info!("GraphQL endpoint: /graphql");
    tracing::info!("GraphiQL IDE: /graphiql");
{{/if}}
{{/if}}
{{#if (and (not (eq rustOrm "sea-orm")) (not (eq rustOrm "sqlx")) (eq rustApi "async-graphql"))}}
    // Build GraphQL schema
    let schema = web::Data::new(graphql::build_schema());
    tracing::info!("GraphQL endpoint: /graphql");
    tracing::info!("GraphiQL IDE: /graphiql");
{{/if}}

    // Get host and port from environment
    let host = std::env::var("HOST").unwrap_or_else(|_| "127.0.0.1".to_string());
    let port: u16 = std::env::var("PORT")
        .unwrap_or_else(|_| "3000".to_string())
        .parse()?;

    tracing::info!("Starting HTTP server at http://{}:{}", host, port);

{{#if (eq rustApi "tonic")}}
    // Start gRPC server on a separate port
    let grpc_port = std::env::var("GRPC_PORT").unwrap_or_else(|_| "50051".to_string());
    let grpc_host = host.clone();
    let grpc_addr = format!("{}:{}", grpc_host, grpc_port).parse()?;

    tracing::info!("Starting gRPC server at {}", grpc_addr);

    // Spawn gRPC server in a separate task
    let grpc_handle = tokio::spawn(async move {
        tonic::transport::Server::builder()
            .add_service(grpc::create_grpc_server())
            .serve(grpc_addr)
            .await
    });

    // Start HTTP server
{{#if (or (eq rustOrm "sea-orm") (eq rustOrm "sqlx"))}}
    let http_server = HttpServer::new(move || {
        let cors = Cors::permissive();
        App::new()
            .wrap(cors)
            .app_data(state.clone())
            .service(health)
    })
{{else}}
    let http_server = HttpServer::new(|| {
        let cors = Cors::permissive();
        App::new()
            .wrap(cors)
            .service(health)
    })
{{/if}}
    .bind((host, port))?
    .run();

    // Run both servers concurrently
    tokio::select! {
        result = http_server => {
            if let Err(e) = result {
                tracing::error!("HTTP server error: {}", e);
            }
        }
        result = grpc_handle => {
            match result {
                Ok(Ok(())) => {}
                Ok(Err(e)) => tracing::error!("gRPC server error: {}", e),
                Err(e) => tracing::error!("gRPC task error: {}", e),
            }
        }
    }
{{else if (eq rustApi "async-graphql")}}
    // Start server with GraphQL
{{#if (or (eq rustOrm "sea-orm") (eq rustOrm "sqlx"))}}
    HttpServer::new(move || {
        let cors = Cors::permissive();
        App::new()
            .wrap(cors)
            .app_data(state.clone())
            .app_data(schema.clone())
            .service(health)
            .service(graphiql)
            .route("/graphql", web::post().to(graphql_handler))
    })
{{else}}
    HttpServer::new(move || {
        let cors = Cors::permissive();
        App::new()
            .wrap(cors)
            .app_data(schema.clone())
            .service(health)
            .service(graphiql)
            .route("/graphql", web::post().to(graphql_handler))
    })
{{/if}}
    .bind((host, port))?
    .run()
    .await?;
{{else}}
    // Start server
{{#if (or (eq rustOrm "sea-orm") (eq rustOrm "sqlx"))}}
    HttpServer::new(move || {
        let cors = Cors::permissive();
        App::new()
            .wrap(cors)
            .app_data(state.clone())
            .service(health)
    })
{{else}}
    HttpServer::new(|| {
        let cors = Cors::permissive();
        App::new()
            .wrap(cors)
            .service(health)
    })
{{/if}}
    .bind((host, port))?
    .run()
    .await?;
{{/if}}

    Ok(())
}
{{else}}
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};
{{#if (eq rustApi "tonic")}}

mod grpc;
{{/if}}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // Load environment variables
    dotenvy::dotenv().ok();

    // Initialize tracing
    tracing_subscriber::registry()
        .with(tracing_subscriber::EnvFilter::try_from_default_env().unwrap_or_else(|_| "debug".into()))
        .with(tracing_subscriber::fmt::layer())
        .init();

{{#if (eq rustApi "tonic")}}
    // Get host and port from environment
    let host = std::env::var("HOST").unwrap_or_else(|_| "127.0.0.1".to_string());
    let grpc_port = std::env::var("GRPC_PORT").unwrap_or_else(|_| "50051".to_string());
    let grpc_addr = format!("{}:{}", host, grpc_port).parse()?;

    tracing::info!("Starting gRPC server at {}", grpc_addr);

    tonic::transport::Server::builder()
        .add_service(grpc::create_grpc_server())
        .serve(grpc_addr)
        .await?;
{{else}}
    tracing::info!("Hello from {{projectName}}!");
    tracing::info!("Add a web framework (axum or actix-web) to start building your API.");
{{/if}}

    Ok(())
}
{{/if}}
`],
  ["rust-base/crates/server/src/graphql.rs.hbs", `use async_graphql::{Context, EmptySubscription, Object, Schema};
{{#if (eq rustOrm "sea-orm")}}
use sea_orm::DatabaseConnection;
use std::sync::Arc;
{{/if}}
{{#if (eq rustOrm "sqlx")}}
use sqlx::PgPool;
{{/if}}

/// GraphQL Query root
pub struct QueryRoot;

#[Object]
impl QueryRoot {
    /// Returns a greeting message
    async fn hello(&self, name: Option<String>) -> String {
        format!("Hello, {}!", name.unwrap_or_else(|| "World".to_string()))
    }

    /// Returns the server status
    async fn status(&self) -> &'static str {
        "Server is running"
    }

{{#if (eq rustOrm "sea-orm")}}
    /// Example query using database connection
    async fn db_status(&self, ctx: &Context<'_>) -> async_graphql::Result<String> {
        let db = ctx.data::<Arc<DatabaseConnection>>()?;
        match db.ping().await {
            Ok(_) => Ok("Database connected".to_string()),
            Err(e) => Ok(format!("Database error: {}", e)),
        }
    }
{{/if}}
{{#if (eq rustOrm "sqlx")}}
    /// Example query using database pool
    async fn db_status(&self, ctx: &Context<'_>) -> async_graphql::Result<String> {
        let pool = ctx.data::<PgPool>()?;
        match pool.acquire().await {
            Ok(_) => Ok("Database connected".to_string()),
            Err(e) => Ok(format!("Database error: {}", e)),
        }
    }
{{/if}}
}

/// GraphQL Mutation root
pub struct MutationRoot;

#[Object]
impl MutationRoot {
    /// Example mutation that echoes back a message
    async fn echo(&self, message: String) -> String {
        message
    }
}

/// The GraphQL schema type
pub type GraphQLSchema = Schema<QueryRoot, MutationRoot, EmptySubscription>;

/// Build the GraphQL schema with optional data sources
{{#if (eq rustOrm "sea-orm")}}
pub fn build_schema(db: Arc<DatabaseConnection>) -> GraphQLSchema {
    Schema::build(QueryRoot, MutationRoot, EmptySubscription)
        .data(db)
        .finish()
}
{{else if (eq rustOrm "sqlx")}}
pub fn build_schema(pool: PgPool) -> GraphQLSchema {
    Schema::build(QueryRoot, MutationRoot, EmptySubscription)
        .data(pool)
        .finish()
}
{{else}}
pub fn build_schema() -> GraphQLSchema {
    Schema::build(QueryRoot, MutationRoot, EmptySubscription)
        .finish()
}
{{/if}}
`],
  ["rust-base/crates/server/src/grpc.rs.hbs", `//! gRPC service implementations for {{projectName}}.

use {{projectName}}_proto::{Greeter, GreeterServer, HelloReply, HelloRequest};
use tokio_stream::wrappers::ReceiverStream;
use tonic::{Request, Response, Status};

/// Implementation of the Greeter gRPC service.
#[derive(Debug, Default)]
pub struct GreeterService;

#[tonic::async_trait]
impl Greeter for GreeterService {
    /// Handle a unary greeting request.
    async fn say_hello(
        &self,
        request: Request<HelloRequest>,
    ) -> Result<Response<HelloReply>, Status> {
        let name = request.into_inner().name;
        tracing::info!("Received gRPC request: SayHello from '{}'", name);

        let reply = HelloReply {
            message: format!("Hello, {}!", name),
        };

        Ok(Response::new(reply))
    }

    type SayHelloStreamStream = ReceiverStream<Result<HelloReply, Status>>;

    /// Handle a streaming greeting request.
    async fn say_hello_stream(
        &self,
        request: Request<HelloRequest>,
    ) -> Result<Response<Self::SayHelloStreamStream>, Status> {
        let name = request.into_inner().name;
        tracing::info!("Received gRPC streaming request: SayHelloStream from '{}'", name);

        let (tx, rx) = tokio::sync::mpsc::channel(4);

        tokio::spawn(async move {
            for i in 1..=5 {
                let reply = HelloReply {
                    message: format!("Hello #{} to {}!", i, name),
                };
                if tx.send(Ok(reply)).await.is_err() {
                    break;
                }
                tokio::time::sleep(tokio::time::Duration::from_millis(500)).await;
            }
        });

        Ok(Response::new(ReceiverStream::new(rx)))
    }
}

/// Create and configure the gRPC server.
pub fn create_grpc_server() -> GreeterServer<GreeterService> {
    GreeterServer::new(GreeterService::default())
}
`],
  ["rust-base/crates/cli/src/main.rs.hbs", `use anyhow::Result;
use clap::{Parser, Subcommand};
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};

/// {{projectName}} CLI - Command-line interface
#[derive(Parser, Debug)]
#[command(name = "{{projectName}}")]
#[command(author, version, about, long_about = None)]
struct Cli {
    /// Turn on verbose output
    #[arg(short, long, global = true)]
    verbose: bool,

    /// Config file path
    #[arg(short, long, global = true)]
    config: Option<String>,

    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand, Debug)]
enum Commands {
    /// Start the application
    Start {
        /// Port to listen on
        #[arg(short, long, default_value = "3000")]
        port: u16,

        /// Host to bind to
        #[arg(short = 'H', long, default_value = "127.0.0.1")]
        host: String,
    },

    /// Check configuration and health
    Check {
        /// Check database connection
        #[arg(long)]
        database: bool,

        /// Check all services
        #[arg(long)]
        all: bool,
    },

    /// Run database migrations
    Migrate {
        /// Run pending migrations
        #[arg(long)]
        up: bool,

        /// Rollback last migration
        #[arg(long)]
        down: bool,

        /// Migration status
        #[arg(long)]
        status: bool,
    },

    /// Generate project components
    Generate {
        /// Component type to generate
        #[arg(value_enum)]
        component: GenerateComponent,

        /// Name for the generated component
        name: String,
    },
}

#[derive(clap::ValueEnum, Clone, Debug)]
enum GenerateComponent {
    /// Generate a new model
    Model,
    /// Generate a new handler/controller
    Handler,
    /// Generate a new service
    Service,
    /// Generate a new migration
    Migration,
}

#[tokio::main]
async fn main() -> Result<()> {
    // Load environment variables
    dotenvy::dotenv().ok();

    let cli = Cli::parse();

    // Initialize tracing with verbosity level
    let filter = if cli.verbose { "debug" } else { "info" };
    tracing_subscriber::registry()
        .with(tracing_subscriber::EnvFilter::try_from_default_env().unwrap_or_else(|_| filter.into()))
        .with(tracing_subscriber::fmt::layer())
        .init();

    if let Some(config_path) = &cli.config {
        tracing::info!("Using config file: {}", config_path);
    }

    match cli.command {
        Commands::Start { port, host } => {
            tracing::info!("Starting server on {}:{}", host, port);
            // TODO: Implement server start logic
            // This is where you would start your Axum/Actix server
            println!("Server would start on {}:{}", host, port);
        }

        Commands::Check { database, all } => {
            tracing::info!("Running health checks...");

            if database || all {
                tracing::info!("Checking database connection...");
                // TODO: Implement database check
                println!("Database check: Not implemented");
            }

            if all {
                tracing::info!("Checking all services...");
                // TODO: Implement other service checks
                println!("All checks complete");
            }

            if !database && !all {
                println!("No checks specified. Use --database or --all");
            }
        }

        Commands::Migrate { up, down, status } => {
            if status {
                tracing::info!("Checking migration status...");
                // TODO: Implement migration status check
                println!("Migration status: Not implemented");
            } else if up {
                tracing::info!("Running pending migrations...");
                // TODO: Implement migration up
                println!("Migrations run: Not implemented");
            } else if down {
                tracing::info!("Rolling back last migration...");
                // TODO: Implement migration down
                println!("Migration rollback: Not implemented");
            } else {
                println!("No migration action specified. Use --up, --down, or --status");
            }
        }

        Commands::Generate { component, name } => {
            tracing::info!("Generating {:?}: {}", component, name);
            match component {
                GenerateComponent::Model => {
                    println!("Would generate model: {}", name);
                    // TODO: Implement model generation
                }
                GenerateComponent::Handler => {
                    println!("Would generate handler: {}", name);
                    // TODO: Implement handler generation
                }
                GenerateComponent::Service => {
                    println!("Would generate service: {}", name);
                    // TODO: Implement service generation
                }
                GenerateComponent::Migration => {
                    println!("Would generate migration: {}", name);
                    // TODO: Implement migration generation
                }
            }
        }
    }

    Ok(())
}
`],
  ["rust-base/crates/client/style/main.css", `/* Leptos Application Styles */

:root {
  --bg-color: #1a1a2e;
  --text-color: #eaeaea;
  --primary-color: #e94560;
  --secondary-color: #16213e;
  --accent-color: #0f3460;
}

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family:
    -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans",
    "Helvetica Neue", sans-serif;
  background-color: var(--bg-color);
  color: var(--text-color);
  min-height: 100vh;
  display: flex;
  justify-content: center;
  align-items: center;
}

.container {
  max-width: 800px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

h1 {
  font-size: 2.5rem;
  margin-bottom: 1rem;
  color: var(--primary-color);
}

h2 {
  font-size: 1.5rem;
  margin: 1.5rem 0 1rem;
  color: var(--text-color);
}

p {
  font-size: 1.1rem;
  line-height: 1.6;
  margin-bottom: 1rem;
  opacity: 0.9;
}

.home,
.about {
  background: var(--secondary-color);
  border-radius: 12px;
  padding: 2rem;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
}

.counter {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 1rem;
  margin: 2rem 0;
}

.count {
  font-size: 2rem;
  font-weight: bold;
  min-width: 4rem;
  padding: 0.5rem 1rem;
  background: var(--accent-color);
  border-radius: 8px;
}

.btn {
  font-size: 1.5rem;
  padding: 0.5rem 1.5rem;
  background: var(--primary-color);
  color: white;
  border: none;
  border-radius: 8px;
  cursor: pointer;
  transition:
    transform 0.1s,
    background 0.2s;
}

.btn:hover {
  background: #ff6b6b;
}

.btn:active {
  transform: scale(0.95);
}

nav {
  margin-top: 2rem;
}

nav a {
  color: var(--primary-color);
  text-decoration: none;
  font-weight: 500;
  padding: 0.5rem 1rem;
  border: 2px solid var(--primary-color);
  border-radius: 6px;
  transition: all 0.2s;
}

nav a:hover {
  background: var(--primary-color);
  color: white;
}

ul {
  list-style: none;
  text-align: left;
  max-width: 400px;
  margin: 0 auto;
}

ul li {
  padding: 0.5rem 0;
  padding-left: 1.5rem;
  position: relative;
}

ul li::before {
  content: "\\2713";
  position: absolute;
  left: 0;
  color: var(--primary-color);
}
`],
  ["rust-base/crates/proto/proto/greeter.proto.hbs", `syntax = "proto3";

package greeter;

// The greeting service definition.
service Greeter {
  // Sends a greeting
  rpc SayHello (HelloRequest) returns (HelloReply) {}

  // Sends a streaming greeting
  rpc SayHelloStream (HelloRequest) returns (stream HelloReply) {}
}

// The request message containing the user's name.
message HelloRequest {
  string name = 1;
}

// The response message containing the greeting.
message HelloReply {
  string message = 1;
}
`],
  ["rust-base/crates/client/src/lib.rs.hbs", `use leptos::prelude::*;
use leptos_meta::*;
use leptos_router::components::*;
use leptos_router::path;

/// Main application component
#[component]
pub fn App() -> impl IntoView {
    // Provides context for managing document head metadata
    provide_meta_context();

    view! {
        <Stylesheet id="leptos" href="/pkg/{{projectName}}_client.css"/>
        <Title text="{{projectName}} - Built with Leptos"/>
        <Meta name="description" content="A Rust WASM application built with Leptos"/>

        <Router>
            <main class="container">
                <Routes fallback=|| "Page not found.".into_view()>
                    <Route path=path!("/") view=HomePage/>
                    <Route path=path!("/about") view=AboutPage/>
                </Routes>
            </main>
        </Router>
    }
}

/// Home page component
#[component]
fn HomePage() -> impl IntoView {
    let (count, set_count) = signal(0);

    view! {
        <div class="home">
            <h1>"Welcome to {{projectName}}"</h1>
            <p>"A full-stack Rust application powered by Leptos"</p>

            <div class="counter">
                <button
                    class="btn"
                    on:click=move |_| set_count.update(|n| *n -= 1)
                >
                    "-"
                </button>
                <span class="count">{count}</span>
                <button
                    class="btn"
                    on:click=move |_| set_count.update(|n| *n += 1)
                >
                    "+"
                </button>
            </div>

            <nav>
                <a href="/about">"About"</a>
            </nav>
        </div>
    }
}

/// About page component
#[component]
fn AboutPage() -> impl IntoView {
    view! {
        <div class="about">
            <h1>"About"</h1>
            <p>"This application was generated with Better-Fullstack using the Leptos framework."</p>

            <h2>"Technology Stack"</h2>
            <ul>
                <li>"Leptos - Fine-grained reactive framework"</li>
                <li>"Rust + WebAssembly - High-performance frontend"</li>
{{#if (eq rustWebFramework "axum")}}
                <li>"Axum - Ergonomic web framework by Tokio team"</li>
{{/if}}
{{#if (eq rustWebFramework "actix-web")}}
                <li>"Actix-web - Powerful, pragmatic web framework"</li>
{{/if}}
            </ul>

            <nav>
                <a href="/">"Back to Home"</a>
            </nav>
        </div>
    }
}

/// Initialize the Leptos client-side app
#[wasm_bindgen::prelude::wasm_bindgen(start)]
pub fn main() {
    // Set up better panic messages in console
    console_error_panic_hook::set_once();

    // Initialize logging
    _ = console_log::init_with_level(log::Level::Debug);

    log::info!("Starting Leptos client application");

    leptos::mount::mount_to_body(App);
}
`],
  ["api/garph/native/utils/garph.ts.hbs", `import { QueryClient } from "@tanstack/react-query";
import { createClient, type InferClient } from "@garph/gqty";
import {
  createGeneratedSchema,
  createScalarsEnumsHash,
} from "@garph/gqty/dist/utils";
import {
  g,
  queryType,
  mutationType,
{{#if (includes examples "todo")}}
  todoType,
{{/if}}
} from "@{{projectName}}/api/index";
import { API_URL } from "@/lib/api";

// Create QueryClient for React Query integration
export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      retry: 2,
      staleTime: 1000 * 60,
    },
  },
});

// Generate schema and scalars for GQty client
const generatedSchema = createGeneratedSchema(g);
const scalarsEnumsHash = createScalarsEnumsHash(g);

// Create type-safe GraphQL client
export const client = createClient<{
  query: InferClient<typeof queryType>;
  mutation: InferClient<typeof mutationType>;
}>({
  generatedSchema,
  scalarsEnumsHash,
  url: \`\${API_URL}/graphql\`,
{{#if (eq auth "better-auth")}}
  credentials: "include",
{{/if}}
});

// Export typed query and mutation functions
export const { query, mutation, resolved } = client;

// Helper for React Query integration
export async function graphqlFetcher<T>(
  fn: () => T | Promise<T>
): Promise<T> {
  return resolved(fn);
}
`],
  ["rust-base/crates/dioxus-client/assets/main.css", `/* Dioxus Application Styles */

:root {
  --bg-color: #1a1a2e;
  --text-color: #eaeaea;
  --primary-color: #00b4d8;
  --secondary-color: #16213e;
  --accent-color: #0f3460;
}

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family:
    -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans",
    "Helvetica Neue", sans-serif;
  background-color: var(--bg-color);
  color: var(--text-color);
  min-height: 100vh;
  display: flex;
  justify-content: center;
  align-items: center;
}

.container {
  max-width: 800px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

h1 {
  font-size: 2.5rem;
  margin-bottom: 1rem;
  color: var(--primary-color);
}

h2 {
  font-size: 1.5rem;
  margin: 1.5rem 0 1rem;
  color: var(--text-color);
}

p {
  font-size: 1.1rem;
  line-height: 1.6;
  margin-bottom: 1rem;
  opacity: 0.9;
}

.home,
.about {
  background: var(--secondary-color);
  border-radius: 12px;
  padding: 2rem;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
}

.counter {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 1rem;
  margin: 2rem 0;
}

.count {
  font-size: 2rem;
  font-weight: bold;
  min-width: 4rem;
  padding: 0.5rem 1rem;
  background: var(--accent-color);
  border-radius: 8px;
}

.btn {
  font-size: 1.5rem;
  padding: 0.5rem 1.5rem;
  background: var(--primary-color);
  color: white;
  border: none;
  border-radius: 8px;
  cursor: pointer;
  transition:
    transform 0.1s,
    background 0.2s;
}

.btn:hover {
  background: #48cae4;
}

.btn:active {
  transform: scale(0.95);
}

nav {
  margin-top: 2rem;
}

nav a {
  color: var(--primary-color);
  text-decoration: none;
  font-weight: 500;
  padding: 0.5rem 1rem;
  border: 2px solid var(--primary-color);
  border-radius: 6px;
  transition: all 0.2s;
}

nav a:hover {
  background: var(--primary-color);
  color: white;
}

ul {
  list-style: none;
  text-align: left;
  max-width: 400px;
  margin: 0 auto;
}

ul li {
  padding: 0.5rem 0;
  padding-left: 1.5rem;
  position: relative;
}

ul li::before {
  content: "\\2713";
  position: absolute;
  left: 0;
  color: var(--primary-color);
}
`],
  ["rust-base/crates/dioxus-client/src/main.rs.hbs", `#![allow(non_snake_case)]

use dioxus::prelude::*;
use dioxus_router::prelude::*;
use tracing::info;

/// Application routes
#[derive(Clone, Routable, Debug, PartialEq)]
enum Route {
    #[route("/")]
    Home {},
    #[route("/about")]
    About {},
}

fn main() {
    // Set up better panic messages in console
    console_error_panic_hook::set_once();

    // Initialize logging
    dioxus_logger::init(tracing::Level::INFO).expect("Failed to init logger");

    info!("Starting Dioxus client application");

    launch(App);
}

/// Main application component
fn App() -> Element {
    rsx! {
        Router::<Route> {}
    }
}

/// Home page component
#[component]
fn Home() -> Element {
    let mut count = use_signal(|| 0);

    rsx! {
        div { class: "container",
            div { class: "home",
                h1 { "Welcome to {{projectName}}" }
                p { "A full-stack Rust application powered by Dioxus" }

                div { class: "counter",
                    button {
                        class: "btn",
                        onclick: move |_| count -= 1,
                        "-"
                    }
                    span { class: "count", "{count}" }
                    button {
                        class: "btn",
                        onclick: move |_| count += 1,
                        "+"
                    }
                }

                nav {
                    Link { to: Route::About {}, "About" }
                }
            }
        }
    }
}

/// About page component
#[component]
fn About() -> Element {
    rsx! {
        div { class: "container",
            div { class: "about",
                h1 { "About" }
                p { "This application was generated with Better-Fullstack using the Dioxus framework." }

                h2 { "Technology Stack" }
                ul {
                    li { "Dioxus - React-like reactive framework" }
                    li { "Rust + WebAssembly - High-performance frontend" }
{{#if (eq rustWebFramework "axum")}}
                    li { "Axum - Ergonomic web framework by Tokio team" }
{{/if}}
{{#if (eq rustWebFramework "actix-web")}}
                    li { "Actix-web - Powerful, pragmatic web framework" }
{{/if}}
                }

                nav {
                    Link { to: Route::Home {}, "Back to Home" }
                }
            }
        }
    }
}
`],
  ["api/garph/server/src/context.ts.hbs", `{{#if (eq backend "hono")}}
import type { Context as HonoContext } from "hono";
{{#if (eq auth "better-auth")}}
import type { Session, User } from "better-auth";
{{/if}}

export type Context = {
  honoContext: HonoContext;
{{#if (eq auth "better-auth")}}
  session: { user: User; session: Session } | null;
{{/if}}
};

export function createContext(c: HonoContext{{#if (eq auth "better-auth")}}, session: { user: User; session: Session } | null{{/if}}): Context {
  return {
    honoContext: c,
{{#if (eq auth "better-auth")}}
    session,
{{/if}}
  };
}
{{else if (eq backend "elysia")}}
{{#if (eq auth "better-auth")}}
import type { Session, User } from "better-auth";
{{/if}}

export type Context = {
{{#if (eq auth "better-auth")}}
  session: { user: User; session: Session } | null;
{{/if}}
};

export function createContext({{#if (eq auth "better-auth")}}session: { user: User; session: Session } | null{{/if}}): Context {
  return {
{{#if (eq auth "better-auth")}}
    session,
{{/if}}
  };
}
{{else if (eq backend "express")}}
import type { Request } from "express";
{{#if (eq auth "better-auth")}}
import type { Session, User } from "better-auth";
{{/if}}

export type Context = {
  req: Request;
{{#if (eq auth "better-auth")}}
  session: { user: User; session: Session } | null;
{{/if}}
};

export function createContext(req: Request{{#if (eq auth "better-auth")}}, session: { user: User; session: Session } | null{{/if}}): Context {
  return {
    req,
{{#if (eq auth "better-auth")}}
    session,
{{/if}}
  };
}
{{else if (eq backend "fastify")}}
import type { FastifyRequest } from "fastify";
{{#if (eq auth "better-auth")}}
import type { Session, User } from "better-auth";
{{/if}}

export type Context = {
  req: FastifyRequest;
{{#if (eq auth "better-auth")}}
  session: { user: User; session: Session } | null;
{{/if}}
};

export function createContext(req: FastifyRequest{{#if (eq auth "better-auth")}}, session: { user: User; session: Session } | null{{/if}}): Context {
  return {
    req,
{{#if (eq auth "better-auth")}}
    session,
{{/if}}
  };
}
{{else if (eq backend "self")}}
{{#if (includes frontend "next")}}
import type { NextRequest } from "next/server";
{{#if (eq auth "better-auth")}}
import type { Session, User } from "better-auth";
{{/if}}

export type Context = {
  req: NextRequest;
{{#if (eq auth "better-auth")}}
  session: { user: User; session: Session } | null;
{{/if}}
};

export function createContext(req: NextRequest{{#if (eq auth "better-auth")}}, session: { user: User; session: Session } | null{{/if}}): Context {
  return {
    req,
{{#if (eq auth "better-auth")}}
    session,
{{/if}}
  };
}
{{else if (includes frontend "tanstack-start")}}
{{#if (eq auth "better-auth")}}
import type { Session, User } from "better-auth";
{{/if}}

export type Context = {
  request: Request;
{{#if (eq auth "better-auth")}}
  session: { user: User; session: Session } | null;
{{/if}}
};

export function createContext(request: Request{{#if (eq auth "better-auth")}}, session: { user: User; session: Session } | null{{/if}}): Context {
  return {
    request,
{{#if (eq auth "better-auth")}}
    session,
{{/if}}
  };
}
{{else if (includes frontend "astro")}}
import type { APIContext } from "astro";
{{#if (eq auth "better-auth")}}
import type { Session, User } from "better-auth";
{{/if}}

export type Context = {
  astroContext: APIContext;
{{#if (eq auth "better-auth")}}
  session: { user: User; session: Session } | null;
{{/if}}
};

export function createContext(astroContext: APIContext{{#if (eq auth "better-auth")}}, session: { user: User; session: Session } | null{{/if}}): Context {
  return {
    astroContext,
{{#if (eq auth "better-auth")}}
    session,
{{/if}}
  };
}
{{/if}}
{{/if}}
`],
  ["api/garph/server/src/index.ts.hbs", `import { g, buildSchema, InferResolvers } from "garph";

// Define GraphQL types using Garph's type-safe builder
{{#if (includes examples "todo")}}
export const todoType = g.type("Todo", {
  id: g.int(),
  content: g.string(),
  completed: g.boolean(),
  createdAt: g.string(),
});
{{/if}}

{{#if (eq auth "better-auth")}}
export const userType = g.type("User", {
  id: g.string(),
  email: g.string(),
  name: g.string().nullable(),
});

export const privateDataType = g.type("PrivateData", {
  message: g.string(),
  user: g.ref(userType),
});
{{/if}}

export const queryType = g.type("Query", {
  health: g.string().description("Health check endpoint"),
{{#if (eq auth "better-auth")}}
  privateData: g.ref(privateDataType).nullable().description("Get private data (requires authentication)"),
{{/if}}
{{#if (includes examples "todo")}}
  todos: g.ref(todoType).list().description("Get all todos"),
  todo: g
    .ref(todoType)
    .nullable()
    .args({ id: g.int() })
    .description("Get a single todo by ID"),
{{/if}}
});

export const mutationType = g.type("Mutation", {
{{#if (includes examples "todo")}}
  createTodo: g
    .ref(todoType)
    .args({ content: g.string() })
    .description("Create a new todo"),
  toggleTodo: g
    .ref(todoType)
    .nullable()
    .args({ id: g.int() })
    .description("Toggle a todo's completed status"),
  deleteTodo: g
    .boolean()
    .args({ id: g.int() })
    .description("Delete a todo"),
{{/if}}
  _empty: g.string().nullable().description("Placeholder mutation"),
});

// Export types for resolver type inference
export type QueryType = typeof queryType;
export type MutationType = typeof mutationType;
{{#if (includes examples "todo")}}
export type TodoType = typeof todoType;
{{/if}}

// Re-export Garph utilities for use in resolvers
export { g, buildSchema, type InferResolvers };
`],
  ["api/ts-rest/server/src/context.ts.hbs", `{{#if (eq backend "hono")}}
import type { Context as HonoContext } from "hono";
{{#if (eq auth "better-auth")}}
import type { Session, User } from "better-auth";
{{/if}}

export type Context = {
  honoContext: HonoContext;
{{#if (eq auth "better-auth")}}
  session: { user: User; session: Session } | null;
{{/if}}
};

export function createContext(c: HonoContext{{#if (eq auth "better-auth")}}, session: { user: User; session: Session } | null{{/if}}): Context {
  return {
    honoContext: c,
{{#if (eq auth "better-auth")}}
    session,
{{/if}}
  };
}
{{else if (eq backend "elysia")}}
{{#if (eq auth "better-auth")}}
import type { Session, User } from "better-auth";
{{/if}}

export type Context = {
{{#if (eq auth "better-auth")}}
  session: { user: User; session: Session } | null;
{{/if}}
};

export function createContext({{#if (eq auth "better-auth")}}session: { user: User; session: Session } | null{{/if}}): Context {
  return {
{{#if (eq auth "better-auth")}}
    session,
{{/if}}
  };
}
{{else if (eq backend "express")}}
import type { Request } from "express";
{{#if (eq auth "better-auth")}}
import type { Session, User } from "better-auth";
{{/if}}

export type Context = {
  req: Request;
{{#if (eq auth "better-auth")}}
  session: { user: User; session: Session } | null;
{{/if}}
};

export function createContext(req: Request{{#if (eq auth "better-auth")}}, session: { user: User; session: Session } | null{{/if}}): Context {
  return {
    req,
{{#if (eq auth "better-auth")}}
    session,
{{/if}}
  };
}
{{else if (eq backend "fastify")}}
import type { FastifyRequest } from "fastify";
{{#if (eq auth "better-auth")}}
import type { Session, User } from "better-auth";
{{/if}}

export type Context = {
  req: FastifyRequest;
{{#if (eq auth "better-auth")}}
  session: { user: User; session: Session } | null;
{{/if}}
};

export function createContext(req: FastifyRequest{{#if (eq auth "better-auth")}}, session: { user: User; session: Session } | null{{/if}}): Context {
  return {
    req,
{{#if (eq auth "better-auth")}}
    session,
{{/if}}
  };
}
{{else if (eq backend "self")}}
{{#if (includes frontend "next")}}
import type { NextRequest } from "next/server";
{{#if (eq auth "better-auth")}}
import type { Session, User } from "better-auth";
{{/if}}

export type Context = {
  req: NextRequest;
{{#if (eq auth "better-auth")}}
  session: { user: User; session: Session } | null;
{{/if}}
};

export function createContext(req: NextRequest{{#if (eq auth "better-auth")}}, session: { user: User; session: Session } | null{{/if}}): Context {
  return {
    req,
{{#if (eq auth "better-auth")}}
    session,
{{/if}}
  };
}
{{else if (includes frontend "tanstack-start")}}
{{#if (eq auth "better-auth")}}
import type { Session, User } from "better-auth";
{{/if}}

export type Context = {
  request: Request;
{{#if (eq auth "better-auth")}}
  session: { user: User; session: Session } | null;
{{/if}}
};

export function createContext(request: Request{{#if (eq auth "better-auth")}}, session: { user: User; session: Session } | null{{/if}}): Context {
  return {
    request,
{{#if (eq auth "better-auth")}}
    session,
{{/if}}
  };
}
{{else if (includes frontend "astro")}}
import type { APIContext } from "astro";
{{#if (eq auth "better-auth")}}
import type { Session, User } from "better-auth";
{{/if}}

export type Context = {
  astroContext: APIContext;
{{#if (eq auth "better-auth")}}
  session: { user: User; session: Session } | null;
{{/if}}
};

export function createContext(astroContext: APIContext{{#if (eq auth "better-auth")}}, session: { user: User; session: Session } | null{{/if}}): Context {
  return {
    astroContext,
{{#if (eq auth "better-auth")}}
    session,
{{/if}}
  };
}
{{/if}}
{{/if}}
`],
  ["api/ts-rest/server/src/index.ts.hbs", `import { initContract } from "@ts-rest/core";
import { z } from "zod";

const c = initContract();

export const contract = c.router({
  healthCheck: {
    method: "GET",
    path: "/health",
    responses: {
      200: z.literal("OK"),
    },
  },
{{#if (eq auth "better-auth")}}
  privateData: {
    method: "GET",
    path: "/private",
    responses: {
      200: z.object({
        message: z.string(),
        user: z.object({
          id: z.string(),
          email: z.string(),
          name: z.string().nullable(),
        }),
      }),
      401: z.object({
        message: z.string(),
      }),
    },
  },
{{/if}}
{{#if (includes examples "todo")}}
  todos: {
    getAll: {
      method: "GET",
      path: "/todos",
      responses: {
        200: z.array(
          z.object({
            id: z.number(),
            content: z.string(),
            completed: z.boolean(),
            createdAt: z.string(),
          })
        ),
      },
    },
    create: {
      method: "POST",
      path: "/todos",
      body: z.object({
        content: z.string().min(1),
      }),
      responses: {
        201: z.object({
          id: z.number(),
          content: z.string(),
          completed: z.boolean(),
          createdAt: z.string(),
        }),
      },
    },
    toggle: {
      method: "PATCH",
      path: "/todos/:id/toggle",
      pathParams: z.object({
        id: z.coerce.number(),
      }),
      body: z.object({}),
      responses: {
        200: z.object({
          id: z.number(),
          content: z.string(),
          completed: z.boolean(),
          createdAt: z.string(),
        }),
        404: z.object({
          message: z.string(),
        }),
      },
    },
    delete: {
      method: "DELETE",
      path: "/todos/:id",
      pathParams: z.object({
        id: z.coerce.number(),
      }),
      body: z.object({}),
      responses: {
        200: z.object({
          success: z.boolean(),
        }),
        404: z.object({
          message: z.string(),
        }),
      },
    },
  },
{{/if}}
});

export type AppContract = typeof contract;
`],
  ["api/ts-rest/native/utils/ts-rest.ts.hbs", `import { QueryClient } from "@tanstack/react-query";
import { initClient, tsRestFetchApi } from "@ts-rest/core";
import { initTsrReactQuery } from "@ts-rest/react-query";
import { contract } from "@{{projectName}}/api/index";
import { env } from "@{{projectName}}/env/native";

export const queryClient = new QueryClient({
	defaultOptions: {
		queries: {
			retry: 2,
			staleTime: 1000 * 60,
		},
	},
});

const client = initClient(contract, {
	baseUrl: \`\${env.EXPO_PUBLIC_SERVER_URL}/rest\`,
	baseHeaders: {},
{{#if (eq auth "better-auth")}}
	credentials: "include",
{{/if}}
	api: tsRestFetchApi,
});

export const tsr = initTsrReactQuery(contract, client);
`],
  ["frontend/react/tanstack-start/public/robots.txt", `# https://www.robotstxt.org/robotstxt.html
User-agent: *
Disallow:
`],
  ["frontend/react/tanstack-start/src/router.tsx.hbs", `{{#if (eq backend "convex")}}
import { createRouter as createTanStackRouter } from "@tanstack/react-router";
import { QueryClient } from "@tanstack/react-query";
import { setupRouterSsrQueryIntegration } from "@tanstack/react-router-ssr-query";
import { ConvexQueryClient } from "@convex-dev/react-query";
import { routeTree } from "./routeTree.gen";
import Loader from "./components/loader";
import "./index.css";
import { env } from "@{{projectName}}/env/web";
{{else}}
import { createRouter as createTanStackRouter } from "@tanstack/react-router";
import Loader from "./components/loader";
import "./index.css";
import { routeTree } from "./routeTree.gen";
{{#if (eq api "trpc")}}
import { QueryCache, QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { createTRPCClient, httpBatchLink } from "@trpc/client";
import { createTRPCOptionsProxy } from "@trpc/tanstack-react-query";
import { toast } from "sonner";
import type { AppRouter } from "@{{projectName}}/api/routers/index";
import { TRPCProvider } from "./utils/trpc";
{{#unless (eq backend "self")}}
import { env } from "@{{projectName}}/env/web";
{{/unless}}
{{else if (eq api "orpc")}}
import { QueryClientProvider } from "@tanstack/react-query";
import { orpc, queryClient } from "./utils/orpc";
{{/if}}
{{/if}}

{{#if (eq backend "convex")}}
export function getRouter() {
	const convexUrl = env.VITE_CONVEX_URL;
	if (!convexUrl) {
		throw new Error("VITE_CONVEX_URL is not set");
	}

	const convexQueryClient = new ConvexQueryClient(convexUrl);

	const queryClient: QueryClient = new QueryClient({
		defaultOptions: {
			queries: {
				queryKeyHashFn: convexQueryClient.hashFn(),
				queryFn: convexQueryClient.queryFn(),
			},
		},
	});
	convexQueryClient.connect(queryClient);

	const router = createTanStackRouter({
		routeTree,
		defaultPreload: "intent",
		defaultPendingComponent: () => <Loader />,
		defaultNotFoundComponent: () => <div>Not Found</div>,
		context: { queryClient, convexQueryClient },
	});

	setupRouterSsrQueryIntegration({
		router,
		queryClient,
	});

	return router;
}
{{else}}
{{#if (eq api "trpc")}}
export const queryClient = new QueryClient({
	queryCache: new QueryCache({
		onError: (error, query) => {
			toast.error(error.message, {
				action: {
					label: "retry",
					onClick: query.invalidate,
				},
			});
		},
	}),
	defaultOptions: { queries: { staleTime: 60 * 1000 } },
});

const trpcClient = createTRPCClient<AppRouter>({
	links: [
		httpBatchLink({
			url: {{#if (eq backend "self")}}"/api/trpc"{{else}}\`\${env.VITE_SERVER_URL}/trpc\`{{/if}},
{{#if (eq auth "better-auth")}}
			fetch(url, options) {
				return fetch(url, {
					...options,
					credentials: "include",
				});
			},
{{/if}}
		}),
	],
});

const trpc = createTRPCOptionsProxy({
	client: trpcClient,
	queryClient: queryClient,
});
{{else if (eq api "orpc")}}
{{/if}}

export const getRouter = () => {
	const router = createTanStackRouter({
		routeTree,
		scrollRestoration: true,
		defaultPreloadStaleTime: 0,
{{#if (eq api "trpc")}}
		context: { trpc, queryClient },
{{else if (eq api "orpc")}}
		context: { orpc, queryClient },
{{else}}
		context: {},
{{/if}}
		defaultPendingComponent: () => <Loader />,
		defaultNotFoundComponent: () => <div>Not Found</div>,
{{#if (eq api "trpc")}}
		Wrap: ({ children }) => (
			<QueryClientProvider client={queryClient}>
				<TRPCProvider trpcClient={trpcClient} queryClient={queryClient}>
					{children}
				</TRPCProvider>
			</QueryClientProvider>
		),
{{else if (eq api "orpc")}}
		Wrap: ({ children }) => (
			<QueryClientProvider client={queryClient}>
				{children}
			</QueryClientProvider>
		),
{{else}}
		Wrap: ({ children }) => <>{children}</>,
{{/if}}
	});
	return router;
};
{{/if}}

declare module "@tanstack/react-router" {
	interface Register {
		router: ReturnType<typeof getRouter>;
	}
}
`],
  ["frontend/react/web-base/src/index.css.hbs", `{{#if (eq cssFramework "tailwind")}}
@import 'tailwindcss';
@import 'tw-animate-css';
{{#if (eq uiLibrary "shadcn-ui")}}
@import 'shadcn/tailwind.css';
{{/if}}
{{#if (includes examples "ai")}}
@source "../node_modules/streamdown/dist/*.js";
{{/if}}

@custom-variant dark (&:is(.dark *));

{{#if (eq uiLibrary "shadcn-ui")}}
:root {
  --background: oklch(1 0 0);
  --foreground: oklch(0.145 0 0);
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.145 0 0);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.145 0 0);
  --primary: oklch(0.205 0 0);
  --primary-foreground: oklch(0.985 0 0);
  --secondary: oklch(0.97 0 0);
  --secondary-foreground: oklch(0.205 0 0);
  --muted: oklch(0.97 0 0);
  --muted-foreground: oklch(0.556 0 0);
  --accent: oklch(0.97 0 0);
  --accent-foreground: oklch(0.205 0 0);
  --destructive: oklch(0.58 0.22 27);
  --border: oklch(0.922 0 0);
  --input: oklch(0.922 0 0);
  --ring: oklch(0.708 0 0);
  --chart-1: oklch(0.809 0.105 251.813);
  --chart-2: oklch(0.623 0.214 259.815);
  --chart-3: oklch(0.546 0.245 262.881);
  --chart-4: oklch(0.488 0.243 264.376);
  --chart-5: oklch(0.424 0.199 265.638);
  --radius: 0.625rem;
  --sidebar: oklch(0.985 0 0);
  --sidebar-foreground: oklch(0.145 0 0);
  --sidebar-primary: oklch(0.205 0 0);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.97 0 0);
  --sidebar-accent-foreground: oklch(0.205 0 0);
  --sidebar-border: oklch(0.922 0 0);
  --sidebar-ring: oklch(0.708 0 0);
}

.dark {
  --background: oklch(0.145 0 0);
  --foreground: oklch(0.985 0 0);
  --card: oklch(0.205 0 0);
  --card-foreground: oklch(0.985 0 0);
  --popover: oklch(0.205 0 0);
  --popover-foreground: oklch(0.985 0 0);
  --primary: oklch(0.87 0 0);
  --primary-foreground: oklch(0.205 0 0);
  --secondary: oklch(0.269 0 0);
  --secondary-foreground: oklch(0.985 0 0);
  --muted: oklch(0.269 0 0);
  --muted-foreground: oklch(0.708 0 0);
  --accent: oklch(0.371 0 0);
  --accent-foreground: oklch(0.985 0 0);
  --destructive: oklch(0.704 0.191 22.216);
  --border: oklch(1 0 0 / 10%);
  --input: oklch(1 0 0 / 15%);
  --ring: oklch(0.556 0 0);
  --chart-1: oklch(0.809 0.105 251.813);
  --chart-2: oklch(0.623 0.214 259.815);
  --chart-3: oklch(0.546 0.245 262.881);
  --chart-4: oklch(0.488 0.243 264.376);
  --chart-5: oklch(0.424 0.199 265.638);
  --sidebar: oklch(0.205 0 0);
  --sidebar-foreground: oklch(0.985 0 0);
  --sidebar-primary: oklch(0.488 0.243 264.376);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.269 0 0);
  --sidebar-accent-foreground: oklch(0.985 0 0);
  --sidebar-border: oklch(1 0 0 / 10%);
  --sidebar-ring: oklch(0.556 0 0);
}

@theme inline {
  --font-sans: 'Inter Variable', sans-serif;
  --color-sidebar-ring: var(--sidebar-ring);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar: var(--sidebar);
  --color-chart-5: var(--chart-5);
  --color-chart-4: var(--chart-4);
  --color-chart-3: var(--chart-3);
  --color-chart-2: var(--chart-2);
  --color-chart-1: var(--chart-1);
  --color-ring: var(--ring);
  --color-input: var(--input);
  --color-border: var(--border);
  --color-destructive: var(--destructive);
  --color-accent-foreground: var(--accent-foreground);
  --color-accent: var(--accent);
  --color-muted-foreground: var(--muted-foreground);
  --color-muted: var(--muted);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-secondary: var(--secondary);
  --color-primary-foreground: var(--primary-foreground);
  --color-primary: var(--primary);
  --color-popover-foreground: var(--popover-foreground);
  --color-popover: var(--popover);
  --color-card-foreground: var(--card-foreground);
  --color-card: var(--card);
  --color-foreground: var(--foreground);
  --color-background: var(--background);
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
  --radius-2xl: calc(var(--radius) + 8px);
  --radius-3xl: calc(var(--radius) + 12px);
  --radius-4xl: calc(var(--radius) + 16px);
}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply font-sans bg-background text-foreground;
  }
  html {
    @apply font-sans;
  }
}
{{else}}
/* Basic Tailwind setup without shadcn-ui theme */
@layer base {
  body {
    font-family: 'Inter Variable', system-ui, sans-serif;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }
}
{{/if}}
{{else}}
/* Non-Tailwind CSS framework styles */
:root {
  --color-background: #ffffff;
  --color-foreground: #1a1a1a;
  --color-primary: #3b82f6;
  --color-secondary: #64748b;
}

.dark {
  --color-background: #1a1a1a;
  --color-foreground: #fafafa;
  --color-primary: #60a5fa;
  --color-secondary: #94a3b8;
}

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: 'Inter Variable', system-ui, sans-serif;
  background-color: var(--color-background);
  color: var(--color-foreground);
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}
{{/if}}
`],
  ["frontend/react/react-router/public/favicon.ico", `[Binary file]`],
  ["frontend/react/react-router/src/routes.ts", `import { type RouteConfig } from "@react-router/dev/routes";
import { flatRoutes } from "@react-router/fs-routes";

export default flatRoutes() satisfies RouteConfig;
`],
  ["frontend/react/react-router/src/root.tsx.hbs", `import {
  isRouteErrorResponse,
  Links,
  Meta,
  Outlet,
  Scripts,
  ScrollRestoration,
} from "react-router";
import type { Route } from "./+types/root";
import "./index.css";
import Header from "./components/header";
import { ThemeProvider } from "./components/theme-provider";
import { Toaster } from "./components/ui/sonner";

{{#if (eq backend "convex")}}
import { ConvexReactClient } from "convex/react";
import { env } from "@{{projectName}}/env/web";
{{#if (eq auth "clerk")}}
import { ClerkProvider, useAuth } from "@clerk/clerk-react";
import { ConvexProviderWithClerk } from "convex/react-clerk";
{{else}}
import { ConvexProvider } from "convex/react";
{{/if}}
{{else}}
  {{#unless (eq api "none")}}
import { QueryClientProvider } from "@tanstack/react-query";
import { ReactQueryDevtools } from "@tanstack/react-query-devtools";
    {{#if (eq api "orpc")}}
import { queryClient } from "./utils/orpc";
    {{/if}}
    {{#if (eq api "trpc")}}
import { queryClient } from "./utils/trpc";
    {{/if}}
  {{/unless}}
{{/if}}

export const links: Route.LinksFunction = () => [
  { rel: "preconnect", href: "https://fonts.googleapis.com" },
  { rel: "preconnect", href: "https://fonts.gstatic.com", crossOrigin: "anonymous" },
  {
    rel: "stylesheet",
    href:
      "https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap",
  },
];

export function Layout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en">
      <head>
        <meta charSet="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <Meta />
        <Links />
      </head>
      <body>
        {children}
        <ScrollRestoration />
        <Scripts />
      </body>
    </html>
  );
}

{{#if (eq backend "convex")}}
export default function App() {
  const convex = new ConvexReactClient(env.VITE_CONVEX_URL);
  {{#if (eq auth "clerk")}}
  return (
    <ClerkProvider publishableKey={env.VITE_CLERK_PUBLISHABLE_KEY}>
      <ConvexProviderWithClerk client={convex} useAuth={useAuth}>
        <ThemeProvider
          attribute="class"
          defaultTheme="dark"
          disableTransitionOnChange
          storageKey="vite-ui-theme"
        >
          <div className="grid grid-rows-[auto_1fr] h-svh">
            <Header />
            <Outlet />
          </div>
          <Toaster richColors />
        </ThemeProvider>
      </ConvexProviderWithClerk>
    </ClerkProvider>
  );
  {{else}}
  return (
    <ConvexProvider client={convex}>
      <ThemeProvider
        attribute="class"
        defaultTheme="dark"
        disableTransitionOnChange
        storageKey="vite-ui-theme"
      >
        <div className="grid grid-rows-[auto_1fr] h-svh">
          <Header />
          <Outlet />
        </div>
        <Toaster richColors />
      </ThemeProvider>
    </ConvexProvider>
  );
  {{/if}}
}
{{else if (eq api "orpc")}}
export default function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <ThemeProvider
        attribute="class"
        defaultTheme="dark"
        disableTransitionOnChange
        storageKey="vite-ui-theme"
      >
        <div className="grid grid-rows-[auto_1fr] h-svh">
          <Header />
          <Outlet />
        </div>
        <Toaster richColors />
      </ThemeProvider>
      <ReactQueryDevtools position="bottom" buttonPosition="bottom-right" />
    </QueryClientProvider>
  );
}
{{else if (eq api "trpc")}}
export default function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <ThemeProvider
        attribute="class"
        defaultTheme="dark"
        disableTransitionOnChange
        storageKey="vite-ui-theme"
      >
        <div className="grid grid-rows-[auto_1fr] h-svh">
          <Header />
          <Outlet />
        </div>
        <Toaster richColors />
      </ThemeProvider>
      <ReactQueryDevtools position="bottom" buttonPosition="bottom-right" />
    </QueryClientProvider>
  );
}
{{else}}
export default function App() {
  return (
    <ThemeProvider
      attribute="class"
      defaultTheme="dark"
      disableTransitionOnChange
      storageKey="vite-ui-theme"
    >
      <div className="grid grid-rows-[auto_1fr] h-svh">
        <Header />
        <Outlet />
      </div>
      <Toaster richColors />
    </ThemeProvider>
  );
}
{{/if}}

export function ErrorBoundary({ error }: Route.ErrorBoundaryProps) {
  let message = "Oops!";
  let details = "An unexpected error occurred.";
  let stack: string | undefined;
  if (isRouteErrorResponse(error)) {
    message = error.status === 404 ? "404" : "Error";
    details =
      error.status === 404
        ? "The requested page could not be found."
        : error.statusText || details;
  } else if (import.meta.env.DEV && error && error instanceof Error) {
    details = error.message;
    stack = error.stack;
  }
  return (
    <main className="pt-16 p-4 container mx-auto">
      <h1>{message}</h1>
      <p>{details}</p>
      {stack && (
        <pre className="w-full p-4 overflow-x-auto">
          <code>{stack}</code>
        </pre>
      )}
    </main>
  );
}
`],
  ["api/trpc/native/utils/trpc.ts.hbs", `{{#if (eq auth "better-auth")}}
import { authClient } from "@/lib/auth-client";
{{/if}}
import { QueryClient } from "@tanstack/react-query";
import { createTRPCClient, httpBatchLink } from "@trpc/client";
import { createTRPCOptionsProxy } from "@trpc/tanstack-react-query";
import type { AppRouter } from "@{{projectName}}/api/routers/index";
import { env } from "@{{projectName}}/env/native";

export const queryClient = new QueryClient();

const trpcClient = createTRPCClient<AppRouter>({
	links: [
		httpBatchLink({
{{#if (eq backend "self")}}
			url: \`\${env.EXPO_PUBLIC_SERVER_URL}/api/trpc\`,
{{else}}
			url: \`\${env.EXPO_PUBLIC_SERVER_URL}/trpc\`,
{{/if}}
{{#if (eq auth "better-auth")}}
			headers() {
				const headers = new Map<string, string>();
				const cookies = authClient.getCookie();
				if (cookies) {
					headers.set("Cookie", cookies);
				}
				return Object.fromEntries(headers);
			},
{{/if}}
		}),
	],
});

export const trpc = createTRPCOptionsProxy<AppRouter>({
	client: trpcClient,
	queryClient,
});
`],
  ["frontend/react/tanstack-router/src/main.tsx.hbs", `import { RouterProvider, createRouter } from "@tanstack/react-router";
import ReactDOM from "react-dom/client";
import Loader from "./components/loader";
import { routeTree } from "./routeTree.gen";

{{#if (eq api "orpc")}}
  import { QueryClientProvider } from "@tanstack/react-query";
  import { orpc, queryClient } from "./utils/orpc";
{{/if}}
{{#if (eq api "trpc")}}
  import { QueryClientProvider } from "@tanstack/react-query";
  import { queryClient, trpc } from "./utils/trpc";
{{/if}}
{{#if (eq backend "convex")}}
  import { ConvexReactClient } from "convex/react";
  import { env } from "@{{projectName}}/env/web";
  {{#if (eq auth "clerk")}}
  import { ClerkProvider, useAuth } from "@clerk/clerk-react";
  import { ConvexProviderWithClerk } from "convex/react-clerk";
  {{else if (eq auth "better-auth")}}
  import { ConvexBetterAuthProvider } from "@convex-dev/better-auth/react";
  import { authClient } from "@/lib/auth-client";
  {{else}}
  import { ConvexProvider } from "convex/react";
  {{/if}}
  const convex = new ConvexReactClient(env.VITE_CONVEX_URL);
{{/if}}

const router = createRouter({
  routeTree,
  defaultPreload: "intent",
  defaultPendingComponent: () => <Loader />,
  {{#if (eq api "orpc")}}
  context: { orpc, queryClient },
  Wrap: function WrapComponent({ children }: { children: React.ReactNode }) {
    return (
      <QueryClientProvider client={queryClient}>
        {children}
      </QueryClientProvider>
    );
  },
  {{else if (eq api "trpc")}}
  context: { trpc, queryClient },
  Wrap: function WrapComponent({ children }: { children: React.ReactNode }) {
    return (
      <QueryClientProvider client={queryClient}>
        {children}
      </QueryClientProvider>
    );
  },
  {{else if (eq backend "convex")}}
  context: {},
  Wrap: function WrapComponent({ children }: { children: React.ReactNode }) {
    {{#if (eq auth "clerk")}}
    return (
      <ClerkProvider
        publishableKey={env.VITE_CLERK_PUBLISHABLE_KEY}
      >
        <ConvexProviderWithClerk client={convex} useAuth={useAuth}>
          {children}
        </ConvexProviderWithClerk>
      </ClerkProvider>
    );
    {{else if (eq auth "better-auth")}}
    return <ConvexBetterAuthProvider client={convex} authClient={authClient}>{children}</ConvexBetterAuthProvider>;
    {{else}}
    return <ConvexProvider client={convex}>{children}</ConvexProvider>;
    {{/if}}
  },
  {{else}}
  context: {},
  {{/if}}
});

declare module "@tanstack/react-router" {
  interface Register {
    router: typeof router;
  }
}

const rootElement = document.getElementById("app");

if (!rootElement) {
  throw new Error("Root element not found");
}

if (!rootElement.innerHTML) {
  const root = ReactDOM.createRoot(rootElement);
  root.render(<RouterProvider router={router} />);
}
`],
  ["api/orpc/server/src/context.ts.hbs", `{{#if (and (eq backend 'self') (includes frontend "next"))}}
import type { NextRequest } from "next/server";
{{#if (eq auth "better-auth")}}
import { auth } from "@{{projectName}}/auth";
{{/if}}

export async function createContext(req: NextRequest) {
{{#if (eq auth "better-auth")}}
  const session = await auth.api.getSession({
    headers: req.headers,
  });
  return {
    session,
  };
{{else}}
  return {}
{{/if}}
}

{{else if (and (eq backend 'self') (includes frontend "tanstack-start"))}}
{{#if (eq auth "better-auth")}}
import { auth } from "@{{projectName}}/auth";
{{/if}}

export async function createContext({ req }: { req: Request }) {
{{#if (eq auth "better-auth")}}
	const session = await auth.api.getSession({
		headers: req.headers,
	});
	return {
		session,
	};
{{else}}
	return {};
{{/if}}
}

{{else if (eq backend 'hono')}}
import type { Context as HonoContext } from "hono";
{{#if (eq auth "better-auth")}}
import { auth } from "@{{projectName}}/auth";
{{/if}}

export type CreateContextOptions = {
  context: HonoContext;
};

export async function createContext({ context }: CreateContextOptions) {
{{#if (eq auth "better-auth")}}
  const session = await auth.api.getSession({
    headers: context.req.raw.headers,
  });
  return {
    session,
  };
{{else}}
  // No auth configured
  return {
    session: null,
  };
{{/if}}
}

{{else if (eq backend 'elysia')}}
import type { Context as ElysiaContext } from "elysia";
{{#if (eq auth "better-auth")}}
import { auth } from "@{{projectName}}/auth";
{{/if}}

export type CreateContextOptions = {
  context: ElysiaContext;
};

export async function createContext({ context }: CreateContextOptions) {
{{#if (eq auth "better-auth")}}
  const session = await auth.api.getSession({
    headers: context.request.headers,
  });
  return {
    session,
  };
{{else}}
  // No auth configured
  return {
    session: null,
  };
{{/if}}
}

{{else if (eq backend 'express')}}
import type { Request } from "express";
{{#if (eq auth "better-auth")}}
import { fromNodeHeaders } from "better-auth/node";
import { auth } from "@{{projectName}}/auth";
{{/if}}

interface CreateContextOptions {
	req: Request;
}

export async function createContext(opts: CreateContextOptions) {
{{#if (eq auth "better-auth")}}
	const session = await auth.api.getSession({
		headers: fromNodeHeaders(opts.req.headers),
	});
	return {
		session,
	};
{{else}}
  // No auth configured
	return {
		session: null,
	};
{{/if}}
}

{{else if (eq backend 'fastify')}}
import type { IncomingHttpHeaders } from "node:http";
{{#if (eq auth "better-auth")}}
import { fromNodeHeaders } from "better-auth/node";
import { auth } from "@{{projectName}}/auth";
{{/if}}

export async function createContext(req: IncomingHttpHeaders) {
{{#if (eq auth "better-auth")}}
  const session = await auth.api.getSession({
    headers: fromNodeHeaders(req),
  });
  return {
    session,
  };
{{else}}
  // No auth configured
  return {
    session: null,
  };
{{/if}}
}

{{else}}
export async function createContext() {
  return {
    session: null,
  };
}
{{/if}}

export type Context = Awaited<ReturnType<typeof createContext>>;
`],
  ["api/orpc/server/src/index.ts.hbs", `import { ORPCError, os } from "@orpc/server";
import type { Context } from "./context";

export const o = os.$context<Context>();

export const publicProcedure = o;

{{#if (eq auth "better-auth")}}
const requireAuth = o.middleware(async ({ context, next }) => {
  if (!context.session?.user) {
    throw new ORPCError("UNAUTHORIZED");
  }
  return next({
    context: {
      session: context.session,
    },
  });
});

export const protectedProcedure = publicProcedure.use(requireAuth);
{{/if}}
`],
  ["cms/sanity/web/next/sanity.cli.ts.hbs", `import { defineCliConfig } from "sanity/cli";

const projectId = process.env.NEXT_PUBLIC_SANITY_PROJECT_ID!;
const dataset = process.env.NEXT_PUBLIC_SANITY_DATASET!;

export default defineCliConfig({
  api: {
    projectId,
    dataset,
  },
});
`],
  ["cms/sanity/web/next/sanity.config.ts.hbs", `"use client";

import { defineConfig } from "sanity";
import { structureTool } from "sanity/structure";
import { visionTool } from "@sanity/vision";

import { schemaTypes } from "./src/sanity/schemas";

const projectId = process.env.NEXT_PUBLIC_SANITY_PROJECT_ID!;
const dataset = process.env.NEXT_PUBLIC_SANITY_DATASET!;

export default defineConfig({
  name: "{{projectName}}",
  title: "{{projectName}}",

  projectId,
  dataset,

  basePath: "/studio",

  plugins: [structureTool(), visionTool()],

  schema: {
    types: schemaTypes,
  },
});
`],
  ["api/trpc/server/src/context.ts.hbs", `{{#if (and (eq backend 'self') (includes frontend "next"))}}
import type { NextRequest } from "next/server";
{{#if (eq auth "better-auth")}}
import { auth } from "@{{projectName}}/auth";
{{/if}}

export async function createContext(req: NextRequest) {
{{#if (eq auth "better-auth")}}
  const session = await auth.api.getSession({
    headers: req.headers,
  });
  return {
    session,
  };
{{else}}
  // No auth configured
  return {
    session: null,
  };
{{/if}}
}

{{else if (and (eq backend 'self') (includes frontend "tanstack-start"))}}
{{#if (eq auth "better-auth")}}
import { auth } from "@{{projectName}}/auth";
{{/if}}

export async function createContext({ req }: { req: Request }) {
{{#if (eq auth "better-auth")}}
	const session = await auth.api.getSession({
		headers: req.headers,
	});
	return {
		session,
	};
{{else}}
	// No auth configured
	return {
		session: null,
	};
{{/if}}
}

{{else if (eq backend 'hono')}}
import type { Context as HonoContext } from "hono";
{{#if (eq auth "better-auth")}}
import { auth } from "@{{projectName}}/auth";
{{/if}}

export type CreateContextOptions = {
  context: HonoContext;
};

export async function createContext({ context }: CreateContextOptions) {
{{#if (eq auth "better-auth")}}
  const session = await auth.api.getSession({
    headers: context.req.raw.headers,
  });
  return {
    session,
  };
{{else}}
  // No auth configured
  return {
    session: null,
  };
{{/if}}
}

{{else if (eq backend 'elysia')}}
import type { Context as ElysiaContext } from "elysia";
{{#if (eq auth "better-auth")}}
import { auth } from "@{{projectName}}/auth";
{{/if}}

export type CreateContextOptions = {
  context: ElysiaContext;
};

export async function createContext({ context }: CreateContextOptions) {
{{#if (eq auth "better-auth")}}
  const session = await auth.api.getSession({
    headers: context.request.headers,
  });
  return {
    session,
  };
{{else}}
  // No auth configured
  return {
    session: null,
  };
{{/if}}
}

{{else if (eq backend 'express')}}
import type { CreateExpressContextOptions } from "@trpc/server/adapters/express";
{{#if (eq auth "better-auth")}}
import { fromNodeHeaders } from "better-auth/node";
import { auth } from "@{{projectName}}/auth";
{{/if}}

export async function createContext(opts: CreateExpressContextOptions) {
{{#if (eq auth "better-auth")}}
	const session = await auth.api.getSession({
		headers: fromNodeHeaders(opts.req.headers),
	});
	return {
		session,
	};
{{else}}
  // No auth configured
	return {
		session: null,
	};
{{/if}}
}

{{else if (eq backend 'fastify')}}
import type { CreateFastifyContextOptions } from "@trpc/server/adapters/fastify";
{{#if (eq auth "better-auth")}}
import { fromNodeHeaders } from "better-auth/node";
import { auth } from "@{{projectName}}/auth";
{{/if}}

export async function createContext({ req, res }: CreateFastifyContextOptions) {
{{#if (eq auth "better-auth")}}
  const session = await auth.api.getSession({
    headers: fromNodeHeaders(req.headers),
  });
  return { session };
{{else}}
  // No auth configured
	return {
		session: null,
	};
{{/if}}
}

{{else}}
export async function createContext() {
  return {
    session: null,
  };
}
{{/if}}

export type Context = Awaited<ReturnType<typeof createContext>>;
`],
  ["api/trpc/server/src/index.ts.hbs", `import { initTRPC, TRPCError } from "@trpc/server";
import type { Context } from "./context";

export const t = initTRPC.context<Context>().create();

export const router = t.router;

export const publicProcedure = t.procedure;

{{#if (eq auth "better-auth")}}
export const protectedProcedure = t.procedure.use(({ ctx, next }) => {
  if (!ctx.session) {
    throw new TRPCError({
      code: "UNAUTHORIZED",
      message: "Authentication required",
      cause: "No session",
    });
  }
  return next({
    ctx: {
      ...ctx,
      session: ctx.session,
    },
  });
});
{{/if}}
`],
  ["backend/convex/packages/backend/package.json.hbs", `{
  "name": "@{{projectName}}/backend",
  "version": "1.0.0",
  "scripts": {
    "dev": "convex dev",
    "dev:setup": "convex dev --configure --until-success"
  },
  "author": "",
  "license": "ISC",
  "description": "",
  "devDependencies": {
    "@types/node": "^24.3.0"
  },
  "dependencies": {}
}
`],
  ["backend/convex/packages/backend/_gitignore", `
.env.local
`],
  ["backend/server/elysia/src/index.ts.hbs", `import { env } from "@{{projectName}}/env/server";
{{#if (eq runtime "node")}}
import { node } from "@elysiajs/node";
{{/if}}
import { Elysia } from "elysia";
import { cors } from "@elysiajs/cors";
{{#if (includes examples "ai")}}
import { google } from "@ai-sdk/google";
import { convertToModelMessages, streamText, wrapLanguageModel } from "ai";
import { devToolsMiddleware } from "@ai-sdk/devtools";
{{/if}}
{{#if (eq api "trpc")}}
import { createContext } from "@{{projectName}}/api/context";
import { appRouter } from "@{{projectName}}/api/routers/index";
import { fetchRequestHandler } from "@trpc/server/adapters/fetch";
{{/if}}
{{#if (eq api "orpc")}}
import { OpenAPIHandler } from "@orpc/openapi/fetch";
import { OpenAPIReferencePlugin } from "@orpc/openapi/plugins";
import { ZodToJsonSchemaConverter } from "@orpc/zod/zod4";
import { RPCHandler } from "@orpc/server/fetch";
import { onError } from "@orpc/server";
import { appRouter } from "@{{projectName}}/api/routers/index";
import { createContext } from "@{{projectName}}/api/context";
{{/if}}
{{#if (eq auth "better-auth")}}
import { auth } from "@{{projectName}}/auth";
{{/if}}

{{#if (eq api "orpc")}}
const rpcHandler = new RPCHandler(appRouter, {
	interceptors: [
		onError((error) => {
			console.error(error);
		}),
	],
});
const apiHandler = new OpenAPIHandler(appRouter, {
	plugins: [
		new OpenAPIReferencePlugin({
			schemaConverters: [new ZodToJsonSchemaConverter()],
		}),
	],
	interceptors: [
		onError((error) => {
			console.error(error);
		}),
	],
});
{{/if}}

{{#if (eq runtime "node")}}
const app = new Elysia({ adapter: node() })
{{else}}
const app = new Elysia()
{{/if}}
	.use(
		cors({
			origin: env.CORS_ORIGIN,
			methods: ["GET", "POST", "OPTIONS"],
{{#if (eq auth "better-auth")}}
			allowedHeaders: ["Content-Type", "Authorization"],
			credentials: true,
{{/if}}
		}),
	)
{{#if (eq auth "better-auth")}}
	.all("/api/auth/*", async (context) => {
		const { request, status } = context;
		if (["POST", "GET"].includes(request.method)) {
			return auth.handler(request);
		}
		return status(405)
	})
{{/if}}
{{#if (eq api "orpc")}}
	.all('/rpc*', async (context) => {
		const { response } = await rpcHandler.handle(context.request, {
			prefix: '/rpc',
			context: await createContext({ context })
		})
		return response ?? new Response('Not Found', { status: 404 })
	})
	.all('/api*', async (context) => {
		const { response } = await apiHandler.handle(context.request, {
			prefix: '/api-reference',
			context: await createContext({ context })
		})
		return response ?? new Response('Not Found', { status: 404 })
	})
{{/if}}
{{#if (eq api "trpc")}}
	.all("/trpc/*", async (context) => {
		const res = await fetchRequestHandler({
			endpoint: "/trpc",
			router: appRouter,
			req: context.request,
			createContext: () => createContext({ context }),
		});
		return res;
	})
{{/if}}
{{#if (includes examples "ai")}}
	.post("/ai", async (context) => {
		const body = await context.request.json();
		const uiMessages = body.messages || [];
		const model = wrapLanguageModel({
			model: google("gemini-2.5-flash"),
			middleware: devToolsMiddleware(),
		});
		const result = streamText({
			model,
			messages: await convertToModelMessages(uiMessages)
		});

		return result.toUIMessageStreamResponse();
	})
{{/if}}
	.get("/", () => "OK")
	.listen(3000, () => {
		console.log("Server is running on http://localhost:3000");
	});
`],
  ["api/orpc/native/utils/orpc.ts.hbs", `import { createORPCClient } from "@orpc/client";
import { RPCLink } from "@orpc/client/fetch";
import { createTanstackQueryUtils } from "@orpc/tanstack-query";
import { QueryCache, QueryClient } from "@tanstack/react-query";
import type { AppRouterClient } from "@{{projectName}}/api/routers/index";
import { env } from "@{{projectName}}/env/native";
{{#if (eq auth "better-auth")}}
import { authClient } from "@/lib/auth-client";
{{/if}}

export const queryClient = new QueryClient({
	queryCache: new QueryCache({
		onError: (error) => {
			console.log(error)
		},
	}),
});

export const link = new RPCLink({
{{#if (eq backend "self")}}
	url: \`\${env.EXPO_PUBLIC_SERVER_URL}/api/rpc\`,
{{else}}
	url: \`\${env.EXPO_PUBLIC_SERVER_URL}/rpc\`,
{{/if}}
{{#if (eq auth "better-auth")}}
	headers() {
		const headers = new Map<string, string>();
		const cookies = authClient.getCookie();
		if (cookies) {
			headers.set("Cookie", cookies);
		}
		return Object.fromEntries(headers);
	},
{{/if}}
});

export const client: AppRouterClient = createORPCClient(link);

export const orpc = createTanstackQueryUtils(client);
`],
  ["backend/server/nitro/routes/ai.post.ts.hbs", `{{#if (includes examples "ai")}}
import { streamText, type UIMessage, convertToModelMessages, wrapLanguageModel } from "ai";
{{#if (or (eq runtime "bun") (eq runtime "node"))}}
import { google } from "@ai-sdk/google";
{{else}}
import { createGoogleGenerativeAI } from "@ai-sdk/google";
import { env } from "@{{projectName}}/env/server";
{{/if}}
import { devToolsMiddleware } from "@ai-sdk/devtools";

export default defineEventHandler(async (event) => {
	const body = await readBody<{ messages?: UIMessage[] }>(event);
	const messages = body.messages || [];

{{#if (eq runtime "workers")}}
	const google = createGoogleGenerativeAI({
		apiKey: env.GOOGLE_GENERATIVE_AI_API_KEY,
	});
{{/if}}
	const model = wrapLanguageModel({
		model: google("gemini-2.5-flash"),
		middleware: devToolsMiddleware(),
	});

	const result = streamText({
		model,
		messages: await convertToModelMessages(messages),
	});

	return result.toUIMessageStreamResponse();
});
{{else}}
// AI placeholder - AI example not included
export default defineEventHandler(() => {
	return { error: "AI not configured" };
});
{{/if}}
`],
  ["backend/server/nitro/routes/index.ts.hbs", `// Health check endpoint
export default defineEventHandler(() => {
	return "OK";
});
`],
  ["backend/server/fastify/src/index.ts.hbs", `import { env } from "@{{projectName}}/env/server";
import Fastify from "fastify";
import fastifyCors from "@fastify/cors";

{{#if (eq api "trpc")}}
import { fastifyTRPCPlugin, type FastifyTRPCPluginOptions } from "@trpc/server/adapters/fastify";
import { createContext } from "@{{projectName}}/api/context";
import { appRouter, type AppRouter } from "@{{projectName}}/api/routers/index";
{{/if}}

{{#if (eq api "orpc")}}
import { OpenAPIHandler } from "@orpc/openapi/node";
import { OpenAPIReferencePlugin } from "@orpc/openapi/plugins";
import { ZodToJsonSchemaConverter } from "@orpc/zod/zod4";
import { RPCHandler } from "@orpc/server/node";
import { CORSPlugin } from "@orpc/server/plugins";
import { onError } from "@orpc/server";
import { appRouter } from "@{{projectName}}/api/routers/index";
import { createServer } from "node:http";
{{#if (eq auth "better-auth")}}
import { createContext } from "@{{projectName}}/api/context";
{{/if}}
{{/if}}

{{#if (includes examples "ai")}}
import { streamText, type UIMessage, convertToModelMessages, wrapLanguageModel } from "ai";
import { google } from "@ai-sdk/google";
import { devToolsMiddleware } from "@ai-sdk/devtools";
{{/if}}

{{#if (eq auth "better-auth")}}
import { auth } from "@{{projectName}}/auth";
{{/if}}

const baseCorsConfig = {
	origin: env.CORS_ORIGIN,
	methods: ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
	allowedHeaders: [
		"Content-Type",
		"Authorization",
		"X-Requested-With"
	],
	credentials: true,
	maxAge: 86400,
};

{{#if (eq api "orpc")}}
const rpcHandler = new RPCHandler(appRouter, {
	plugins: [
		new CORSPlugin({
			origin: env.CORS_ORIGIN,
			credentials: true,
			allowHeaders: ["Content-Type", "Authorization"],
		}),
	],
	interceptors: [
		onError((error) => {
			console.error(error);
		}),
	],
});

const apiHandler = new OpenAPIHandler(appRouter, {
	plugins: [
		new OpenAPIReferencePlugin({
			schemaConverters: [new ZodToJsonSchemaConverter()],
		}),
	],
	interceptors: [
		onError((error) => {
			console.error(error);
		}),
	],
});

const fastify = Fastify({
	logger: true,
	serverFactory: (fastifyHandler) => {
		const server = createServer(async (req, res) => {
			const { matched } = await rpcHandler.handle(req, res, {
				context: await createContext(req.headers),
				prefix: "/rpc",
			});

			if (matched) {
				return;
			}

			const apiResult = await apiHandler.handle(req, res, {
				context: await createContext(req.headers),
				prefix: "/api-reference",
			});

			if (apiResult.matched) {
				return;
			}

			fastifyHandler(req, res);
		});

		return server;
	},
});
{{else}}
const fastify = Fastify({
	logger: true,
});
{{/if}}

fastify.register(fastifyCors, baseCorsConfig);

{{#if (eq auth "better-auth")}}
fastify.route({
	method: ["GET", "POST"],
	url: "/api/auth/*",
	async handler(request, reply) {
		try {
			const url = new URL(request.url, \`http://\${request.headers.host}\`);
			const headers = new Headers();
			Object.entries(request.headers).forEach(([key, value]) => {
				if (value) headers.append(key, value.toString());
			});
			const req = new Request(url.toString(), {
				method: request.method,
				headers,
				body: request.body ? JSON.stringify(request.body) : undefined,
			});
			const response = await auth.handler(req);
			reply.status(response.status);
			response.headers.forEach((value, key) => reply.header(key, value));
			reply.send(response.body ? await response.text() : null);
		} catch (error) {
			fastify.log.error({ err: error }, "Authentication Error:");
			reply.status(500).send({
				error: "Internal authentication error",
				code: "AUTH_FAILURE"
			});
		}
	}
});
{{/if}}

{{#if (eq api "trpc")}}
fastify.register(fastifyTRPCPlugin, {
	prefix: "/trpc",
	trpcOptions: {
		router: appRouter,
		createContext,
		onError({ path, error }) {
			console.error(\`Error in tRPC handler on path '\${path}':\`, error);
		},
	} satisfies FastifyTRPCPluginOptions<AppRouter>["trpcOptions"],
});
{{/if}}

{{#if (includes examples "ai")}}
interface AiRequestBody {
	id?: string;
	messages: UIMessage[];
}

fastify.post('/ai', async function (request) {
	const { messages } = request.body as AiRequestBody;
	const model = wrapLanguageModel({
		model: google('gemini-2.5-flash'),
		middleware: devToolsMiddleware(),
	});
	const result = streamText({
		model,
		messages: await convertToModelMessages(messages),
	});

	return result.toUIMessageStreamResponse();
});
{{/if}}

fastify.get('/', async () => {
	return 'OK';
});

fastify.listen({ port: 3000 }, (err) => {
	if (err) {
		fastify.log.error(err);
		process.exit(1);
	}
	console.log("Server running on port 3000");
});
`],
  ["backend/server/encore/src/index.ts.hbs", `import { api } from "encore.dev/api";
{{#if (eq auth "better-auth")}}
import { auth } from "@{{projectName}}/auth";
{{/if}}
{{#if (and (includes examples "ai") (or (eq runtime "bun") (eq runtime "node")))}}
import { streamText, convertToModelMessages, wrapLanguageModel } from "ai";
import { google } from "@ai-sdk/google";
import { devToolsMiddleware } from "@ai-sdk/devtools";
{{/if}}

interface Response {
	message: string;
}

interface HealthResponse {
	status: string;
	timestamp: string;
}

// Health check endpoint
export const health = api(
	{ expose: true, method: "GET", path: "/health" },
	async (): Promise<HealthResponse> => {
		return {
			status: "ok",
			timestamp: new Date().toISOString(),
		};
	}
);

// Hello world endpoint
export const hello = api(
	{ expose: true, method: "GET", path: "/hello/:name" },
	async ({ name }: { name: string }): Promise<Response> => {
		return { message: \`Hello \${name}!\` };
	}
);

// Root endpoint
export const root = api(
	{ expose: true, method: "GET", path: "/" },
	async (): Promise<Response> => {
		return { message: "OK" };
	}
);
{{#if (and (includes examples "ai") (or (eq runtime "bun") (eq runtime "node")))}}

interface AIRequest {
	messages: Array<{ role: string; content: string }>;
}

// AI chat endpoint (Encore.ts uses native streaming)
export const chat = api(
	{ expose: true, method: "POST", path: "/ai" },
	async (req: AIRequest): Promise<Response> => {
		const model = wrapLanguageModel({
			model: google("gemini-2.5-flash"),
			middleware: devToolsMiddleware(),
		});

		const result = await streamText({
			model,
			messages: await convertToModelMessages(req.messages),
		});

		// For simple response - streaming would need Encore's streaming API
		const text = await result.text;
		return { message: text };
	}
);
{{/if}}
`],
  ["backend/server/express/src/index.ts.hbs", `import { env } from "@{{projectName}}/env/server";
{{#if (eq api "trpc")}}
import { createExpressMiddleware } from "@trpc/server/adapters/express";
import { createContext } from "@{{projectName}}/api/context";
import { appRouter } from "@{{projectName}}/api/routers/index";
{{/if}}
{{#if (eq api "orpc")}}
import { OpenAPIHandler } from "@orpc/openapi/node";
import { OpenAPIReferencePlugin } from "@orpc/openapi/plugins";
import { ZodToJsonSchemaConverter } from "@orpc/zod/zod4";
import { RPCHandler } from "@orpc/server/node";
import { onError } from "@orpc/server";
import { appRouter } from "@{{projectName}}/api/routers/index";
{{#if (eq auth "better-auth")}}
import { createContext } from "@{{projectName}}/api/context";
{{/if}}
{{/if}}
import cors from "cors";
import express from "express";
{{#if (includes examples "ai")}}
import { streamText, type UIMessage, convertToModelMessages, wrapLanguageModel } from "ai";
import { google } from "@ai-sdk/google";
import { devToolsMiddleware } from "@ai-sdk/devtools";
{{/if}}
{{#if (eq auth "better-auth")}}
import { auth } from "@{{projectName}}/auth";
import { toNodeHandler } from "better-auth/node";
{{/if}}

const app = express();

app.use(
	cors({
		origin: env.CORS_ORIGIN,
		methods: ["GET", "POST", "OPTIONS"],
{{#if (eq auth "better-auth")}}
		allowedHeaders: ["Content-Type", "Authorization"],
		credentials: true,
{{/if}}
	})
);

{{#if (eq auth "better-auth")}}
app.all("/api/auth{/*path}", toNodeHandler(auth));
{{/if}}

{{#if (eq api "trpc")}}
app.use(
	"/trpc",
	createExpressMiddleware({
		router: appRouter,
		createContext,
	})
);
{{/if}}

{{#if (eq api "orpc")}}
const rpcHandler = new RPCHandler(appRouter, {
	interceptors: [
		onError((error) => {
			console.error(error);
		}),
	],
});
const apiHandler = new OpenAPIHandler(appRouter, {
	plugins: [
		new OpenAPIReferencePlugin({
			schemaConverters: [new ZodToJsonSchemaConverter()],
		}),
	],
	interceptors: [
		onError((error) => {
			console.error(error);
		}),
	],
});

app.use(async (req, res, next) => {
	const rpcResult = await rpcHandler.handle(req, res, {
		prefix: "/rpc",
{{#if (eq auth "better-auth")}}
		context: await createContext({ req }),
{{else}}
		context: {},
{{/if}}
	});
	if (rpcResult.matched) return;

	const apiResult = await apiHandler.handle(req, res, {
		prefix: "/api-reference",
{{#if (eq auth "better-auth")}}
		context: await createContext({ req }),
{{else}}
		context: {},
{{/if}}
	});
	if (apiResult.matched) return;

	next();
});
{{/if}}

app.use(express.json());

{{#if (includes examples "ai")}}
app.post("/ai", async (req, res) => {
	const { messages = [] } = (req.body || {}) as { messages: UIMessage[] };
	const model = wrapLanguageModel({
		model: google("gemini-2.5-flash"),
		middleware: devToolsMiddleware(),
	});
	const result = streamText({
		model,
		messages: await convertToModelMessages(messages),
	});
	result.pipeUIMessageStreamToResponse(res);
});
{{/if}}

app.get("/", (_req, res) => {
	res.status(200).send("OK");
});

app.listen(3000, () => {
	console.log("Server is running on http://localhost:3000");
});
`],
  ["backend/server/nestjs/src/app.module.ts.hbs", `import { Module } from "@nestjs/common";
import { AppController } from "./app.controller";
import { AppService } from "./app.service";
{{#if (eq api "trpc")}}
import { TrpcModule } from "./trpc/trpc.module";
{{/if}}
{{#if (eq api "orpc")}}
import { OrpcModule } from "./orpc/orpc.module";
{{/if}}
{{#if (includes examples "ai")}}
import { AiModule } from "./ai/ai.module";
{{/if}}

@Module({
	imports: [
{{#if (eq api "trpc")}}
		TrpcModule,
{{/if}}
{{#if (eq api "orpc")}}
		OrpcModule,
{{/if}}
{{#if (includes examples "ai")}}
		AiModule,
{{/if}}
	],
	controllers: [AppController],
	providers: [AppService],
})
export class AppModule {}
`],
  ["backend/server/nestjs/src/app.controller.ts.hbs", `import { Controller, Get } from "@nestjs/common";
import { AppService } from "./app.service";

@Controller()
export class AppController {
	constructor(private readonly appService: AppService) {}

	@Get()
	getHello(): string {
		return this.appService.getHello();
	}
}
`],
  ["backend/server/nestjs/src/index.ts.hbs", `import "reflect-metadata";
import { env } from "@{{projectName}}/env/server";
import { NestFactory } from "@nestjs/core";
import { AppModule } from "./app.module";
{{#if (eq auth "better-auth")}}
import { auth } from "@{{projectName}}/auth";
{{/if}}

async function bootstrap() {
	const app = await NestFactory.create(AppModule);

	app.enableCors({
		origin: env.CORS_ORIGIN,
		methods: ["GET", "POST", "OPTIONS"],
{{#if (eq auth "better-auth")}}
		allowedHeaders: ["Content-Type", "Authorization"],
		credentials: true,
{{/if}}
	});

{{#if (eq auth "better-auth")}}
	const expressApp = app.getHttpAdapter().getInstance();
	expressApp.all("/api/auth/*path", async (req: any, res: any) => {
		return auth.handler(req);
	});
{{/if}}

	await app.listen(3000);
	console.log("Server is running on http://localhost:3000");
}

bootstrap();
`],
  ["backend/server/nestjs/src/app.service.ts.hbs", `import { Injectable } from "@nestjs/common";

@Injectable()
export class AppService {
	getHello(): string {
		return "OK";
	}
}
`],
  ["backend/server/fets/src/index.ts.hbs", `import { env } from "@{{projectName}}/env/server";
{{#if (eq api "orpc")}}
import { OpenAPIHandler } from "@orpc/openapi/fetch";
import { OpenAPIReferencePlugin } from "@orpc/openapi/plugins";
import { ZodToJsonSchemaConverter } from "@orpc/zod/zod4";
import { RPCHandler } from "@orpc/server/fetch";
import { onError } from "@orpc/server";
import { createContext } from "@{{projectName}}/api/context";
import { appRouter } from "@{{projectName}}/api/routers/index";
{{/if}}
{{#if (eq api "trpc")}}
import { fetchRequestHandler } from "@trpc/server/adapters/fetch";
import { createContext } from "@{{projectName}}/api/context";
import { appRouter } from "@{{projectName}}/api/routers/index";
{{/if}}
{{#if (eq auth "better-auth")}}
import { auth } from "@{{projectName}}/auth";
{{/if}}
import { createRouter, Response } from "fets";
{{#if (and (includes examples "ai") (or (eq runtime "bun") (eq runtime "node")))}}
import { streamText, convertToModelMessages, wrapLanguageModel } from "ai";
import { google } from "@ai-sdk/google";
import { devToolsMiddleware } from "@ai-sdk/devtools";
{{/if}}
{{#if (and (includes examples "ai") (eq runtime "workers"))}}
import { streamText, convertToModelMessages, wrapLanguageModel } from "ai";
import { createGoogleGenerativeAI } from "@ai-sdk/google";
import { devToolsMiddleware } from "@ai-sdk/devtools";
{{/if}}

const router = createRouter({
	openAPI: {
		info: {
			title: "{{projectName}} API",
			version: "1.0.0",
		},
	},
	swaggerUI: {
		endpoint: "/docs",
	},
})
	.route({
		method: "GET",
		path: "/",
		schemas: {
			responses: {
				200: {
					type: "object",
					properties: {
						status: { type: "string" },
					},
					required: ["status"],
					additionalProperties: false,
				},
			},
		},
		handler: () => Response.json({ status: "OK" }),
	})
{{#if (eq auth "better-auth")}}
	.route({
		method: "GET",
		path: "/api/auth/*",
		handler: (request) => auth.handler(request),
	})
	.route({
		method: "POST",
		path: "/api/auth/*",
		handler: (request) => auth.handler(request),
	})
{{/if}}
{{#if (eq api "trpc")}}
	.route({
		method: "GET",
		path: "/trpc/*",
		handler: (request) =>
			fetchRequestHandler({
				endpoint: "/trpc",
				req: request,
				router: appRouter,
				createContext: () => createContext({ context: request }),
			}),
	})
	.route({
		method: "POST",
		path: "/trpc/*",
		handler: (request) =>
			fetchRequestHandler({
				endpoint: "/trpc",
				req: request,
				router: appRouter,
				createContext: () => createContext({ context: request }),
			}),
	})
{{/if}}
{{#if (eq api "orpc")}}
	.route({
		method: "GET",
		path: "/rpc/*",
		handler: async (request) => {
			const context = await createContext({ context: request });
			const rpcHandler = new RPCHandler(appRouter, {
				interceptors: [
					onError((error) => {
						console.error(error);
					}),
				],
			});
			const result = await rpcHandler.handle(request, {
				prefix: "/rpc",
				context,
			});
			if (result.matched) {
				return result.response;
			}
			return Response.json({ error: "Not found" }, { status: 404 });
		},
	})
	.route({
		method: "POST",
		path: "/rpc/*",
		handler: async (request) => {
			const context = await createContext({ context: request });
			const rpcHandler = new RPCHandler(appRouter, {
				interceptors: [
					onError((error) => {
						console.error(error);
					}),
				],
			});
			const result = await rpcHandler.handle(request, {
				prefix: "/rpc",
				context,
			});
			if (result.matched) {
				return result.response;
			}
			return Response.json({ error: "Not found" }, { status: 404 });
		},
	})
	.route({
		method: "GET",
		path: "/api-reference/*",
		handler: async (request) => {
			const context = await createContext({ context: request });
			const apiHandler = new OpenAPIHandler(appRouter, {
				plugins: [
					new OpenAPIReferencePlugin({
						schemaConverters: [new ZodToJsonSchemaConverter()],
					}),
				],
				interceptors: [
					onError((error) => {
						console.error(error);
					}),
				],
			});
			const result = await apiHandler.handle(request, {
				prefix: "/api-reference",
				context,
			});
			if (result.matched) {
				return result.response;
			}
			return Response.json({ error: "Not found" }, { status: 404 });
		},
	})
{{/if}}
{{#if (and (includes examples "ai") (or (eq runtime "bun") (eq runtime "node")))}}
	.route({
		method: "POST",
		path: "/ai",
		handler: async (request) => {
			const body = await request.json();
			const uiMessages = body.messages || [];
			const model = wrapLanguageModel({
				model: google("gemini-2.5-flash"),
				middleware: devToolsMiddleware(),
			});
			const result = streamText({
				model,
				messages: await convertToModelMessages(uiMessages),
			});
			return result.toUIMessageStreamResponse();
		},
	})
{{/if}}
{{#if (and (includes examples "ai") (eq runtime "workers"))}}
	.route({
		method: "POST",
		path: "/ai",
		handler: async (request) => {
			const body = await request.json();
			const uiMessages = body.messages || [];
			const google = createGoogleGenerativeAI({
				apiKey: env.GOOGLE_GENERATIVE_AI_API_KEY,
			});
			const model = wrapLanguageModel({
				model: google("gemini-2.5-flash"),
				middleware: devToolsMiddleware(),
			});
			const result = streamText({
				model,
				messages: await convertToModelMessages(uiMessages),
			});
			return result.toUIMessageStreamResponse();
		},
	})
{{/if}};

{{#if (eq runtime "node")}}
import { createServer } from "node:http";

// Add CORS middleware wrapper
const corsOrigin = env.CORS_ORIGIN;

const corsMiddleware = (handler: typeof router) => {
	return async (request: Request): Promise<globalThis.Response> => {
		// Handle preflight OPTIONS request
		if (request.method === "OPTIONS") {
			return new globalThis.Response(null, {
				status: 204,
				headers: {
					"Access-Control-Allow-Origin": corsOrigin,
					"Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, OPTIONS",
{{#if (eq auth "better-auth")}}
					"Access-Control-Allow-Headers": "Content-Type, Authorization",
					"Access-Control-Allow-Credentials": "true",
{{else}}
					"Access-Control-Allow-Headers": "Content-Type",
{{/if}}
				},
			});
		}

		const response = await handler.fetch(request);
		const newHeaders = new Headers(response.headers);
		newHeaders.set("Access-Control-Allow-Origin", corsOrigin);
		newHeaders.set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS");
{{#if (eq auth "better-auth")}}
		newHeaders.set("Access-Control-Allow-Headers", "Content-Type, Authorization");
		newHeaders.set("Access-Control-Allow-Credentials", "true");
{{else}}
		newHeaders.set("Access-Control-Allow-Headers", "Content-Type");
{{/if}}

		return new globalThis.Response(response.body, {
			status: response.status,
			statusText: response.statusText,
			headers: newHeaders,
		});
	};
};

const handler = corsMiddleware(router);

createServer((req, res) => {
	const url = new URL(req.url || "/", \`http://\${req.headers.host}\`);
	const headers: Record<string, string> = {};
	for (const [key, value] of Object.entries(req.headers)) {
		if (value) headers[key] = Array.isArray(value) ? value.join(", ") : value;
	}

	const body: Buffer[] = [];
	req.on("data", (chunk) => body.push(chunk));
	req.on("end", async () => {
		const request = new Request(url.href, {
			method: req.method,
			headers,
			body: req.method !== "GET" && req.method !== "HEAD" ? Buffer.concat(body) : undefined,
		});

		const response = await handler(request);
		res.statusCode = response.status;
		response.headers.forEach((value, key) => {
			res.setHeader(key, value);
		});
		const responseBody = await response.arrayBuffer();
		res.end(Buffer.from(responseBody));
	});
}).listen(3000, () => {
	console.log("Server is running on http://localhost:3000");
	console.log("Swagger UI is available at http://localhost:3000/docs");
});
{{else}}
{{#if (eq runtime "bun")}}
const corsOrigin = env.CORS_ORIGIN;

const corsMiddleware = (handler: typeof router) => {
	return async (request: Request): Promise<globalThis.Response> => {
		if (request.method === "OPTIONS") {
			return new globalThis.Response(null, {
				status: 204,
				headers: {
					"Access-Control-Allow-Origin": corsOrigin,
					"Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, OPTIONS",
{{#if (eq auth "better-auth")}}
					"Access-Control-Allow-Headers": "Content-Type, Authorization",
					"Access-Control-Allow-Credentials": "true",
{{else}}
					"Access-Control-Allow-Headers": "Content-Type",
{{/if}}
				},
			});
		}

		const response = await handler.fetch(request);
		const newHeaders = new Headers(response.headers);
		newHeaders.set("Access-Control-Allow-Origin", corsOrigin);
		newHeaders.set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS");
{{#if (eq auth "better-auth")}}
		newHeaders.set("Access-Control-Allow-Headers", "Content-Type, Authorization");
		newHeaders.set("Access-Control-Allow-Credentials", "true");
{{else}}
		newHeaders.set("Access-Control-Allow-Headers", "Content-Type");
{{/if}}

		return new globalThis.Response(response.body, {
			status: response.status,
			statusText: response.statusText,
			headers: newHeaders,
		});
	};
};

const server = Bun.serve({
	port: 3000,
	fetch: corsMiddleware(router),
});

console.log(\`Server is running on http://localhost:\${server.port}\`);
console.log(\`Swagger UI is available at http://localhost:\${server.port}/docs\`);
{{/if}}
{{#if (eq runtime "workers")}}
export default router;
{{/if}}
{{/if}}
`],
  ["backend/server/hono/src/index.ts.hbs", `import { env } from "@{{projectName}}/env/server";
{{#if (eq api "orpc")}}
import { OpenAPIHandler } from "@orpc/openapi/fetch";
import { OpenAPIReferencePlugin } from "@orpc/openapi/plugins";
import { ZodToJsonSchemaConverter } from "@orpc/zod/zod4";
import { RPCHandler } from "@orpc/server/fetch";
import { onError } from "@orpc/server";
import { createContext } from "@{{projectName}}/api/context";
import { appRouter } from "@{{projectName}}/api/routers/index";
{{/if}}
{{#if (eq api "trpc")}}
import { trpcServer } from "@hono/trpc-server";
import { createContext } from "@{{projectName}}/api/context";
import { appRouter } from "@{{projectName}}/api/routers/index";
{{/if}}
{{#if (eq auth "better-auth")}}
import { auth } from "@{{projectName}}/auth";
{{/if}}
import { Hono } from "hono";
import { cors } from "hono/cors";
import { logger } from "hono/logger";
{{#if (and (includes examples "ai") (or (eq runtime "bun") (eq runtime "node")))}}
import { streamText, convertToModelMessages, wrapLanguageModel } from "ai";
import { google } from "@ai-sdk/google";
import { devToolsMiddleware } from "@ai-sdk/devtools";
{{/if}}
{{#if (and (includes examples "ai") (eq runtime "workers"))}}
import { streamText, convertToModelMessages, wrapLanguageModel } from "ai";
import { createGoogleGenerativeAI } from "@ai-sdk/google";
import { devToolsMiddleware } from "@ai-sdk/devtools";
{{/if}}

const app = new Hono();

app.use(logger());
app.use(
	"/*",
	cors({
		origin: env.CORS_ORIGIN,
		allowMethods: ["GET", "POST", "OPTIONS"],
{{#if (eq auth "better-auth")}}
		allowHeaders: ["Content-Type", "Authorization"],
		credentials: true,
{{/if}}
	})
);

{{#if (eq auth "better-auth")}}
app.on(["POST", "GET"], "/api/auth/*", (c) => auth.handler(c.req.raw));
{{/if}}

{{#if (eq api "orpc")}}
export const apiHandler = new OpenAPIHandler(appRouter, {
	plugins: [
		new OpenAPIReferencePlugin({
			schemaConverters: [new ZodToJsonSchemaConverter()],
		}),
	],
	interceptors: [
		onError((error) => {
			console.error(error);
		}),
	],
});

export const rpcHandler = new RPCHandler(appRouter, {
	interceptors: [
		onError((error) => {
			console.error(error);
		}),
	],
});

app.use("/*", async (c, next) => {
	const context = await createContext({ context: c });

	const rpcResult = await rpcHandler.handle(c.req.raw, {
		prefix: "/rpc",
		context: context,
	});

	if (rpcResult.matched) {
		return c.newResponse(rpcResult.response.body, rpcResult.response);
	}

	const apiResult = await apiHandler.handle(c.req.raw, {
		prefix: "/api-reference",
		context: context,
	});

	if (apiResult.matched) {
		return c.newResponse(apiResult.response.body, apiResult.response);
	}

	await next();
});
{{/if}}

{{#if (eq api "trpc")}}
app.use(
	"/trpc/*",
	trpcServer({
		router: appRouter,
		createContext: (_opts, context) => {
			return createContext({ context });
		},
	})
);
{{/if}}

{{#if (and (includes examples "ai") (or (eq runtime "bun") (eq runtime "node")))}}
app.post("/ai", async (c) => {
	const body = await c.req.json();
	const uiMessages = body.messages || [];
	const model = wrapLanguageModel({
		model: google("gemini-2.5-flash"),
		middleware: devToolsMiddleware(),
	});
	const result = streamText({
		model,
		messages: await convertToModelMessages(uiMessages),
	});

	return result.toUIMessageStreamResponse();
});
{{/if}}

{{#if (and (includes examples "ai") (eq runtime "workers"))}}
app.post("/ai", async (c) => {
	const body = await c.req.json();
	const uiMessages = body.messages || [];
	const google = createGoogleGenerativeAI({
		apiKey: env.GOOGLE_GENERATIVE_AI_API_KEY,
	});
	const model = wrapLanguageModel({
		model: google("gemini-2.5-flash"),
		middleware: devToolsMiddleware(),
	});
	const result = streamText({
		model,
		messages: await convertToModelMessages(uiMessages),
	});

	return result.toUIMessageStreamResponse();
});
{{/if}}

app.get("/", (c) => {
	return c.text("OK");
});

{{#if (eq runtime "node")}}
import { serve } from "@hono/node-server";

serve(
	{
		fetch: app.fetch,
		port: 3000,
	},
	(info) => {
		console.log(\`Server is running on http://localhost:\${info.port}\`);
	}
);
{{else}}
{{#if (eq runtime "bun")}}
export default app;
{{/if}}
{{#if (eq runtime "workers")}}
export default app;
{{/if}}
{{/if}}
`],
  ["db/mikroorm/postgres/src/index.ts.hbs", `import { MikroORM, type Options } from "@mikro-orm/core";
import { PostgreSqlDriver } from "@mikro-orm/postgresql";
import { env } from "@{{projectName}}/env/server";

const config: Options<PostgreSqlDriver> = {
	driver: PostgreSqlDriver,
	clientUrl: env.DATABASE_URL,
	entities: ["./src/entities"],
	entitiesTs: ["./src/entities"],
	debug: process.env.NODE_ENV !== "production",
{{#if (eq dbSetup "neon")}}
	driverOptions: {
		connection: {
			ssl: {
				rejectUnauthorized: false,
			},
		},
	},
{{/if}}
};

let orm: MikroORM<PostgreSqlDriver> | null = null;

export const initializeDatabase = async () => {
	if (!orm) {
		orm = await MikroORM.init(config);
	}
	return orm;
};

export const getEntityManager = async () => {
	const db = await initializeDatabase();
	return db.em.fork();
};

export const db = {
	getORM: initializeDatabase,
	getEM: getEntityManager,
};
`],
  ["db/redis/base/src/index.ts.hbs", `import Redis from "ioredis";

// Create Redis client with connection from environment
// Supports both REDIS_URL format and individual host/port/password
const redisUrl = process.env.REDIS_URL || process.env.DATABASE_URL;

export const redis = redisUrl
  ? new Redis(redisUrl)
  : new Redis({
      host: process.env.REDIS_HOST || "localhost",
      port: parseInt(process.env.REDIS_PORT || "6379", 10),
      password: process.env.REDIS_PASSWORD || undefined,
      db: parseInt(process.env.REDIS_DB || "0", 10),
    });

// Re-export as db for consistency with other database packages
export { redis as db };

/**
 * String operations
 */
export async function get<T = string>(key: string): Promise<T | null> {
  const value = await redis.get(key);
  if (value === null) return null;
  try {
    return JSON.parse(value) as T;
  } catch {
    return value as T;
  }
}

export async function set(
  key: string,
  value: unknown,
  options?: { ex?: number; px?: number; nx?: boolean; xx?: boolean }
): Promise<"OK" | null> {
  const serialized = typeof value === "string" ? value : JSON.stringify(value);
  if (options?.ex) {
    return redis.set(key, serialized, "EX", options.ex);
  }
  if (options?.px) {
    return redis.set(key, serialized, "PX", options.px);
  }
  if (options?.nx) {
    return redis.set(key, serialized, "NX");
  }
  if (options?.xx) {
    return redis.set(key, serialized, "XX");
  }
  return redis.set(key, serialized);
}

export async function del(...keys: string[]): Promise<number> {
  if (keys.length === 0) return 0;
  return redis.del(...keys);
}

export async function exists(...keys: string[]): Promise<number> {
  if (keys.length === 0) return 0;
  return redis.exists(...keys);
}

export async function expire(key: string, seconds: number): Promise<number> {
  return redis.expire(key, seconds);
}

export async function ttl(key: string): Promise<number> {
  return redis.ttl(key);
}

export async function incr(key: string): Promise<number> {
  return redis.incr(key);
}

export async function incrby(key: string, increment: number): Promise<number> {
  return redis.incrby(key, increment);
}

export async function decr(key: string): Promise<number> {
  return redis.decr(key);
}

/**
 * Get or set pattern - retrieves from cache or executes function and caches result
 */
export async function getOrSet<T>(
  key: string,
  fn: () => Promise<T>,
  ttlSeconds?: number
): Promise<T> {
  const cached = await get<T>(key);
  if (cached !== null) {
    return cached;
  }

  const value = await fn();
  await set(key, value, ttlSeconds ? { ex: ttlSeconds } : undefined);
  return value;
}

/**
 * Hash operations
 */
export const hash = {
  async get<T = string>(key: string, field: string): Promise<T | null> {
    const value = await redis.hget(key, field);
    if (value === null) return null;
    try {
      return JSON.parse(value) as T;
    } catch {
      return value as T;
    }
  },

  async getAll<T extends Record<string, unknown>>(key: string): Promise<T> {
    const result = await redis.hgetall(key);
    const parsed: Record<string, unknown> = {};
    for (const [field, value] of Object.entries(result)) {
      try {
        parsed[field] = JSON.parse(value);
      } catch {
        parsed[field] = value;
      }
    }
    return parsed as T;
  },

  async set(key: string, field: string, value: unknown): Promise<number> {
    const serialized = typeof value === "string" ? value : JSON.stringify(value);
    return redis.hset(key, field, serialized);
  },

  async setMultiple(key: string, values: Record<string, unknown>): Promise<"OK"> {
    const serialized: Record<string, string> = {};
    for (const [field, value] of Object.entries(values)) {
      serialized[field] = typeof value === "string" ? value : JSON.stringify(value);
    }
    return redis.hset(key, serialized) as unknown as Promise<"OK">;
  },

  async del(key: string, ...fields: string[]): Promise<number> {
    return redis.hdel(key, ...fields);
  },

  async exists(key: string, field: string): Promise<boolean> {
    const result = await redis.hexists(key, field);
    return result === 1;
  },

  async keys(key: string): Promise<string[]> {
    return redis.hkeys(key);
  },

  async len(key: string): Promise<number> {
    return redis.hlen(key);
  },
};

/**
 * List operations
 */
export const list = {
  async push(key: string, ...values: unknown[]): Promise<number> {
    const serialized = values.map((v) => (typeof v === "string" ? v : JSON.stringify(v)));
    return redis.rpush(key, ...serialized);
  },

  async unshift(key: string, ...values: unknown[]): Promise<number> {
    const serialized = values.map((v) => (typeof v === "string" ? v : JSON.stringify(v)));
    return redis.lpush(key, ...serialized);
  },

  async pop<T = string>(key: string): Promise<T | null> {
    const value = await redis.rpop(key);
    if (value === null) return null;
    try {
      return JSON.parse(value) as T;
    } catch {
      return value as T;
    }
  },

  async shift<T = string>(key: string): Promise<T | null> {
    const value = await redis.lpop(key);
    if (value === null) return null;
    try {
      return JSON.parse(value) as T;
    } catch {
      return value as T;
    }
  },

  async range<T = string>(key: string, start: number, stop: number): Promise<T[]> {
    const values = await redis.lrange(key, start, stop);
    return values.map((v) => {
      try {
        return JSON.parse(v) as T;
      } catch {
        return v as T;
      }
    });
  },

  async len(key: string): Promise<number> {
    return redis.llen(key);
  },

  async trim(key: string, start: number, stop: number): Promise<"OK"> {
    return redis.ltrim(key, start, stop);
  },
};

/**
 * Set operations
 */
export const set_ = {
  async add(key: string, ...members: unknown[]): Promise<number> {
    const serialized = members.map((m) => (typeof m === "string" ? m : JSON.stringify(m)));
    return redis.sadd(key, ...serialized);
  },

  async remove(key: string, ...members: unknown[]): Promise<number> {
    const serialized = members.map((m) => (typeof m === "string" ? m : JSON.stringify(m)));
    return redis.srem(key, ...serialized);
  },

  async members<T = string>(key: string): Promise<T[]> {
    const values = await redis.smembers(key);
    return values.map((v) => {
      try {
        return JSON.parse(v) as T;
      } catch {
        return v as T;
      }
    });
  },

  async isMember(key: string, member: unknown): Promise<boolean> {
    const serialized = typeof member === "string" ? member : JSON.stringify(member);
    const result = await redis.sismember(key, serialized);
    return result === 1;
  },

  async size(key: string): Promise<number> {
    return redis.scard(key);
  },
};

/**
 * Sorted set operations
 */
export const zset = {
  async add(key: string, ...scoreMembers: Array<{ score: number; member: unknown }>): Promise<number> {
    const args: (string | number)[] = [];
    for (const { score, member } of scoreMembers) {
      args.push(score, typeof member === "string" ? member : JSON.stringify(member));
    }
    return redis.zadd(key, ...args);
  },

  async range<T = string>(key: string, start: number, stop: number): Promise<T[]> {
    const values = await redis.zrange(key, start, stop);
    return values.map((v) => {
      try {
        return JSON.parse(v) as T;
      } catch {
        return v as T;
      }
    });
  },

  async rangeWithScores<T = string>(
    key: string,
    start: number,
    stop: number
  ): Promise<Array<{ member: T; score: number }>> {
    const values = await redis.zrange(key, start, stop, "WITHSCORES");
    const result: Array<{ member: T; score: number }> = [];
    for (let i = 0; i < values.length; i += 2) {
      const memberStr = values[i];
      const scoreStr = values[i + 1];
      if (memberStr !== undefined && scoreStr !== undefined) {
        let member: T;
        try {
          member = JSON.parse(memberStr) as T;
        } catch {
          member = memberStr as T;
        }
        result.push({ member, score: parseFloat(scoreStr) });
      }
    }
    return result;
  },

  async score(key: string, member: unknown): Promise<number | null> {
    const serialized = typeof member === "string" ? member : JSON.stringify(member);
    return redis.zscore(key, serialized);
  },

  async rank(key: string, member: unknown): Promise<number | null> {
    const serialized = typeof member === "string" ? member : JSON.stringify(member);
    return redis.zrank(key, serialized);
  },

  async remove(key: string, ...members: unknown[]): Promise<number> {
    const serialized = members.map((m) => (typeof m === "string" ? m : JSON.stringify(m)));
    return redis.zrem(key, ...serialized);
  },

  async size(key: string): Promise<number> {
    return redis.zcard(key);
  },
};

/**
 * Pub/Sub operations
 */
export const pubsub = {
  async publish(channel: string, message: unknown): Promise<number> {
    const serialized = typeof message === "string" ? message : JSON.stringify(message);
    return redis.publish(channel, serialized);
  },

  /**
   * Subscribe to channel(s) - returns a new Redis client for subscriptions
   * Note: A Redis client in subscriber mode cannot be used for other commands
   */
  createSubscriber(): Redis {
    return redis.duplicate();
  },
};

/**
 * Utility functions
 */
export async function ping(): Promise<string> {
  return redis.ping();
}

export async function keys(pattern: string): Promise<string[]> {
  return redis.keys(pattern);
}

export async function flushdb(): Promise<"OK"> {
  return redis.flushdb();
}

/**
 * Gracefully close the Redis connection
 */
export async function disconnect(): Promise<"OK"> {
  return redis.quit();
}
`],
  ["backend/server/adonisjs/start/routes.ts.hbs", `import { env } from "@{{projectName}}/env/server";
{{#if (eq api "trpc")}}
import { createExpressMiddleware } from "@trpc/server/adapters/express";
import { createContext } from "@{{projectName}}/api/context";
import { appRouter } from "@{{projectName}}/api/routers/index";
{{/if}}
{{#if (eq api "orpc")}}
import { OpenAPIHandler } from "@orpc/openapi/node";
import { OpenAPIReferencePlugin } from "@orpc/openapi/plugins";
import { ZodToJsonSchemaConverter } from "@orpc/zod/zod4";
import { RPCHandler } from "@orpc/server/node";
import { onError } from "@orpc/server";
import { appRouter } from "@{{projectName}}/api/routers/index";
{{#if (eq auth "better-auth")}}
import { createContext } from "@{{projectName}}/api/context";
{{/if}}
{{/if}}
{{#if (includes examples "ai")}}
import { streamText, type UIMessage, convertToModelMessages, wrapLanguageModel } from "ai";
import { google } from "@ai-sdk/google";
import { devToolsMiddleware } from "@ai-sdk/devtools";
{{/if}}
{{#if (eq auth "better-auth")}}
import { auth } from "@{{projectName}}/auth";
import { toNodeHandler } from "better-auth/node";
{{/if}}
import router from "@adonisjs/core/services/router";

// CORS headers helper
const setCorsHeaders = (response: any) => {
	const origin = env.CORS_ORIGIN;
	response.header("Access-Control-Allow-Origin", origin);
	response.header("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS");
{{#if (eq auth "better-auth")}}
	response.header("Access-Control-Allow-Headers", "Content-Type, Authorization");
	response.header("Access-Control-Allow-Credentials", "true");
{{else}}
	response.header("Access-Control-Allow-Headers", "Content-Type");
{{/if}}
};

// CORS preflight handler
router.options("*", ({ response }) => {
	setCorsHeaders(response);
	return response.status(204);
});

// Health check endpoint
router.get("/", ({ response }) => {
	setCorsHeaders(response);
	return response.send("OK");
});

{{#if (eq auth "better-auth")}}
// Better Auth handler
const authHandler = toNodeHandler(auth);
router.any("/api/auth/*", async ({ request, response }) => {
	setCorsHeaders(response);
	return new Promise<void>((resolve) => {
		authHandler(request.request as any, response.response as any, () => {
			resolve();
		});
	});
});
{{/if}}

{{#if (eq api "trpc")}}
// tRPC middleware adapter for AdonisJS
const trpcMiddleware = createExpressMiddleware({
	router: appRouter,
	createContext,
});

router.any("/trpc/*", async ({ request, response }) => {
	setCorsHeaders(response);
	return new Promise<void>((resolve) => {
		trpcMiddleware(request.request as any, response.response as any, () => {
			resolve();
		});
	});
});
{{/if}}

{{#if (eq api "orpc")}}
const rpcHandler = new RPCHandler(appRouter, {
	interceptors: [
		onError((error) => {
			console.error(error);
		}),
	],
});
const apiHandler = new OpenAPIHandler(appRouter, {
	plugins: [
		new OpenAPIReferencePlugin({
			schemaConverters: [new ZodToJsonSchemaConverter()],
		}),
	],
	interceptors: [
		onError((error) => {
			console.error(error);
		}),
	],
});

router.any("/rpc/*", async ({ request, response }) => {
	setCorsHeaders(response);
	const result = await rpcHandler.handle(request.request as any, response.response as any, {
		prefix: "/rpc",
{{#if (eq auth "better-auth")}}
		context: await createContext({ req: request.request as any }),
{{else}}
		context: {},
{{/if}}
	});
	if (!result.matched) {
		return response.status(404).send("Not Found");
	}
});

router.any("/api-reference/*", async ({ request, response }) => {
	setCorsHeaders(response);
	const result = await apiHandler.handle(request.request as any, response.response as any, {
		prefix: "/api-reference",
{{#if (eq auth "better-auth")}}
		context: await createContext({ req: request.request as any }),
{{else}}
		context: {},
{{/if}}
	});
	if (!result.matched) {
		return response.status(404).send("Not Found");
	}
});
{{/if}}

{{#if (includes examples "ai")}}
router.post("/ai", async ({ request, response }) => {
	setCorsHeaders(response);
	const body = request.body() as { messages?: UIMessage[] };
	const messages = body.messages || [];
	const model = wrapLanguageModel({
		model: google("gemini-2.5-flash"),
		middleware: devToolsMiddleware(),
	});
	const result = streamText({
		model,
		messages: await convertToModelMessages(messages),
	});
	result.pipeUIMessageStreamToResponse(response.response as any);
});
{{/if}}
`],
  ["db/redis/upstash/src/index.ts.hbs", `import { Redis } from "@upstash/redis";

// Create Upstash Redis client from environment variables
// Get your credentials at https://console.upstash.com
export const redis = new Redis({
  url: process.env.UPSTASH_REDIS_REST_URL!,
  token: process.env.UPSTASH_REDIS_REST_TOKEN!,
});

// Re-export as db for consistency with other database packages
export { redis as db };

/**
 * String operations
 */
export async function get<T = string>(key: string): Promise<T | null> {
  return redis.get<T>(key);
}

export async function set(
  key: string,
  value: unknown,
  options?: { ex?: number; px?: number; nx?: boolean; xx?: boolean }
): Promise<"OK" | null> {
  if (options?.ex) {
    return redis.set(key, value, { ex: options.ex });
  }
  if (options?.px) {
    return redis.set(key, value, { px: options.px });
  }
  if (options?.nx) {
    return redis.set(key, value, { nx: true });
  }
  if (options?.xx) {
    return redis.set(key, value, { xx: true });
  }
  return redis.set(key, value);
}

export async function del(...keys: string[]): Promise<number> {
  if (keys.length === 0) return 0;
  return redis.del(...keys);
}

export async function exists(...keys: string[]): Promise<number> {
  if (keys.length === 0) return 0;
  return redis.exists(...keys);
}

export async function expire(key: string, seconds: number): Promise<number> {
  return redis.expire(key, seconds);
}

export async function ttl(key: string): Promise<number> {
  return redis.ttl(key);
}

export async function incr(key: string): Promise<number> {
  return redis.incr(key);
}

export async function incrby(key: string, increment: number): Promise<number> {
  return redis.incrby(key, increment);
}

export async function decr(key: string): Promise<number> {
  return redis.decr(key);
}

/**
 * Get or set pattern - retrieves from cache or executes function and caches result
 */
export async function getOrSet<T>(
  key: string,
  fn: () => Promise<T>,
  ttlSeconds?: number
): Promise<T> {
  const cached = await get<T>(key);
  if (cached !== null) {
    return cached;
  }

  const value = await fn();
  await set(key, value, ttlSeconds ? { ex: ttlSeconds } : undefined);
  return value;
}

/**
 * Hash operations
 */
export const hash = {
  async get<T = string>(key: string, field: string): Promise<T | null> {
    return redis.hget<T>(key, field);
  },

  async getAll<T extends Record<string, unknown>>(key: string): Promise<T | null> {
    return redis.hgetall<T>(key);
  },

  async set(key: string, field: string, value: unknown): Promise<number> {
    return redis.hset(key, { [field]: value });
  },

  async setMultiple(key: string, values: Record<string, unknown>): Promise<number> {
    return redis.hset(key, values);
  },

  async del(key: string, ...fields: string[]): Promise<number> {
    return redis.hdel(key, ...fields);
  },

  async exists(key: string, field: string): Promise<boolean> {
    const result = await redis.hexists(key, field);
    return result === 1;
  },

  async keys(key: string): Promise<string[]> {
    return redis.hkeys(key);
  },

  async len(key: string): Promise<number> {
    return redis.hlen(key);
  },
};

/**
 * List operations
 */
export const list = {
  async push(key: string, ...values: unknown[]): Promise<number> {
    return redis.rpush(key, ...values);
  },

  async unshift(key: string, ...values: unknown[]): Promise<number> {
    return redis.lpush(key, ...values);
  },

  async pop<T = string>(key: string): Promise<T | null> {
    return redis.rpop<T>(key);
  },

  async shift<T = string>(key: string): Promise<T | null> {
    return redis.lpop<T>(key);
  },

  async range<T = string>(key: string, start: number, stop: number): Promise<T[]> {
    return redis.lrange<T>(key, start, stop);
  },

  async len(key: string): Promise<number> {
    return redis.llen(key);
  },

  async trim(key: string, start: number, stop: number): Promise<"OK"> {
    return redis.ltrim(key, start, stop);
  },
};

/**
 * Set operations
 */
export const set_ = {
  async add(key: string, ...members: unknown[]): Promise<number> {
    return redis.sadd(key, ...members);
  },

  async remove(key: string, ...members: unknown[]): Promise<number> {
    return redis.srem(key, ...members);
  },

  async members<T = string>(key: string): Promise<T[]> {
    return redis.smembers<T[]>(key);
  },

  async isMember(key: string, member: unknown): Promise<boolean> {
    const result = await redis.sismember(key, member as string);
    return result === 1;
  },

  async size(key: string): Promise<number> {
    return redis.scard(key);
  },
};

/**
 * Sorted set operations
 */
export const zset = {
  async add(key: string, ...scoreMembers: Array<{ score: number; member: unknown }>): Promise<number> {
    const args = scoreMembers.map(({ score, member }) => ({ score, member }));
    return redis.zadd(key, ...args);
  },

  async range<T = string>(key: string, start: number, stop: number): Promise<T[]> {
    return redis.zrange<T[]>(key, start, stop);
  },

  async rangeWithScores<T = string>(
    key: string,
    start: number,
    stop: number
  ): Promise<Array<{ member: T; score: number }>> {
    const values = await redis.zrange<T[]>(key, start, stop, { withScores: true });
    const result: Array<{ member: T; score: number }> = [];
    for (let i = 0; i < values.length; i += 2) {
      const member = values[i];
      const score = values[i + 1] as unknown as number;
      if (member !== undefined) {
        result.push({ member, score });
      }
    }
    return result;
  },

  async score(key: string, member: unknown): Promise<number | null> {
    return redis.zscore(key, member as string);
  },

  async rank(key: string, member: unknown): Promise<number | null> {
    return redis.zrank(key, member as string);
  },

  async remove(key: string, ...members: unknown[]): Promise<number> {
    return redis.zrem(key, ...members as string[]);
  },

  async size(key: string): Promise<number> {
    return redis.zcard(key);
  },
};

/**
 * JSON operations (Upstash Redis supports JSON natively)
 */
export const json = {
  async get<T>(key: string, path = "$"): Promise<T | null> {
    return redis.json.get<T>(key, path);
  },

  async set(key: string, path: string, value: unknown): Promise<"OK" | null> {
    return redis.json.set(key, path, value);
  },

  async del(key: string, path = "$"): Promise<number> {
    return redis.json.del(key, path);
  },
};

/**
 * Utility functions
 */
export async function ping(): Promise<string> {
  return redis.ping();
}

export async function keys(pattern: string): Promise<string[]> {
  return redis.keys(pattern);
}

export async function flushdb(): Promise<string> {
  return redis.flushdb();
}
`],
  ["db/sequelize/postgres/src/index.ts.hbs", `import { Sequelize } from "sequelize-typescript";
import { env } from "@{{projectName}}/env/server";

export const sequelize = new Sequelize(env.DATABASE_URL, {
	dialect: "postgres",
	logging: false,
	models: [__dirname + "/models/**/*.ts"],
{{#if (eq dbSetup "neon")}}
	dialectOptions: {
		ssl: {
			require: true,
			rejectUnauthorized: false,
		},
	},
{{/if}}
});

export const initializeDatabase = async () => {
	await sequelize.authenticate();
	await sequelize.sync();
	return sequelize;
};

export const db = sequelize;
`],
  ["db/sequelize/sqlite/src/index.ts.hbs", `import { Sequelize } from "sequelize-typescript";
import { env } from "@{{projectName}}/env/server";

const dbPath = env.DATABASE_URL.replace("file:", "");

export const sequelize = new Sequelize({
	dialect: "sqlite",
	storage: dbPath,
	logging: false,
	models: [__dirname + "/models/**/*.ts"],
});

export const initializeDatabase = async () => {
	await sequelize.authenticate();
	await sequelize.sync();
	return sequelize;
};

export const db = sequelize;
`],
  ["db/sequelize/mysql/src/index.ts.hbs", `import { Sequelize } from "sequelize-typescript";
import { env } from "@{{projectName}}/env/server";

export const sequelize = new Sequelize(env.DATABASE_URL, {
	dialect: "mysql",
	logging: false,
	models: [__dirname + "/models/**/*.ts"],
{{#if (eq dbSetup "planetscale")}}
	dialectOptions: {
		ssl: {
			rejectUnauthorized: false,
		},
	},
{{/if}}
});

export const initializeDatabase = async () => {
	await sequelize.authenticate();
	await sequelize.sync();
	return sequelize;
};

export const db = sequelize;
`],
  ["db/mongoose/mongodb/src/index.ts.hbs", `import mongoose from "mongoose";
import { env } from "@{{projectName}}/env/server";

await mongoose.connect(env.DATABASE_URL).catch((error) => {
	console.log("Error connecting to database:", error);
});

const client = mongoose.connection.getClient().db("myDB");

export { client };
`],
  ["backend/server/adonisjs/bin/server.ts.hbs", `import "reflect-metadata";
import { Ignitor, prettyPrintError } from "@adonisjs/core";

const APP_ROOT = new URL("../", import.meta.url);

const ignitor = new Ignitor(APP_ROOT);

ignitor
	.tap((app) => {
		app.booting(async () => {
			await import("#start/routes");
		});
	})
	.httpServer()
	.start()
	.catch((error) => {
		process.exitCode = 1;
		prettyPrintError(error);
	});
`],
  ["backend/server/adonisjs/config/app.ts.hbs", `import { defineConfig } from "@adonisjs/core/http";

export default defineConfig({
	generateRequestId: true,
	useAsyncLocalStorage: true,
	qs: {
		parse: {},
	},
});
`],
  ["db/mikroorm/mysql/src/index.ts.hbs", `import { MikroORM, type Options } from "@mikro-orm/core";
import { MySqlDriver } from "@mikro-orm/mysql";
import { env } from "@{{projectName}}/env/server";

const config: Options<MySqlDriver> = {
	driver: MySqlDriver,
	clientUrl: env.DATABASE_URL,
	entities: ["./src/entities"],
	entitiesTs: ["./src/entities"],
	debug: process.env.NODE_ENV !== "production",
{{#if (eq dbSetup "planetscale")}}
	driverOptions: {
		connection: {
			ssl: {
				rejectUnauthorized: false,
			},
		},
	},
{{/if}}
};

let orm: MikroORM<MySqlDriver> | null = null;

export const initializeDatabase = async () => {
	if (!orm) {
		orm = await MikroORM.init(config);
	}
	return orm;
};

export const getEntityManager = async () => {
	const db = await initializeDatabase();
	return db.em.fork();
};

export const db = {
	getORM: initializeDatabase,
	getEM: getEntityManager,
};
`],
  ["db/typeorm/mysql/src/index.ts.hbs", `import "reflect-metadata";
import { DataSource } from "typeorm";
import { env } from "@{{projectName}}/env/server";

export const AppDataSource = new DataSource({
	type: "mysql",
	url: env.DATABASE_URL,
	synchronize: true,
	logging: false,
	entities: ["src/entities/**/*.ts"],
	migrations: ["src/migrations/**/*.ts"],
	subscribers: ["src/subscribers/**/*.ts"],
{{#if (eq dbSetup "planetscale")}}
	ssl: {
		rejectUnauthorized: false,
	},
{{/if}}
});

export const initializeDatabase = async () => {
	if (!AppDataSource.isInitialized) {
		await AppDataSource.initialize();
	}
	return AppDataSource;
};

export const db = AppDataSource;
`],
  ["db/edgedb/base/dbschema/default.esdl.hbs", `module default {
{{#if (includes examples "todo")}}
  # Todo type for the todo example
  type Todo {
    required title: str;
    completed: bool {
      default := false;
    };
    created_at: datetime {
      default := datetime_current();
    };
  }
{{/if}}

{{#if (eq auth "better-auth")}}
  # User type for authentication
  type User {
    required email: str {
      constraint exclusive;
    };
    required name: str;
    email_verified: bool {
      default := false;
    };
    image: str;
    created_at: datetime {
      default := datetime_current();
    };
    updated_at: datetime {
      default := datetime_current();
    };
  }

  # Session type for authentication
  type Session {
    required token: str {
      constraint exclusive;
    };
    required expires_at: datetime;
    ip_address: str;
    user_agent: str;
    required user: User;
    created_at: datetime {
      default := datetime_current();
    };
    updated_at: datetime {
      default := datetime_current();
    };
  }

  # Account type for OAuth providers
  type Account {
    required account_id: str;
    required provider_id: str;
    access_token: str;
    refresh_token: str;
    access_token_expires_at: datetime;
    refresh_token_expires_at: datetime;
    scope: str;
    id_token: str;
    password: str;
    required user: User;
    created_at: datetime {
      default := datetime_current();
    };
    updated_at: datetime {
      default := datetime_current();
    };

    constraint exclusive on ((.provider_id, .account_id));
  }

  # Verification token for email verification
  type Verification {
    required identifier: str;
    required value: str;
    required expires_at: datetime;
    created_at: datetime {
      default := datetime_current();
    };
    updated_at: datetime {
      default := datetime_current();
    };
  }
{{/if}}
}
`],
  ["db/kysely/postgres/src/index.ts.hbs", `import { env } from "@{{projectName}}/env/server";
import { Kysely, PostgresDialect } from "kysely";
import { Pool } from "pg";
import type { Database as DB } from "./schema";

const dialect = new PostgresDialect({
	pool: new Pool({
		connectionString: env.DATABASE_URL,
{{#if (eq dbSetup "neon")}}
		ssl: {
			rejectUnauthorized: false,
		},
{{/if}}
	}),
});

export const db = new Kysely<DB>({
	dialect,
});
`],
  ["db/edgedb/base/src/index.ts.hbs", `import * as edgedb from "edgedb";

// Create a client instance - automatically discovers connection settings
// from environment variables (EDGEDB_DSN) or edgedb.toml
export const client = edgedb.createClient();

// For serverless/edge environments, use the HTTP client instead:
// import { createHttpClient } from "edgedb";
// export const client = createHttpClient();

// Re-export the client for use in your application
export { client as db };
`],
  ["db/mikroorm/sqlite/src/index.ts.hbs", `import { MikroORM, type Options } from "@mikro-orm/core";
import { BetterSqliteDriver } from "@mikro-orm/better-sqlite";
import { env } from "@{{projectName}}/env/server";

const config: Options<BetterSqliteDriver> = {
	driver: BetterSqliteDriver,
	dbName: env.DATABASE_URL.replace("file:", ""),
	entities: ["./src/entities"],
	entitiesTs: ["./src/entities"],
	debug: process.env.NODE_ENV !== "production",
};

let orm: MikroORM<BetterSqliteDriver> | null = null;

export const initializeDatabase = async () => {
	if (!orm) {
		orm = await MikroORM.init(config);
	}
	return orm;
};

export const getEntityManager = async () => {
	const db = await initializeDatabase();
	return db.em.fork();
};

export const db = {
	getORM: initializeDatabase,
	getEM: getEntityManager,
};
`],
  ["db/kysely/sqlite/src/index.ts.hbs", `import { env } from "@{{projectName}}/env/server";
import { Kysely, SqliteDialect } from "kysely";
import Database from "better-sqlite3";
import type { Database as DB } from "./schema";

const dialect = new SqliteDialect({
	database: new Database(env.DATABASE_URL.replace("file:", "")),
});

export const db = new Kysely<DB>({
	dialect,
});
`],
  ["db/drizzle/sqlite/src/index.ts.hbs", `{{#if (or (eq runtime "bun") (eq runtime "node") (eq runtime "none"))}}
import { env } from "@{{projectName}}/env/server";
import * as schema from "./schema";
import { drizzle } from "drizzle-orm/libsql";
import { createClient } from "@libsql/client";

const client = createClient({
	url: env.DATABASE_URL,
{{#if (eq dbSetup "turso")}}
	authToken: env.DATABASE_AUTH_TOKEN,
{{/if}}
});

export const db = drizzle({ client, schema });
{{/if}}

{{#if (eq runtime "workers")}}
import * as schema from "./schema";

{{#if (eq dbSetup "d1")}}
import { drizzle } from "drizzle-orm/d1";
import { env } from "@{{projectName}}/env/server";

export const db = drizzle(env.DB, { schema });
{{else}}
import { drizzle } from "drizzle-orm/libsql";
import { env } from "@{{projectName}}/env/server";
import { createClient } from "@libsql/client";

const client = createClient({
	url: env.DATABASE_URL || "",
{{#if (eq dbSetup "turso")}}
	authToken: env.DATABASE_AUTH_TOKEN,
{{/if}}
});

export const db = drizzle({ client, schema });
{{/if}}
{{/if}}
`],
  ["db/drizzle/postgres/src/index.ts.hbs", `{{#if (or (eq runtime "bun") (eq runtime "node") (eq runtime "none"))}}
import { env } from "@{{projectName}}/env/server";
import * as schema from "./schema";

{{#if (eq dbSetup "neon")}}
import { neon, neonConfig } from '@neondatabase/serverless';
import { drizzle } from 'drizzle-orm/neon-http';
import ws from "ws";

neonConfig.webSocketConstructor = ws;

// To work in edge environments (Cloudflare Workers, Vercel Edge, etc.), enable querying over fetch
// neonConfig.poolQueryViaFetch = true

const sql = neon(env.DATABASE_URL);
export const db = drizzle(sql, { schema });
{{else}}
import { drizzle } from "drizzle-orm/node-postgres";

export const db = drizzle(env.DATABASE_URL, { schema });
{{/if}}
{{/if}}

{{#if (eq runtime "workers")}}
import * as schema from "./schema";

{{#if (eq dbSetup "neon")}}
import { neon, neonConfig } from '@neondatabase/serverless';
import { drizzle } from 'drizzle-orm/neon-http';
import { env } from "@{{projectName}}/env/server";
import ws from "ws";

neonConfig.webSocketConstructor = ws;
neonConfig.poolQueryViaFetch = true;

const sql = neon(env.DATABASE_URL || "");
export const db = drizzle(sql, { schema });
{{else}}
import { drizzle } from "drizzle-orm/node-postgres";
import { env } from "@{{projectName}}/env/server";

export const db = drizzle(env.DATABASE_URL || "", { schema });
{{/if}}
{{/if}}`],
  ["db/kysely/mysql/src/index.ts.hbs", `import { env } from "@{{projectName}}/env/server";
import { Kysely, MysqlDialect } from "kysely";
import { createPool } from "mysql2";
import type { Database as DB } from "./schema";

{{#if (eq dbSetup "planetscale")}}
const dialect = new MysqlDialect({
	pool: createPool({
		host: env.DATABASE_HOST,
		user: env.DATABASE_USERNAME,
		password: env.DATABASE_PASSWORD,
		database: env.DATABASE_NAME,
		ssl: {
			rejectUnauthorized: true,
		},
	}),
});
{{else}}
const dialect = new MysqlDialect({
	pool: createPool(env.DATABASE_URL),
});
{{/if}}

export const db = new Kysely<DB>({
	dialect,
});
`],
  ["db/prisma/postgres/src/index.ts.hbs", `{{#if (eq runtime "workers")}}
import { PrismaClient } from "../prisma/generated/client";
import { env } from "@{{projectName}}/env/server";
{{#if (eq dbSetup "neon")}}
import { PrismaNeon } from "@prisma/adapter-neon";
import { neonConfig } from "@neondatabase/serverless";

neonConfig.poolQueryViaFetch = true;

const prisma = new PrismaClient({
	adapter: new PrismaNeon({
		connectionString: env.DATABASE_URL,
	}),
});

{{else if (eq dbSetup "prisma-postgres")}}
import { PrismaPg } from "@prisma/adapter-pg";

const adapter = new PrismaPg({
	connectionString: env.DATABASE_URL,
});

const prisma = new PrismaClient({ adapter });

{{else}}
import { PrismaPg } from "@prisma/adapter-pg";

const adapter = new PrismaPg({ connectionString: env.DATABASE_URL });
const prisma = new PrismaClient({ adapter });

{{/if}}

export default prisma;
{{else}}
import { PrismaClient } from "../prisma/generated/client";
import { env } from "@{{projectName}}/env/server";
{{#if (eq dbSetup "neon")}}
import { PrismaNeon } from "@prisma/adapter-neon";
import { neonConfig } from "@neondatabase/serverless";
import ws from "ws";

neonConfig.webSocketConstructor = ws;
neonConfig.poolQueryViaFetch = true;

const adapter = new PrismaNeon({
	connectionString: env.DATABASE_URL,
});

const prisma = new PrismaClient({ adapter });

{{else if (eq dbSetup "prisma-postgres")}}
import { PrismaPg } from "@prisma/adapter-pg";

const adapter = new PrismaPg({
	connectionString: env.DATABASE_URL,
});

const prisma = new PrismaClient({ adapter });

{{else}}
import { PrismaPg } from "@prisma/adapter-pg";

const adapter = new PrismaPg({ connectionString: env.DATABASE_URL });
const prisma = new PrismaClient({ adapter });

{{/if}}

export default prisma;
{{/if}}`],
  ["db/typeorm/postgres/src/index.ts.hbs", `import "reflect-metadata";
import { DataSource } from "typeorm";
import { env } from "@{{projectName}}/env/server";

export const AppDataSource = new DataSource({
	type: "postgres",
	url: env.DATABASE_URL,
	synchronize: true,
	logging: false,
	entities: ["src/entities/**/*.ts"],
	migrations: ["src/migrations/**/*.ts"],
	subscribers: ["src/subscribers/**/*.ts"],
{{#if (eq dbSetup "neon")}}
	ssl: {
		rejectUnauthorized: false,
	},
{{/if}}
});

export const initializeDatabase = async () => {
	if (!AppDataSource.isInitialized) {
		await AppDataSource.initialize();
	}
	return AppDataSource;
};

export const db = AppDataSource;
`],
  ["db/prisma/sqlite/src/index.ts.hbs", `import { PrismaClient } from "../prisma/generated/client";

{{#if (eq dbSetup "d1")}}
import { PrismaD1 } from "@prisma/adapter-d1";
import { env } from "@{{projectName}}/env/server";

const adapter = new PrismaD1(env.DB);
const prisma = new PrismaClient({ adapter });

export default prisma;
{{else}}
import { PrismaLibSql } from "@prisma/adapter-libsql";
import { env } from "@{{projectName}}/env/server";

const adapter = new PrismaLibSql({
	url: env.DATABASE_URL,
{{#if (eq dbSetup "turso")}}
	authToken: env.DATABASE_AUTH_TOKEN || "",
{{/if}}
});

const prisma = new PrismaClient({ adapter });

export default prisma;
{{/if}}`],
  ["db/typeorm/sqlite/src/index.ts.hbs", `import "reflect-metadata";
import { DataSource } from "typeorm";
import { env } from "@{{projectName}}/env/server";

export const AppDataSource = new DataSource({
	type: "better-sqlite3",
	database: env.DATABASE_URL.replace("file:", ""),
	synchronize: true,
	logging: false,
	entities: ["src/entities/**/*.ts"],
	migrations: ["src/migrations/**/*.ts"],
	subscribers: ["src/subscribers/**/*.ts"],
});

export const initializeDatabase = async () => {
	if (!AppDataSource.isInitialized) {
		await AppDataSource.initialize();
	}
	return AppDataSource;
};

export const db = AppDataSource;
`],
  ["db/prisma/mongodb/src/index.ts.hbs", `import { PrismaClient } from "../prisma/generated/client";

const prisma = new PrismaClient();

export default prisma;
`],
  ["db/prisma/mysql/src/index.ts.hbs", `{{#if (eq runtime "workers")}}
import { PrismaClient } from "../prisma/generated/client";
import { env } from "@{{projectName}}/env/server";

{{#if (eq dbSetup "planetscale")}}
import { PrismaPlanetScale } from "@prisma/adapter-planetscale";

const adapter = new PrismaPlanetScale({ url: env.DATABASE_URL });
const prisma = new PrismaClient({ adapter });
{{else}}
import { PrismaMariaDb } from "@prisma/adapter-mariadb";

const databaseUrl: string = env.DATABASE_URL;
const url: URL = new URL(databaseUrl);
const connectionConfig = {
	host: url.hostname,
	port: parseInt(url.port || "3306"),
	user: url.username,
	password: url.password,
	database: url.pathname.slice(1),
};

const adapter = new PrismaMariaDb(connectionConfig);
const prisma = new PrismaClient({ adapter });
{{/if}}

export default prisma;
{{else}}
import { PrismaClient } from "../prisma/generated/client";
import { env } from "@{{projectName}}/env/server";

{{#if (eq dbSetup "planetscale")}}
import { PrismaPlanetScale } from "@prisma/adapter-planetscale";

const adapter = new PrismaPlanetScale({ url: env.DATABASE_URL });
const prisma = new PrismaClient({ adapter });
{{else}}
import { PrismaMariaDb } from "@prisma/adapter-mariadb";

const databaseUrl: string = env.DATABASE_URL;
const url: URL = new URL(databaseUrl);
const connectionConfig = {
	host: url.hostname,
	port: parseInt(url.port || "3306"),
	user: url.username,
	password: url.password,
	database: url.pathname.slice(1),
};

const adapter = new PrismaMariaDb(connectionConfig);
const prisma = new PrismaClient({ adapter });
{{/if}}

export default prisma;
{{/if}}`],
  ["deploy/fly/web/nuxt/fly.toml.hbs", `# Fly.io configuration for {{projectName}} Nuxt app
# See https://fly.io/docs/reference/configuration/ for all options

app = "{{projectName}}"
primary_region = "iad"

[build]
  dockerfile = "Dockerfile"

[env]
  NODE_ENV = "production"
  NITRO_PORT = "3000"
  NITRO_HOST = "0.0.0.0"

[http_service]
  internal_port = 3000
  force_https = true
  auto_stop_machines = "stop"
  auto_start_machines = true
  min_machines_running = 1
  processes = ["app"]

  [http_service.concurrency]
    type = "requests"
    soft_limit = 200
    hard_limit = 250

[[http_service.checks]]
  grace_period = "10s"
  interval = "30s"
  method = "GET"
  timeout = "5s"
  path = "/"

[[vm]]
  size = "shared-cpu-1x"
  memory = "512mb"
  processes = ["app"]
`],
  ["deploy/fly/web/nuxt/Dockerfile.hbs", `# Dockerfile for {{projectName}} Nuxt app
# Optimized multi-stage build for Fly.io deployment

{{#if (eq packageManager "bun")}}
FROM oven/bun:1 AS builder

WORKDIR /app

COPY package.json bun.lock* ./
RUN bun install --frozen-lockfile

COPY . .
RUN bun run build

FROM oven/bun:1-slim AS runner

WORKDIR /app

ENV NODE_ENV=production
ENV NITRO_PORT=3000
ENV NITRO_HOST=0.0.0.0

COPY --from=builder /app/.output ./

EXPOSE 3000

CMD ["bun", "run", ".output/server/index.mjs"]
{{else}}
FROM node:20-alpine AS builder

WORKDIR /app

{{#if (eq packageManager "pnpm")}}
RUN corepack enable && corepack prepare pnpm@latest --activate
COPY package.json pnpm-lock.yaml* ./
RUN pnpm install --frozen-lockfile
{{else}}
COPY package.json package-lock.json* ./
RUN npm ci
{{/if}}

COPY . .

{{#if (eq packageManager "pnpm")}}
RUN pnpm run build
{{else}}
RUN npm run build
{{/if}}

FROM node:20-alpine AS runner

WORKDIR /app

ENV NODE_ENV=production
ENV NITRO_PORT=3000
ENV NITRO_HOST=0.0.0.0

COPY --from=builder /app/.output ./

EXPOSE 3000

CMD ["node", ".output/server/index.mjs"]
{{/if}}
`],
  ["deploy/fly/web/svelte/fly.toml.hbs", `# Fly.io configuration for {{projectName}} SvelteKit app
# See https://fly.io/docs/reference/configuration/ for all options

app = "{{projectName}}"
primary_region = "iad"

[build]
  dockerfile = "Dockerfile"

[env]
  NODE_ENV = "production"
  PORT = "3000"

[http_service]
  internal_port = 3000
  force_https = true
  auto_stop_machines = "stop"
  auto_start_machines = true
  min_machines_running = 1
  processes = ["app"]

  [http_service.concurrency]
    type = "requests"
    soft_limit = 200
    hard_limit = 250

[[http_service.checks]]
  grace_period = "10s"
  interval = "30s"
  method = "GET"
  timeout = "5s"
  path = "/"

[[vm]]
  size = "shared-cpu-1x"
  memory = "512mb"
  processes = ["app"]
`],
  ["deploy/fly/web/svelte/Dockerfile.hbs", `# Dockerfile for {{projectName}} SvelteKit app
# Optimized multi-stage build for Fly.io deployment

{{#if (eq packageManager "bun")}}
FROM oven/bun:1 AS builder

WORKDIR /app

COPY package.json bun.lock* ./
RUN bun install --frozen-lockfile

COPY . .
RUN bun run build

FROM oven/bun:1-slim AS runner

WORKDIR /app

ENV NODE_ENV=production
ENV PORT=3000

COPY --from=builder /app/build ./build
COPY --from=builder /app/package.json ./

RUN bun install --production --frozen-lockfile

EXPOSE 3000

CMD ["bun", "run", "build/index.js"]
{{else}}
FROM node:20-alpine AS builder

WORKDIR /app

{{#if (eq packageManager "pnpm")}}
RUN corepack enable && corepack prepare pnpm@latest --activate
COPY package.json pnpm-lock.yaml* ./
RUN pnpm install --frozen-lockfile
{{else}}
COPY package.json package-lock.json* ./
RUN npm ci
{{/if}}

COPY . .

{{#if (eq packageManager "pnpm")}}
RUN pnpm run build
{{else}}
RUN npm run build
{{/if}}

FROM node:20-alpine AS runner

WORKDIR /app

ENV NODE_ENV=production
ENV PORT=3000

{{#if (eq packageManager "pnpm")}}
RUN corepack enable && corepack prepare pnpm@latest --activate
{{/if}}

COPY --from=builder /app/build ./build
COPY --from=builder /app/package.json ./

{{#if (eq packageManager "pnpm")}}
RUN pnpm install --prod --frozen-lockfile
{{else}}
RUN npm ci --omit=dev
{{/if}}

EXPOSE 3000

CMD ["node", "build/index.js"]
{{/if}}
`],
  ["deploy/docker/web/solid/Dockerfile.hbs", `# Dockerfile for {{projectName}} SolidStart app
# Optimized multi-stage build for Docker deployment

{{#if (eq packageManager "bun")}}
FROM oven/bun:1 AS builder

WORKDIR /app

COPY package.json bun.lock* ./
RUN bun install --frozen-lockfile

COPY . .
RUN bun run build

FROM oven/bun:1-slim AS runner

WORKDIR /app

ENV NODE_ENV=production
ENV PORT=3000

COPY --from=builder /app/.output ./.output

EXPOSE 3000

CMD ["bun", "run", ".output/server/index.mjs"]
{{else}}
FROM node:20-alpine AS builder

WORKDIR /app

{{#if (eq packageManager "pnpm")}}
RUN corepack enable && corepack prepare pnpm@latest --activate
COPY package.json pnpm-lock.yaml* ./
RUN pnpm install --frozen-lockfile
{{else}}
COPY package.json package-lock.json* ./
RUN npm ci
{{/if}}

COPY . .

{{#if (eq packageManager "pnpm")}}
RUN pnpm run build
{{else}}
RUN npm run build
{{/if}}

FROM node:20-alpine AS runner

WORKDIR /app

ENV NODE_ENV=production
ENV PORT=3000

COPY --from=builder /app/.output ./.output

EXPOSE 3000

CMD ["node", ".output/server/index.mjs"]
{{/if}}
`],
  ["deploy/docker/web/nuxt/Dockerfile.hbs", `# Dockerfile for {{projectName}} Nuxt app
# Optimized multi-stage build for Docker deployment

{{#if (eq packageManager "bun")}}
FROM oven/bun:1 AS builder

WORKDIR /app

COPY package.json bun.lock* ./
RUN bun install --frozen-lockfile

COPY . .
RUN bun run build

FROM oven/bun:1-slim AS runner

WORKDIR /app

ENV NODE_ENV=production
ENV PORT=3000
ENV HOST=0.0.0.0

COPY --from=builder /app/.output ./.output

EXPOSE 3000

CMD ["bun", "run", ".output/server/index.mjs"]
{{else}}
FROM node:20-alpine AS builder

WORKDIR /app

{{#if (eq packageManager "pnpm")}}
RUN corepack enable && corepack prepare pnpm@latest --activate
COPY package.json pnpm-lock.yaml* ./
RUN pnpm install --frozen-lockfile
{{else}}
COPY package.json package-lock.json* ./
RUN npm ci
{{/if}}

COPY . .

{{#if (eq packageManager "pnpm")}}
RUN pnpm run build
{{else}}
RUN npm run build
{{/if}}

FROM node:20-alpine AS runner

WORKDIR /app

ENV NODE_ENV=production
ENV PORT=3000
ENV HOST=0.0.0.0

COPY --from=builder /app/.output ./.output

EXPOSE 3000

CMD ["node", ".output/server/index.mjs"]
{{/if}}
`],
  ["deploy/fly/web/solid/fly.toml.hbs", `# Fly.io configuration for {{projectName}} SolidStart app
# See https://fly.io/docs/reference/configuration/ for all options

app = "{{projectName}}"
primary_region = "iad"

[build]
  dockerfile = "Dockerfile"

[env]
  NODE_ENV = "production"
  PORT = "3000"

[http_service]
  internal_port = 3000
  force_https = true
  auto_stop_machines = "stop"
  auto_start_machines = true
  min_machines_running = 0
  processes = ["app"]

  [http_service.concurrency]
    type = "requests"
    soft_limit = 200
    hard_limit = 250

[[http_service.checks]]
  grace_period = "10s"
  interval = "30s"
  method = "GET"
  timeout = "5s"
  path = "/"

[[vm]]
  size = "shared-cpu-1x"
  memory = "256mb"
  processes = ["app"]
`],
  ["deploy/fly/web/solid/Dockerfile.hbs", `# Dockerfile for {{projectName}} SolidStart app
# Static file serving with nginx for Fly.io deployment

FROM node:20-alpine AS builder

WORKDIR /app

{{#if (eq packageManager "pnpm")}}
RUN corepack enable && corepack prepare pnpm@latest --activate
COPY package.json pnpm-lock.yaml* ./
RUN pnpm install --frozen-lockfile
{{else if (eq packageManager "bun")}}
RUN npm install -g bun
COPY package.json bun.lock* ./
RUN bun install --frozen-lockfile
{{else}}
COPY package.json package-lock.json* ./
RUN npm ci
{{/if}}

COPY . .

{{#if (eq packageManager "pnpm")}}
RUN pnpm run build
{{else if (eq packageManager "bun")}}
RUN bun run build
{{else}}
RUN npm run build
{{/if}}

# Production stage with nginx for SPA
FROM nginx:alpine AS runner

# Copy nginx configuration for SPA routing
RUN echo 'server { \\
    listen 3000; \\
    root /usr/share/nginx/html; \\
    index index.html; \\
    location / { \\
        try_files $uri $uri/ /index.html; \\
    } \\
    location ~* \\.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2)$ { \\
        expires 1y; \\
        add_header Cache-Control "public, immutable"; \\
    } \\
}' > /etc/nginx/conf.d/default.conf

# Copy built assets
COPY --from=builder /app/dist /usr/share/nginx/html

EXPOSE 3000

CMD ["nginx", "-g", "daemon off;"]
`],
  ["deploy/docker/web/svelte/Dockerfile.hbs", `# Dockerfile for {{projectName}} SvelteKit app
# Optimized multi-stage build for Docker deployment

{{#if (eq packageManager "bun")}}
FROM oven/bun:1 AS builder

WORKDIR /app

COPY package.json bun.lock* ./
RUN bun install --frozen-lockfile

COPY . .
RUN bun run build

FROM oven/bun:1-slim AS runner

WORKDIR /app

ENV NODE_ENV=production
ENV PORT=3000

COPY --from=builder /app/build ./build
COPY --from=builder /app/package.json ./

RUN bun install --production --frozen-lockfile

EXPOSE 3000

CMD ["bun", "run", "build/index.js"]
{{else}}
FROM node:20-alpine AS builder

WORKDIR /app

{{#if (eq packageManager "pnpm")}}
RUN corepack enable && corepack prepare pnpm@latest --activate
COPY package.json pnpm-lock.yaml* ./
RUN pnpm install --frozen-lockfile
{{else}}
COPY package.json package-lock.json* ./
RUN npm ci
{{/if}}

COPY . .

{{#if (eq packageManager "pnpm")}}
RUN pnpm run build
{{else}}
RUN npm run build
{{/if}}

FROM node:20-alpine AS runner

WORKDIR /app

ENV NODE_ENV=production
ENV PORT=3000

{{#if (eq packageManager "pnpm")}}
RUN corepack enable && corepack prepare pnpm@latest --activate
{{/if}}

COPY --from=builder /app/build ./build
COPY --from=builder /app/package.json ./

{{#if (eq packageManager "pnpm")}}
RUN pnpm install --prod --frozen-lockfile
{{else}}
RUN npm ci --omit=dev
{{/if}}

EXPOSE 3000

CMD ["node", "build/index.js"]
{{/if}}
`],
  ["deploy/railway/web/svelte/Dockerfile.hbs", `# Dockerfile for {{projectName}} SvelteKit app
# Optimized multi-stage build for Railway deployment

{{#if (eq packageManager "bun")}}
FROM oven/bun:1 AS builder

WORKDIR /app

COPY package.json bun.lock* ./
RUN bun install --frozen-lockfile

COPY . .
RUN bun run build

FROM oven/bun:1-slim AS runner

WORKDIR /app

ENV NODE_ENV=production
ENV PORT=3000

COPY --from=builder /app/build ./build
COPY --from=builder /app/package.json ./

RUN bun install --production --frozen-lockfile

EXPOSE 3000

CMD ["bun", "run", "build/index.js"]
{{else}}
FROM node:20-alpine AS builder

WORKDIR /app

{{#if (eq packageManager "pnpm")}}
RUN corepack enable && corepack prepare pnpm@latest --activate
COPY package.json pnpm-lock.yaml* ./
RUN pnpm install --frozen-lockfile
{{else}}
COPY package.json package-lock.json* ./
RUN npm ci
{{/if}}

COPY . .

{{#if (eq packageManager "pnpm")}}
RUN pnpm run build
{{else}}
RUN npm run build
{{/if}}

FROM node:20-alpine AS runner

WORKDIR /app

ENV NODE_ENV=production
ENV PORT=3000

{{#if (eq packageManager "pnpm")}}
RUN corepack enable && corepack prepare pnpm@latest --activate
{{/if}}

COPY --from=builder /app/build ./build
COPY --from=builder /app/package.json ./

{{#if (eq packageManager "pnpm")}}
RUN pnpm install --prod --frozen-lockfile
{{else}}
RUN npm ci --omit=dev
{{/if}}

EXPOSE 3000

CMD ["node", "build/index.js"]
{{/if}}
`],
  ["deploy/railway/web/svelte/railway.toml.hbs", `# Railway configuration for {{projectName}} SvelteKit app
# See https://docs.railway.app/reference/config-as-code for all options

[build]
builder = "dockerfile"
dockerfilePath = "Dockerfile"

[deploy]
startCommand = "{{#if (eq packageManager "bun")}}bun run build/index.js{{else}}node build/index.js{{/if}}"
healthcheckPath = "/"
healthcheckTimeout = 300
restartPolicyType = "on_failure"
restartPolicyMaxRetries = 3
`],
  ["deploy/railway/web/nuxt/Dockerfile.hbs", `# Dockerfile for {{projectName}} Nuxt app
# Optimized multi-stage build for Railway deployment

{{#if (eq packageManager "bun")}}
FROM oven/bun:1 AS builder

WORKDIR /app

COPY package.json bun.lock* ./
RUN bun install --frozen-lockfile

COPY . .
RUN bun run build

FROM oven/bun:1-slim AS runner

WORKDIR /app

ENV NODE_ENV=production
ENV NITRO_PORT=3000
ENV NITRO_HOST=0.0.0.0

COPY --from=builder /app/.output ./

EXPOSE 3000

CMD ["bun", "run", ".output/server/index.mjs"]
{{else}}
FROM node:20-alpine AS builder

WORKDIR /app

{{#if (eq packageManager "pnpm")}}
RUN corepack enable && corepack prepare pnpm@latest --activate
COPY package.json pnpm-lock.yaml* ./
RUN pnpm install --frozen-lockfile
{{else}}
COPY package.json package-lock.json* ./
RUN npm ci
{{/if}}

COPY . .

{{#if (eq packageManager "pnpm")}}
RUN pnpm run build
{{else}}
RUN npm run build
{{/if}}

FROM node:20-alpine AS runner

WORKDIR /app

ENV NODE_ENV=production
ENV NITRO_PORT=3000
ENV NITRO_HOST=0.0.0.0

COPY --from=builder /app/.output ./

EXPOSE 3000

CMD ["node", ".output/server/index.mjs"]
{{/if}}
`],
  ["deploy/railway/web/nuxt/railway.toml.hbs", `# Railway configuration for {{projectName}} Nuxt app
# See https://docs.railway.app/reference/config-as-code for all options

[build]
builder = "dockerfile"
dockerfilePath = "Dockerfile"

[deploy]
startCommand = "{{#if (eq packageManager "bun")}}bun run .output/server/index.mjs{{else}}node .output/server/index.mjs{{/if}}"
healthcheckPath = "/"
healthcheckTimeout = 300
restartPolicyType = "on_failure"
restartPolicyMaxRetries = 3
`],
  ["deploy/railway/web/solid/Dockerfile.hbs", `# Dockerfile for {{projectName}} SolidStart app
# Static file serving with nginx for Railway deployment

FROM node:20-alpine AS builder

WORKDIR /app

{{#if (eq packageManager "pnpm")}}
RUN corepack enable && corepack prepare pnpm@latest --activate
COPY package.json pnpm-lock.yaml* ./
RUN pnpm install --frozen-lockfile
{{else if (eq packageManager "bun")}}
RUN npm install -g bun
COPY package.json bun.lock* ./
RUN bun install --frozen-lockfile
{{else}}
COPY package.json package-lock.json* ./
RUN npm ci
{{/if}}

COPY . .

{{#if (eq packageManager "pnpm")}}
RUN pnpm run build
{{else if (eq packageManager "bun")}}
RUN bun run build
{{else}}
RUN npm run build
{{/if}}

# Production stage with nginx for SPA
FROM nginx:alpine AS runner

# Copy nginx configuration for SPA routing
RUN echo 'server { \\
    listen 3000; \\
    root /usr/share/nginx/html; \\
    index index.html; \\
    location / { \\
        try_files $uri $uri/ /index.html; \\
    } \\
    location ~* \\.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2)$ { \\
        expires 1y; \\
        add_header Cache-Control "public, immutable"; \\
    } \\
}' > /etc/nginx/conf.d/default.conf

# Copy built assets
COPY --from=builder /app/dist /usr/share/nginx/html

EXPOSE 3000

CMD ["nginx", "-g", "daemon off;"]
`],
  ["deploy/railway/web/solid/railway.toml.hbs", `# Railway configuration for {{projectName}} SolidStart SPA
# See https://docs.railway.app/reference/config-as-code for all options

[build]
builder = "dockerfile"
dockerfilePath = "Dockerfile"

[deploy]
healthcheckPath = "/"
healthcheckTimeout = 300
restartPolicyType = "on_failure"
restartPolicyMaxRetries = 3
`],
  ["db/drizzle/mysql/src/index.ts.hbs", `{{#if (or (eq runtime "bun") (eq runtime "node") (eq runtime "none"))}}
import { env } from "@{{projectName}}/env/server";
import * as schema from "./schema";

{{#if (eq dbSetup "planetscale")}}
import { drizzle } from "drizzle-orm/planetscale-serverless";

export const db = drizzle({
	connection: {
		host: env.DATABASE_HOST,
		username: env.DATABASE_USERNAME,
		password: env.DATABASE_PASSWORD,
	},
	schema,
});
{{else}}
import { drizzle } from "drizzle-orm/mysql2";

export const db = drizzle({
	connection: {
		uri: env.DATABASE_URL,
	},
	schema,
});
{{/if}}
{{/if}}

{{#if (eq runtime "workers")}}
import * as schema from "./schema";

{{#if (eq dbSetup "planetscale")}}
import { drizzle } from "drizzle-orm/planetscale-serverless";
import { env } from "@{{projectName}}/env/server";

export const db = drizzle({
	connection: {
		host: env.DATABASE_HOST,
		username: env.DATABASE_USERNAME,
		password: env.DATABASE_PASSWORD,
	},
	schema,
});
{{else}}
import { drizzle } from "drizzle-orm/mysql2";
import { env } from "@{{projectName}}/env/server";

export const db = drizzle({
	connection: {
		uri: env.DATABASE_URL,
	},
	schema,
});
{{/if}}
{{/if}}
`],
  ["addons/storybook/apps/web/.storybook/main.ts.hbs", `import type { StorybookConfig } from "{{#if (eq frontend "next")}}@storybook/nextjs{{else if (or (eq frontend "tanstack-router") (eq frontend "react-router") (eq frontend "solid"))}}@storybook/react-vite{{else if (eq frontend "nuxt")}}@storybook/vue3-vite{{else if (eq frontend "svelte")}}@storybook/svelte-vite{{else}}@storybook/react-vite{{/if}}";

const config: StorybookConfig = {
  stories: ["../src/**/*.mdx", "../src/**/*.stories.@(js|jsx|mjs|ts|tsx)"],
  addons: [
    "@storybook/addon-essentials",
    "@storybook/addon-interactions",
  ],
  framework: {
    name: "{{#if (eq frontend "next")}}@storybook/nextjs{{else if (or (eq frontend "tanstack-router") (eq frontend "react-router") (eq frontend "solid"))}}@storybook/react-vite{{else if (eq frontend "nuxt")}}@storybook/vue3-vite{{else if (eq frontend "svelte")}}@storybook/svelte-vite{{else}}@storybook/react-vite{{/if}}",
    options: {},
  },
};

export default config;
`],
  ["addons/storybook/apps/web/.storybook/preview.ts.hbs", `{{#if (eq frontend "next")}}
import type { Preview } from "@storybook/nextjs";
{{else if (or (eq frontend "tanstack-router") (eq frontend "react-router") (eq frontend "solid"))}}
import type { Preview } from "@storybook/react-vite";
{{else if (eq frontend "nuxt")}}
import type { Preview } from "@storybook/vue3-vite";
{{else if (eq frontend "svelte")}}
import type { Preview } from "@storybook/svelte-vite";
{{else}}
import type { Preview } from "@storybook/react-vite";
{{/if}}
{{#if (eq cssFramework "tailwind")}}
import "../src/index.css";
{{/if}}

const preview: Preview = {
  parameters: {
    controls: {
      matchers: {
        color: /(background|color)$/i,
        date: /Date$/i,
      },
    },
  },
};

export default preview;
`],
  ["addons/pwa/apps/web/vite/pwa-assets.config.ts.hbs", `import {
  defineConfig,
  minimal2023Preset as preset,
} from "@vite-pwa/assets-generator/config";

export default defineConfig({
  headLinkOptions: {
    preset: "2023",
  },
  preset,
  images: ["public/logo.png"],
});
`],
  ["auth/auth0/fullstack/next/src/middleware.ts.hbs", `import { withMiddlewareAuthRequired } from "@auth0/nextjs-auth0/edge";

export default withMiddlewareAuthRequired();

export const config = {
  matcher: ["/dashboard/:path*"],
};
`],
  ["auth/nextauth/fullstack/next/src/middleware.ts.hbs", `export { auth as middleware } from "@/lib/auth";

export const config = {
  matcher: [
    // Skip Next.js internals and all static files
    "/((?!_next|[^?]*\\\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)",
    // Always run for API routes
    "/(api|trpc)(.*)",
  ],
};
`],
  ["auth/supabase-auth/fullstack/next/src/middleware.ts.hbs", `import { type NextRequest } from "next/server";
import { updateSession } from "@/lib/supabase/middleware";

export async function middleware(request: NextRequest) {
  return await updateSession(request);
}

export const config = {
  matcher: [
    /*
     * Match all request paths except for the ones starting with:
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     * Feel free to modify this pattern to include more paths.
     */
    "/((?!_next/static|_next/image|favicon.ico|.*\\\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)",
  ],
};
`],
  ["auth/clerk/convex/backend/convex/auth.config.ts.hbs", `export default {
	providers: [
		{
			// Replace with your own Clerk Issuer URL from your "convex" JWT template
			// or with \`process.env.CLERK_JWT_ISSUER_DOMAIN\`
			// and configure CLERK_JWT_ISSUER_DOMAIN on the Convex Dashboard
			// See https://docs.convex.dev/auth/clerk#configuring-dev-and-prod-instances
			domain: process.env.CLERK_JWT_ISSUER_DOMAIN,
			applicationID: "convex",
		},
	],
};
`],
  ["auth/clerk/convex/backend/convex/privateData.ts.hbs", `import { query } from "./_generated/server";

export const get = query({
	args: {},
	handler: async (ctx) => {
		const identity = await ctx.auth.getUserIdentity();
		if (identity === null) {
			return {
				message: "Not authenticated",
			};
		}
		return {
			message: "This is private",
		};
	},
});
`],
  ["auth/better-auth/native/base/lib/auth-client.ts.hbs", `import { expoClient } from "@better-auth/expo/client";
import { createAuthClient } from "better-auth/react";
import * as SecureStore from "expo-secure-store";
import Constants from "expo-constants";
import { env } from "@{{projectName}}/env/native";

export const authClient = createAuthClient({
	baseURL: env.EXPO_PUBLIC_SERVER_URL,
	plugins: [
		expoClient({
			scheme: Constants.expoConfig?.scheme as string,
			storagePrefix: Constants.expoConfig?.scheme as string,
			storage: SecureStore,
		}),
	],
});
`],
  ["auth/better-auth/convex/backend/convex/auth.ts.hbs", `import { createClient, type GenericCtx } from "@convex-dev/better-auth";
{{#if (or (includes frontend "native-bare") (includes frontend "native-uniwind") (includes frontend "native-unistyles"))}}
import { convex } from "@convex-dev/better-auth/plugins";
import { expo } from "@better-auth/expo";
{{else if (or (includes frontend "tanstack-router") (includes frontend "react-router") (includes frontend "nuxt") (includes frontend "svelte") (includes frontend "solid"))}}
import { convex, crossDomain } from "@convex-dev/better-auth/plugins";
{{else}}
import { convex } from "@convex-dev/better-auth/plugins";
{{/if}}
import { components } from "./_generated/api";
import type { DataModel } from "./_generated/dataModel";
import { query } from "./_generated/server";
import { betterAuth } from "better-auth";
import authConfig from "./auth.config";

{{#if (or (includes frontend "tanstack-start") (includes frontend "next"))}}
const siteUrl = process.env.SITE_URL!;
{{else if (or (includes frontend "tanstack-router") (includes frontend "react-router") (includes frontend "nuxt") (includes frontend "svelte") (includes frontend "solid"))}}
const siteUrl = process.env.SITE_URL!;
{{/if}}
{{#if (or (includes frontend "native-bare") (includes frontend "native-uniwind") (includes frontend "native-unistyles"))}}
const nativeAppUrl = process.env.NATIVE_APP_URL || "mybettertapp://";
{{/if}}

export const authComponent = createClient<DataModel>(components.betterAuth);

function createAuth(ctx: GenericCtx<DataModel>) {
  return betterAuth({
    {{#if (and (or (includes frontend "native-bare") (includes frontend "native-uniwind") (includes frontend "native-unistyles")) (or (includes frontend "tanstack-start") (includes frontend "next")))}}
    baseURL: siteUrl,
    trustedOrigins: [siteUrl, nativeAppUrl],
    {{else if (and (or (includes frontend "native-bare") (includes frontend "native-uniwind") (includes frontend "native-unistyles")) (or (includes frontend "tanstack-router") (includes frontend "react-router") (includes frontend "nuxt") (includes frontend "svelte") (includes frontend "solid")))}}
    trustedOrigins: [siteUrl, nativeAppUrl],
    {{else if (or (includes frontend "native-bare") (includes frontend "native-uniwind") (includes frontend "native-unistyles"))}}
    trustedOrigins: [nativeAppUrl],
    {{else if (or (includes frontend "tanstack-start") (includes frontend "next"))}}
    baseURL: siteUrl,
    trustedOrigins: [siteUrl],
    {{else if (or (includes frontend "tanstack-router") (includes frontend "react-router") (includes frontend "nuxt") (includes frontend "svelte") (includes frontend "solid"))}}
    trustedOrigins: [siteUrl],
    {{/if}}
    database: authComponent.adapter(ctx),
    emailAndPassword: {
      enabled: true,
      requireEmailVerification: false,
    },
    plugins: [
      {{#if (or (includes frontend "native-bare") (includes frontend "native-uniwind") (includes frontend "native-unistyles"))}}
      expo(),
      {{else if (or (includes frontend "tanstack-router") (includes frontend "react-router") (includes frontend "nuxt") (includes frontend "svelte") (includes frontend "solid"))}}
      crossDomain({ siteUrl }),
      {{/if}}
      convex({
        authConfig,
        jwksRotateOnTokenGenerationError: true,
      }),
    ],
  });
}

export { createAuth };

export const getCurrentUser = query({
  args: {},
  handler: async (ctx) => {
    return await authComponent.safeGetAuthUser(ctx);
  },
});
`],
  ["auth/better-auth/convex/backend/convex/http.ts.hbs", `import { httpRouter } from "convex/server";
import { authComponent, createAuth } from "./auth";

const http = httpRouter();

{{#if (or (includes frontend "tanstack-router") (includes frontend "react-router") (includes frontend "nuxt") (includes frontend "svelte") (includes frontend "solid"))}}
authComponent.registerRoutes(http, createAuth, { cors: true });
{{else}}
authComponent.registerRoutes(http, createAuth);
{{/if}}

export default http;
`],
  ["auth/better-auth/convex/backend/convex/auth.config.ts.hbs", `import { getAuthConfigProvider } from "@convex-dev/better-auth/auth-config";
import type { AuthConfig } from "convex/server";

export default {
  providers: [getAuthConfigProvider()],
} satisfies AuthConfig;
`],
  ["auth/better-auth/convex/backend/convex/privateData.ts.hbs", `import { query } from "./_generated/server";
import { authComponent } from "./auth";

export const get = query({
  args: {},
  handler: async (ctx) => {
    const authUser = await authComponent.safeGetAuthUser(ctx);
    if (!authUser) {
      return {
        message: "Not authenticated",
      };
    }
    return {
      message: "This is private",
    };
  },
});
`],
  ["auth/better-auth/native/unistyles/components/sign-up.tsx.hbs", `import { authClient } from "@/lib/auth-client";
{{#if (eq api "trpc")}}
import { queryClient } from "@/utils/trpc";
{{/if}}
{{#if (eq api "orpc")}}
import { queryClient } from "@/utils/orpc";
{{/if}}
import { useState } from "react";
import {
  ActivityIndicator,
  Text,
  TextInput,
  TouchableOpacity,
  View,
} from "react-native";
import { StyleSheet } from "react-native-unistyles";

export function SignUp() {
  const [name, setName] = useState("");
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const handleSignUp = async () => {
    setIsLoading(true);
    setError(null);

    await authClient.signUp.email(
      {
        name,
        email,
        password,
      },
      {
        onError: (error) => {
          setError(error.error?.message || "Failed to sign up");
          setIsLoading(false);
        },
        onSuccess: () => {
          setName("");
          setEmail("");
          setPassword("");
          {{#if (eq api "orpc")}}
          queryClient.refetchQueries();
          {{/if}}
          {{#if (eq api "trpc")}}
          queryClient.refetchQueries();
          {{/if}}
        },
        onFinished: () => {
          setIsLoading(false);
        },
      },
    );
  };

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Create Account</Text>

      {error && (
        <View style={styles.errorContainer}>
          <Text style={styles.errorText}>{error}</Text>
        </View>
      )}

      <TextInput
        style={styles.input}
        placeholder="Name"
        value={name}
        onChangeText={setName}
      />

      <TextInput
        style={styles.input}
        placeholder="Email"
        value={email}
        onChangeText={setEmail}
        keyboardType="email-address"
        autoCapitalize="none"
      />

      <TextInput
        style={styles.inputLast}
        placeholder="Password"
        value={password}
        onChangeText={setPassword}
        secureTextEntry
      />

      <TouchableOpacity
        onPress={handleSignUp}
        disabled={isLoading}
        style={styles.button}
      >
        {isLoading ? (
          <ActivityIndicator size="small" color="#fff" />
        ) : (
          <Text style={styles.buttonText}>Sign Up</Text>
        )}
      </TouchableOpacity>
    </View>
  );
}

const styles = StyleSheet.create((theme) => ({
  container: {
    marginTop: 24,
    padding: 16,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: theme.colors.border,
  },
  title: {
    fontSize: 18,
    fontWeight: "600",
    color: theme.colors.typography,
    marginBottom: 16,
  },
  errorContainer: {
    marginBottom: 16,
    padding: 12,
    borderRadius: 6,
  },
  errorText: {
    color: theme.colors.destructive,
    fontSize: 14,
  },
  input: {
    marginBottom: 12,
    padding: 16,
    borderRadius: 6,
    color: theme.colors.typography,
    borderWidth: 1,
    borderColor: theme.colors.border,
  },
  inputLast: {
    marginBottom: 16,
    padding: 16,
    borderRadius: 6,
    color: theme.colors.typography,
    borderWidth: 1,
    borderColor: theme.colors.border,
  },
  button: {
    backgroundColor: theme.colors.primary,
    padding: 16,
    borderRadius: 6,
    flexDirection: "row",
    justifyContent: "center",
    alignItems: "center",
  },
  buttonText: {
    fontWeight: "500",
  },
}));
`],
  ["auth/better-auth/native/unistyles/components/sign-in.tsx.hbs", `import { authClient } from "@/lib/auth-client";
{{#if (eq api "trpc")}}
import { queryClient } from "@/utils/trpc";
{{/if}}
{{#if (eq api "orpc")}}
import { queryClient } from "@/utils/orpc";
{{/if}}
import { useState } from "react";
import {
  ActivityIndicator,
  Text,
  TextInput,
  TouchableOpacity,
  View,
} from "react-native";
import { StyleSheet } from "react-native-unistyles";

export function SignIn() {
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const handleLogin = async () => {
    setIsLoading(true);
    setError(null);

    await authClient.signIn.email(
      {
        email,
        password,
      },
      {
        onError: (error) => {
          setError(error.error?.message || "Failed to sign in");
          setIsLoading(false);
        },
        onSuccess: () => {
          setEmail("");
          setPassword("");
          {{#if (eq api "orpc")}}
          queryClient.refetchQueries();
          {{/if}}
          {{#if (eq api "trpc")}}
          queryClient.refetchQueries();
          {{/if}}
        },
        onFinished: () => {
          setIsLoading(false);
        },
      },
    );
  };

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Sign In</Text>

      {error && (
        <View style={styles.errorContainer}>
          <Text style={styles.errorText}>{error}</Text>
        </View>
      )}

      <TextInput
        style={styles.input}
        placeholder="Email"
        value={email}
        onChangeText={setEmail}
        keyboardType="email-address"
        autoCapitalize="none"
      />

      <TextInput
        style={styles.input}
        placeholder="Password"
        value={password}
        onChangeText={setPassword}
        secureTextEntry
      />

      <TouchableOpacity
        onPress={handleLogin}
        disabled={isLoading}
        style={styles.button}
      >
        {isLoading ? (
          <ActivityIndicator size="small" color="#fff" />
        ) : (
          <Text style={styles.buttonText}>Sign In</Text>
        )}
      </TouchableOpacity>
    </View>
  );
}

const styles = StyleSheet.create((theme) => ({
  container: {
    marginTop: 24,
    padding: 16,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: theme.colors.border,
  },
  title: {
    fontSize: 18,
    fontWeight: "600",
    color: theme.colors.typography,
    marginBottom: 16,
  },
  errorContainer: {
    marginBottom: 16,
    padding: 12,
    borderRadius: 6,
  },
  errorText: {
    color: theme.colors.destructive,
    fontSize: 14,
  },
  input: {
    marginBottom: 12,
    padding: 16,
    borderRadius: 6,
    color: theme.colors.typography,
    borderWidth: 1,
    borderColor: theme.colors.border,
  },
  button: {
    backgroundColor: theme.colors.primary,
    padding: 16,
    borderRadius: 6,
    flexDirection: "row",
    justifyContent: "center",
    alignItems: "center",
  },
  buttonText: {
    fontWeight: "500",
  },
}));
`],
  ["email/resend/components/src/emails/welcome.tsx.hbs", `import {
  Body,
  Button,
  Container,
  Head,
  Heading,
  Html,
  Link,
  Preview,
  Section,
  Text,
} from "@react-email/components";

interface WelcomeEmailProps {
  username?: string;
  loginUrl?: string;
}

export function WelcomeEmail({
  username = "there",
  loginUrl = "{{#if (includes frontend 'next')}}http://localhost:3000{{else}}http://localhost:5173{{/if}}",
}: WelcomeEmailProps) {
  return (
    <Html>
      <Head />
      <Preview>Welcome to {{projectName}}!</Preview>
      <Body style={main}>
        <Container style={container}>
          <Heading style={h1}>Welcome to {{projectName}}!</Heading>
          <Text style={text}>Hi {username},</Text>
          <Text style={text}>
            Thanks for signing up! We're excited to have you on board.
          </Text>
          <Section style={buttonContainer}>
            <Button style={button} href={loginUrl}>
              Get Started
            </Button>
          </Section>
          <Text style={footer}>
            If you didn't create an account, you can safely ignore this email.
          </Text>
        </Container>
      </Body>
    </Html>
  );
}

export default WelcomeEmail;

const main = {
  backgroundColor: "#f6f9fc",
  fontFamily:
    '-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Ubuntu,sans-serif',
};

const container = {
  backgroundColor: "#ffffff",
  margin: "0 auto",
  padding: "20px 0 48px",
  marginBottom: "64px",
  borderRadius: "5px",
  maxWidth: "600px",
};

const h1 = {
  color: "#333",
  fontSize: "24px",
  fontWeight: "bold",
  margin: "40px 0",
  padding: "0",
  textAlign: "center" as const,
};

const text = {
  color: "#333",
  fontSize: "16px",
  lineHeight: "26px",
  padding: "0 48px",
};

const buttonContainer = {
  padding: "27px 0 27px",
  textAlign: "center" as const,
};

const button = {
  backgroundColor: "#000",
  borderRadius: "5px",
  color: "#fff",
  fontSize: "16px",
  fontWeight: "bold",
  textDecoration: "none",
  textAlign: "center" as const,
  display: "inline-block",
  padding: "12px 30px",
};

const footer = {
  color: "#898989",
  fontSize: "12px",
  lineHeight: "22px",
  padding: "0 48px",
  marginTop: "20px",
};
`],
  ["email/resend/components/src/emails/index.ts.hbs", `export { WelcomeEmail } from "./welcome";
`],
  ["auth/better-auth/native/bare/components/sign-up.tsx.hbs", `import { authClient } from "@/lib/auth-client";
{{#if (eq api "trpc")}}
import { queryClient } from "@/utils/trpc";
{{/if}}
{{#if (eq api "orpc")}}
import { queryClient } from "@/utils/orpc";
{{/if}}
import { useState } from "react";
import {
  ActivityIndicator,
  Text,
  TextInput,
  TouchableOpacity,
  View,
  StyleSheet,
} from "react-native";
import { useColorScheme } from "@/lib/use-color-scheme";
import { NAV_THEME } from "@/lib/constants";

function SignUp() {
  const { colorScheme } = useColorScheme();
  const theme = colorScheme === "dark" ? NAV_THEME.dark : NAV_THEME.light;
  const [name, setName] = useState("");
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  async function handleSignUp() {
    setIsLoading(true);
    setError(null);

    await authClient.signUp.email(
      {
        name,
        email,
        password,
      },
      {
        onError(error) {
          setError(error.error?.message || "Failed to sign up");
          setIsLoading(false);
        },
        onSuccess() {
          setName("");
          setEmail("");
          setPassword("");
          {{#if (eq api "orpc")}}
          queryClient.refetchQueries();
          {{/if}}
          {{#if (eq api "trpc")}}
          queryClient.refetchQueries();
          {{/if}}
        },
        onFinished() {
          setIsLoading(false);
        },
      }
    );
  }

  return (
    <View style={[styles.card, { backgroundColor: theme.card, borderColor: theme.border }]}>
      <Text style={[styles.title, { color: theme.text }]}>Create Account</Text>

      {error ? (
        <View style={[styles.errorContainer, { backgroundColor: theme.notification + "20" }]}>
          <Text style={[styles.errorText, { color: theme.notification }]}>{error}</Text>
        </View>
      ) : null}

      <TextInput
        style={[styles.input, { color: theme.text, borderColor: theme.border, backgroundColor: theme.background }]}
        placeholder="Name"
        placeholderTextColor={theme.text}
        value={name}
        onChangeText={setName}
      />

      <TextInput
        style={[styles.input, { color: theme.text, borderColor: theme.border, backgroundColor: theme.background }]}
        placeholder="Email"
        placeholderTextColor={theme.text}
        value={email}
        onChangeText={setEmail}
        keyboardType="email-address"
        autoCapitalize="none"
      />

      <TextInput
        style={[styles.input, { color: theme.text, borderColor: theme.border, backgroundColor: theme.background }]}
        placeholder="Password"
        placeholderTextColor={theme.text}
        value={password}
        onChangeText={setPassword}
        secureTextEntry
      />

      <TouchableOpacity
        onPress={handleSignUp}
        disabled={isLoading}
        style={[styles.button, { backgroundColor: theme.primary, opacity: isLoading ? 0.5 : 1 }]}
      >
        {isLoading ? (
          <ActivityIndicator size="small" color="#ffffff" />
        ) : (
          <Text style={styles.buttonText}>Sign Up</Text>
        )}
      </TouchableOpacity>
    </View>
  );
}

const styles = StyleSheet.create({
  card: {
    marginTop: 16,
    padding: 16,
    borderWidth: 1,
  },
  title: {
    fontSize: 18,
    fontWeight: "bold",
    marginBottom: 12,
  },
  errorContainer: {
    marginBottom: 12,
    padding: 8,
  },
  errorText: {
    fontSize: 14,
  },
  input: {
    borderWidth: 1,
    padding: 12,
    fontSize: 16,
    marginBottom: 12,
  },
  button: {
    padding: 12,
    alignItems: "center",
    justifyContent: "center",
  },
  buttonText: {
    color: "#ffffff",
    fontSize: 16,
  },
});

export { SignUp };

`],
  ["auth/better-auth/native/bare/components/sign-in.tsx.hbs", `import { authClient } from "@/lib/auth-client";
{{#if (eq api "trpc")}}
import { queryClient } from "@/utils/trpc";
{{/if}}
{{#if (eq api "orpc")}}
import { queryClient } from "@/utils/orpc";
{{/if}}
import { useState } from "react";
import {
ActivityIndicator,
Text,
TextInput,
TouchableOpacity,
View,
StyleSheet,
} from "react-native";
import { useColorScheme } from "@/lib/use-color-scheme";
import { NAV_THEME } from "@/lib/constants";

function SignIn() {
const { colorScheme } = useColorScheme();
const theme = colorScheme === "dark" ? NAV_THEME.dark : NAV_THEME.light;
const [form, setForm] = useState({ email: "", password: "" });
const [isLoading, setIsLoading] = useState(false);
const [error, setError] = useState<string | null>(null);

    function handleFormChange(field: "email" | "password", value: string) {
    setForm(prev => ({ ...prev, [field]: value }));
    }

    async function handleLogin() {
    setIsLoading(true);
    setError(null);

    await authClient.signIn.email(
    {
    email: form.email,
    password: form.password,
    },
    {
    onError(error) {
    setError(error.error?.message || "Failed to sign in");
    setIsLoading(false);
    },
    onSuccess() {
    setForm({ email: "", password: "" });
    {{#if (eq api "orpc")}}
    queryClient.refetchQueries();
    {{/if}}
    {{#if (eq api "trpc")}}
    queryClient.refetchQueries();
    {{/if}}
    },
    onFinished() {
    setIsLoading(false);
    },
    }
    );
    }

    return (
    <View style={[styles.card, { backgroundColor: theme.card, borderColor: theme.border }]}>
        <Text style={[styles.title, { color: theme.text }]}>Sign In</Text>

        {error ? (
        <View style={[styles.errorContainer, { backgroundColor: theme.notification + "20" }]}>
            <Text style={[styles.errorText, { color: theme.notification }]}>{error}</Text>
        </View>
        ) : null}

        <TextInput style={[ styles.input, { color: theme.text, borderColor: theme.border, backgroundColor:
            theme.background }, ]} placeholder="Email" placeholderTextColor={theme.text} value={form.email}
            onChangeText={value=> handleFormChange("email", value)}
            keyboardType="email-address"
            autoCapitalize="none"
            />

            <TextInput style={[ styles.input, { color: theme.text, borderColor: theme.border, backgroundColor:
                theme.background }, ]} placeholder="Password" placeholderTextColor={theme.text} value={form.password}
                onChangeText={value=> handleFormChange("password", value)}
                secureTextEntry
                />

                <TouchableOpacity onPress={handleLogin} disabled={isLoading} style={[ styles.button, { backgroundColor:
                    theme.primary, opacity: isLoading ? 0.5 : 1 }, ]}>
                    {isLoading ? (
                    <ActivityIndicator size="small" color="#ffffff" />
                    ) : (
                    <Text style={styles.buttonText}>Sign In</Text>
                    )}
                </TouchableOpacity>
    </View>
    );
    }

    const styles = StyleSheet.create({
    card: {
    marginTop: 16,
    padding: 16,
    borderWidth: 1,
    },
    title: {
    fontSize: 18,
    fontWeight: "bold",
    marginBottom: 12,
    },
    errorContainer: {
    marginBottom: 12,
    padding: 8,
    },
    errorText: {
    fontSize: 14,
    },
    input: {
    borderWidth: 1,
    padding: 12,
    fontSize: 16,
    marginBottom: 12,
    },
    button: {
    padding: 12,
    alignItems: "center",
    justifyContent: "center",
    },
    buttonText: {
    color: "#ffffff",
    fontSize: 16,
    },
    });

    export { SignIn };`],
  ["auth/better-auth/server/base/src/index.ts.hbs", `{{#if (eq orm "prisma")}}
import { betterAuth } from "better-auth";
import { prismaAdapter } from "better-auth/adapters/prisma";
import { env } from "@{{projectName}}/env/server";
{{#if (eq payments "polar")}}
import { polar, checkout, portal } from "@polar-sh/better-auth";
import { polarClient } from "./lib/payments";
{{/if}}
import prisma from "@{{projectName}}/db";

export const auth = betterAuth({
	database: prismaAdapter(prisma, {
{{#if (eq database "postgres")}}provider: "postgresql",{{/if}}
{{#if (eq database "sqlite")}}provider: "sqlite",{{/if}}
{{#if (eq database "mysql")}}provider: "mysql",{{/if}}
{{#if (eq database "mongodb")}}provider: "mongodb",{{/if}}
	}),

	trustedOrigins: [
		env.CORS_ORIGIN,
{{#if (or (includes frontend "native-bare") (includes frontend "native-uniwind") (includes frontend "native-unistyles"))}}
		"mybettertapp://", "exp://"
{{/if}}
	],
	emailAndPassword: {
		enabled: true,
	},
{{#if (ne backend "self")}}
	advanced: {
		defaultCookieAttributes: {
			sameSite: "none",
			secure: true,
			httpOnly: true,
		},
	},
{{/if}}
	plugins: [
{{#if (or (includes frontend "native-bare") (includes frontend "native-uniwind") (includes frontend "native-unistyles"))}}
        expo(),
{{/if}}
{{#if (and (eq backend "self") (includes frontend "tanstack-start"))}}
        tanstackStartCookies(),
{{/if}}
{{#if (and (eq backend "self") (includes frontend "next"))}}
        nextCookies(),
{{/if}}
{{#if (eq payments "polar")}}
		polar({
			client: polarClient,
			createCustomerOnSignUp: true,
			enableCustomerPortal: true,
			use: [
				checkout({
					products: [
						{
							productId: "your-product-id",
							slug: "pro",
						},
					],
					successUrl: env.POLAR_SUCCESS_URL,
					authenticatedUsersOnly: true,
				}),
				portal(),
			],
		}),
{{/if}}
	],
});
{{/if}}

{{#if (eq orm "drizzle")}}
{{#if (or (eq runtime "bun") (eq runtime "node") (eq runtime "none"))}}
import { betterAuth } from "better-auth";
import { drizzleAdapter } from "better-auth/adapters/drizzle";
import { env } from "@{{projectName}}/env/server";
{{#if (eq payments "polar")}}
import { polar, checkout, portal } from "@polar-sh/better-auth";
import { polarClient } from "./lib/payments";
{{/if}}
import { db } from "@{{projectName}}/db";
import * as schema from "@{{projectName}}/db/schema/auth";
{{#if (or (includes frontend "native-bare") (includes frontend "native-uniwind") (includes frontend "native-unistyles"))}}
import { expo } from "@better-auth/expo";
{{/if}}
{{#if (and (eq backend "self") (includes frontend "tanstack-start"))}}
import { tanstackStartCookies } from "better-auth/tanstack-start";
{{/if}}
{{#if (and (eq backend "self") (includes frontend "next"))}}
import { nextCookies } from "better-auth/next-js";
{{/if}}

export const auth = betterAuth({
	database: drizzleAdapter(db, {
{{#if (eq database "postgres")}}provider: "pg",{{/if}}
{{#if (eq database "sqlite")}}provider: "sqlite",{{/if}}
{{#if (eq database "mysql")}}provider: "mysql",{{/if}}
		schema: schema,
	}),
	trustedOrigins: [
		env.CORS_ORIGIN,
{{#if (or (includes frontend "native-bare") (includes frontend "native-uniwind") (includes frontend "native-unistyles"))}}
		"mybettertapp://", "exp://"
{{/if}}
	],
	emailAndPassword: {
		enabled: true,
	},
{{#if (ne backend "self")}}
	advanced: {
		defaultCookieAttributes: {
			sameSite: "none",
			secure: true,
			httpOnly: true,
		},
	},
{{/if}}
	plugins: [
{{#if (eq payments "polar")}}
		polar({
			client: polarClient,
			createCustomerOnSignUp: true,
			enableCustomerPortal: true,
			use: [
				checkout({
					products: [
						{
							productId: "your-product-id",
							slug: "pro",
						},
					],
					successUrl: env.POLAR_SUCCESS_URL,
					authenticatedUsersOnly: true,
				}),
				portal(),
			],
		}),
{{/if}}
	],
});
{{/if}}

{{#if (eq runtime "workers")}}
import { betterAuth } from "better-auth";
import { drizzleAdapter } from "better-auth/adapters/drizzle";
import { env } from "@{{projectName}}/env/server";
{{#if (eq payments "polar")}}
import { polar, checkout, portal } from "@polar-sh/better-auth";
import { polarClient } from "./lib/payments";
{{/if}}
import { db } from "@{{projectName}}/db";
import * as schema from "@{{projectName}}/db/schema/auth";


export const auth = betterAuth({
	database: drizzleAdapter(db, {
{{#if (eq database "postgres")}}provider: "pg",{{/if}}
{{#if (eq database "sqlite")}}provider: "sqlite",{{/if}}
{{#if (eq database "mysql")}}provider: "mysql",{{/if}}
		schema: schema,
	}),
	trustedOrigins: [
		env.CORS_ORIGIN,
{{#if (or (includes frontend "native-bare") (includes frontend "native-uniwind") (includes frontend "native-unistyles"))}}
		"mybettertapp://", "exp://"
{{/if}}
	],
	emailAndPassword: {
		enabled: true,
	},
	// uncomment cookieCache setting when ready to deploy to Cloudflare using *.workers.dev domains
	// session: {
	//   cookieCache: {
	//     enabled: true,
	//     maxAge: 60,
	//   },
	// },
	secret: env.BETTER_AUTH_SECRET,
	baseURL: env.BETTER_AUTH_URL,
	advanced: {
		defaultCookieAttributes: {
			sameSite: "none",
			secure: true,
			httpOnly: true,
		},
		// uncomment crossSubDomainCookies setting when ready to deploy and replace <your-workers-subdomain> with your actual workers subdomain
		// https://developers.cloudflare.com/workers/wrangler/configuration/#workersdev
		// crossSubDomainCookies: {
		//   enabled: true,
		//   domain: "<your-workers-subdomain>",
		// },
	},
{{#if (eq payments "polar")}}
	plugins: [
		polar({
			client: polarClient,
			createCustomerOnSignUp: true,
			enableCustomerPortal: true,
			use: [
				checkout({
					products: [
						{
							productId: "your-product-id",
							slug: "pro",
						},
					],
					successUrl: env.POLAR_SUCCESS_URL,
					authenticatedUsersOnly: true,
				}),
				portal(),
			],
		}),
	],
{{/if}}
});
{{/if}}
{{/if}}

{{#if (eq orm "mongoose")}}
import { betterAuth } from "better-auth";
import { mongodbAdapter } from "better-auth/adapters/mongodb";
import { env } from "@{{projectName}}/env/server";
{{#if (eq payments "polar")}}
import { polar, checkout, portal } from "@polar-sh/better-auth";
import { polarClient } from "./lib/payments";
{{/if}}
import { client } from "@{{projectName}}/db";

export const auth = betterAuth({
	database: mongodbAdapter(client),
	trustedOrigins: [
		env.CORS_ORIGIN,
{{#if (or (includes frontend "native-bare") (includes frontend "native-uniwind") (includes frontend "native-unistyles"))}}
		"mybettertapp://", "exp://"
{{/if}}
	],
	emailAndPassword: {
		enabled: true,
	},
{{#if (ne backend "self")}}
	advanced: {
		defaultCookieAttributes: {
			sameSite: "none",
			secure: true,
			httpOnly: true,
		},
	},
{{/if}}
{{#if (eq payments "polar")}}
	plugins: [
		polar({
			client: polarClient,
			createCustomerOnSignUp: true,
			enableCustomerPortal: true,
			use: [
				checkout({
					products: [
						{
							productId: "your-product-id",
							slug: "pro",
						},
					],
					successUrl: env.POLAR_SUCCESS_URL,
					authenticatedUsersOnly: true,
				}),
				portal(),
			],
		}),
	],
{{/if}}
});
{{/if}}

{{#if (eq orm "none")}}
import { betterAuth } from "better-auth";
import { env } from "@{{projectName}}/env/server";
{{#if (eq payments "polar")}}
import { polar, checkout, portal } from "@polar-sh/better-auth";
import { polarClient } from "./lib/payments";
{{/if}}


export const auth = betterAuth({
	database: "", // Invalid configuration
	trustedOrigins: [
		env.CORS_ORIGIN,
{{#if (or (includes frontend "native-bare") (includes frontend "native-uniwind") (includes frontend "native-unistyles"))}}
		"mybettertapp://", "exp://"
{{/if}}
	],
	emailAndPassword: {
		enabled: true,
	},
{{#if (ne backend "self")}}
	advanced: {
		defaultCookieAttributes: {
			sameSite: "none",
			secure: true,
			httpOnly: true,
		},
	},
{{/if}}
{{#if (eq payments "polar")}}
	plugins: [
		polar({
			client: polarClient,
			createCustomerOnSignUp: true,
			enableCustomerPortal: true,
			use: [
				checkout({
					products: [
						{
							productId: "your-product-id",
							slug: "pro",
						},
					],
					successUrl: env.POLAR_SUCCESS_URL,
					authenticatedUsersOnly: true,
				}),
				portal(),
			],
		}),
	],
{{/if}}
});
{{/if}}`],
  ["auth/better-auth/native/uniwind/components/sign-up.tsx.hbs", `import { authClient } from "@/lib/auth-client";
{{#if (eq api "trpc")}}
import { queryClient } from "@/utils/trpc";
{{/if}}
{{#if (eq api "orpc")}}
import { queryClient } from "@/utils/orpc";
{{/if}}
import { useState } from "react";
import { Text, View } from "react-native";
import { Button, ErrorView, Spinner, Surface, TextField } from "heroui-native";

function signUpHandler({
name,
email,
password,
setError,
setIsLoading,
setName,
setEmail,
setPassword,
}: {
  name: string;
  email: string;
  password: string;
  setError: (error: string | null) => void;
  setIsLoading: (loading: boolean) => void;
  setName: (name: string) => void;
  setEmail: (email: string) => void;
  setPassword: (password: string) => void;
}) {
setIsLoading(true);
setError(null);

authClient.signUp.email(
{
name,
email,
password,
},
{
onError(error) {
setError(error.error?.message || "Failed to sign up");
setIsLoading(false);
},
onSuccess() {
setName("");
setEmail("");
setPassword("");
{{#if (eq api "orpc")}}
queryClient.refetchQueries();
{{/if}}
{{#if (eq api "trpc")}}
queryClient.refetchQueries();
{{/if}}
},
onFinished() {
setIsLoading(false);
},
}
);
}

export function SignUp() {
const [name, setName] = useState("");
const [email, setEmail] = useState("");
const [password, setPassword] = useState("");
const [isLoading, setIsLoading] = useState(false);
const [error, setError] = useState<string | null>(null);

  function handlePress() {
  signUpHandler({
  name,
  email,
  password,
  setError,
  setIsLoading,
  setName,
  setEmail,
  setPassword,
  });
  }

  return (
  <Surface variant="secondary" className="p-4 rounded-lg">
    <Text className="text-foreground font-medium mb-4">Create Account</Text>

    <ErrorView isInvalid={!!error} className="mb-3">
      {error}
    </ErrorView>

    <View className="gap-3">
      <TextField>
        <TextField.Label>Name</TextField.Label>
        <TextField.Input value={name} onChangeText={setName} placeholder="John Doe" />
      </TextField>

      <TextField>
        <TextField.Label>Email</TextField.Label>
        <TextField.Input
          value={email}
          onChangeText={setEmail}
          placeholder="email@example.com"
          keyboardType="email-address"
          autoCapitalize="none"
        />
      </TextField>

      <TextField>
        <TextField.Label>Password</TextField.Label>
        <TextField.Input
          value={password}
          onChangeText={setPassword}
          placeholder=""
          secureTextEntry
        />
      </TextField>

      <Button onPress={handlePress} isDisabled={isLoading} className="mt-1">
        {isLoading ? (
          <Spinner size="sm" color="default" />
        ) : (
          <Button.Label>Create Account</Button.Label>
        )}
      </Button>
    </View>
  </Surface>
  );
  }`],
  ["auth/better-auth/native/uniwind/components/sign-in.tsx.hbs", `import { authClient } from "@/lib/auth-client";
{{#if (eq api "trpc")}}
import { queryClient } from "@/utils/trpc";
{{/if}}
{{#if (eq api "orpc")}}
import { queryClient } from "@/utils/orpc";
{{/if}}
import { useState } from "react";
import { Text, View } from "react-native";
import { Button, ErrorView, Spinner, Surface, TextField } from "heroui-native";

function SignIn() {
const [email, setEmail] = useState("");
const [password, setPassword] = useState("");
const [isLoading, setIsLoading] = useState(false);
const [error, setError] = useState<string | null>(null);

  async function handleLogin() {
  setIsLoading(true);
  setError(null);

  await authClient.signIn.email(
  {
  email,
  password,
  },
  {
  onError(error) {
  setError(error.error?.message || "Failed to sign in");
  setIsLoading(false);
  },
  onSuccess() {
  setEmail("");
  setPassword("");
  {{#if (eq api "orpc")}}
  queryClient.refetchQueries();
  {{/if}}
  {{#if (eq api "trpc")}}
  queryClient.refetchQueries();
  {{/if}}
  },
  onFinished() {
  setIsLoading(false);
  },
  }
  );
  }

  return (
  <Surface variant="secondary" className="p-4 rounded-lg">
    <Text className="text-foreground font-medium mb-4">Sign In</Text>

    <ErrorView isInvalid={!!error} className="mb-3">
      {error}
    </ErrorView>

    <View className="gap-3">
      <TextField>
        <TextField.Label>Email</TextField.Label>
        <TextField.Input
          value={email}
          onChangeText={setEmail}
          placeholder="email@example.com"
          keyboardType="email-address"
          autoCapitalize="none"
        />
      </TextField>

      <TextField>
        <TextField.Label>Password</TextField.Label>
        <TextField.Input
          value={password}
          onChangeText={setPassword}
          placeholder=""
          secureTextEntry
        />
      </TextField>

      <Button onPress={handleLogin} isDisabled={isLoading} className="mt-1">
        {isLoading ? <Spinner size="sm" color="default" /> : <Button.Label>Sign In</Button.Label>}
      </Button>
    </View>
  </Surface>
  );
  }

  export { SignIn };`],
  ["email/react-email/components/src/emails/welcome.tsx.hbs", `import {
  Body,
  Button,
  Container,
  Head,
  Heading,
  Html,
  Link,
  Preview,
  Section,
  Text,
} from "@react-email/components";

interface WelcomeEmailProps {
  username?: string;
  loginUrl?: string;
}

export function WelcomeEmail({
  username = "there",
  loginUrl = "{{#if (includes frontend 'next')}}http://localhost:3000{{else}}http://localhost:5173{{/if}}",
}: WelcomeEmailProps) {
  return (
    <Html>
      <Head />
      <Preview>Welcome to {{projectName}}!</Preview>
      <Body style={main}>
        <Container style={container}>
          <Heading style={h1}>Welcome to {{projectName}}!</Heading>
          <Text style={text}>Hi {username},</Text>
          <Text style={text}>
            Thanks for signing up! We're excited to have you on board.
          </Text>
          <Section style={buttonContainer}>
            <Button style={button} href={loginUrl}>
              Get Started
            </Button>
          </Section>
          <Text style={footer}>
            If you didn't create an account, you can safely ignore this email.
          </Text>
        </Container>
      </Body>
    </Html>
  );
}

export default WelcomeEmail;

const main = {
  backgroundColor: "#f6f9fc",
  fontFamily:
    '-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Ubuntu,sans-serif',
};

const container = {
  backgroundColor: "#ffffff",
  margin: "0 auto",
  padding: "20px 0 48px",
  marginBottom: "64px",
  borderRadius: "5px",
  maxWidth: "600px",
};

const h1 = {
  color: "#333",
  fontSize: "24px",
  fontWeight: "bold",
  margin: "40px 0",
  padding: "0",
  textAlign: "center" as const,
};

const text = {
  color: "#333",
  fontSize: "16px",
  lineHeight: "26px",
  padding: "0 48px",
};

const buttonContainer = {
  padding: "27px 0 27px",
  textAlign: "center" as const,
};

const button = {
  backgroundColor: "#000",
  borderRadius: "5px",
  color: "#fff",
  fontSize: "16px",
  fontWeight: "bold",
  textDecoration: "none",
  textAlign: "center" as const,
  display: "inline-block",
  padding: "12px 30px",
};

const footer = {
  color: "#898989",
  fontSize: "12px",
  lineHeight: "22px",
  padding: "0 48px",
  marginTop: "20px",
};
`],
  ["email/react-email/components/src/emails/index.ts.hbs", `export { WelcomeEmail } from "./welcome";
`],
  ["frontend/qwik/src/components/router-head/router-head.tsx", `import { component$ } from "@builder.io/qwik";
import { useDocumentHead, useLocation } from "@builder.io/qwik-city";

export const RouterHead = component$(() => {
  const head = useDocumentHead();
  const loc = useLocation();

  return (
    <>
      <title>{head.title}</title>

      <link rel="canonical" href={loc.url.href} />
      <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="icon" type="image/svg+xml" href="/favicon.svg" />

      {head.meta.map((m) => (
        <meta key={m.key} {...m} />
      ))}

      {head.links.map((l) => (
        <link key={l.key} {...l} />
      ))}

      {head.styles.map((s) => (
        <style
          key={s.key}
          {...s.props}
          {...(s.props?.dangerouslySetInnerHTML ? {} : { dangerouslySetInnerHTML: s.style })}
        />
      ))}

      {head.scripts.map((s) => (
        <script
          key={s.key}
          {...s.props}
          {...(s.props?.dangerouslySetInnerHTML ? {} : { dangerouslySetInnerHTML: s.script })}
        />
      ))}
    </>
  );
});
`],
  ["frontend/redwood/api/src/graphql/posts.sdl.ts", `export const schema = gql\`
  type Post {
    id: Int!
    title: String!
    body: String!
    createdAt: DateTime!
  }

  type Query {
    posts: [Post!]! @skipAuth
    post(id: Int!): Post @skipAuth
  }

  input CreatePostInput {
    title: String!
    body: String!
  }

  input UpdatePostInput {
    title: String
    body: String
  }

  type Mutation {
    createPost(input: CreatePostInput!): Post! @requireAuth
    updatePost(id: Int!, input: UpdatePostInput!): Post! @requireAuth
    deletePost(id: Int!): Post! @requireAuth
  }
\`;
`],
  ["frontend/redwood/api/src/lib/auth.ts", `/**
 * Once you have your authentication type defined (e.g. Cookie, OAuth, etc.),
 * you can add auth to your API functions by importing this file
 * and calling \`isAuthenticated()\` and \`hasRole()\` in your handler functions.
 *
 * @see https://redwoodjs.com/docs/authentication
 */
import type { Decoded } from "@redwoodjs/api";

/**
 * Represents the user attributes returned by the decoding the
 * Authentication provider's JWT token together with any additional
 * attributes that you wish to add to the user's context.
 */
export interface CurrentUser {
  id: string;
  email?: string;
  roles?: string[];
}

/**
 * The session object sent in as the first argument to getCurrentUser() will
 * have a single key \`id\` containing the unique ID of the logged in user
 * (whatever field you set as \`authFields.id\` in your auth function config).
 */
export const getCurrentUser = async (
  decoded: Decoded,
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  { _token, _type }: { _token: string; _type: string },
): Promise<CurrentUser | null> => {
  if (!decoded) {
    return null;
  }

  // Add your custom user lookup logic here
  return {
    id: decoded.sub || decoded.id || "user",
    email: decoded.email,
    roles: decoded.roles || [],
  };
};

/**
 * The user is authenticated if there is a currentUser in the context
 */
export const isAuthenticated = (): boolean => {
  return !!context.currentUser;
};

/**
 * When checking role membership, roles can be a single value, a list, or none.
 * You can use Prisma enum types if you have defined them.
 */
export const hasRole = (roles: string | string[]): boolean => {
  if (!isAuthenticated()) {
    return false;
  }

  const currentUserRoles = context.currentUser?.roles;

  if (typeof roles === "string") {
    if (typeof currentUserRoles === "string") {
      return currentUserRoles === roles;
    } else if (Array.isArray(currentUserRoles)) {
      return currentUserRoles?.some((allowedRole) => roles === allowedRole);
    }
  }

  if (Array.isArray(roles)) {
    if (Array.isArray(currentUserRoles)) {
      return currentUserRoles?.some((allowedRole) => roles.includes(allowedRole));
    } else if (typeof currentUserRoles === "string") {
      return roles.some((allowedRole) => currentUserRoles === allowedRole);
    }
  }

  return false;
};

/**
 * Use requireAuth in your services to check that a user is logged in
 *
 * @example
 *
 * export const createPost = ({ input }: { input: CreatePostInput }) => {
 *   requireAuth({ roles: ['admin'] })
 *
 *   return db.post.create({ data: input })
 * }
 *
 */
export const requireAuth = ({ roles }: { roles?: string | string[] } = {}) => {
  if (!isAuthenticated()) {
    throw new Error("You must be logged in to access this");
  }

  if (roles && !hasRole(roles)) {
    throw new Error("You do not have permission to access this");
  }
};
`],
  ["frontend/redwood/api/src/lib/db.ts", `// See https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/constructor
// for options.

import { PrismaClient } from "@prisma/client";
import { emitLogLevels, handlePrismaLogging } from "@redwoodjs/api/logger";

import { logger } from "./logger";

/*
 * Instance of the Prisma Client
 */
export const db = new PrismaClient({
  log: emitLogLevels(["info", "warn", "error"]),
});

handlePrismaLogging({
  db,
  logger,
  logLevels: ["info", "warn", "error"],
});
`],
  ["frontend/redwood/api/src/lib/logger.ts", `import { createLogger } from "@redwoodjs/api/logger";

/**
 * Creates a logger with RedwoodLoggerOptions
 *
 * These extend and adhere to options defined in https://github.com/pinojs/pino/blob/master/docs/api.md
 *
 * @param RedwoodLoggerOptions
 *
 * @returns Logger
 */
export const logger = createLogger({});
`],
  ["frontend/redwood/api/src/functions/graphql.ts", `import { createGraphQLHandler } from "@redwoodjs/graphql-server";
import directives from "src/directives/**/*.{js,ts}";
import sdls from "src/graphql/**/*.sdl.{js,ts}";
import { db } from "src/lib/db";
import { logger } from "src/lib/logger";
import services from "src/services/**/*.{js,ts}";

export const handler = createGraphQLHandler({
  loggerConfig: { logger, options: {} },
  directives,
  sdls,
  services,
  onException: () => {
    // Disconnect from your database with an unhandled exception.
    db.$disconnect();
  },
});
`],
  ["frontend/angular/src/app/components/header.component.ts.hbs", `import { Component } from '@angular/core';

@Component({
  selector: 'app-header',
  standalone: true,
  template: \`
    {{#if (eq cssFramework "tailwind")}}
    <header class="flex items-center justify-between border-b border-gray-200 dark:border-gray-800 px-4 py-3">
      <div class="flex items-center gap-2">
        <span class="font-semibold">Better Fullstack</span>
      </div>
      <nav class="flex items-center gap-4">
        <a href="https://github.com/Marve10s/Better-Fullstack"
           target="_blank"
           rel="noopener noreferrer"
           class="text-sm text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-gray-100 transition-colors">
          GitHub
        </a>
        <a href="https://better-fullstack-web.vercel.app"
           target="_blank"
           rel="noopener noreferrer"
           class="text-sm text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-gray-100 transition-colors">
          Docs
        </a>
      </nav>
    </header>
    {{else}}
    <header [style.display]="'flex'"
            [style.alignItems]="'center'"
            [style.justifyContent]="'space-between'"
            [style.borderBottom]="'1px solid var(--border-color)'"
            [style.padding]="'0.75rem 1rem'">
      <div [style.display]="'flex'" [style.alignItems]="'center'" [style.gap]="'0.5rem'">
        <span [style.fontWeight]="600">Better Fullstack</span>
      </div>
      <nav [style.display]="'flex'" [style.alignItems]="'center'" [style.gap]="'1rem'">
        <a href="https://github.com/Marve10s/Better-Fullstack"
           target="_blank"
           rel="noopener noreferrer"
           [style.fontSize]="'0.875rem'"
           [style.color]="'var(--muted-color)'">
          GitHub
        </a>
        <a href="https://better-fullstack-web.vercel.app"
           target="_blank"
           rel="noopener noreferrer"
           [style.fontSize]="'0.875rem'"
           [style.color]="'var(--muted-color)'">
          Docs
        </a>
      </nav>
    </header>
    {{/if}}
  \`,
})
export class HeaderComponent {}
`],
  ["frontend/nuxt/app/assets/css/main.css", `@import "tailwindcss";
@import "@nuxt/ui";
`],
  ["frontend/native/unistyles/app/(drawer)/_layout.tsx.hbs", `import { Ionicons, MaterialIcons } from "@expo/vector-icons";
import { Link } from "expo-router";
import { Drawer } from "expo-router/drawer";
import { useUnistyles } from "react-native-unistyles";

import { HeaderButton } from "../../components/header-button";

const DrawerLayout = () => {
  const { theme } = useUnistyles();

  return (
    <Drawer
      screenOptions=\\{{
        headerStyle: {
          backgroundColor: theme.colors.background,
        },
        headerTitleStyle: {
          color: theme.colors.foreground,
        },
        headerTintColor: theme.colors.foreground,
        drawerStyle: {
          backgroundColor: theme.colors.background,
        },
        drawerLabelStyle: {
          color: theme.colors.foreground,
        },
        drawerInactiveTintColor: theme.colors.mutedForeground,
      }}
    >
      <Drawer.Screen
        name="index"
        options=\\{{
          headerTitle: "Home",
          drawerLabel: "Home",
          drawerIcon: ({ size, color }) => (
            <Ionicons name="home-outline" size={size} color={color} />
          ),
        }}
      />
      <Drawer.Screen
        name="(tabs)"
        options=\\{{
          headerTitle: "Tabs",
          drawerLabel: "Tabs",
          drawerIcon: ({ size, color }) => (
            <MaterialIcons name="border-bottom" size={size} color={color} />
          ),
          headerRight: () => (
            <Link href="/modal" asChild>
              <HeaderButton />
            </Link>
          ),
        }}
      />
      {{#if (includes examples "todo")}}
      <Drawer.Screen
        name="todos"
        options=\\{{
          headerTitle: "Todos",
          drawerLabel: "Todos",
          drawerIcon: ({ size, color }) => (
            <Ionicons name="checkbox-outline" size={size} color={color} />
          ),
        }}
      />
      {{/if}}
      {{#if (includes examples "ai")}}
      <Drawer.Screen
        name="ai"
        options=\\{{
          headerTitle: "AI",
          drawerLabel: "AI",
          drawerIcon: ({ size, color }) => (
            <Ionicons
              name="chatbubble-ellipses-outline"
              size={size}
              color={color}
            />
          ),
        }}
      />
      {{/if}}
    </Drawer>
  );
};

export default DrawerLayout;
`],
  ["frontend/native/unistyles/app/(drawer)/index.tsx.hbs", `import { ScrollView, Text, View, TouchableOpacity } from "react-native";
import { StyleSheet } from "react-native-unistyles";
import { Container } from "@/components/container";

{{#if (eq api "orpc")}}
import { useQuery } from "@tanstack/react-query";
import { orpc } from "@/utils/orpc";
{{/if}}
{{#if (eq api "trpc")}}
import { useQuery } from "@tanstack/react-query";
import { trpc } from "@/utils/trpc";
{{/if}}
{{#if (and (eq backend "convex") (eq auth "clerk"))}}
import { Link } from "expo-router";
import { Authenticated, AuthLoading, Unauthenticated, useQuery } from "convex/react";
import { api } from "@{{ projectName }}/backend/convex/_generated/api";
import { useUser } from "@clerk/clerk-expo";
import { SignOutButton } from "@/components/sign-out-button";
{{else if (and (eq backend "convex") (eq auth "better-auth"))}}
import { useConvexAuth, useQuery } from "convex/react";
import { api } from "@{{ projectName }}/backend/convex/_generated/api";
import { authClient } from "@/lib/auth-client";
import { SignIn } from "@/components/sign-in";
import { SignUp } from "@/components/sign-up";
{{else if (eq backend "convex")}}
import { useQuery } from "convex/react";
import { api } from "@{{ projectName }}/backend/convex/_generated/api";
{{/if}}

export default function Home() {
  {{#if (eq api "orpc")}}
  const healthCheck = useQuery(orpc.healthCheck.queryOptions());
  {{/if}}
  {{#if (eq api "trpc")}}
  const healthCheck = useQuery(trpc.healthCheck.queryOptions());
  {{/if}}
  {{#if (and (eq backend "convex") (eq auth "clerk"))}}
  const { user } = useUser();
  const healthCheck = useQuery(api.healthCheck.get);
  const privateData = useQuery(api.privateData.get);
  {{else if (and (eq backend "convex") (eq auth "better-auth"))}}
  const healthCheck = useQuery(api.healthCheck.get);
  const { isAuthenticated } = useConvexAuth();
  const user = useQuery(api.auth.getCurrentUser, isAuthenticated ? {} : "skip");
  {{else if (eq backend "convex")}}
  const healthCheck = useQuery(api.healthCheck.get);
  {{/if}}

  return (
    <Container>
      <ScrollView
        contentContainerStyle={styles.container}
        showsVerticalScrollIndicator={false}
      >
        <Text style={styles.heroTitle}>
          BETTER T STACK
        </Text>

        {{#unless (and (eq backend "convex") (eq auth "better-auth"))}}
        <View style={styles.statusCard}>
          <View style={styles.statusHeader}>
            <Text style={styles.statusTitle}>System Status</Text>
            <View style={styles.statusBadge}>
              <Text style={styles.statusBadgeText}>LIVE</Text>
            </View>
          </View>
          {{#if (eq backend "convex")}}
            {{#unless (eq auth "better-auth")}}
            <View style={styles.statusRow}>
              <View
                style={[
                  styles.statusDot,
                  healthCheck === "OK"
                    ? styles.statusDotSuccess
                    : styles.statusDotWarning,
                ]}
              />
              <View style={styles.statusContent}>
                <Text style={styles.statusLabel}>Convex</Text>
                <Text style={styles.statusDescription}>
                  {healthCheck === undefined
                    ? "Checking connection..."
                    : healthCheck === "OK"
                    ? "Connected to API"
                    : "API Disconnected"}
                </Text>
              </View>
            </View>
            {{/unless}}
          {{else}}
            {{#unless (eq api "none")}}
            <View style={styles.statusRow}>
              <View
                style={[
                  styles.statusDot,
                  healthCheck.data
                    ? styles.statusDotSuccess
                    : styles.statusDotWarning,
                ]}
              />
              <View style={styles.statusContent}>
                <Text style={styles.statusLabel}>
                  {{#if (eq api "orpc")}}ORPC{{/if}}
                  {{#if (eq api "trpc")}}TRPC{{/if}}
                </Text>
                <Text style={styles.statusDescription}>
                  {healthCheck.isLoading
                    ? "Checking connection..."
                    : healthCheck.data
                    ? "Connected to API"
                    : "API Disconnected"}
                </Text>
              </View>
            </View>
            {{/unless}}
          {{/if}}
        </View>
        {{/unless}}

        {{#if (and (eq backend "convex") (eq auth "clerk"))}}
        <Authenticated>
          <Text>
            Hello {user?.emailAddresses[0].emailAddress}
          </Text>
          <Text>
            Private Data: {privateData?.message}
          </Text>
          <SignOutButton />
        </Authenticated>
        <Unauthenticated>
          <Link href="/(auth)/sign-in">
            <Text>Sign in</Text>
          </Link>
          <Link href="/(auth)/sign-up">
            <Text>Sign up</Text>
          </Link>
        </Unauthenticated>
        <AuthLoading>
          <Text>Loading...</Text>
        </AuthLoading>
        {{/if}}

        {{#if (and (eq backend "convex") (eq auth "better-auth"))}}
        {user ? (
          <View style={styles.userCard}>
            <View style={styles.userHeader}>
              <Text style={styles.userWelcome}>
                Welcome,{" "}
                <Text style={styles.userName}>{user.name}</Text>
              </Text>
            </View>
            <Text style={styles.userEmail}>{user.email}</Text>
            <TouchableOpacity
              style={styles.signOutButton}
              onPress={() => {
                authClient.signOut();
              }}
            >
              <Text style={styles.signOutText}>Sign Out</Text>
            </TouchableOpacity>
          </View>
        ) : null}
        <View style={styles.apiStatusCard}>
          <Text style={styles.apiStatusTitle}>API Status</Text>
          <View style={styles.apiStatusRow}>
            <View
              style={[
                styles.statusDot,
                healthCheck === "OK"
                  ? styles.statusDotSuccess
                  : styles.statusDotWarning,
              ]}
            />
            <Text style={styles.apiStatusText}>
              {healthCheck === undefined
                ? "Checking..."
                : healthCheck === "OK"
                ? "Connected to API"
                : "API Disconnected"}
            </Text>
          </View>
        </View>
        {!user && (
          <>
            <SignIn />
            <SignUp />
          </>
        )}
        {{/if}}
      </ScrollView>
    </Container>
  );
}

const styles = StyleSheet.create((theme) => ({
  container: {
    paddingHorizontal: theme.spacing.md,
  },
  heroSection: {
    paddingVertical: theme.spacing.xl,
  },
  heroTitle: {
    fontSize: theme.fontSize["4xl"],
    fontWeight: "bold",
    color: theme.colors.foreground,
    marginBottom: theme.spacing.sm,
  },
  heroSubtitle: {
    fontSize: theme.fontSize.lg,
    color: theme.colors.mutedForeground,
    lineHeight: 28,
  },
  statusCard: {
    backgroundColor: theme.colors.card,
    borderWidth: 1,
    borderColor: theme.colors.border,
    borderRadius: theme.borderRadius.xl,
    padding: theme.spacing.lg,
    marginBottom: theme.spacing.lg,
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.05,
    shadowRadius: 3,
    elevation: 2,
  },
  statusHeader: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    marginBottom: theme.spacing.md,
  },
  statusTitle: {
    fontSize: theme.fontSize.lg,
    fontWeight: "600",
    color: theme.colors.cardForeground,
  },
  statusBadge: {
    backgroundColor: theme.colors.secondary,
    paddingHorizontal: theme.spacing.sm + 4,
    paddingVertical: theme.spacing.xs,
    borderRadius: 9999,
  },
  statusBadgeText: {
    fontSize: theme.fontSize.xs,
    fontWeight: "500",
    color: theme.colors.secondaryForeground,
  },
  statusRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: theme.spacing.sm + 4,
  },
  statusDot: {
    height: 12,
    width: 12,
    borderRadius: 6,
  },
  statusDotSuccess: {
    backgroundColor: theme.colors.success,
  },
  statusDotWarning: {
    backgroundColor: "#F59E0B",
  },
  statusContent: {
    flex: 1,
  },
  statusLabel: {
    fontSize: theme.fontSize.sm,
    fontWeight: "500",
    color: theme.colors.cardForeground,
  },
  statusDescription: {
    fontSize: theme.fontSize.xs,
    color: theme.colors.mutedForeground,
  },
  userCard: {
    backgroundColor: theme.colors.card,
    borderWidth: 1,
    borderColor: theme.colors.border,
    borderRadius: theme.borderRadius.lg,
    padding: theme.spacing.md,
    marginBottom: theme.spacing.md,
  },
  userHeader: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    marginBottom: theme.spacing.xs,
  },
  userWelcome: {
    fontSize: theme.fontSize.base,
    color: theme.colors.foreground,
  },
  userName: {
    fontWeight: "500",
  },
  userEmail: {
    fontSize: theme.fontSize.sm,
    color: theme.colors.mutedForeground,
    marginBottom: theme.spacing.md,
  },
  signOutButton: {
    backgroundColor: theme.colors.destructive,
    paddingVertical: theme.spacing.sm,
    paddingHorizontal: theme.spacing.md,
    borderRadius: theme.borderRadius.md,
    alignSelf: "flex-start",
  },
  signOutText: {
    color: theme.colors.destructiveForeground,
    fontWeight: "500",
  },
  apiStatusCard: {
    marginBottom: theme.spacing.md,
    borderRadius: theme.borderRadius.lg,
    borderWidth: 1,
    borderColor: theme.colors.border,
    padding: theme.spacing.md,
  },
  apiStatusTitle: {
    marginBottom: theme.spacing.sm,
    fontWeight: "500",
    color: theme.colors.foreground,
  },
  apiStatusRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: theme.spacing.xs,
  },
  apiStatusText: {
    color: theme.colors.mutedForeground,
  },
}));`],
  ["frontend/native/bare/app/(drawer)/_layout.tsx.hbs", `import { Ionicons, MaterialIcons } from "@expo/vector-icons";
import { Link } from "expo-router";
import { Drawer } from "expo-router/drawer";
import { useColorScheme } from "@/lib/use-color-scheme";
import { NAV_THEME } from "@/lib/constants";

import { HeaderButton } from "@/components/header-button";

const DrawerLayout = () => {
  const { colorScheme } = useColorScheme();
  const theme = colorScheme === "dark" ? NAV_THEME.dark : NAV_THEME.light;

  return (
    <Drawer
      screenOptions=\\{{
        headerStyle: {
          backgroundColor: theme.background,
        },
        headerTitleStyle: {
          color: theme.text,
        },
        headerTintColor: theme.text,
        drawerStyle: {
          backgroundColor: theme.background,
        },
        drawerLabelStyle: {
          color: theme.text,
        },
        drawerInactiveTintColor: theme.text,
      }}
    >
      <Drawer.Screen
        name="index"
        options=\\{{
          headerTitle: "Home",
          drawerLabel: "Home",
          drawerIcon: ({ size, color }) => (
            <Ionicons name="home-outline" size={size} color={color} />
          ),
        }}
      />
      <Drawer.Screen
        name="(tabs)"
        options=\\{{
          headerTitle: "Tabs",
          drawerLabel: "Tabs",
          drawerIcon: ({ size, color }) => (
            <MaterialIcons name="border-bottom" size={size} color={color} />
          ),
          headerRight: () => (
            <Link href="/modal" asChild>
              <HeaderButton />
            </Link>
          ),
        }}
      />
      {{#if (includes examples "todo")}}
      <Drawer.Screen
        name="todos"
        options=\\{{
          headerTitle: "Todos",
          drawerLabel: "Todos",
          drawerIcon: ({ size, color }) => (
            <Ionicons name="checkbox-outline" size={size} color={color} />
          ),
        }}
      />
      {{/if}}
      {{#if (includes examples "ai")}}
      <Drawer.Screen
        name="ai"
        options=\\{{
          headerTitle: "AI",
          drawerLabel: "AI",
          drawerIcon: ({ size, color }) => (
            <Ionicons
              name="chatbubble-ellipses-outline"
              size={size}
              color={color}
            />
          ),
        }}
      />
      {{/if}}
    </Drawer>
  );
};

export default DrawerLayout;

`],
  ["frontend/native/bare/app/(drawer)/index.tsx.hbs", `import { View, Text, ScrollView, TouchableOpacity, StyleSheet } from "react-native";
import { Container } from "@/components/container";
import { useColorScheme } from "@/lib/use-color-scheme";
import { NAV_THEME } from "@/lib/constants";
{{#if (eq api "orpc")}}
import { useQuery } from "@tanstack/react-query";
import { orpc } from "@/utils/orpc";
{{/if}}
{{#if (eq api "trpc")}}
import { useQuery } from "@tanstack/react-query";
import { trpc } from "@/utils/trpc";
{{/if}}
{{#if (and (eq backend "convex") (eq auth "clerk"))}}
import { Link } from "expo-router";
import { Authenticated, AuthLoading, Unauthenticated, useQuery } from "convex/react";
import { api } from "@{{ projectName }}/backend/convex/_generated/api";
import { useUser } from "@clerk/clerk-expo";
import { SignOutButton } from "@/components/sign-out-button";
{{else if (and (eq backend "convex") (eq auth "better-auth"))}}
import { useConvexAuth, useQuery } from "convex/react";
import { api } from "@{{ projectName }}/backend/convex/_generated/api";
import { authClient } from "@/lib/auth-client";
import { SignIn } from "@/components/sign-in";
import { SignUp } from "@/components/sign-up";
{{else if (eq backend "convex")}}
import { useQuery } from "convex/react";
import { api } from "@{{ projectName }}/backend/convex/_generated/api";
{{/if}}

export default function Home() {
const { colorScheme } = useColorScheme();
const theme = colorScheme === "dark" ? NAV_THEME.dark : NAV_THEME.light;
{{#if (eq api "orpc")}}
const healthCheck = useQuery(orpc.healthCheck.queryOptions());
{{/if}}
{{#if (eq api "trpc")}}
const healthCheck = useQuery(trpc.healthCheck.queryOptions());
{{/if}}
{{#if (and (eq backend "convex") (eq auth "clerk"))}}
const { user } = useUser();
const healthCheck = useQuery(api.healthCheck.get);
const privateData = useQuery(api.privateData.get);
{{else if (and (eq backend "convex") (eq auth "better-auth"))}}
const healthCheck = useQuery(api.healthCheck.get);
const { isAuthenticated } = useConvexAuth();
const user = useQuery(api.auth.getCurrentUser, isAuthenticated ? {} : "skip");
{{else if (eq backend "convex")}}
const healthCheck = useQuery(api.healthCheck.get);
{{/if}}

return (
<Container>
  <ScrollView style={styles.scrollView}>
    <View style={styles.content}>
      <Text style={[styles.title, { color: theme.text }]}>
        BETTER T STACK
      </Text>

      {{#unless (and (eq backend "convex") (eq auth "better-auth"))}}
      <View style={[styles.card, { backgroundColor: theme.card, borderColor: theme.border }]}>
        {{#if (eq backend "convex")}}
        <View style={styles.statusRow}>
          <View style={[styles.statusIndicator, { backgroundColor: healthCheck ? "#10b981" : "#f59e0b" }]} />
          <View style={styles.statusContent}>
            <Text style={[styles.statusTitle, { color: theme.text }]}>
              Convex
            </Text>
            <Text style={[styles.statusText, { color: theme.text, opacity: 0.7 }]}>
              {healthCheck === undefined
              ? "Checking..."
              : healthCheck === "OK"
              ? "Connected to API"
              : "API Disconnected"}
            </Text>
          </View>
        </View>
        {{else}}
        {{#unless (eq api "none")}}
        <View style={styles.statusRow}>
          <View style={[styles.statusIndicator, { backgroundColor: healthCheck.data ? "#10b981" : "#f59e0b" }]} />
          <View style={styles.statusContent}>
            <Text style={[styles.statusTitle, { color: theme.text }]}>
              {{#if (eq api "orpc")}}ORPC{{else}}TRPC{{/if}}
            </Text>
            <Text style={[styles.statusText, { color: theme.text, opacity: 0.7 }]}>
              {healthCheck.isLoading
              ? "Checking connection..."
              : healthCheck.data
              ? "All systems operational"
              : "Service unavailable"}
            </Text>
          </View>
        </View>
        {{/unless}}
        {{/if}}
      </View>
      {{/unless}}

      {{#if (and (eq backend "convex") (eq auth "clerk"))}}
      <Authenticated>
        <Text style=\\{{ color: theme.text }}>Hello {user?.emailAddresses[0].emailAddress}</Text>
        <Text style=\\{{ color: theme.text }}>Private Data: {privateData?.message}</Text>
        <SignOutButton />
      </Authenticated>
      <Unauthenticated>
        <Link href="/(auth)/sign-in">
        <Text style=\\{{ color: theme.primary }}>Sign in</Text>
        </Link>
        <Link href="/(auth)/sign-up">
        <Text style=\\{{ color: theme.primary }}>Sign up</Text>
        </Link>
      </Unauthenticated>
      <AuthLoading>
        <Text style=\\{{ color: theme.text }}>Loading...</Text>
      </AuthLoading>
      {{/if}}

      {{#if (and (eq backend "convex") (eq auth "better-auth"))}}
      {user ? (
      <View style={[styles.userCard, { backgroundColor: theme.card, borderColor: theme.border }]}>
        <View style={styles.userHeader}>
          <Text style={[styles.userText, { color: theme.text }]}>
            Welcome, <Text style={styles.userName}>{user.name}</Text>
          </Text>
        </View>
        <Text style={[styles.userEmail, { color: theme.text, opacity: 0.7 }]}>
          {user.email}
        </Text>
        <TouchableOpacity style={[styles.signOutButton, { backgroundColor: theme.notification }]} onPress={()=> {
          authClient.signOut();
          }}
          >
          <Text style={styles.signOutText}>Sign Out</Text>
        </TouchableOpacity>
      </View>
      ) : null}
      <View style={[styles.statusCard, { backgroundColor: theme.card, borderColor: theme.border }]}>
        <Text style={[styles.statusCardTitle, { color: theme.text }]}>
          API Status
        </Text>
        <View style={styles.statusRow}>
          <View style={[styles.statusIndicator, { backgroundColor: healthCheck ? "#10b981" : "#ef4444" }]} />
          <Text style={[styles.statusText, { color: theme.text, opacity: 0.7 }]}>
            {healthCheck === undefined
            ? "Checking..."
            : healthCheck === "OK"
            ? "Connected to API"
            : "API Disconnected"}
          </Text>
        </View>
      </View>
      {!user && (
      <>
        <SignIn />
        <SignUp />
      </>
      )}
      {{/if}}
    </View>
  </ScrollView>
</Container>
);
}

const styles = StyleSheet.create({
scrollView: {
flex: 1,
},
content: {
padding: 16,
},
title: {
fontSize: 24,
fontWeight: "bold",
marginBottom: 16,
},
card: {
padding: 16,
marginBottom: 16,
borderWidth: 1,
},
statusRow: {
flexDirection: "row",
alignItems: "center",
gap: 8,
},
statusIndicator: {
height: 8,
width: 8,
},
statusContent: {
flex: 1,
},
statusTitle: {
fontSize: 14,
fontWeight: "bold",
},
statusText: {
fontSize: 12,
},
userCard: {
marginBottom: 16,
padding: 16,
borderWidth: 1,
},
userHeader: {
marginBottom: 8,
},
userText: {
fontSize: 16,
},
userName: {
fontWeight: "bold",
},
userEmail: {
fontSize: 14,
marginBottom: 12,
},
signOutButton: {
padding: 12,
},
signOutText: {
color: "#ffffff",
},
statusCard: {
marginBottom: 16,
padding: 16,
borderWidth: 1,
},
statusCardTitle: {
marginBottom: 8,
fontWeight: "bold",
},
});`],
  ["frontend/native/base/assets/images/partial-react-logo.png", `[Binary file]`],
  ["frontend/native/base/assets/images/react-logo.png", `[Binary file]`],
  ["frontend/native/base/assets/images/react-logo@2x.png", `[Binary file]`],
  ["frontend/native/base/assets/images/android-icon-monochrome.png", `[Binary file]`],
  ["frontend/native/base/assets/images/splash-icon.png", `[Binary file]`],
  ["frontend/native/base/assets/images/react-logo@3x.png", `[Binary file]`],
  ["frontend/native/base/assets/images/icon.png", `[Binary file]`],
  ["frontend/native/base/assets/images/android-icon-foreground.png", `[Binary file]`],
  ["frontend/native/base/assets/images/favicon.png", `[Binary file]`],
  ["frontend/native/base/assets/images/android-icon-background.png", `[Binary file]`],
  ["frontend/native/uniwind/app/(drawer)/_layout.tsx.hbs", `import React, { useCallback } from "react";
import { Ionicons, MaterialIcons } from "@expo/vector-icons";
import { Link } from "expo-router";
import { Drawer } from "expo-router/drawer";
import { useThemeColor } from "heroui-native";
import { Pressable, Text } from "react-native";
import { ThemeToggle } from "@/components/theme-toggle";

function DrawerLayout() {
  const themeColorForeground = useThemeColor("foreground");
  const themeColorBackground = useThemeColor("background");

  const renderThemeToggle = useCallback(() => <ThemeToggle />, []);

  return (
    <Drawer
      screenOptions=\\{{
        headerTintColor: themeColorForeground,
        headerStyle: { backgroundColor: themeColorBackground },
        headerTitleStyle: {
          fontWeight: "600",
          color: themeColorForeground,
        },
        headerRight: renderThemeToggle,
        drawerStyle: { backgroundColor: themeColorBackground },
      }}
    >
      <Drawer.Screen
        name="index"
        options=\\{{
          headerTitle: "Home",
          drawerLabel: ({ color, focused }) => (
            <Text style=\\{{ color: focused ? color : themeColorForeground }}>Home</Text>
          ),
          drawerIcon: ({ size, color, focused }) => (
            <Ionicons name="home-outline" size={size} color={focused ? color : themeColorForeground} />
          ),
        }}
      />
      <Drawer.Screen
        name="(tabs)"
        options=\\{{
          headerTitle: "Tabs",
          drawerLabel: ({ color, focused }) => (
            <Text style=\\{{ color: focused ? color : themeColorForeground }}>Tabs</Text>
          ),
          drawerIcon: ({ size, color, focused }) => (
            <MaterialIcons name="border-bottom" size={size} color={focused ? color : themeColorForeground} />
          ),
          headerRight: () => (
            <Link href="/modal" asChild>
              <Pressable className="mr-4">
                <Ionicons name="add-outline" size={24} color={themeColorForeground} />
              </Pressable>
            </Link>
          ),
        }}
      />
      {{#if (includes examples "todo")}}
      <Drawer.Screen
        name="todos"
        options=\\{{
          headerTitle: "Todos",
          drawerLabel: ({ color, focused }) => (
            <Text style=\\{{ color: focused ? color : themeColorForeground }}>Todos</Text>
          ),
          drawerIcon: ({ size, color, focused }) => (
            <Ionicons name="checkbox-outline" size={size} color={focused ? color : themeColorForeground} />
          ),
        }}
      />
      {{/if}}
      {{#if (includes examples "ai")}}
      <Drawer.Screen
        name="ai"
        options=\\{{
          headerTitle: "AI",
          drawerLabel: ({ color, focused }) => (
            <Text style=\\{{ color: focused ? color : themeColorForeground }}>AI</Text>
          ),
          drawerIcon: ({ size, color, focused }) => (
            <Ionicons name="chatbubble-ellipses-outline" size={size} color={focused ? color : themeColorForeground} />
          ),
        }}
      />
      {{/if}}
    </Drawer>
  );
}

export default DrawerLayout;`],
  ["frontend/native/uniwind/app/(drawer)/index.tsx.hbs", `import { Text, View } from "react-native";
import { Container } from "@/components/container";
{{#if (eq api "orpc")}}
import { useQuery } from "@tanstack/react-query";
import { orpc } from "@/utils/orpc";
{{/if}}
{{#if (eq api "trpc")}}
import { useQuery } from "@tanstack/react-query";
import { trpc } from "@/utils/trpc";
{{/if}}
{{#if (and (eq backend "convex") (eq auth "clerk"))}}
import { Link } from "expo-router";
import { Authenticated, AuthLoading, Unauthenticated, useQuery } from "convex/react";
import { api } from "@{{projectName}}/backend/convex/_generated/api";
import { useUser } from "@clerk/clerk-expo";
import { SignOutButton } from "@/components/sign-out-button";
{{else if (and (eq backend "convex") (eq auth "better-auth"))}}
import { useConvexAuth, useQuery } from "convex/react";
import { api } from "@{{projectName}}/backend/convex/_generated/api";
import { authClient } from "@/lib/auth-client";
import { SignIn } from "@/components/sign-in";
import { SignUp } from "@/components/sign-up";
{{else if (eq backend "convex")}}
import { useQuery } from "convex/react";
import { api } from "@{{projectName}}/backend/convex/_generated/api";
{{/if}}
{{#unless (or (eq backend "none") (and (eq backend "convex") (eq auth "better-auth")))}}
import { Ionicons } from "@expo/vector-icons";
{{/unless}}
import { Button, Chip, Divider, Spinner, Surface, useThemeColor } from "heroui-native";

export default function Home() {
{{#if (eq api "orpc")}}
const healthCheck = useQuery(orpc.healthCheck.queryOptions());
{{/if}}
{{#if (eq api "trpc")}}
const healthCheck = useQuery(trpc.healthCheck.queryOptions());
{{/if}}
{{#if (and (eq backend "convex") (eq auth "clerk"))}}
const { user } = useUser();
const healthCheck = useQuery(api.healthCheck.get);
const privateData = useQuery(api.privateData.get);
{{else if (and (eq backend "convex") (eq auth "better-auth"))}}
const healthCheck = useQuery(api.healthCheck.get);
const { isAuthenticated } = useConvexAuth();
const user = useQuery(api.auth.getCurrentUser, isAuthenticated ? {} : "skip");
{{else if (eq backend "convex")}}
const healthCheck = useQuery(api.healthCheck.get);
{{/if}}
{{#unless (eq backend "none")}}
const successColor = useThemeColor("success");
const dangerColor = useThemeColor("danger");

{{#if (eq backend "convex")}}
const isConnected = healthCheck === "OK";
const isLoading = healthCheck === undefined;
{{else}}
{{#unless (eq api "none")}}
const isConnected = healthCheck?.data === "OK";
const isLoading = healthCheck?.isLoading;
{{/unless}}
{{/if}}
{{/unless}}

return (
<Container className="p-4">
  <View className="py-6 mb-4">
    <Text className="text-3xl font-semibold text-foreground tracking-tight">
      Better T Stack
    </Text>
    <Text className="text-muted text-sm mt-1">Full-stack TypeScript starter</Text>
  </View>

  {{#unless (or (eq backend "none") (and (eq backend "convex") (eq auth "better-auth")))}}
  <Surface variant="secondary" className="p-4 rounded-lg">
    <View className="flex-row items-center justify-between mb-3">
      <Text className="text-foreground font-medium">System Status</Text>
      <Chip variant="secondary" color={isConnected ? "success" : "danger" } size="sm">
        <Chip.Label>
          {isConnected ? "LIVE" : "OFFLINE"}
        </Chip.Label>
      </Chip>
    </View>

    <Divider className="mb-3" />

    <Surface variant="tertiary" className="p-3 rounded-md">
      <View className="flex-row items-center">
        <View className={\`w-2 h-2 rounded-full mr-3 \${ isConnected ? "bg-success" : "bg-muted" }\`} />
        <View className="flex-1">
          <Text className="text-foreground text-sm font-medium">
            {{#if (eq backend "convex")}}
            Convex Backend
            {{else}}
            {{#unless (eq api "none")}}
            {{#if (eq api "orpc")}}ORPC{{else}}TRPC{{/if}} Backend
            {{/unless}}
            {{/if}}
          </Text>
          <Text className="text-muted text-xs mt-0.5">
            {isLoading
            ? "Checking connection..."
            : isConnected
            ? "Connected to API"
            : "API Disconnected"}
          </Text>
        </View>
        {isLoading && <Spinner size="sm" />}
        {!isLoading && isConnected && (
        <Ionicons name="checkmark-circle" size={18} color={successColor} />
        )}
        {!isLoading && !isConnected && (
        <Ionicons name="close-circle" size={18} color={dangerColor} />
        )}
      </View>
    </Surface>
  </Surface>
  {{/unless}}

  {{#if (and (eq backend "convex") (eq auth "clerk"))}}
  <Authenticated>
    <Surface variant="secondary" className="mt-4 p-4 rounded-lg">
      <View className="flex-row items-center justify-between">
        <View className="flex-1">
          <Text className="text-foreground font-medium">{user?.emailAddresses[0].emailAddress}</Text>
          <Text className="text-muted text-xs mt-0.5">Private: {privateData?.message}</Text>
        </View>
        <SignOutButton />
      </View>
    </Surface>
  </Authenticated>
  <Unauthenticated>
    <View className="mt-4 gap-3">
      <Link href="/(auth)/sign-in" asChild>
        <Button variant="secondary"><Button.Label>Sign In</Button.Label></Button>
      </Link>
      <Link href="/(auth)/sign-up" asChild>
        <Button variant="ghost"><Button.Label>Sign Up</Button.Label></Button>
      </Link>
    </View>
  </Unauthenticated>
  <AuthLoading>
    <View className="mt-4 items-center">
      <Spinner size="sm" />
    </View>
  </AuthLoading>
  {{/if}}

  {{#if (and (eq backend "convex") (eq auth "better-auth"))}}
  {user ? (
  <Surface variant="secondary" className="mb-4 p-4 rounded-lg">
    <View className="flex-row items-center justify-between">
      <View className="flex-1">
        <Text className="text-foreground font-medium">{user.name}</Text>
        <Text className="text-muted text-xs mt-0.5">{user.email}</Text>
      </View>
      <Button
        variant="destructive"
        size="sm"
        onPress={() => {
          authClient.signOut();
        }}
      >
        Sign Out
      </Button>
    </View>
  </Surface>
  ) : null}
  <Surface variant="secondary" className="p-4 rounded-lg">
    <Text className="text-foreground font-medium mb-2">API Status</Text>
    <View className="flex-row items-center gap-2">
      <View className={\`w-2 h-2 rounded-full \${healthCheck==="OK" ? "bg-success" : "bg-danger" }\`} />
      <Text className="text-muted text-xs">
        {healthCheck === undefined
        ? "Checking..."
        : healthCheck === "OK"
        ? "Connected to API"
        : "API Disconnected"}
      </Text>
    </View>
  </Surface>
  {!user && (
  <View className="mt-4 gap-4">
    <SignIn />
    <SignUp />
  </View>
  )}
  {{/if}}
</Container>
);
}`],
  ["rust-base/crates/proto/src/generated/greeter.rs.hbs", `// This file is @generated by prost-build.
/// The request message containing the user's name.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HelloRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The response message containing the greeting.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HelloReply {
    #[prost(string, tag = "1")]
    pub message: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod greeter_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The greeting service definition.
    #[derive(Debug, Clone)]
    pub struct GreeterClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl GreeterClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> GreeterClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> GreeterClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            GreeterClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: \`4MB\`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: \`usize::MAX\`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Sends a greeting
        pub async fn say_hello(
            &mut self,
            request: impl tonic::IntoRequest<super::HelloRequest>,
        ) -> std::result::Result<tonic::Response<super::HelloReply>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/greeter.Greeter/SayHello");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("greeter.Greeter", "SayHello"));
            self.inner.unary(req, path, codec).await
        }
        /// Sends a streaming greeting
        pub async fn say_hello_stream(
            &mut self,
            request: impl tonic::IntoRequest<super::HelloRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::HelloReply>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/greeter.Greeter/SayHelloStream",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("greeter.Greeter", "SayHelloStream"));
            self.inner.server_streaming(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod greeter_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with GreeterServer.
    #[async_trait]
    pub trait Greeter: std::marker::Send + std::marker::Sync + 'static {
        /// Sends a greeting
        async fn say_hello(
            &self,
            request: tonic::Request<super::HelloRequest>,
        ) -> std::result::Result<tonic::Response<super::HelloReply>, tonic::Status>;
        /// Server streaming response type for the SayHelloStream method.
        type SayHelloStreamStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::HelloReply, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        /// Sends a streaming greeting
        async fn say_hello_stream(
            &self,
            request: tonic::Request<super::HelloRequest>,
        ) -> std::result::Result<tonic::Response<Self::SayHelloStreamStream>, tonic::Status>;
    }
    /// The greeting service definition.
    #[derive(Debug)]
    pub struct GreeterServer<T: Greeter> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T: Greeter> GreeterServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: \`4MB\`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: \`usize::MAX\`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for GreeterServer<T>
    where
        T: Greeter,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/greeter.Greeter/SayHello" => {
                    #[allow(non_camel_case_types)]
                    struct SayHelloSvc<T: Greeter>(pub Arc<T>);
                    impl<T: Greeter> tonic::server::UnaryService<super::HelloRequest>
                    for SayHelloSvc<T> {
                        type Response = super::HelloReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::HelloRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Greeter>::say_hello(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SayHelloSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/greeter.Greeter/SayHelloStream" => {
                    #[allow(non_camel_case_types)]
                    struct SayHelloStreamSvc<T: Greeter>(pub Arc<T>);
                    impl<
                        T: Greeter,
                    > tonic::server::ServerStreamingService<super::HelloRequest>
                    for SayHelloStreamSvc<T> {
                        type Response = super::HelloReply;
                        type ResponseStream = T::SayHelloStreamStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::HelloRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Greeter>::say_hello_stream(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SayHelloStreamSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T: Greeter> Clone for GreeterServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "greeter.Greeter";
    impl<T: Greeter> tonic::server::NamedService for GreeterServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
`],
  ["api/garph/server/src/routers/index.ts.hbs", `import { g, buildSchema, type InferResolvers, queryType, mutationType } from "../index";
import type { Context } from "../context";
{{#if (includes examples "todo")}}
import { todoResolvers } from "./todo";
{{/if}}

export function createResolvers(ctx: Context): InferResolvers<{ Query: typeof queryType; Mutation: typeof mutationType }, { context: Context }> {
{{#if (includes examples "todo")}}
  const todos = todoResolvers(ctx);
{{/if}}

  return {
    Query: {
      health: () => "OK",
{{#if (eq auth "better-auth")}}
      privateData: () => {
        if (!ctx.session) {
          return null;
        }
        return {
          message: "This is private data",
          user: ctx.session.user,
        };
      },
{{/if}}
{{#if (includes examples "todo")}}
      todos: todos.getAll,
      todo: todos.getOne,
{{/if}}
    },
    Mutation: {
{{#if (includes examples "todo")}}
      createTodo: todos.create,
      toggleTodo: todos.toggle,
      deleteTodo: todos.delete,
{{/if}}
      _empty: () => null,
    },
  };
}

export function createSchema(ctx: Context) {
  const resolvers = createResolvers(ctx);
  return buildSchema({ g, resolvers });
}
`],
  ["api/garph/server/src/routers/todo.ts.hbs", `{{#if (includes examples "todo")}}
import type { Context } from "../context";
import { db } from "@{{projectName}}/db";
import { todos } from "@{{projectName}}/db/schema";
import { eq } from "drizzle-orm";

export function todoResolvers(ctx: Context) {
  return {
    getAll: async () => {
      const allTodos = await db.select().from(todos).orderBy(todos.createdAt);
      return allTodos.map((t) => ({
        ...t,
        createdAt: t.createdAt.toISOString(),
      }));
    },
    getOne: async (_: unknown, args: { id: number }) => {
      const [todo] = await db.select().from(todos).where(eq(todos.id, args.id));
      if (!todo) return null;
      return {
        ...todo,
        createdAt: todo.createdAt.toISOString(),
      };
    },
    create: async (_: unknown, args: { content: string }) => {
      const [newTodo] = await db
        .insert(todos)
        .values({ content: args.content })
        .returning();
      return {
        ...newTodo,
        createdAt: newTodo.createdAt.toISOString(),
      };
    },
    toggle: async (_: unknown, args: { id: number }) => {
      const [existing] = await db
        .select()
        .from(todos)
        .where(eq(todos.id, args.id));
      if (!existing) return null;
      const [updated] = await db
        .update(todos)
        .set({ completed: !existing.completed })
        .where(eq(todos.id, args.id))
        .returning();
      return {
        ...updated,
        createdAt: updated.createdAt.toISOString(),
      };
    },
    delete: async (_: unknown, args: { id: number }) => {
      const [existing] = await db
        .select()
        .from(todos)
        .where(eq(todos.id, args.id));
      if (!existing) return false;
      await db.delete(todos).where(eq(todos.id, args.id));
      return true;
    },
  };
}
{{/if}}
`],
  ["api/ts-rest/server/src/routers/index.ts.hbs", `import { contract } from "../index";
import type { Context } from "../context";
{{#if (includes examples "todo")}}
import { todoHandlers } from "./todo";
{{/if}}

export function createRouter(ctx: Context) {
  return {
    healthCheck: async () => {
      return {
        status: 200 as const,
        body: "OK" as const,
      };
    },
{{#if (eq auth "better-auth")}}
    privateData: async () => {
      if (!ctx.session) {
        return {
          status: 401 as const,
          body: {
            message: "Authentication required",
          },
        };
      }
      return {
        status: 200 as const,
        body: {
          message: "This is private",
          user: ctx.session.user,
        },
      };
    },
{{/if}}
{{#if (includes examples "todo")}}
    todos: todoHandlers(ctx),
{{/if}}
  };
}

export type AppRouter = ReturnType<typeof createRouter>;
`],
  ["api/ts-rest/server/src/routers/todo.ts.hbs", `{{#if (includes examples "todo")}}
import type { Context } from "../context";
import { db } from "@{{projectName}}/db";
import { todos } from "@{{projectName}}/db/schema";
import { eq } from "drizzle-orm";

export function todoHandlers(ctx: Context) {
  return {
    getAll: async () => {
      const allTodos = await db.select().from(todos).orderBy(todos.createdAt);
      return {
        status: 200 as const,
        body: allTodos.map((t) => ({
          ...t,
          createdAt: t.createdAt.toISOString(),
        })),
      };
    },
    create: async ({ body }: { body: { content: string } }) => {
      const [newTodo] = await db
        .insert(todos)
        .values({ content: body.content })
        .returning();
      return {
        status: 201 as const,
        body: {
          ...newTodo,
          createdAt: newTodo.createdAt.toISOString(),
        },
      };
    },
    toggle: async ({ params }: { params: { id: number } }) => {
      const [existing] = await db
        .select()
        .from(todos)
        .where(eq(todos.id, params.id));
      if (!existing) {
        return {
          status: 404 as const,
          body: { message: "Todo not found" },
        };
      }
      const [updated] = await db
        .update(todos)
        .set({ completed: !existing.completed })
        .where(eq(todos.id, params.id))
        .returning();
      return {
        status: 200 as const,
        body: {
          ...updated,
          createdAt: updated.createdAt.toISOString(),
        },
      };
    },
    delete: async ({ params }: { params: { id: number } }) => {
      const [existing] = await db
        .select()
        .from(todos)
        .where(eq(todos.id, params.id));
      if (!existing) {
        return {
          status: 404 as const,
          body: { message: "Todo not found" },
        };
      }
      await db.delete(todos).where(eq(todos.id, params.id));
      return {
        status: 200 as const,
        body: { success: true },
      };
    },
  };
}
{{/if}}
`],
  ["frontend/react/tanstack-start/src/routes/__root.tsx.hbs", `import { Toaster } from "@/components/ui/sonner";
{{#unless (eq backend "convex")}} {{#unless (eq api "none")}}
import { ReactQueryDevtools } from "@tanstack/react-query-devtools";
{{/unless}} {{/unless}}
import {
  HeadContent,
  Outlet,
  Scripts,
  createRootRouteWithContext,
{{#if (and (eq backend "convex") (or (eq auth "clerk") (eq auth "better-auth")))}}
  useRouteContext,
{{/if}}
} from "@tanstack/react-router";
import { TanStackRouterDevtools } from "@tanstack/react-router-devtools";
import Header from "../components/header";
import appCss from "../index.css?url";
{{#if (eq backend "convex")}}
import type { QueryClient } from "@tanstack/react-query";
import type { ConvexQueryClient } from "@convex-dev/react-query";
{{else}}
{{#if (or (eq api "trpc") (eq api "orpc"))}}
import type { QueryClient } from "@tanstack/react-query";
{{/if}}
{{/if}}

{{#if (and (eq backend "convex") (eq auth "clerk"))}}
import { ClerkProvider, useAuth } from "@clerk/tanstack-react-start";
import { auth } from "@clerk/tanstack-react-start/server";
import { createServerFn } from "@tanstack/react-start";
import { ConvexProviderWithClerk } from "convex/react-clerk";

const fetchClerkAuth = createServerFn({ method: "GET" }).handler(async () => {
  const clerkAuth = await auth();
  const token = await clerkAuth.getToken({ template: "convex" });
  return { userId: clerkAuth.userId, token };
});
{{else if (and (eq backend "convex") (eq auth "better-auth"))}}
import { createServerFn } from "@tanstack/react-start";
import { ConvexBetterAuthProvider } from "@convex-dev/better-auth/react";
import { authClient } from "@/lib/auth-client";
import { getToken } from "@/lib/auth-server";

const getAuth = createServerFn({ method: "GET" }).handler(async () => {
  return await getToken();
});
{{else if (eq backend "convex")}}
import { ConvexProvider } from "convex/react";
{{/if}}

{{#if (eq backend "convex")}}
export interface RouterAppContext {
  queryClient: QueryClient;
  convexQueryClient: ConvexQueryClient;
}
{{else}}
  {{#if (eq api "trpc")}}
import type { TRPCOptionsProxy } from "@trpc/tanstack-react-query";
import type { AppRouter } from "@{{projectName}}/api/routers/index";
export interface RouterAppContext {
  trpc: TRPCOptionsProxy<AppRouter>;
  queryClient: QueryClient;
}
  {{else if (eq api "orpc")}}
import type { orpc } from "@/utils/orpc";
export interface RouterAppContext {
  orpc: typeof orpc;
  queryClient: QueryClient;
}
  {{else}}
export interface RouterAppContext {
}
  {{/if}}
{{/if}}

export const Route = createRootRouteWithContext<RouterAppContext>()({
  head: () => ({
    meta: [
      {
        charSet: "utf-8",
      },
      {
        name: "viewport",
        content: "width=device-width, initial-scale=1",
      },
      {
        title: "My App",
      },
    ],
    links: [
      {
        rel: "stylesheet",
        href: appCss,
      },
    ],
  }),

  component: RootDocument,
  {{#if (and (eq backend "convex") (eq auth "clerk"))}}
  beforeLoad: async (ctx) => {
    const { userId, token } = await fetchClerkAuth();
    if (token) {
      ctx.context.convexQueryClient.serverHttpClient?.setAuth(token);
    }
    return { userId, token };
  },
  {{else if (and (eq backend "convex") (eq auth "better-auth"))}}
  beforeLoad: async (ctx) => {
    const token = await getAuth();
    if (token) {
      ctx.context.convexQueryClient.serverHttpClient?.setAuth(token);
    }
    return {
      isAuthenticated: !!token,
      token,
    };
  },
  {{/if}}
});

function RootDocument() {
  {{#if (and (eq backend "convex") (eq auth "clerk"))}}
  const context = useRouteContext({ from: Route.id });
  return (
    <ClerkProvider>
      <ConvexProviderWithClerk client={context.convexQueryClient.convexClient} useAuth={useAuth}>
        <html lang="en" className="dark">
          <head>
            <HeadContent />
          </head>
          <body>
            <div className="grid h-svh grid-rows-[auto_1fr]">
              <Header />
              <Outlet />
            </div>
            <Toaster richColors />
            <TanStackRouterDevtools position="bottom-left" />
            <Scripts />
          </body>
        </html>
      </ConvexProviderWithClerk>
    </ClerkProvider>
  );
  {{else if (and (eq backend "convex") (eq auth "better-auth"))}}
  const context = useRouteContext({ from: Route.id });
  return (
    <ConvexBetterAuthProvider
      client={context.convexQueryClient.convexClient}
      authClient={authClient}
      initialToken={context.token}
    >
      <html lang="en" className="dark">
        <head>
          <HeadContent />
        </head>
        <body>
          <div className="grid h-svh grid-rows-[auto_1fr]">
            <Header />
            <Outlet />
          </div>
          <Toaster richColors />
          <TanStackRouterDevtools position="bottom-left" />
          <Scripts />
        </body>
      </html>
    </ConvexBetterAuthProvider>
  );
  {{else if (eq backend "convex")}}
  const { convexQueryClient } = Route.useRouteContext();
  return (
    <ConvexProvider client={convexQueryClient.convexClient}>
      <html lang="en" className="dark">
        <head>
          <HeadContent />
        </head>
        <body>
          <div className="grid h-svh grid-rows-[auto_1fr]">
            <Header />
            <Outlet />
          </div>
          <Toaster richColors />
          <TanStackRouterDevtools position="bottom-left" />
          <Scripts />
        </body>
      </html>
    </ConvexProvider>
  );
  {{else}}
  return (
    <html lang="en" className="dark">
      <head>
        <HeadContent />
      </head>
      <body>
        <div className="grid h-svh grid-rows-[auto_1fr]">
          <Header />
          <Outlet />
        </div>
        <Toaster richColors />
        <TanStackRouterDevtools position="bottom-left" />
        {{#unless (eq api "none")}}
        <ReactQueryDevtools position="bottom" buttonPosition="bottom-right" />
        {{/unless}}
        <Scripts />
      </body>
    </html>
  );
  {{/if}}
}
`],
  ["frontend/react/tanstack-start/src/routes/index.tsx.hbs", `import { createFileRoute } from "@tanstack/react-router";
{{#if (eq backend "convex")}}
import { convexQuery } from "@convex-dev/react-query";
import { useQuery } from "@tanstack/react-query";
import { api } from "@{{projectName}}/backend/convex/_generated/api";
{{else if (or (eq api "trpc") (eq api "orpc"))}}
import { useQuery } from "@tanstack/react-query";
  {{#if (eq api "trpc")}}
import { useTRPC } from "@/utils/trpc";
  {{/if}}
  {{#if (eq api "orpc")}}
import { orpc } from "@/utils/orpc";
  {{/if}}
{{/if}}

export const Route = createFileRoute("/")({
  component: HomeComponent,
});

const TITLE_TEXT = \`
  
 
                 
                 
               
                

          
      
                      
                      
                     
                      
 \`;

function HomeComponent() {
  {{#if (eq backend "convex")}}
  const healthCheck = useQuery(convexQuery(api.healthCheck.get, {}));
  {{else if (eq api "trpc")}}
  const trpc = useTRPC();
  const healthCheck = useQuery(trpc.healthCheck.queryOptions());
  {{else if (eq api "orpc")}}
  const healthCheck = useQuery(orpc.healthCheck.queryOptions());
  {{/if}}

  return (
    <div className="container mx-auto max-w-3xl px-4 py-2">
      <pre className="overflow-x-auto font-mono text-sm">{TITLE_TEXT}</pre>
      <div className="grid gap-6">
        <section className="rounded-lg border p-4">
          <h2 className="mb-2 font-medium">API Status</h2>
          {{#if (eq backend "convex")}}
          <div className="flex items-center gap-2">
            <div
              className={\`h-2 w-2 rounded-full \${healthCheck.data === "OK" ? "bg-green-500" : healthCheck.isLoading ? "bg-orange-400" : "bg-red-500"}\`}
            />
            <span className="text-muted-foreground text-sm">
              {healthCheck.isLoading
                ? "Checking..."
                : healthCheck.data === "OK"
                  ? "Connected"
                  : "Error"}
            </span>
          </div>
          {{else}}
            {{#unless (eq api "none")}}
            <div className="flex items-center gap-2">
              <div
                className={\`h-2 w-2 rounded-full \${healthCheck.data ? "bg-green-500" : "bg-red-500"}\`}
              />
              <span className="text-muted-foreground text-sm">
                {healthCheck.isLoading
                  ? "Checking..."
                  : healthCheck.data
                    ? "Connected"
                    : "Disconnected"}
              </span>
            </div>
            {{/unless}}
          {{/if}}
        </section>
      </div>
    </div>
  );
}
`],
  ["frontend/react/web-base/src/components/loader.tsx.hbs", `import { Loader2 } from "lucide-react";

export default function Loader() {
  return (
    <div className="flex h-full items-center justify-center pt-8">
      <Loader2 className="animate-spin" />
    </div>
  );
}
`],
  ["frontend/react/web-base/src/components/header.tsx.hbs", `{{#if (includes frontend "next")}}
"use client";
import Link from "next/link";
{{else if (includes frontend "react-router")}}
import { NavLink } from "react-router";
{{else if (or (includes frontend "tanstack-router") (includes frontend "tanstack-start"))}}
import { Link } from "@tanstack/react-router";
{{/if}}
{{#unless (includes frontend "tanstack-start")}}
import { ModeToggle } from "./mode-toggle";
{{/unless}}
{{#if (and (eq auth "better-auth") (ne backend "convex"))}}
import UserMenu from "./user-menu";
{{/if}}

export default function Header() {
  const links = [
    { to: "/", label: "Home" },
    {{#if (or (eq auth "better-auth") (eq auth "clerk"))}}
      { to: "/dashboard", label: "Dashboard" },
    {{/if}}
    {{#if (includes examples "todo")}}
    { to: "/todos", label: "Todos" },
    {{/if}}
    {{#if (includes examples "ai")}}
    { to: "/ai", label: "AI Chat" },
    {{/if}}
  ] as const;

  return (
    <div>
      <div className="flex flex-row items-center justify-between px-2 py-1">
        <nav className="flex gap-4 text-lg">
          {links.map(({ to, label }) => {
            {{#if (includes frontend "next")}}
            return (
              <Link key={to} href={to}>
                {label}
              </Link>
            );
            {{else if (includes frontend "react-router")}}
            return (
              <NavLink
                key={to}
                to={to}
                className={({ isActive }) => isActive ? "font-bold" : ""}
                end
              >
                {label}
              </NavLink>
            );
            {{else if (or (includes frontend "tanstack-router") (includes frontend "tanstack-start"))}}
            return (
              <Link
                key={to}
                to={to}
              >
                {label}
              </Link>
            );
            {{else}}
            return null;
            {{/if}}
          })}
        </nav>
        <div className="flex items-center gap-2">
          {{#unless (includes frontend "tanstack-start")}}
          <ModeToggle />
          {{/unless}}
          {{#if (and (eq auth "better-auth") (ne backend "convex"))}}
          <UserMenu />
          {{/if}}
        </div>
      </div>
      <hr />
    </div>
  );
}
`],
  ["frontend/react/react-router/src/routes/_index.tsx.hbs", `import type { Route } from "./+types/_index";
{{#if (eq backend "convex")}}
import { useQuery } from "convex/react";
import { api } from "@{{projectName}}/backend/convex/_generated/api";
{{else if (or (eq api "orpc") (eq api "trpc"))}}
import { useQuery } from "@tanstack/react-query";
  {{#if (eq api "orpc")}}
  import { orpc } from "@/utils/orpc";
  {{/if}}
  {{#if (eq api "trpc")}}
  import { trpc } from "@/utils/trpc";
  {{/if}}
{{/if}}

const TITLE_TEXT = \`
  
 
                 
                 
               
                

          
      
                      
                      
                     
                      
 \`;

export function meta({}: Route.MetaArgs) {
  return [{ title: "{{projectName}}" }, { name: "description", content: "{{projectName}} is a web application" }];
}

export default function Home() {
  {{#if (eq backend "convex")}}
  const healthCheck = useQuery(api.healthCheck.get);
  {{else if (eq api "orpc")}}
  const healthCheck = useQuery(orpc.healthCheck.queryOptions());
  {{else if (eq api "trpc")}}
  const healthCheck = useQuery(trpc.healthCheck.queryOptions());
  {{/if}}

  return (
    <div className="container mx-auto max-w-3xl px-4 py-2">
      <pre className="overflow-x-auto font-mono text-sm">{TITLE_TEXT}</pre>
      <div className="grid gap-6">
        <section className="rounded-lg border p-4">
          <h2 className="mb-2 font-medium">API Status</h2>
          {{#if (eq backend "convex")}}
          <div className="flex items-center gap-2">
            <div
              className={\`h-2 w-2 rounded-full \${healthCheck === "OK" ? "bg-green-500" : healthCheck === undefined ? "bg-orange-400" : "bg-red-500"}\`}
            />
            <span className="text-sm text-muted-foreground">
              {healthCheck === undefined
                ? "Checking..."
                : healthCheck === "OK"
                  ? "Connected"
                  : "Error"}
            </span>
          </div>
          {{else}}
            {{#unless (eq api "none")}}
            <div className="flex items-center gap-2">
              <div
                className={\`h-2 w-2 rounded-full \${
                  healthCheck.data ? "bg-green-500" : "bg-red-500"
                }\`}
              />
              <span className="text-sm text-muted-foreground">
                {healthCheck.isLoading
                  ? "Checking..."
                  : healthCheck.data
                  ? "Connected"
                  : "Disconnected"}
              </span>
            </div>
            {{/unless}}
          {{/if}}
        </section>
      </div>
    </div>
  );
}
`],
  ["frontend/react/react-router/src/components/theme-provider.tsx.hbs", `import * as React from "react";
import { ThemeProvider as NextThemesProvider } from "next-themes";

export function ThemeProvider({
  children,
  ...props
}: React.ComponentProps<typeof NextThemesProvider>) {
  return <NextThemesProvider {...props}>{children}</NextThemesProvider>;
}

export { useTheme } from "next-themes";
`],
  ["frontend/react/react-router/src/components/mode-toggle.tsx.hbs", `import { Moon, Sun } from "lucide-react";

import { Button } from "@/components/ui/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { useTheme } from "@/components/theme-provider";

export function ModeToggle() {
  const { setTheme } = useTheme();

  return (
    <DropdownMenu>
      <DropdownMenuTrigger render={<Button variant="outline" size="icon" />}>
        <Sun className="h-[1.2rem] w-[1.2rem] scale-100 rotate-0 transition-all dark:scale-0 dark:-rotate-90" />
        <Moon className="absolute h-[1.2rem] w-[1.2rem] scale-0 rotate-90 transition-all dark:scale-100 dark:rotate-0" />
        <span className="sr-only">Toggle theme</span>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end">
        <DropdownMenuItem onClick={() => setTheme("light")}>Light</DropdownMenuItem>
        <DropdownMenuItem onClick={() => setTheme("dark")}>Dark</DropdownMenuItem>
        <DropdownMenuItem onClick={() => setTheme("system")}>System</DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}
`],
  ["frontend/react/web-base/src/lib/utils.ts.hbs", `import { clsx, type ClassValue } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}
`],
  ["frontend/react/next/src/app/favicon.ico", `[Binary file]`],
  ["frontend/react/next/src/app/page.tsx.hbs", `"use client"
{{#if (eq backend "convex")}}
import { useQuery } from "convex/react";
import { api } from "@{{projectName}}/backend/convex/_generated/api";
{{else if (or (eq api "orpc") (eq api "trpc"))}}
import { useQuery } from "@tanstack/react-query";
  {{#if (eq api "orpc")}}
import { orpc } from "@/utils/orpc";
  {{/if}}
  {{#if (eq api "trpc")}}
import { trpc } from "@/utils/trpc";
  {{/if}}
{{/if}}

const TITLE_TEXT = \`
  
 
                 
                 
               
                

          
      
                      
                      
                     
                      
 \`;

export default function Home() {
  {{#if (eq backend "convex")}}
  const healthCheck = useQuery(api.healthCheck.get);
  {{else if (eq api "orpc")}}
  const healthCheck = useQuery(orpc.healthCheck.queryOptions());
  {{else if (eq api "trpc")}}
  const healthCheck = useQuery(trpc.healthCheck.queryOptions());
  {{/if}}

  return (
    <div className="container mx-auto max-w-3xl px-4 py-2">
      <pre className="overflow-x-auto font-mono text-sm">{TITLE_TEXT}</pre>
      <div className="grid gap-6">
        <section className="rounded-lg border p-4">
          <h2 className="mb-2 font-medium">API Status</h2>
          {{#if (eq backend "convex")}}
          <div className="flex items-center gap-2">
            <div
              className={\`h-2 w-2 rounded-full \${healthCheck === "OK" ? "bg-green-500" : healthCheck === undefined ? "bg-orange-400" : "bg-red-500"}\`}
            />
            <span className="text-sm text-muted-foreground">
              {healthCheck === undefined
                ? "Checking..."
                : healthCheck === "OK"
                  ? "Connected"
                  : "Error"}
            </span>
          </div>
          {{else}}
            {{#unless (eq api "none")}}
            <div className="flex items-center gap-2">
              <div
                className={\`h-2 w-2 rounded-full \${healthCheck.data ? "bg-green-500" : "bg-red-500"}\`}
              />
              <span className="text-sm text-muted-foreground">
                {healthCheck.isLoading
                  ? "Checking..."
                  : healthCheck.data
                    ? "Connected"
                    : "Disconnected"}
              </span>
            </div>
            {{/unless}}
          {{/if}}
        </section>
      </div>
    </div>
  );
}
`],
  ["frontend/react/next/src/app/layout.tsx.hbs", `import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "../index.css";
{{#if (eq auth "clerk")}}{{#if (eq backend "convex")}}import { ClerkProvider } from "@clerk/nextjs";
{{/if}}{{/if}}{{#if (and (eq backend "convex") (eq auth "better-auth"))}}
import { getToken } from "@/lib/auth-server";
{{/if}}
import Providers from "@/components/providers";
import Header from "@/components/header";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "{{projectName}}",
  description: "{{projectName}}",
};

{{#if (and (eq backend "convex") (eq auth "better-auth"))}}
export default async function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  const token = await getToken();
  return (
    <html lang="en" suppressHydrationWarning>
      <body
        className={\`\${geistSans.variable} \${geistMono.variable} antialiased\`}
      >
        <Providers initialToken={token}>
          <div className="grid grid-rows-[auto_1fr] h-svh">
            <Header />
            {children}
          </div>
        </Providers>
      </body>
    </html>
  );
}
{{else}}
export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  	return (
		<html lang="en" suppressHydrationWarning>
			<body
				className={\`\${geistSans.variable} \${geistMono.variable} antialiased\`}
			>
				{{#if (and (eq auth "clerk") (eq backend "convex"))}}<ClerkProvider>
					<Providers>
						<div className="grid grid-rows-[auto_1fr] h-svh">
							<Header />
							{children}
						</div>
					</Providers>
				</ClerkProvider>{{else}}<Providers>
					<div className="grid grid-rows-[auto_1fr] h-svh">
						<Header />
						{children}
					</div>
				</Providers>{{/if}}
			</body>
		</html>
	);
}
{{/if}}
`],
  ["frontend/react/next/src/components/theme-provider.tsx.hbs", `"use client"

import * as React from "react"
import { ThemeProvider as NextThemesProvider } from "next-themes"

export function ThemeProvider({
  children,
  ...props
}: React.ComponentProps<typeof NextThemesProvider>) {
  return <NextThemesProvider {...props}>{children}</NextThemesProvider>
}
`],
  ["frontend/react/next/src/components/mode-toggle.tsx.hbs", `"use client"

import * as React from "react"
import { Moon, Sun } from "lucide-react"
import { useTheme } from "next-themes"
import { Button } from "@/components/ui/button"
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu"

export function ModeToggle() {
  const { setTheme } = useTheme()

  return (
    <DropdownMenu>
      <DropdownMenuTrigger render={<Button variant="outline" size="icon" />}>
        <Sun className="h-[1.2rem] w-[1.2rem] rotate-0 scale-100 transition-all dark:-rotate-90 dark:scale-0" />
        <Moon className="absolute h-[1.2rem] w-[1.2rem] rotate-90 scale-0 transition-all dark:rotate-0 dark:scale-100" />
        <span className="sr-only">Toggle theme</span>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end">
        <DropdownMenuItem onClick={() => setTheme("light")}>
          Light
        </DropdownMenuItem>
        <DropdownMenuItem onClick={() => setTheme("dark")}>
          Dark
        </DropdownMenuItem>
        <DropdownMenuItem onClick={() => setTheme("system")}>
          System
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  )
}
`],
  ["frontend/react/next/src/components/providers.tsx.hbs", `"use client";

{{#if (eq backend "convex")}}
{{#if (eq auth "clerk")}}
import { useAuth } from "@clerk/nextjs";
import { ConvexReactClient } from "convex/react";
import { ConvexProviderWithClerk } from "convex/react-clerk";
import { env } from "@{{projectName}}/env/web";
{{else if (eq auth "better-auth")}}
import { ConvexReactClient } from "convex/react";
import { ConvexBetterAuthProvider } from "@convex-dev/better-auth/react";
import { authClient } from "@/lib/auth-client";
import { env } from "@{{projectName}}/env/web";
{{else}}
import { ConvexProvider, ConvexReactClient } from "convex/react";
import { env } from "@{{projectName}}/env/web";
{{/if}}
{{else}}
{{#unless (eq api "none")}}
import { QueryClientProvider } from "@tanstack/react-query";
import { ReactQueryDevtools } from "@tanstack/react-query-devtools";
{{#if (eq api "orpc")}}
import { queryClient } from "@/utils/orpc";
{{/if}}
{{#if (eq api "trpc")}}
import { queryClient } from "@/utils/trpc";
{{/if}}
{{/unless}}
{{/if}}
import { ThemeProvider } from "./theme-provider";
import { Toaster } from "./ui/sonner";

{{#if (eq backend "convex")}}
const convex = new ConvexReactClient(env.NEXT_PUBLIC_CONVEX_URL);
{{/if}}

export default function Providers({
  children,
{{#if (and (eq backend "convex") (eq auth "better-auth"))}}
  initialToken,
{{/if}}
}: {
  children: React.ReactNode;
{{#if (and (eq backend "convex") (eq auth "better-auth"))}}
  initialToken?: string | null;
{{/if}}
}) {
  return (
    <ThemeProvider
      attribute="class"
      defaultTheme="system"
      enableSystem
      disableTransitionOnChange
    >
      {{#if (eq backend "convex")}}
      {{#if (eq auth "clerk")}}
      <ConvexProviderWithClerk client={convex} useAuth={useAuth}>
        {children}
      </ConvexProviderWithClerk>
      {{else if (eq auth "better-auth")}}
      <ConvexBetterAuthProvider
        client={convex}
        authClient={authClient}
        initialToken={initialToken}
      >
        {children}
      </ConvexBetterAuthProvider>
      {{else}}
      <ConvexProvider client={convex}>{children}</ConvexProvider>
      {{/if}}
      {{else}}
      {{#unless (eq api "none")}}
      <QueryClientProvider client={queryClient}>
        {{#if (eq api "orpc")}}
        {children}
        {{/if}}
        {{#if (eq api "trpc")}}
        {children}
        {{/if}}
        <ReactQueryDevtools />
      </QueryClientProvider>
      {{else}}
      {children}
      {{/unless}}
      {{/if}}
      <Toaster richColors />
    </ThemeProvider>
  );
}
`],
  ["frontend/react/tanstack-router/src/routes/__root.tsx.hbs", `import Header from "@/components/header";
import { ThemeProvider } from "@/components/theme-provider";
import { Toaster } from "@/components/ui/sonner";
{{#if (eq api "orpc")}}
import { link, orpc } from "@/utils/orpc";
import type { QueryClient } from "@tanstack/react-query";
import { ReactQueryDevtools } from "@tanstack/react-query-devtools";
import { useState } from "react";
import { createTanstackQueryUtils } from "@orpc/tanstack-query";
import type { AppRouterClient } from "@{{projectName}}/api/routers/index";
import { createORPCClient } from "@orpc/client";
{{/if}}
{{#if (eq api "trpc")}}
import type { trpc } from "@/utils/trpc";
import type { QueryClient } from "@tanstack/react-query";
import { ReactQueryDevtools } from "@tanstack/react-query-devtools";
{{/if}}
import {
  HeadContent,
  Outlet,
  createRootRouteWithContext,
} from "@tanstack/react-router";
import { TanStackRouterDevtools } from "@tanstack/react-router-devtools";
import "../index.css";

{{#if (eq api "orpc")}}
export interface RouterAppContext {
  orpc: typeof orpc;
  queryClient: QueryClient;
}
{{else if (eq api "trpc")}}
export interface RouterAppContext {
  trpc: typeof trpc;
  queryClient: QueryClient;
}
{{else}}
export interface RouterAppContext {}
{{/if}}

export const Route = createRootRouteWithContext<RouterAppContext>()({
  component: RootComponent,
  head: () => ({
    meta: [
      {
        title: "{{projectName}}",
      },
      {
        name: "description",
        content: "{{projectName}} is a web application",
      },
    ],
    links: [
      {
        rel: "icon",
        href: "/favicon.ico",
      },
    ],
  }),
});

function RootComponent() {
  {{#if (eq api "orpc")}}
  const [client] = useState<AppRouterClient>(() => createORPCClient(link));
  const [orpcUtils] = useState(() => createTanstackQueryUtils(client));
  {{/if}}

  return (
    <>
      <HeadContent />
      {{#if (eq api "orpc")}}
        <ThemeProvider
          attribute="class"
          defaultTheme="dark"
          disableTransitionOnChange
          storageKey="vite-ui-theme"
        >
          <div className="grid grid-rows-[auto_1fr] h-svh">
            <Header />
            <Outlet />
          </div>
          <Toaster richColors />
        </ThemeProvider>
      {{else}}
      <ThemeProvider
        attribute="class"
        defaultTheme="dark"
        disableTransitionOnChange
        storageKey="vite-ui-theme"
      >
        <div className="grid grid-rows-[auto_1fr] h-svh">
          <Header />
          <Outlet />
        </div>
        <Toaster richColors />
      </ThemeProvider>
      {{/if}}
      <TanStackRouterDevtools position="bottom-left" />
      {{#if (or (eq api "orpc") (eq api "trpc"))}}
      <ReactQueryDevtools position="bottom" buttonPosition="bottom-right" />
      {{/if}}
    </>
  );
}
`],
  ["frontend/react/tanstack-router/src/routes/index.tsx.hbs", `import { createFileRoute } from "@tanstack/react-router";
{{#if (eq api "orpc")}}
import { orpc } from "@/utils/orpc";
import { useQuery } from "@tanstack/react-query";
{{/if}}
{{#if (eq api "trpc")}}
import { trpc } from "@/utils/trpc";
import { useQuery } from "@tanstack/react-query";
{{/if}}
{{#if (eq backend "convex")}}
import { useQuery } from "convex/react";
import { api } from "@{{ projectName }}/backend/convex/_generated/api";
{{/if}}

export const Route = createFileRoute("/")({
  component: HomeComponent,
});

const TITLE_TEXT = \`
  
 
                 
                 
               
                

          
      
                      
                      
                     
                      
 \`;

function HomeComponent() {
  {{#if (eq api "orpc")}}
  const healthCheck = useQuery(orpc.healthCheck.queryOptions());
  {{/if}}
  {{#if (eq api "trpc")}}
  const healthCheck = useQuery(trpc.healthCheck.queryOptions());
  {{/if}}
  {{#if (eq backend "convex")}}
  const healthCheck = useQuery(api.healthCheck.get);
  {{/if}}

  return (
    <div className="container mx-auto max-w-3xl px-4 py-2">
      <pre className="overflow-x-auto font-mono text-sm">{TITLE_TEXT}</pre>
      <div className="grid gap-6">
        <section className="rounded-lg border p-4">
          <h2 className="mb-2 font-medium">API Status</h2>
          {{#if (eq backend "convex")}}
          <div className="flex items-center gap-2">
            <div
              className={\`h-2 w-2 rounded-full \${healthCheck === "OK" ? "bg-green-500" : healthCheck === undefined ? "bg-orange-400" : "bg-red-500"}\`}
            />
            <span className="text-sm text-muted-foreground">
              {healthCheck === undefined
                ? "Checking..."
                : healthCheck === "OK"
                  ? "Connected"
                  : "Error"}
            </span>
          </div>
          {{else}}
            {{#unless (eq api "none")}}
            <div className="flex items-center gap-2">
              <div
                className={\`h-2 w-2 rounded-full \${healthCheck.data ? "bg-green-500" : "bg-red-500"}\`}
              />
              <span className="text-sm text-muted-foreground">
                {healthCheck.isLoading
                  ? "Checking..."
                  : healthCheck.data
                    ? "Connected"
                    : "Disconnected"}
              </span>
            </div>
            {{/unless}}
          {{/if}}
        </section>
      </div>
    </div>
  );
}
`],
  ["frontend/react/tanstack-router/src/components/theme-provider.tsx.hbs", `import * as React from "react";
import { ThemeProvider as NextThemesProvider } from "next-themes";

export function ThemeProvider({
  children,
  ...props
}: React.ComponentProps<typeof NextThemesProvider>) {
  return <NextThemesProvider {...props}>{children}</NextThemesProvider>;
}

export { useTheme } from "next-themes";
`],
  ["frontend/react/tanstack-router/src/components/mode-toggle.tsx.hbs", `import { Moon, Sun } from "lucide-react";

import { Button } from "@/components/ui/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { useTheme } from "@/components/theme-provider";

export function ModeToggle() {
  const { setTheme } = useTheme();

  return (
    <DropdownMenu>
      <DropdownMenuTrigger render={<Button variant="outline" size="icon" />}>
        <Sun className="h-[1.2rem] w-[1.2rem] scale-100 rotate-0 transition-all dark:scale-0 dark:-rotate-90" />
        <Moon className="absolute h-[1.2rem] w-[1.2rem] scale-0 rotate-90 transition-all dark:scale-100 dark:rotate-0" />
        <span className="sr-only">Toggle theme</span>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end">
        <DropdownMenuItem onClick={() => setTheme("light")}>Light</DropdownMenuItem>
        <DropdownMenuItem onClick={() => setTheme("dark")}>Dark</DropdownMenuItem>
        <DropdownMenuItem onClick={() => setTheme("system")}>System</DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}
`],
  ["api/orpc/server/src/routers/index.ts.hbs", `{{#if (eq api "orpc")}}
import { {{#if (eq auth "better-auth")}}protectedProcedure, {{/if}}publicProcedure } from "../index";
import type { RouterClient } from "@orpc/server";
{{#if (includes examples "todo")}}
import { todoRouter } from "./todo";
{{/if}}

export const appRouter = {
  healthCheck: publicProcedure.handler(() => {
    return "OK";
  }),
  {{#if (eq auth "better-auth")}}
  privateData: protectedProcedure.handler(({ context }) => {
    return {
      message: "This is private",
      user: context.session?.user,
    };
  }),
  {{/if}}
  {{#if (includes examples "todo")}}
  todo: todoRouter,
  {{/if}}
};
export type AppRouter = typeof appRouter;
export type AppRouterClient = RouterClient<typeof appRouter>;
{{else if (eq api "trpc")}}
import {
  {{#if (eq auth "better-auth")}}protectedProcedure, {{/if}}publicProcedure,
  router,
} from "../index";
{{#if (includes examples "todo")}}
import { todoRouter } from "./todo";
{{/if}}

export const appRouter = router({
  healthCheck: publicProcedure.query(() => {
    return "OK";
  }),
  {{#if (eq auth "better-auth")}}
  privateData: protectedProcedure.query(({ ctx }) => {
    return {
      message: "This is private",
      user: ctx.session.user,
    };
  }),
  {{/if}}
  {{#if (includes examples "todo")}}
  todo: todoRouter,
  {{/if}}
});
export type AppRouter = typeof appRouter;
{{else}}
export const appRouter = {};
export type AppRouter = typeof appRouter;
{{/if}}
`],
  ["api/trpc/server/src/routers/index.ts.hbs", `{{#if (eq api "orpc")}}
import { {{#if (eq auth "better-auth")}}protectedProcedure, {{/if}}publicProcedure } from "../index";
import type { RouterClient } from "@orpc/server";
{{#if (includes examples "todo")}}
import { todoRouter } from "./todo";
{{/if}}

export const appRouter = {
  healthCheck: publicProcedure.handler(() => {
    return "OK";
  }),
  {{#if (eq auth "better-auth")}}
  privateData: protectedProcedure.handler(({ context }) => {
    return {
      message: "This is private",
      user: context.session?.user,
    };
  }),
  {{/if}}
  {{#if (includes examples "todo")}}
  todo: todoRouter,
  {{/if}}
};
export type AppRouter = typeof appRouter;
export type AppRouterClient = RouterClient<typeof appRouter>;
{{else if (eq api "trpc")}}
import {
  {{#if (eq auth "better-auth")}}protectedProcedure, {{/if}}publicProcedure,
  router,
} from "../index";
{{#if (includes examples "todo")}}
import { todoRouter } from "./todo";
{{/if}}

export const appRouter = router({
  healthCheck: publicProcedure.query(() => {
    return "OK";
  }),
  {{#if (eq auth "better-auth")}}
  privateData: protectedProcedure.query(({ ctx }) => {
    return {
      message: "This is private",
      user: ctx.session.user,
    };
  }),
  {{/if}}
  {{#if (includes examples "todo")}}
  todo: todoRouter,
  {{/if}}
});
export type AppRouter = typeof appRouter;
{{else}}
export const appRouter = {};
export type AppRouter = typeof appRouter;
{{/if}}
`],
  ["cms/payload/web/next/src/payload.config.ts.hbs", `import { buildConfig } from "payload";
import { lexicalEditor } from "@payloadcms/richtext-lexical";
{{#if (eq database "postgres")}}
import { postgresAdapter } from "@payloadcms/db-postgres";
{{else if (eq database "mongodb")}}
import { mongooseAdapter } from "@payloadcms/db-mongodb";
{{else}}
import { sqliteAdapter } from "@payloadcms/db-sqlite";
{{/if}}

import { Users } from "./payload/collections/Users";
import { Media } from "./payload/collections/Media";
import { Pages } from "./payload/collections/Pages";

export default buildConfig({
  // Rich text editor
  editor: lexicalEditor(),

  // Collections
  collections: [Users, Media, Pages],

  // Secret for encryption (should be a complex and secure string)
  secret: process.env.PAYLOAD_SECRET || "",

  // Database adapter
{{#if (eq database "postgres")}}
  db: postgresAdapter({
    pool: {
      connectionString: process.env.DATABASE_URL || "",
    },
  }),
{{else if (eq database "mongodb")}}
  db: mongooseAdapter({
    url: process.env.DATABASE_URL || "",
  }),
{{else}}
  db: sqliteAdapter({
    client: {
      url: process.env.DATABASE_URL || "file:./payload.db",
    },
  }),
{{/if}}

  // Admin panel configuration
  admin: {
    // Customize admin panel
    meta: {
      titleSuffix: "- {{projectName}}",
    },
  },

  // TypeScript configuration
  typescript: {
    outputFile: "./src/payload-types.ts",
  },
});
`],
  ["backend/convex/packages/backend/convex/convex.config.ts.hbs", `import { defineApp } from "convex/server";
{{#if (eq auth "better-auth")}}
import betterAuth from "@convex-dev/better-auth/convex.config";
{{/if}}
{{#if (includes examples "ai")}}
import agent from "@convex-dev/agent/convex.config";
{{/if}}

const app = defineApp();
{{#if (eq auth "better-auth")}}
app.use(betterAuth);
{{/if}}
{{#if (includes examples "ai")}}
app.use(agent);
{{/if}}

export default app;
`],
  ["backend/convex/packages/backend/convex/schema.ts.hbs", `import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";

export default defineSchema({
{{#if (includes examples "todo")}}
  todos: defineTable({
    text: v.string(),
    completed: v.boolean(),
  }),
{{/if}}
});
`],
  ["backend/convex/packages/backend/convex/healthCheck.ts.hbs", `import { query } from "./_generated/server";

export const get = query({
  handler: async () => {
    return "OK";
  },
});
`],
  ["backend/convex/packages/backend/convex/tsconfig.json.hbs", `{
  /* This TypeScript project config describes the environment that
   * Convex functions run in and is used to typecheck them.
   * You can modify it, but some settings are required to use Convex.
   */
  "compilerOptions": {
    /* These settings are not required by Convex and can be modified. */
    "allowJs": true,
    "strict": true,
    "moduleResolution": "Bundler",
    "jsx": "react-jsx",
    "skipLibCheck": true,
    "allowSyntheticDefaultImports": true,

    /* These compiler options are required by Convex */
    "target": "ESNext",
    "lib": ["ES2021", "dom"],
    "forceConsistentCasingInFileNames": true,
    "module": "ESNext",
    "isolatedModules": true,
    "noEmit": true
  },
  "include": ["./**/*"],
  "exclude": ["./_generated"]
}
`],
  ["backend/convex/packages/backend/convex/README.md", `# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

\`\`\`ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
\`\`\`

Using this query function in a React component looks like:

\`\`\`ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
\`\`\`

A mutation function looks like:

\`\`\`ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
\`\`\`

Using this mutation function in a React component looks like:

\`\`\`ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
\`\`\`

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running \`npx convex -h\` in your project root
directory. To learn more, launch the docs with \`npx convex docs\`.
`],
  ["backend/server/nitro/routes/api-reference/[...path].ts.hbs", `{{#if (eq api "orpc")}}
import { OpenAPIHandler } from "@orpc/openapi/node";
import { OpenAPIReferencePlugin } from "@orpc/openapi/plugins";
import { ZodToJsonSchemaConverter } from "@orpc/zod/zod4";
import { onError } from "@orpc/server";
import { appRouter } from "@{{projectName}}/api/routers/index";
{{#if (eq auth "better-auth")}}
import { createContext } from "@{{projectName}}/api/context";
{{/if}}

const apiHandler = new OpenAPIHandler(appRouter, {
	plugins: [
		new OpenAPIReferencePlugin({
			schemaConverters: [new ZodToJsonSchemaConverter()],
		}),
	],
	interceptors: [
		onError((error) => {
			console.error(error);
		}),
	],
});

export default defineEventHandler(async (event) => {
	const { req, res } = event.node;
	const result = await apiHandler.handle(req, res, {
		prefix: "/api-reference",
{{#if (eq auth "better-auth")}}
		context: await createContext({ req }),
{{else}}
		context: {},
{{/if}}
	});
	if (!result.matched) {
		setResponseStatus(event, 404);
		return "Not Found";
	}
});
{{else}}
// OpenAPI reference placeholder - oRPC not configured
export default defineEventHandler(() => {
	return { error: "OpenAPI reference not configured" };
});
{{/if}}
`],
  ["backend/server/nitro/routes/trpc/[...path].ts.hbs", `{{#if (eq api "trpc")}}
import { fetchRequestHandler } from "@trpc/server/adapters/fetch";
import { createContext } from "@{{projectName}}/api/context";
import { appRouter } from "@{{projectName}}/api/routers/index";

export default defineEventHandler(async (event) => {
	const response = await fetchRequestHandler({
		endpoint: "/trpc",
		req: event.node.req as unknown as Request,
		router: appRouter,
		createContext: ({ req }) => createContext({ req }),
	});
	return response;
});
{{else}}
// tRPC placeholder - not configured
export default defineEventHandler(() => {
	return { error: "tRPC not configured" };
});
{{/if}}
`],
  ["backend/server/nitro/routes/rpc/[...path].ts.hbs", `{{#if (eq api "orpc")}}
import { RPCHandler } from "@orpc/server/node";
import { onError } from "@orpc/server";
import { appRouter } from "@{{projectName}}/api/routers/index";
{{#if (eq auth "better-auth")}}
import { createContext } from "@{{projectName}}/api/context";
{{/if}}

const rpcHandler = new RPCHandler(appRouter, {
	interceptors: [
		onError((error) => {
			console.error(error);
		}),
	],
});

export default defineEventHandler(async (event) => {
	const { req, res } = event.node;
	const result = await rpcHandler.handle(req, res, {
		prefix: "/rpc",
{{#if (eq auth "better-auth")}}
		context: await createContext({ req }),
{{else}}
		context: {},
{{/if}}
	});
	if (!result.matched) {
		setResponseStatus(event, 404);
		return "Not Found";
	}
});
{{else}}
// oRPC placeholder - not configured
export default defineEventHandler(() => {
	return { error: "oRPC not configured" };
});
{{/if}}
`],
  ["backend/server/nestjs/src/trpc/trpc.module.ts.hbs", `import { Module, type MiddlewareConsumer, type NestModule } from "@nestjs/common";
import { TrpcMiddleware } from "./trpc.middleware";

@Module({})
export class TrpcModule implements NestModule {
	configure(consumer: MiddlewareConsumer) {
		consumer.apply(TrpcMiddleware).forRoutes("trpc/*path");
	}
}
`],
  ["backend/server/nestjs/src/trpc/trpc.middleware.ts.hbs", `import { Injectable, type NestMiddleware } from "@nestjs/common";
import { createExpressMiddleware } from "@trpc/server/adapters/express";
import { createContext } from "@{{projectName}}/api/context";
import { appRouter } from "@{{projectName}}/api/routers/index";
import type { Request, Response, NextFunction } from "express";

@Injectable()
export class TrpcMiddleware implements NestMiddleware {
	private trpcMiddleware = createExpressMiddleware({
		router: appRouter,
		createContext,
	});

	use(req: Request, res: Response, next: NextFunction) {
		this.trpcMiddleware(req, res, next);
	}
}
`],
  ["backend/server/nestjs/src/ai/ai.service.ts.hbs", `import { Injectable } from "@nestjs/common";
import { streamText, type UIMessage, convertToModelMessages, wrapLanguageModel } from "ai";
import { google } from "@ai-sdk/google";
import { devToolsMiddleware } from "@ai-sdk/devtools";
import type { Request, Response } from "express";

@Injectable()
export class AiService {
	async streamChat(req: Request, res: Response) {
		const { messages = [] } = (req.body || {}) as { messages: UIMessage[] };
		const model = wrapLanguageModel({
			model: google("gemini-2.5-flash"),
			middleware: devToolsMiddleware(),
		});
		const result = streamText({
			model,
			messages: await convertToModelMessages(messages),
		});
		result.pipeUIMessageStreamToResponse(res);
	}
}
`],
  ["backend/server/nestjs/src/ai/ai.controller.ts.hbs", `import { Controller, Post, Req, Res } from "@nestjs/common";
import { AiService } from "./ai.service";
import type { Request, Response } from "express";

@Controller("ai")
export class AiController {
	constructor(private readonly aiService: AiService) {}

	@Post()
	async chat(@Req() req: Request, @Res() res: Response) {
		return this.aiService.streamChat(req, res);
	}
}
`],
  ["backend/server/nestjs/src/ai/ai.module.ts.hbs", `import { Module } from "@nestjs/common";
import { AiController } from "./ai.controller";
import { AiService } from "./ai.service";

@Module({
	controllers: [AiController],
	providers: [AiService],
})
export class AiModule {}
`],
  ["backend/server/nestjs/src/orpc/orpc.module.ts.hbs", `import { Module, type MiddlewareConsumer, type NestModule } from "@nestjs/common";
import { OrpcMiddleware } from "./orpc.middleware";

@Module({})
export class OrpcModule implements NestModule {
	configure(consumer: MiddlewareConsumer) {
		consumer.apply(OrpcMiddleware).forRoutes("rpc/*path", "api-reference/*path");
	}
}
`],
  ["backend/server/nestjs/src/orpc/orpc.middleware.ts.hbs", `import { Injectable, type NestMiddleware } from "@nestjs/common";
import { OpenAPIHandler } from "@orpc/openapi/node";
import { OpenAPIReferencePlugin } from "@orpc/openapi/plugins";
import { ZodToJsonSchemaConverter } from "@orpc/zod/zod4";
import { RPCHandler } from "@orpc/server/node";
import { onError } from "@orpc/server";
import { appRouter } from "@{{projectName}}/api/routers/index";
{{#if (eq auth "better-auth")}}
import { createContext } from "@{{projectName}}/api/context";
{{/if}}
import type { Request, Response, NextFunction } from "express";

@Injectable()
export class OrpcMiddleware implements NestMiddleware {
	private rpcHandler = new RPCHandler(appRouter, {
		interceptors: [
			onError((error) => {
				console.error(error);
			}),
		],
	});

	private apiHandler = new OpenAPIHandler(appRouter, {
		plugins: [
			new OpenAPIReferencePlugin({
				schemaConverters: [new ZodToJsonSchemaConverter()],
			}),
		],
		interceptors: [
			onError((error) => {
				console.error(error);
			}),
		],
	});

	async use(req: Request, res: Response, next: NextFunction) {
		const rpcResult = await this.rpcHandler.handle(req, res, {
			prefix: "/rpc",
{{#if (eq auth "better-auth")}}
			context: await createContext({ req }),
{{else}}
			context: {},
{{/if}}
		});
		if (rpcResult.matched) return;

		const apiResult = await this.apiHandler.handle(req, res, {
			prefix: "/api-reference",
{{#if (eq auth "better-auth")}}
			context: await createContext({ req }),
{{else}}
			context: {},
{{/if}}
		});
		if (apiResult.matched) return;

		next();
	}
}
`],
  ["db/mikroorm/base/src/entities/index.ts.hbs", `{{#if (eq auth "better-auth")}}
export * from "./user";
export * from "./session";
export * from "./account";
export * from "./verification";
{{/if}}
{{#if (includes examples "todo")}}
export * from "./todo";
{{/if}}
export {};
`],
  ["db/sequelize/base/src/models/index.ts.hbs", `{{#if (eq auth "better-auth")}}
export * from "./user";
export * from "./session";
export * from "./account";
export * from "./verification";
{{/if}}
{{#if (includes examples "todo")}}
export * from "./todo";
{{/if}}
export {};
`],
  ["db/kysely/base/src/schema/index.ts.hbs", `import type { Generated, ColumnType } from "kysely";

{{#if (eq auth "better-auth")}}
// Auth tables
export interface UserTable {
	id: string;
	name: string;
	email: string;
	emailVerified: number;
	image: string | null;
	createdAt: ColumnType<Date, string | undefined, never>;
	updatedAt: ColumnType<Date, string | undefined, never>;
}

export interface SessionTable {
	id: string;
	expiresAt: ColumnType<Date, string, string>;
	token: string;
	createdAt: ColumnType<Date, string | undefined, never>;
	updatedAt: ColumnType<Date, string | undefined, never>;
	ipAddress: string | null;
	userAgent: string | null;
	userId: string;
}

export interface AccountTable {
	id: string;
	accountId: string;
	providerId: string;
	userId: string;
	accessToken: string | null;
	refreshToken: string | null;
	idToken: string | null;
	accessTokenExpiresAt: ColumnType<Date, string | null, string | null>;
	refreshTokenExpiresAt: ColumnType<Date, string | null, string | null>;
	scope: string | null;
	password: string | null;
	createdAt: ColumnType<Date, string | undefined, never>;
	updatedAt: ColumnType<Date, string | undefined, never>;
}

export interface VerificationTable {
	id: string;
	identifier: string;
	value: string;
	expiresAt: ColumnType<Date, string, string>;
	createdAt: ColumnType<Date, string | undefined, never>;
	updatedAt: ColumnType<Date, string | undefined, never>;
}
{{/if}}

{{#if (includes examples "todo")}}
// Todo table
export interface TodoTable {
	id: Generated<number>;
	text: string;
	completed: number;
	createdAt: ColumnType<Date, string | undefined, never>;
}
{{/if}}

// Database interface - lists all tables
export interface Database {
{{#if (eq auth "better-auth")}}
	user: UserTable;
	session: SessionTable;
	account: AccountTable;
	verification: VerificationTable;
{{/if}}
{{#if (includes examples "todo")}}
	todo: TodoTable;
{{/if}}
}
`],
  ["db/prisma/postgres/prisma/schema/schema.prisma.hbs", `generator client {
  provider = "prisma-client"
  output   = "../generated"
  moduleFormat = "esm"
  {{#if (eq runtime "bun")}}
  runtime = "bun"
  {{/if}}
  {{#if (eq runtime "node")}}
  runtime = "nodejs"
  {{/if}}
  {{#if (or (eq runtime "workers") (and (eq backend "self") (eq webDeploy "cloudflare")))}}
  runtime = "workerd"
  {{/if}}
}

datasource db {
  provider = "postgresql"
  {{#if (eq dbSetup "planetscale")}}
  relationMode = "prisma"
  {{/if}}
}
`],
  ["db/typeorm/base/src/entities/index.ts.hbs", `{{#if (eq auth "better-auth")}}
export * from "./user";
export * from "./session";
export * from "./account";
export * from "./verification";
{{/if}}
{{#if (includes examples "todo")}}
export * from "./todo";
{{/if}}
export {};
`],
  ["db/drizzle/base/src/schema/index.ts.hbs", `{{#if (eq auth "better-auth")}}
export * from "./auth";
{{/if}}
{{#if (includes examples "todo")}}
export * from "./todo";
{{/if}}
export {};`],
  ["db/prisma/sqlite/prisma/schema/schema.prisma.hbs", `generator client {
  provider = "prisma-client"
  output   = "../generated"
  moduleFormat = "esm"
  {{#if (eq runtime "bun")}}
  runtime = "bun"
  {{/if}}
  {{#if (eq runtime "node")}}
  runtime = "nodejs"
  {{/if}}
  {{#if (or (eq runtime "workers") (and (eq backend "self") (eq webDeploy "cloudflare")))}}
  runtime = "workerd"
  {{/if}}
}

datasource db {
  provider = "sqlite"
}
`],
  ["db/prisma/mysql/prisma/schema/schema.prisma.hbs", `generator client {
  provider      = "prisma-client"
  output        = "../generated"
  moduleFormat  = "esm"
  {{#if (eq runtime "bun")}}
  runtime       = "bun"
  {{/if}}
  {{#if (eq runtime "node")}}
  runtime       = "nodejs"
  {{/if}}
  {{#if (or (eq runtime "workers") (and (eq backend "self") (eq webDeploy "cloudflare")))}}
  runtime       = "workerd"
  {{/if}}
}

datasource db {
  provider = "mysql"
  {{#if (eq dbSetup "planetscale")}}
  relationMode = "prisma"
  {{/if}}
}`],
  ["db/prisma/mongodb/prisma/schema/schema.prisma.hbs", `generator client {
  provider = "prisma-client"
  output   = "../generated"
  moduleFormat = "esm"
  {{#if (eq runtime "bun")}}
  runtime = "bun"
  {{/if}}
  {{#if (eq runtime "node")}}
  runtime = "nodejs"
  {{/if}}
  {{#if (or (eq runtime "workers") (and (eq backend "self") (eq webDeploy "cloudflare")))}}
  runtime = "workerd"
  {{/if}}
}

datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}
`],
  ["deploy/fly/web/react/tanstack-start/fly.toml.hbs", `# Fly.io configuration for {{projectName}} TanStack Start app
# See https://fly.io/docs/reference/configuration/ for all options

app = "{{projectName}}"
primary_region = "iad"

[build]
  dockerfile = "Dockerfile"

[env]
  NODE_ENV = "production"
  PORT = "3000"

[http_service]
  internal_port = 3000
  force_https = true
  auto_stop_machines = "stop"
  auto_start_machines = true
  min_machines_running = 1
  processes = ["app"]

  [http_service.concurrency]
    type = "requests"
    soft_limit = 200
    hard_limit = 250

[[http_service.checks]]
  grace_period = "10s"
  interval = "30s"
  method = "GET"
  timeout = "5s"
  path = "/"

[[vm]]
  size = "shared-cpu-1x"
  memory = "512mb"
  processes = ["app"]
`],
  ["deploy/fly/web/react/tanstack-start/Dockerfile.hbs", `# Dockerfile for {{projectName}} TanStack Start app
# Optimized multi-stage build for Fly.io deployment

{{#if (eq packageManager "bun")}}
FROM oven/bun:1 AS builder

WORKDIR /app

COPY package.json bun.lock* ./
RUN bun install --frozen-lockfile

COPY . .
RUN bun run build

FROM oven/bun:1-slim AS runner

WORKDIR /app

ENV NODE_ENV=production
ENV PORT=3000

COPY --from=builder /app/.output ./

EXPOSE 3000

CMD ["bun", "run", ".output/server/index.mjs"]
{{else}}
FROM node:20-alpine AS builder

WORKDIR /app

{{#if (eq packageManager "pnpm")}}
RUN corepack enable && corepack prepare pnpm@latest --activate
COPY package.json pnpm-lock.yaml* ./
RUN pnpm install --frozen-lockfile
{{else}}
COPY package.json package-lock.json* ./
RUN npm ci
{{/if}}

COPY . .

{{#if (eq packageManager "pnpm")}}
RUN pnpm run build
{{else}}
RUN npm run build
{{/if}}

FROM node:20-alpine AS runner

WORKDIR /app

ENV NODE_ENV=production
ENV PORT=3000

COPY --from=builder /app/.output ./

EXPOSE 3000

CMD ["node", ".output/server/index.mjs"]
{{/if}}
`],
  ["deploy/fly/web/react/next/fly.toml.hbs", `# Fly.io configuration for {{projectName}} Next.js app
# See https://fly.io/docs/reference/configuration/ for all options

app = "{{projectName}}"
primary_region = "iad"

[build]
  dockerfile = "Dockerfile"

[env]
  NODE_ENV = "production"
  PORT = "3000"

[http_service]
  internal_port = 3000
  force_https = true
  auto_stop_machines = "stop"
  auto_start_machines = true
  min_machines_running = 1
  processes = ["app"]

  [http_service.concurrency]
    type = "requests"
    soft_limit = 200
    hard_limit = 250

[[http_service.checks]]
  grace_period = "10s"
  interval = "30s"
  method = "GET"
  timeout = "5s"
  path = "/"

[[vm]]
  size = "shared-cpu-1x"
  memory = "512mb"
  processes = ["app"]
`],
  ["deploy/fly/web/react/next/Dockerfile.hbs", `# Dockerfile for {{projectName}} Next.js app
# Optimized multi-stage build for Fly.io deployment

FROM node:20-alpine AS base

# Install dependencies only when needed
FROM base AS deps
RUN apk add --no-cache libc6-compat
WORKDIR /app

{{#if (eq packageManager "pnpm")}}
RUN corepack enable && corepack prepare pnpm@latest --activate
COPY package.json pnpm-lock.yaml* ./
RUN pnpm install --frozen-lockfile
{{else if (eq packageManager "bun")}}
RUN npm install -g bun
COPY package.json bun.lock* ./
RUN bun install --frozen-lockfile
{{else}}
COPY package.json package-lock.json* ./
RUN npm ci
{{/if}}

# Rebuild the source code only when needed
FROM base AS builder
WORKDIR /app

{{#if (eq packageManager "pnpm")}}
RUN corepack enable && corepack prepare pnpm@latest --activate
{{else if (eq packageManager "bun")}}
RUN npm install -g bun
{{/if}}

COPY --from=deps /app/node_modules ./node_modules
COPY . .

# Disable telemetry during build
ENV NEXT_TELEMETRY_DISABLED=1

{{#if (eq packageManager "pnpm")}}
RUN pnpm run build
{{else if (eq packageManager "bun")}}
RUN bun run build
{{else}}
RUN npm run build
{{/if}}

# Production image, copy all the files and run next
FROM base AS runner
WORKDIR /app

ENV NODE_ENV=production
ENV NEXT_TELEMETRY_DISABLED=1
ENV PORT=3000
ENV HOSTNAME="0.0.0.0"

RUN addgroup --system --gid 1001 nodejs
RUN adduser --system --uid 1001 nextjs

COPY --from=builder /app/public ./public

# Automatically leverage output traces to reduce image size
COPY --from=builder --chown=nextjs:nodejs /app/.next/standalone ./
COPY --from=builder --chown=nextjs:nodejs /app/.next/static ./.next/static

USER nextjs

EXPOSE 3000

CMD ["node", "server.js"]
`],
  ["deploy/fly/web/react/next/.dockerignore.hbs", `# Dependencies
node_modules
.pnpm-store

# Build outputs
.next
out
dist
build

# Development
.env*.local
.env.development*
*.log

# Testing
coverage
.nyc_output

# IDE
.idea
.vscode
*.swp
*.swo

# OS
.DS_Store
Thumbs.db

# Git
.git
.gitignore

# Docker
Dockerfile*
.dockerignore
docker-compose*

# Misc
README.md
*.md
.turbo
`],
  ["deploy/fly/web/react/tanstack-router/fly.toml.hbs", `# Fly.io configuration for {{projectName}} TanStack Router SPA
# See https://fly.io/docs/reference/configuration/ for all options

app = "{{projectName}}"
primary_region = "iad"

[build]
  dockerfile = "Dockerfile"

[env]
  NODE_ENV = "production"
  PORT = "3000"

[http_service]
  internal_port = 3000
  force_https = true
  auto_stop_machines = "stop"
  auto_start_machines = true
  min_machines_running = 0
  processes = ["app"]

  [http_service.concurrency]
    type = "requests"
    soft_limit = 200
    hard_limit = 250

[[http_service.checks]]
  grace_period = "10s"
  interval = "30s"
  method = "GET"
  timeout = "5s"
  path = "/"

[[vm]]
  size = "shared-cpu-1x"
  memory = "256mb"
  processes = ["app"]
`],
  ["deploy/fly/web/react/tanstack-router/Dockerfile.hbs", `# Dockerfile for {{projectName}} TanStack Router SPA
# Static file serving with nginx for Fly.io deployment

FROM node:20-alpine AS builder

WORKDIR /app

{{#if (eq packageManager "pnpm")}}
RUN corepack enable && corepack prepare pnpm@latest --activate
COPY package.json pnpm-lock.yaml* ./
RUN pnpm install --frozen-lockfile
{{else if (eq packageManager "bun")}}
RUN npm install -g bun
COPY package.json bun.lock* ./
RUN bun install --frozen-lockfile
{{else}}
COPY package.json package-lock.json* ./
RUN npm ci
{{/if}}

COPY . .

{{#if (eq packageManager "pnpm")}}
RUN pnpm run build
{{else if (eq packageManager "bun")}}
RUN bun run build
{{else}}
RUN npm run build
{{/if}}

# Production stage with nginx
FROM nginx:alpine AS runner

# Copy nginx configuration for SPA routing
RUN echo 'server { \\
    listen 3000; \\
    root /usr/share/nginx/html; \\
    index index.html; \\
    location / { \\
        try_files $uri $uri/ /index.html; \\
    } \\
    location ~* \\.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2)$ { \\
        expires 1y; \\
        add_header Cache-Control "public, immutable"; \\
    } \\
}' > /etc/nginx/conf.d/default.conf

# Copy built assets
COPY --from=builder /app/dist /usr/share/nginx/html

EXPOSE 3000

CMD ["nginx", "-g", "daemon off;"]
`],
  ["deploy/docker/web/react/tanstack-start/Dockerfile.hbs", `# Dockerfile for {{projectName}} TanStack Start app
# Optimized multi-stage build for Docker deployment

{{#if (eq packageManager "bun")}}
FROM oven/bun:1 AS builder

WORKDIR /app

COPY package.json bun.lock* ./
RUN bun install --frozen-lockfile

COPY . .
RUN bun run build

FROM oven/bun:1-slim AS runner

WORKDIR /app

ENV NODE_ENV=production
ENV PORT=3000

COPY --from=builder /app/.output ./.output
COPY --from=builder /app/package.json ./

EXPOSE 3000

CMD ["bun", "run", ".output/server/index.mjs"]
{{else}}
FROM node:20-alpine AS builder

WORKDIR /app

{{#if (eq packageManager "pnpm")}}
RUN corepack enable && corepack prepare pnpm@latest --activate
COPY package.json pnpm-lock.yaml* ./
RUN pnpm install --frozen-lockfile
{{else}}
COPY package.json package-lock.json* ./
RUN npm ci
{{/if}}

COPY . .

{{#if (eq packageManager "pnpm")}}
RUN pnpm run build
{{else}}
RUN npm run build
{{/if}}

FROM node:20-alpine AS runner

WORKDIR /app

ENV NODE_ENV=production
ENV PORT=3000

COPY --from=builder /app/.output ./.output
COPY --from=builder /app/package.json ./

EXPOSE 3000

CMD ["node", ".output/server/index.mjs"]
{{/if}}
`],
  ["deploy/docker/web/react/next/Dockerfile.hbs", `# Dockerfile for {{projectName}} Next.js app
# Optimized multi-stage build for Docker deployment

FROM node:20-alpine AS base

# Install dependencies only when needed
FROM base AS deps
RUN apk add --no-cache libc6-compat
WORKDIR /app

{{#if (eq packageManager "pnpm")}}
RUN corepack enable && corepack prepare pnpm@latest --activate
COPY package.json pnpm-lock.yaml* ./
RUN pnpm install --frozen-lockfile
{{else if (eq packageManager "bun")}}
RUN npm install -g bun
COPY package.json bun.lock* ./
RUN bun install --frozen-lockfile
{{else}}
COPY package.json package-lock.json* ./
RUN npm ci
{{/if}}

# Rebuild the source code only when needed
FROM base AS builder
WORKDIR /app

{{#if (eq packageManager "pnpm")}}
RUN corepack enable && corepack prepare pnpm@latest --activate
{{else if (eq packageManager "bun")}}
RUN npm install -g bun
{{/if}}

COPY --from=deps /app/node_modules ./node_modules
COPY . .

# Disable telemetry during build
ENV NEXT_TELEMETRY_DISABLED=1

{{#if (eq packageManager "pnpm")}}
RUN pnpm run build
{{else if (eq packageManager "bun")}}
RUN bun run build
{{else}}
RUN npm run build
{{/if}}

# Production image, copy all the files and run next
FROM base AS runner
WORKDIR /app

ENV NODE_ENV=production
ENV NEXT_TELEMETRY_DISABLED=1
ENV PORT=3000
ENV HOSTNAME="0.0.0.0"

RUN addgroup --system --gid 1001 nodejs
RUN adduser --system --uid 1001 nextjs

COPY --from=builder /app/public ./public

# Automatically leverage output traces to reduce image size
COPY --from=builder --chown=nextjs:nodejs /app/.next/standalone ./
COPY --from=builder --chown=nextjs:nodejs /app/.next/static ./.next/static

USER nextjs

EXPOSE 3000

CMD ["node", "server.js"]
`],
  ["deploy/docker/web/react/next/.dockerignore.hbs", `# Dependencies
node_modules
.pnpm-store

# Build outputs
.next
out

# Development
.env*.local
.env.development*
*.log

# Testing
coverage
.nyc_output

# IDE
.idea
.vscode
*.swp
*.swo

# OS
.DS_Store
Thumbs.db

# Git
.git
.gitignore

# Docker
Dockerfile*
.dockerignore
docker-compose*

# Misc
README.md
*.md
.turbo
`],
  ["deploy/docker/web/react/react-router/Dockerfile.hbs", `# Dockerfile for {{projectName}} React Router app
# Optimized multi-stage build for Docker deployment

{{#if (eq packageManager "bun")}}
FROM oven/bun:1 AS builder

WORKDIR /app

COPY package.json bun.lock* ./
RUN bun install --frozen-lockfile

COPY . .
RUN bun run build

FROM oven/bun:1-slim AS runner

WORKDIR /app

ENV NODE_ENV=production
ENV PORT=3000

COPY --from=builder /app/build ./build
COPY --from=builder /app/package.json ./

RUN bun install --production --frozen-lockfile

EXPOSE 3000

CMD ["bun", "run", "./build/server/index.js"]
{{else}}
FROM node:20-alpine AS builder

WORKDIR /app

{{#if (eq packageManager "pnpm")}}
RUN corepack enable && corepack prepare pnpm@latest --activate
COPY package.json pnpm-lock.yaml* ./
RUN pnpm install --frozen-lockfile
{{else}}
COPY package.json package-lock.json* ./
RUN npm ci
{{/if}}

COPY . .

{{#if (eq packageManager "pnpm")}}
RUN pnpm run build
{{else}}
RUN npm run build
{{/if}}

FROM node:20-alpine AS runner

WORKDIR /app

ENV NODE_ENV=production
ENV PORT=3000

{{#if (eq packageManager "pnpm")}}
RUN corepack enable && corepack prepare pnpm@latest --activate
{{/if}}

COPY --from=builder /app/build ./build
COPY --from=builder /app/package.json ./

{{#if (eq packageManager "pnpm")}}
RUN pnpm install --prod --frozen-lockfile
{{else}}
RUN npm ci --omit=dev
{{/if}}

EXPOSE 3000

CMD ["node", "./build/server/index.js"]
{{/if}}
`],
  ["deploy/docker/web/react/tanstack-router/Dockerfile.hbs", `# Dockerfile for {{projectName}} TanStack Router SPA
# Static file serving with nginx for Docker deployment

FROM node:20-alpine AS builder

WORKDIR /app

{{#if (eq packageManager "pnpm")}}
RUN corepack enable && corepack prepare pnpm@latest --activate
COPY package.json pnpm-lock.yaml* ./
RUN pnpm install --frozen-lockfile
{{else if (eq packageManager "bun")}}
RUN npm install -g bun
COPY package.json bun.lock* ./
RUN bun install --frozen-lockfile
{{else}}
COPY package.json package-lock.json* ./
RUN npm ci
{{/if}}

COPY . .

{{#if (eq packageManager "pnpm")}}
RUN pnpm run build
{{else if (eq packageManager "bun")}}
RUN bun run build
{{else}}
RUN npm run build
{{/if}}

# Production stage with nginx
FROM nginx:alpine AS runner

# Copy nginx configuration for SPA routing
RUN echo 'server { \\
    listen 3000; \\
    root /usr/share/nginx/html; \\
    index index.html; \\
    location / { \\
        try_files $uri $uri/ /index.html; \\
    } \\
    location ~* \\.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2)$ { \\
        expires 1y; \\
        add_header Cache-Control "public, immutable"; \\
    } \\
}' > /etc/nginx/conf.d/default.conf

# Copy built assets
COPY --from=builder /app/dist /usr/share/nginx/html

EXPOSE 3000

CMD ["nginx", "-g", "daemon off;"]
`],
  ["deploy/fly/web/react/react-router/fly.toml.hbs", `# Fly.io configuration for {{projectName}} React Router app
# See https://fly.io/docs/reference/configuration/ for all options

app = "{{projectName}}"
primary_region = "iad"

[build]
  dockerfile = "Dockerfile"

[env]
  NODE_ENV = "production"
  PORT = "3000"

[http_service]
  internal_port = 3000
  force_https = true
  auto_stop_machines = "stop"
  auto_start_machines = true
  min_machines_running = 1
  processes = ["app"]

  [http_service.concurrency]
    type = "requests"
    soft_limit = 200
    hard_limit = 250

[[http_service.checks]]
  grace_period = "10s"
  interval = "30s"
  method = "GET"
  timeout = "5s"
  path = "/"

[[vm]]
  size = "shared-cpu-1x"
  memory = "512mb"
  processes = ["app"]
`],
  ["deploy/fly/web/react/react-router/Dockerfile.hbs", `# Dockerfile for {{projectName}} React Router app
# Optimized multi-stage build for Fly.io deployment

{{#if (eq packageManager "bun")}}
FROM oven/bun:1 AS builder

WORKDIR /app

COPY package.json bun.lock* ./
RUN bun install --frozen-lockfile

COPY . .
RUN bun run build

FROM oven/bun:1-slim AS runner

WORKDIR /app

ENV NODE_ENV=production
ENV PORT=3000

COPY --from=builder /app/build ./build
COPY --from=builder /app/package.json ./

RUN bun install --production --frozen-lockfile

EXPOSE 3000

CMD ["bun", "run", "./build/server/index.js"]
{{else}}
FROM node:20-alpine AS builder

WORKDIR /app

{{#if (eq packageManager "pnpm")}}
RUN corepack enable && corepack prepare pnpm@latest --activate
COPY package.json pnpm-lock.yaml* ./
RUN pnpm install --frozen-lockfile
{{else}}
COPY package.json package-lock.json* ./
RUN npm ci
{{/if}}

COPY . .

{{#if (eq packageManager "pnpm")}}
RUN pnpm run build
{{else}}
RUN npm run build
{{/if}}

FROM node:20-alpine AS runner

WORKDIR /app

ENV NODE_ENV=production
ENV PORT=3000

{{#if (eq packageManager "pnpm")}}
RUN corepack enable && corepack prepare pnpm@latest --activate
{{/if}}

COPY --from=builder /app/build ./build
COPY --from=builder /app/package.json ./

{{#if (eq packageManager "pnpm")}}
RUN pnpm install --prod --frozen-lockfile
{{else}}
RUN npm ci --omit=dev
{{/if}}

EXPOSE 3000

CMD ["node", "./build/server/index.js"]
{{/if}}
`],
  ["deploy/railway/web/react/tanstack-start/Dockerfile.hbs", `# Dockerfile for {{projectName}} TanStack Start app
# Optimized multi-stage build for Railway deployment

{{#if (eq packageManager "bun")}}
FROM oven/bun:1 AS builder

WORKDIR /app

COPY package.json bun.lock* ./
RUN bun install --frozen-lockfile

COPY . .
RUN bun run build

FROM oven/bun:1-slim AS runner

WORKDIR /app

ENV NODE_ENV=production
ENV PORT=3000

COPY --from=builder /app/.output ./

EXPOSE 3000

CMD ["bun", "run", ".output/server/index.mjs"]
{{else}}
FROM node:20-alpine AS builder

WORKDIR /app

{{#if (eq packageManager "pnpm")}}
RUN corepack enable && corepack prepare pnpm@latest --activate
COPY package.json pnpm-lock.yaml* ./
RUN pnpm install --frozen-lockfile
{{else}}
COPY package.json package-lock.json* ./
RUN npm ci
{{/if}}

COPY . .

{{#if (eq packageManager "pnpm")}}
RUN pnpm run build
{{else}}
RUN npm run build
{{/if}}

FROM node:20-alpine AS runner

WORKDIR /app

ENV NODE_ENV=production
ENV PORT=3000

COPY --from=builder /app/.output ./

EXPOSE 3000

CMD ["node", ".output/server/index.mjs"]
{{/if}}
`],
  ["deploy/railway/web/react/tanstack-start/railway.toml.hbs", `# Railway configuration for {{projectName}} TanStack Start app
# See https://docs.railway.app/reference/config-as-code for all options

[build]
builder = "dockerfile"
dockerfilePath = "Dockerfile"

[deploy]
startCommand = "{{#if (eq packageManager "bun")}}bun run .output/server/index.mjs{{else}}node .output/server/index.mjs{{/if}}"
healthcheckPath = "/"
healthcheckTimeout = 300
restartPolicyType = "on_failure"
restartPolicyMaxRetries = 3
`],
  ["deploy/railway/web/react/react-router/Dockerfile.hbs", `# Dockerfile for {{projectName}} React Router SPA
# Static file serving with nginx for Railway deployment

FROM node:20-alpine AS builder

WORKDIR /app

{{#if (eq packageManager "pnpm")}}
RUN corepack enable && corepack prepare pnpm@latest --activate
COPY package.json pnpm-lock.yaml* ./
RUN pnpm install --frozen-lockfile
{{else if (eq packageManager "bun")}}
RUN npm install -g bun
COPY package.json bun.lock* ./
RUN bun install --frozen-lockfile
{{else}}
COPY package.json package-lock.json* ./
RUN npm ci
{{/if}}

COPY . .

{{#if (eq packageManager "pnpm")}}
RUN pnpm run build
{{else if (eq packageManager "bun")}}
RUN bun run build
{{else}}
RUN npm run build
{{/if}}

# Production stage with nginx
FROM nginx:alpine AS runner

# Copy nginx configuration for SPA routing
RUN echo 'server { \\
    listen 3000; \\
    root /usr/share/nginx/html; \\
    index index.html; \\
    location / { \\
        try_files $uri $uri/ /index.html; \\
    } \\
    location ~* \\.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2)$ { \\
        expires 1y; \\
        add_header Cache-Control "public, immutable"; \\
    } \\
}' > /etc/nginx/conf.d/default.conf

# Copy built assets
COPY --from=builder /app/dist /usr/share/nginx/html

EXPOSE 3000

CMD ["nginx", "-g", "daemon off;"]
`],
  ["deploy/railway/web/react/react-router/railway.toml.hbs", `# Railway configuration for {{projectName}} React Router SPA
# See https://docs.railway.app/reference/config-as-code for all options

[build]
builder = "dockerfile"
dockerfilePath = "Dockerfile"

[deploy]
healthcheckPath = "/"
healthcheckTimeout = 300
restartPolicyType = "on_failure"
restartPolicyMaxRetries = 3
`],
  ["deploy/railway/web/react/tanstack-router/Dockerfile.hbs", `# Dockerfile for {{projectName}} TanStack Router SPA
# Static file serving with nginx for Railway deployment

FROM node:20-alpine AS builder

WORKDIR /app

{{#if (eq packageManager "pnpm")}}
RUN corepack enable && corepack prepare pnpm@latest --activate
COPY package.json pnpm-lock.yaml* ./
RUN pnpm install --frozen-lockfile
{{else if (eq packageManager "bun")}}
RUN npm install -g bun
COPY package.json bun.lock* ./
RUN bun install --frozen-lockfile
{{else}}
COPY package.json package-lock.json* ./
RUN npm ci
{{/if}}

COPY . .

{{#if (eq packageManager "pnpm")}}
RUN pnpm run build
{{else if (eq packageManager "bun")}}
RUN bun run build
{{else}}
RUN npm run build
{{/if}}

# Production stage with nginx
FROM nginx:alpine AS runner

# Copy nginx configuration for SPA routing
RUN echo 'server { \\
    listen 3000; \\
    root /usr/share/nginx/html; \\
    index index.html; \\
    location / { \\
        try_files $uri $uri/ /index.html; \\
    } \\
    location ~* \\.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2)$ { \\
        expires 1y; \\
        add_header Cache-Control "public, immutable"; \\
    } \\
}' > /etc/nginx/conf.d/default.conf

# Copy built assets
COPY --from=builder /app/dist /usr/share/nginx/html

EXPOSE 3000

CMD ["nginx", "-g", "daemon off;"]
`],
  ["deploy/railway/web/react/tanstack-router/railway.toml.hbs", `# Railway configuration for {{projectName}} TanStack Router SPA
# See https://docs.railway.app/reference/config-as-code for all options

[build]
builder = "dockerfile"
dockerfilePath = "Dockerfile"

[deploy]
healthcheckPath = "/"
healthcheckTimeout = 300
restartPolicyType = "on_failure"
restartPolicyMaxRetries = 3
`],
  ["deploy/railway/web/react/next/Dockerfile.hbs", `# Dockerfile for {{projectName}} Next.js app
# Optimized multi-stage build for Railway deployment

FROM node:20-alpine AS base

# Install dependencies only when needed
FROM base AS deps
RUN apk add --no-cache libc6-compat
WORKDIR /app

{{#if (eq packageManager "pnpm")}}
RUN corepack enable && corepack prepare pnpm@latest --activate
COPY package.json pnpm-lock.yaml* ./
RUN pnpm install --frozen-lockfile
{{else if (eq packageManager "bun")}}
RUN npm install -g bun
COPY package.json bun.lock* ./
RUN bun install --frozen-lockfile
{{else}}
COPY package.json package-lock.json* ./
RUN npm ci
{{/if}}

# Rebuild the source code only when needed
FROM base AS builder
WORKDIR /app

{{#if (eq packageManager "pnpm")}}
RUN corepack enable && corepack prepare pnpm@latest --activate
{{else if (eq packageManager "bun")}}
RUN npm install -g bun
{{/if}}

COPY --from=deps /app/node_modules ./node_modules
COPY . .

# Disable telemetry during build
ENV NEXT_TELEMETRY_DISABLED=1

{{#if (eq packageManager "pnpm")}}
RUN pnpm run build
{{else if (eq packageManager "bun")}}
RUN bun run build
{{else}}
RUN npm run build
{{/if}}

# Production image, copy all the files and run next
FROM base AS runner
WORKDIR /app

ENV NODE_ENV=production
ENV NEXT_TELEMETRY_DISABLED=1
ENV PORT=3000
ENV HOSTNAME="0.0.0.0"

RUN addgroup --system --gid 1001 nodejs
RUN adduser --system --uid 1001 nextjs

COPY --from=builder /app/public ./public

# Automatically leverage output traces to reduce image size
COPY --from=builder --chown=nextjs:nodejs /app/.next/standalone ./
COPY --from=builder --chown=nextjs:nodejs /app/.next/static ./.next/static

USER nextjs

EXPOSE 3000

CMD ["node", "server.js"]
`],
  ["deploy/railway/web/react/next/.dockerignore.hbs", `# Dependencies
node_modules
.pnpm-store

# Build outputs
.next
out

# Development
.env*.local
.env.development*
*.log

# Testing
coverage
.nyc_output

# IDE
.idea
.vscode
*.swp
*.swo

# OS
.DS_Store
Thumbs.db

# Git
.git
.gitignore

# Docker
Dockerfile*
.dockerignore
docker-compose*

# Misc
README.md
*.md
.turbo
`],
  ["deploy/railway/web/react/next/railway.toml.hbs", `# Railway configuration for {{projectName}} Next.js app
# See https://docs.railway.app/reference/config-as-code for all options

[build]
builder = "dockerfile"
dockerfilePath = "Dockerfile"

[deploy]
startCommand = "node server.js"
healthcheckPath = "/"
healthcheckTimeout = 300
restartPolicyType = "on_failure"
restartPolicyMaxRetries = 3
`],
  ["addons/msw/apps/web/src/mocks/node.ts.hbs", `/**
 * MSW Node.js server setup
 *
 * This file sets up the MSW request interception for Node.js environments.
 * Use this in your test setup files (e.g., vitest.setup.ts or jest.setup.ts).
 *
 * @see https://mswjs.io/docs/integrations/node
 */
import { setupServer } from "msw/node";
import { handlers } from "./handlers";

export const server = setupServer(...handlers);
`],
  ["addons/msw/apps/web/src/mocks/handlers.ts.hbs", `/**
 * MSW (Mock Service Worker) request handlers
 *
 * Define your mock API handlers here. These handlers intercept network requests
 * and return mocked responses, useful for testing and development.
 *
 * @see https://mswjs.io/docs/basics/mocking-responses
 */
import { http, HttpResponse } from "msw";

export const handlers = [
  // Example: Mock a GET request to /api/user
  http.get("/api/user", () => {
    return HttpResponse.json({
      id: "1",
      name: "John Doe",
      email: "john@example.com",
    });
  }),

  // Example: Mock a POST request to /api/login
  http.post("/api/login", async ({ request }) => {
    const body = (await request.json()) as { email: string; password: string };

    if (body.email === "test@example.com" && body.password === "password") {
      return HttpResponse.json({
        success: true,
        token: "mock-jwt-token",
      });
    }

    return HttpResponse.json(
      { success: false, message: "Invalid credentials" },
      { status: 401 }
    );
  }),

  // Add more handlers as needed for your API endpoints
];
`],
  ["addons/msw/apps/web/src/mocks/browser.ts.hbs", `/**
 * MSW browser worker setup
 *
 * This file sets up the MSW service worker for browser environments.
 * Import and start this in your app's entry point for development mocking.
 *
 * @see https://mswjs.io/docs/integrations/browser
 */
import { setupWorker } from "msw/browser";
import { handlers } from "./handlers";

export const worker = setupWorker(...handlers);
`],
  ["addons/storybook/apps/web/src/stories/Button.stories.ts.hbs", `{{#if (or (eq frontend "tanstack-router") (eq frontend "react-router") (eq frontend "next") (eq frontend "solid"))}}
import type { Meta, StoryObj } from "{{#if (eq frontend "next")}}@storybook/nextjs{{else}}@storybook/react-vite{{/if}}";

// Example Button component for demonstration
// Replace this with your actual component imports
const Button = ({
  primary = false,
  size = "medium",
  label,
  onClick,
}: {
  primary?: boolean;
  size?: "small" | "medium" | "large";
  label: string;
  onClick?: () => void;
}) => {
  const baseStyles = "font-semibold rounded-lg transition-colors";
  const sizeStyles = {
    small: "px-3 py-1.5 text-sm",
    medium: "px-4 py-2 text-base",
    large: "px-6 py-3 text-lg",
  };
  const variantStyles = primary
    ? "bg-blue-600 text-white hover:bg-blue-700"
    : "bg-gray-200 text-gray-900 hover:bg-gray-300";

  return (
    <button
      type="button"
      className={\`\${baseStyles} \${sizeStyles[size]} \${variantStyles}\`}
      onClick={onClick}
    >
      {label}
    </button>
  );
};

const meta: Meta<typeof Button> = {
  title: "Example/Button",
  component: Button,
  parameters: {
    layout: "centered",
  },
  tags: ["autodocs"],
  argTypes: {
    size: {
      control: { type: "select" },
      options: ["small", "medium", "large"],
    },
    onClick: { action: "clicked" },
  },
};

export default meta;
type Story = StoryObj<typeof meta>;

export const Primary: Story = {
  args: {
    primary: true,
    label: "Primary Button",
  },
};

export const Secondary: Story = {
  args: {
    label: "Secondary Button",
  },
};

export const Large: Story = {
  args: {
    size: "large",
    label: "Large Button",
  },
};

export const Small: Story = {
  args: {
    size: "small",
    label: "Small Button",
  },
};
{{else if (eq frontend "nuxt")}}
import type { Meta, StoryObj } from "@storybook/vue3-vite";
import { fn } from "@storybook/test";

// Example Button component for demonstration
const Button = {
  name: "Button",
  props: {
    primary: { type: Boolean, default: false },
    size: { type: String, default: "medium" },
    label: { type: String, required: true },
  },
  emits: ["click"],
  template: \`
    <button
      type="button"
      :class="[
        'font-semibold rounded-lg transition-colors',
        size === 'small' ? 'px-3 py-1.5 text-sm' : size === 'large' ? 'px-6 py-3 text-lg' : 'px-4 py-2 text-base',
        primary ? 'bg-blue-600 text-white hover:bg-blue-700' : 'bg-gray-200 text-gray-900 hover:bg-gray-300'
      ]"
      @click="$emit('click')"
    >
      \\{{ label }}
    </button>
  \`,
};

const meta: Meta<typeof Button> = {
  title: "Example/Button",
  component: Button,
  parameters: {
    layout: "centered",
  },
  tags: ["autodocs"],
  argTypes: {
    size: {
      control: { type: "select" },
      options: ["small", "medium", "large"],
    },
  },
  args: {
    onClick: fn(),
  },
};

export default meta;
type Story = StoryObj<typeof meta>;

export const Primary: Story = {
  args: {
    primary: true,
    label: "Primary Button",
  },
};

export const Secondary: Story = {
  args: {
    label: "Secondary Button",
  },
};
{{else if (eq frontend "svelte")}}
import type { Meta, StoryObj } from "@storybook/svelte-vite";
import { fn } from "@storybook/test";

// Example Button component for demonstration
// In real usage, import your actual Svelte component
const Button = {
  render: (args: { primary?: boolean; size?: string; label: string }) => ({
    Component: {
      // Simplified Svelte-like component representation
      $$: { on_mount: [], on_destroy: [], after_update: [], context: new Map() },
    },
    props: args,
  }),
};

const meta: Meta<typeof Button> = {
  title: "Example/Button",
  component: Button as any,
  parameters: {
    layout: "centered",
  },
  tags: ["autodocs"],
  argTypes: {
    size: {
      control: { type: "select" },
      options: ["small", "medium", "large"],
    },
  },
  args: {
    onClick: fn(),
  },
};

export default meta;
type Story = StoryObj<typeof meta>;

export const Primary: Story = {
  args: {
    primary: true,
    label: "Primary Button",
  },
};

export const Secondary: Story = {
  args: {
    label: "Secondary Button",
  },
};
{{else}}
// Generic Storybook example
import type { Meta, StoryObj } from "@storybook/react-vite";

const Button = ({ label }: { label: string }) => (
  <button type="button">{label}</button>
);

const meta: Meta<typeof Button> = {
  title: "Example/Button",
  component: Button,
};

export default meta;
type Story = StoryObj<typeof meta>;

export const Default: Story = {
  args: {
    label: "Click me",
  },
};
{{/if}}
`],
  ["observability/opentelemetry/server/base/src/lib/tracing.ts.hbs", `import { NodeSDK } from "@opentelemetry/sdk-node";
import { getNodeAutoInstrumentations } from "@opentelemetry/auto-instrumentations-node";
import { OTLPTraceExporter } from "@opentelemetry/exporter-trace-otlp-http";
import { OTLPMetricExporter } from "@opentelemetry/exporter-metrics-otlp-http";
import { Resource } from "@opentelemetry/resources";
import {
  ATTR_SERVICE_NAME,
  ATTR_SERVICE_VERSION,
  ATTR_DEPLOYMENT_ENVIRONMENT_NAME,
} from "@opentelemetry/semantic-conventions";
import { PeriodicExportingMetricReader } from "@opentelemetry/sdk-metrics";

// Service configuration from environment variables
const serviceName = process.env.OTEL_SERVICE_NAME || "{{projectName}}-server";
const serviceVersion = process.env.OTEL_SERVICE_VERSION || "1.0.0";
const environment = process.env.NODE_ENV || "development";

// OTLP endpoint configuration
// Default to localhost:4318 for local development with Jaeger or OTEL Collector
const otlpEndpoint = process.env.OTEL_EXPORTER_OTLP_ENDPOINT || "http://localhost:4318";

// Create resource with service information
const resource = new Resource({
  [ATTR_SERVICE_NAME]: serviceName,
  [ATTR_SERVICE_VERSION]: serviceVersion,
  [ATTR_DEPLOYMENT_ENVIRONMENT_NAME]: environment,
});

// Configure trace exporter
const traceExporter = new OTLPTraceExporter({
  url: \`\${otlpEndpoint}/v1/traces\`,
});

// Configure metric exporter
const metricExporter = new OTLPMetricExporter({
  url: \`\${otlpEndpoint}/v1/metrics\`,
});

// Initialize OpenTelemetry SDK
const sdk = new NodeSDK({
  resource,
  traceExporter,
  metricReader: new PeriodicExportingMetricReader({
    exporter: metricExporter,
    // Export metrics every 30 seconds
    exportIntervalMillis: 30000,
  }),
  instrumentations: [
    getNodeAutoInstrumentations({
      // Disable fs instrumentation to reduce noise
      "@opentelemetry/instrumentation-fs": {
        enabled: false,
      },
      // Configure HTTP instrumentation
      "@opentelemetry/instrumentation-http": {
        enabled: true,
      },
    }),
  ],
});

/**
 * Start the OpenTelemetry SDK
 * Call this at the very beginning of your application, before any other imports
 *
 * @example
 * // At the top of your main entry file (e.g., index.ts)
 * import { startTracing } from './lib/tracing';
 * startTracing();
 *
 * // Then import and start your application
 * import { app } from './app';
 */
export function startTracing(): void {
  sdk.start();
  console.log(\`[OpenTelemetry] Tracing started for service: \${serviceName}\`);
  console.log(\`[OpenTelemetry] Exporting to: \${otlpEndpoint}\`);
}

/**
 * Gracefully shutdown the SDK
 * Call this before your application exits to ensure all spans are flushed
 *
 * @example
 * process.on('SIGTERM', async () => {
 *   await shutdownTracing();
 *   process.exit(0);
 * });
 */
export async function shutdownTracing(): Promise<void> {
  try {
    await sdk.shutdown();
    console.log("[OpenTelemetry] Tracing shutdown complete");
  } catch (error) {
    console.error("[OpenTelemetry] Error shutting down tracing:", error);
  }
}

/**
 * Get the OpenTelemetry API for manual instrumentation
 * Use this when you need to create custom spans or add attributes
 *
 * @example
 * import { trace } from '@opentelemetry/api';
 *
 * const tracer = trace.getTracer('my-component');
 * const span = tracer.startSpan('my-operation');
 * try {
 *   // ... do work
 *   span.setAttribute('result', 'success');
 * } catch (error) {
 *   span.recordException(error);
 *   span.setStatus({ code: SpanStatusCode.ERROR });
 * } finally {
 *   span.end();
 * }
 */
export { trace, context, SpanStatusCode } from "@opentelemetry/api";

/**
 * Environment Variables:
 *
 * OTEL_SERVICE_NAME - Service name for tracing (default: {{projectName}}-server)
 * OTEL_SERVICE_VERSION - Service version (default: 1.0.0)
 * OTEL_EXPORTER_OTLP_ENDPOINT - OTLP collector endpoint (default: http://localhost:4318)
 *
 * Common OTLP backends:
 * - Jaeger: http://localhost:4318 (with OTLP enabled)
 * - OTEL Collector: http://localhost:4318
 * - Grafana Tempo: Your Tempo endpoint
 * - Honeycomb: https://api.honeycomb.io (requires API key header)
 * - Datadog: https://trace.agent.datadoghq.com
 *
 * For production, configure OTEL_EXPORTER_OTLP_HEADERS for authentication:
 * OTEL_EXPORTER_OTLP_HEADERS="x-honeycomb-team=your-api-key"
 */
`],
  ["payments/lemon-squeezy/web/solid/src/routes/success.tsx.hbs", `import { useSearchParams } from "@solidjs/router";

export default function SuccessPage() {
	const [searchParams] = useSearchParams();

	return (
		<div class="container mx-auto px-4 py-8">
			<h1 class="text-2xl font-bold mb-4">Payment Successful!</h1>
			<p class="text-gray-600 mb-4">
				Thank you for your purchase. Your payment has been processed successfully.
			</p>
			{searchParams.checkout_id && (
				<p class="text-sm text-gray-500">Checkout ID: {searchParams.checkout_id}</p>
			)}
		</div>
	);
}
`],
  ["addons/pwa/apps/web/vite/public/logo.png", `[Binary file]`],
  ["payments/lemon-squeezy/server/base/src/lib/lemonsqueezy.ts.hbs", `import {
	lemonSqueezySetup,
	createCheckout,
	getCheckout,
	listProducts,
	getProduct,
	listVariants,
	getVariant,
	listSubscriptions,
	getSubscription,
	cancelSubscription,
	type Checkout,
	type Product,
	type Variant,
	type Subscription,
} from "@lemonsqueezy/lemonsqueezy.js";
import { env } from "@{{projectName}}/env/server";

// Initialize Lemon Squeezy with your API key
lemonSqueezySetup({
	apiKey: env.LEMONSQUEEZY_API_KEY,
	onError: (error) => console.error("Lemon Squeezy Error:", error),
});

export async function createCheckoutSession(params: {
	variantId: number;
	customData?: Record<string, string | number | boolean>;
	checkoutOptions?: {
		embed?: boolean;
		media?: boolean;
		logo?: boolean;
		desc?: boolean;
		discount?: boolean;
		dark?: boolean;
		subscriptionPreview?: boolean;
		buttonColor?: string;
	};
	productOptions?: {
		name?: string;
		description?: string;
		redirectUrl?: string;
		receiptButtonText?: string;
		receiptLinkUrl?: string;
		receiptThankYouNote?: string;
		enabledVariants?: number[];
	};
	checkoutData?: {
		email?: string;
		name?: string;
		billingAddress?: {
			country: string;
			zip?: string;
		};
		taxNumber?: string;
		discountCode?: string;
	};
	expiresAt?: string;
	preview?: boolean;
	testMode?: boolean;
}) {
	const { data, error } = await createCheckout(env.LEMONSQUEEZY_STORE_ID, params.variantId, {
		customData: params.customData,
		checkoutOptions: params.checkoutOptions,
		productOptions: params.productOptions,
		checkoutData: params.checkoutData,
		expiresAt: params.expiresAt,
		preview: params.preview,
		testMode: params.testMode,
	});

	if (error) {
		throw new Error(\`Failed to create checkout: \${error.message}\`);
	}

	return data;
}

export async function getCheckoutById(checkoutId: string): Promise<Checkout | null> {
	const { data, error } = await getCheckout(checkoutId);

	if (error) {
		throw new Error(\`Failed to get checkout: \${error.message}\`);
	}

	return data;
}

export async function getProducts(): Promise<Product[]> {
	const { data, error } = await listProducts({
		filter: { storeId: env.LEMONSQUEEZY_STORE_ID },
	});

	if (error) {
		throw new Error(\`Failed to list products: \${error.message}\`);
	}

	return data?.data ?? [];
}

export async function getProductById(productId: string): Promise<Product | null> {
	const { data, error } = await getProduct(productId);

	if (error) {
		throw new Error(\`Failed to get product: \${error.message}\`);
	}

	return data;
}

export async function getVariants(productId?: string): Promise<Variant[]> {
	const { data, error } = await listVariants({
		filter: productId ? { productId } : undefined,
	});

	if (error) {
		throw new Error(\`Failed to list variants: \${error.message}\`);
	}

	return data?.data ?? [];
}

export async function getVariantById(variantId: string): Promise<Variant | null> {
	const { data, error } = await getVariant(variantId);

	if (error) {
		throw new Error(\`Failed to get variant: \${error.message}\`);
	}

	return data;
}

export async function getUserSubscriptions(customerId?: string): Promise<Subscription[]> {
	const { data, error } = await listSubscriptions({
		filter: customerId ? { customerId } : undefined,
	});

	if (error) {
		throw new Error(\`Failed to list subscriptions: \${error.message}\`);
	}

	return data?.data ?? [];
}

export async function getSubscriptionById(subscriptionId: string): Promise<Subscription | null> {
	const { data, error } = await getSubscription(subscriptionId);

	if (error) {
		throw new Error(\`Failed to get subscription: \${error.message}\`);
	}

	return data;
}

export async function cancelUserSubscription(subscriptionId: string): Promise<Subscription | null> {
	const { data, error } = await cancelSubscription(subscriptionId);

	if (error) {
		throw new Error(\`Failed to cancel subscription: \${error.message}\`);
	}

	return data;
}

export function verifyWebhookSignature(
	payload: string,
	signature: string,
): boolean {
	// Lemon Squeezy uses HMAC-SHA256 for webhook signatures
	const crypto = require("crypto");
	const hmac = crypto.createHmac("sha256", env.LEMONSQUEEZY_WEBHOOK_SECRET);
	const digest = hmac.update(payload).digest("hex");
	return crypto.timingSafeEqual(Buffer.from(signature), Buffer.from(digest));
}

export type WebhookEvent =
	| "order_created"
	| "order_refunded"
	| "subscription_created"
	| "subscription_updated"
	| "subscription_cancelled"
	| "subscription_resumed"
	| "subscription_expired"
	| "subscription_paused"
	| "subscription_unpaused"
	| "subscription_payment_success"
	| "subscription_payment_failed"
	| "subscription_payment_recovered"
	| "license_key_created"
	| "license_key_updated";

export interface WebhookPayload {
	meta: {
		event_name: WebhookEvent;
		custom_data?: Record<string, string | number | boolean>;
		webhook_id: string;
	};
	data: {
		type: string;
		id: string;
		attributes: Record<string, unknown>;
		relationships?: Record<string, unknown>;
	};
}
`],
  ["analytics/plausible/web/react/src/lib/plausible.tsx.hbs", `import Plausible from "plausible-tracker";
import type { PropsWithChildren } from "react";
import { createContext, useContext, useEffect, useMemo, useCallback, useState } from "react";

// Plausible configuration from environment variables
{{#if (eq frontend.[0] "next")}}
const plausibleDomain = process.env.NEXT_PUBLIC_PLAUSIBLE_DOMAIN || "";
const plausibleApiHost = process.env.NEXT_PUBLIC_PLAUSIBLE_API_HOST || "https://plausible.io";
{{else if (eq frontend.[0] "nuxt")}}
const plausibleDomain = process.env.NUXT_PUBLIC_PLAUSIBLE_DOMAIN || "";
const plausibleApiHost = process.env.NUXT_PUBLIC_PLAUSIBLE_API_HOST || "https://plausible.io";
{{else}}
const plausibleDomain = import.meta.env.VITE_PLAUSIBLE_DOMAIN || "";
const plausibleApiHost = import.meta.env.VITE_PLAUSIBLE_API_HOST || "https://plausible.io";
{{/if}}

// Create Plausible instance
const plausible = Plausible({
  domain: plausibleDomain,
  apiHost: plausibleApiHost,
  // Track localhost for development (disable in production if needed)
  trackLocalhost: true,
});

// Enable automatic pageview tracking for SPAs
const { enableAutoPageviews, enableAutoOutboundTracking } = plausible;

// Context for Plausible instance
const PlausibleContext = createContext<typeof plausible | null>(null);

interface PlausibleProviderProps extends PropsWithChildren {
  /**
   * Enable automatic pageview tracking (recommended for SPAs)
   * @default true
   */
  autoPageviews?: boolean;
  /**
   * Enable automatic outbound link tracking
   * @default true
   */
  autoOutboundTracking?: boolean;
}

/**
 * Plausible Analytics Provider component
 * Wrap your app with this provider to enable privacy-focused analytics
 *
 * @example
 * function App() {
 *   return (
 *     <PlausibleProvider>
 *       <YourApp />
 *     </PlausibleProvider>
 *   );
 * }
 */
export function PlausibleProvider({
  children,
  autoPageviews = true,
  autoOutboundTracking = true,
}: PlausibleProviderProps) {
  const [ready, setReady] = useState(false);

  useEffect(() => {
    if (!plausibleDomain) {
      console.warn("[Plausible] Domain not configured, analytics disabled");
      return;
    }

    // Enable automatic pageview tracking for SPAs
    let cleanupPageviews: (() => void) | undefined;
    if (autoPageviews) {
      cleanupPageviews = enableAutoPageviews();
    }

    // Enable automatic outbound link tracking
    let cleanupOutbound: (() => void) | undefined;
    if (autoOutboundTracking) {
      cleanupOutbound = enableAutoOutboundTracking();
    }

    setReady(true);

    return () => {
      cleanupPageviews?.();
      cleanupOutbound?.();
    };
  }, [autoPageviews, autoOutboundTracking]);

  return (
    <PlausibleContext.Provider value={ready ? plausible : null}>
      {children}
    </PlausibleContext.Provider>
  );
}

/**
 * Hook to access the Plausible instance
 */
export function usePlausible() {
  const context = useContext(PlausibleContext);
  return context;
}

/**
 * Hook to track custom events
 *
 * @example
 * function SignupButton() {
 *   const trackEvent = useTrackEvent();
 *
 *   const handleClick = () => {
 *     trackEvent("Signup", { props: { plan: "premium" } });
 *   };
 *
 *   return <button onClick={handleClick}>Sign Up</button>;
 * }
 */
export function useTrackEvent() {
  return useCallback(
    (
      eventName: string,
      options?: {
        props?: Record<string, string | number | boolean>;
        revenue?: { currency: string; amount: number };
        callback?: () => void;
      }
    ) => {
      if (!plausibleDomain) return;
      plausible.trackEvent(eventName, options);
    },
    []
  );
}

/**
 * Hook to manually track pageviews
 * Useful when you need to track virtual pageviews or custom URLs
 *
 * @example
 * function ProductPage({ product }) {
 *   const trackPageview = useTrackPageview();
 *
 *   useEffect(() => {
 *     trackPageview({ url: \`/products/\${product.id}\` });
 *   }, [product.id, trackPageview]);
 * }
 */
export function useTrackPageview() {
  return useCallback(
    (options?: { url?: string; referrer?: string; deviceWidth?: number }) => {
      if (!plausibleDomain) return;
      plausible.trackPageview(options);
    },
    []
  );
}

/**
 * Hook to get the Plausible configuration status
 */
export function usePlausibleStatus() {
  return useMemo(
    () => ({
      isConfigured: !!plausibleDomain,
      domain: plausibleDomain,
      apiHost: plausibleApiHost,
    }),
    []
  );
}

// Re-export the Plausible instance for direct access if needed
export { plausible };

/**
 * Environment Variables:
 *
{{#if (eq frontend.[0] "next")}}
 * NEXT_PUBLIC_PLAUSIBLE_DOMAIN - Your website domain (e.g., "example.com")
 * NEXT_PUBLIC_PLAUSIBLE_API_HOST - Plausible API host (default: https://plausible.io)
{{else if (eq frontend.[0] "nuxt")}}
 * NUXT_PUBLIC_PLAUSIBLE_DOMAIN - Your website domain (e.g., "example.com")
 * NUXT_PUBLIC_PLAUSIBLE_API_HOST - Plausible API host (default: https://plausible.io)
{{else}}
 * VITE_PLAUSIBLE_DOMAIN - Your website domain (e.g., "example.com")
 * VITE_PLAUSIBLE_API_HOST - Plausible API host (default: https://plausible.io)
{{/if}}
 *
 * Getting started:
 * 1. Sign up at https://plausible.io (or self-host)
 * 2. Add your domain in the Plausible dashboard
 * 3. Copy your domain to your .env file
 * 4. If self-hosting, update the API host accordingly
 * 5. Wrap your app with <PlausibleProvider>
 *
 * Example usage:
 * \`\`\`tsx
 * // In your app entry point
 * import { PlausibleProvider } from "./lib/plausible";
 *
 * function App() {
 *   return (
 *     <PlausibleProvider>
 *       <Router />
 *     </PlausibleProvider>
 *   );
 * }
 *
 * // In any component - track custom events
 * import { useTrackEvent } from "./lib/plausible";
 *
 * function PurchaseButton({ product }) {
 *   const trackEvent = useTrackEvent();
 *
 *   const handlePurchase = () => {
 *     trackEvent("Purchase", {
 *       props: { productId: product.id },
 *       revenue: { currency: "USD", amount: product.price }
 *     });
 *   };
 *
 *   return <button onClick={handlePurchase}>Buy Now</button>;
 * }
 * \`\`\`
 *
 * Features:
 * - Automatic pageview tracking for SPAs (React Router, Next.js, etc.)
 * - Automatic outbound link tracking
 * - Custom event tracking with properties
 * - Revenue tracking for e-commerce
 * - Privacy-focused: No cookies, GDPR/CCPA compliant
 * - Lightweight: ~1KB gzipped
 */
`],
  ["observability/grafana/server/base/src/lib/metrics.ts.hbs", `import client, {
  Counter,
  Histogram,
  Gauge,
  Registry,
  collectDefaultMetrics,
} from "prom-client";

// Configuration from environment variables
const metricsPrefix = process.env.METRICS_PREFIX || "{{projectName}}_";
const metricsPath = process.env.METRICS_PATH || "/metrics";
const metricsPort = parseInt(process.env.METRICS_PORT || "9090", 10);

// Create a custom registry for your application metrics
const registry = new Registry();

// Set default labels that will be added to all metrics
registry.setDefaultLabels({
  app: "{{projectName}}",
  environment: process.env.NODE_ENV || "development",
});

// Collect default Node.js metrics (CPU, memory, event loop, etc.)
collectDefaultMetrics({
  register: registry,
  prefix: metricsPrefix,
});

// ============================================================================
// Custom Application Metrics
// ============================================================================

/**
 * HTTP request counter - tracks total number of requests
 *
 * @example
 * httpRequestsTotal.inc({ method: 'GET', route: '/api/users', status_code: '200' });
 */
export const httpRequestsTotal = new Counter({
  name: \`\${metricsPrefix}http_requests_total\`,
  help: "Total number of HTTP requests",
  labelNames: ["method", "route", "status_code"],
  registers: [registry],
});

/**
 * HTTP request duration histogram - tracks request latency
 *
 * @example
 * const end = httpRequestDuration.startTimer({ method: 'GET', route: '/api/users' });
 * // ... handle request
 * end({ status_code: '200' });
 */
export const httpRequestDuration = new Histogram({
  name: \`\${metricsPrefix}http_request_duration_seconds\`,
  help: "HTTP request duration in seconds",
  labelNames: ["method", "route", "status_code"],
  buckets: [0.001, 0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1, 2.5, 5, 10],
  registers: [registry],
});

/**
 * Active connections gauge - tracks current number of active connections
 *
 * @example
 * activeConnections.inc();
 * // ... on disconnect
 * activeConnections.dec();
 */
export const activeConnections = new Gauge({
  name: \`\${metricsPrefix}active_connections\`,
  help: "Number of active connections",
  registers: [registry],
});

/**
 * Database query duration histogram
 *
 * @example
 * const end = dbQueryDuration.startTimer({ operation: 'SELECT', table: 'users' });
 * // ... execute query
 * end();
 */
export const dbQueryDuration = new Histogram({
  name: \`\${metricsPrefix}db_query_duration_seconds\`,
  help: "Database query duration in seconds",
  labelNames: ["operation", "table"],
  buckets: [0.001, 0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1, 2.5, 5],
  registers: [registry],
});

/**
 * Error counter - tracks application errors
 *
 * @example
 * errorsTotal.inc({ type: 'database', operation: 'insert' });
 */
export const errorsTotal = new Counter({
  name: \`\${metricsPrefix}errors_total\`,
  help: "Total number of errors",
  labelNames: ["type", "operation"],
  registers: [registry],
});

// ============================================================================
// Metrics Server
// ============================================================================

let metricsServer: import("http").Server | null = null;

/**
 * Start a dedicated metrics server for Prometheus scraping
 * This runs on a separate port from your main application
 *
 * @example
 * // In your main entry file
 * import { startMetricsServer } from './lib/metrics';
 * startMetricsServer();
 */
export async function startMetricsServer(): Promise<void> {
  const http = await import("http");

  metricsServer = http.createServer(async (req, res) => {
    if (req.url === metricsPath) {
      try {
        res.setHeader("Content-Type", registry.contentType);
        res.end(await registry.metrics());
      } catch (error) {
        res.statusCode = 500;
        res.end("Error collecting metrics");
      }
    } else if (req.url === "/health") {
      res.setHeader("Content-Type", "application/json");
      res.end(JSON.stringify({ status: "healthy" }));
    } else {
      res.statusCode = 404;
      res.end("Not found");
    }
  });

  metricsServer.listen(metricsPort, () => {
    console.log(\`[Metrics] Server running on port \${metricsPort}\`);
    console.log(\`[Metrics] Prometheus scrape endpoint: http://localhost:\${metricsPort}\${metricsPath}\`);
  });
}

/**
 * Stop the metrics server gracefully
 *
 * @example
 * process.on('SIGTERM', async () => {
 *   await stopMetricsServer();
 *   process.exit(0);
 * });
 */
export async function stopMetricsServer(): Promise<void> {
  return new Promise((resolve, reject) => {
    if (!metricsServer) {
      resolve();
      return;
    }

    metricsServer.close((err) => {
      if (err) {
        console.error("[Metrics] Error stopping server:", err);
        reject(err);
      } else {
        console.log("[Metrics] Server stopped");
        resolve();
      }
    });
  });
}

/**
 * Get metrics as a string (for embedding in your main app routes)
 *
 * @example
 * // If you prefer to expose metrics on your main app instead of separate server
 * app.get('/metrics', async (req, res) => {
 *   res.set('Content-Type', registry.contentType);
 *   res.end(await getMetrics());
 * });
 */
export async function getMetrics(): Promise<string> {
  return registry.metrics();
}

/**
 * Get the content type for metrics response
 */
export function getMetricsContentType(): string {
  return registry.contentType;
}

// Re-export prom-client for advanced usage
export { client, registry, Counter, Histogram, Gauge };

/**
 * Environment Variables:
 *
 * METRICS_PORT - Port for the metrics server (default: 9090)
 * METRICS_PATH - Path for the metrics endpoint (default: /metrics)
 * METRICS_PREFIX - Prefix for all metric names (default: {{projectName}}_)
 *
 * Grafana Setup:
 * 1. Add Prometheus as a data source in Grafana
 * 2. Configure Prometheus to scrape http://your-server:9090/metrics
 * 3. Import dashboards or create custom ones using the metrics above
 *
 * Prometheus scrape config example:
 * scrape_configs:
 *   - job_name: '{{projectName}}'
 *     static_configs:
 *       - targets: ['localhost:9090']
 *
 * Built-in metrics include:
 * - http_requests_total: Total HTTP requests (labeled by method, route, status)
 * - http_request_duration_seconds: Request latency histogram
 * - active_connections: Current number of active connections
 * - db_query_duration_seconds: Database query latency
 * - errors_total: Error counter by type
 * - Default Node.js metrics (CPU, memory, event loop, GC, etc.)
 */
`],
  ["observability/sentry/server/base/src/lib/sentry.ts.hbs", `import * as Sentry from "@sentry/node";
import { nodeProfilingIntegration } from "@sentry/profiling-node";

// Sentry configuration from environment variables
const dsn = process.env.SENTRY_DSN;
const environment = process.env.SENTRY_ENVIRONMENT || "development";
const tracesSampleRate = parseFloat(process.env.SENTRY_TRACES_SAMPLE_RATE || "1.0");
const profilesSampleRate = parseFloat(process.env.SENTRY_PROFILES_SAMPLE_RATE || "0.1");

/**
 * Initialize Sentry for error tracking and performance monitoring
 * Call this at the very beginning of your application, before any other imports
 *
 * @example
 * // At the top of your main entry file (e.g., index.ts)
 * import { initSentry } from './lib/sentry';
 * initSentry();
 *
 * // Then import and start your application
 * import { app } from './app';
 */
export function initSentry(): void {
  if (!dsn) {
    console.warn("[Sentry] DSN not configured, skipping initialization");
    return;
  }

  Sentry.init({
    dsn,
    environment,
    integrations: [
      // Add profiling integration for performance insights
      nodeProfilingIntegration(),
    ],
    // Performance Monitoring
    tracesSampleRate,
    // Set sampling rate for profiling - this is relative to tracesSampleRate
    profilesSampleRate,
  });

  console.log(\`[Sentry] Initialized for \${environment}\`);
}

/**
 * Gracefully close Sentry
 * Call this before your application exits to ensure all events are flushed
 *
 * @example
 * process.on('SIGTERM', async () => {
 *   await closeSentry();
 *   process.exit(0);
 * });
 */
export async function closeSentry(): Promise<void> {
  try {
    await Sentry.close(2000);
    console.log("[Sentry] Closed successfully");
  } catch (error) {
    console.error("[Sentry] Error closing:", error);
  }
}

/**
 * Capture an exception with Sentry
 *
 * @example
 * try {
 *   await riskyOperation();
 * } catch (error) {
 *   captureException(error);
 * }
 */
export function captureException(error: Error | unknown): string {
  return Sentry.captureException(error);
}

/**
 * Capture a message with Sentry
 *
 * @example
 * captureMessage("User completed checkout", "info");
 */
export function captureMessage(
  message: string,
  level: Sentry.SeverityLevel = "info",
): string {
  return Sentry.captureMessage(message, level);
}

/**
 * Set user context for Sentry
 *
 * @example
 * setUser({ id: "123", email: "user@example.com" });
 */
export function setUser(user: Sentry.User | null): void {
  Sentry.setUser(user);
}

/**
 * Add a breadcrumb for debugging context
 *
 * @example
 * addBreadcrumb({
 *   category: "auth",
 *   message: "User logged in",
 *   level: "info",
 * });
 */
export function addBreadcrumb(breadcrumb: Sentry.Breadcrumb): void {
  Sentry.addBreadcrumb(breadcrumb);
}

/**
 * Create a span for performance monitoring
 *
 * @example
 * const result = await withSpan(
 *   { name: "database-query", op: "db.query" },
 *   async () => {
 *     return await db.query("SELECT * FROM users");
 *   }
 * );
 */
export async function withSpan<T>(
  context: { name: string; op?: string; attributes?: Record<string, unknown> },
  callback: () => Promise<T>,
): Promise<T> {
  return Sentry.startSpan(context, callback);
}

// Re-export Sentry for advanced usage
export { Sentry };

/**
 * Environment Variables:
 *
 * SENTRY_DSN - Your Sentry DSN from the project settings (required)
 * SENTRY_ENVIRONMENT - Environment name (default: development)
 * SENTRY_TRACES_SAMPLE_RATE - Sample rate for performance monitoring 0.0-1.0 (default: 1.0)
 * SENTRY_PROFILES_SAMPLE_RATE - Sample rate for profiling 0.0-1.0 (default: 0.1)
 *
 * Getting started:
 * 1. Create a project at https://sentry.io
 * 2. Copy your DSN from Project Settings > Client Keys
 * 3. Set SENTRY_DSN in your .env file
 *
 * Production recommendations:
 * - Set SENTRY_TRACES_SAMPLE_RATE to 0.1-0.2 to reduce costs
 * - Set SENTRY_PROFILES_SAMPLE_RATE to 0.1 or lower
 * - Configure release tracking with SENTRY_RELEASE env var
 */
`],
  ["payments/polar/web/solid/src/routes/success.tsx.hbs", `import { createFileRoute } from "@tanstack/solid-router";
import { Show } from "solid-js";

export const Route = createFileRoute("/success")({
	component: SuccessPage,
	validateSearch: (search) => ({
		checkout_id: search.checkout_id as string,
	}),
});

function SuccessPage() {
	const searchParams = Route.useSearch();
	const checkout_id = searchParams().checkout_id;

	return (
		<div class="container mx-auto px-4 py-8">
			<h1>Payment Successful!</h1>
			<Show when={checkout_id}>
				<p>Checkout ID: {checkout_id}</p>
			</Show>
		</div>
	);
}
`],
  ["addons/msw/apps/server/src/mocks/handlers.ts.hbs", `/**
 * MSW (Mock Service Worker) request handlers for server-side testing
 *
 * Define your mock API handlers here. These handlers intercept outgoing
 * HTTP requests during tests, useful for mocking external API calls.
 *
 * @see https://mswjs.io/docs/basics/mocking-responses
 */
import { http, HttpResponse } from "msw";

export const handlers = [
  // Example: Mock an external API call
  http.get("https://api.example.com/data", () => {
    return HttpResponse.json({
      items: [
        { id: "1", name: "Item 1" },
        { id: "2", name: "Item 2" },
      ],
    });
  }),

  // Add more handlers as needed for external API mocking
];
`],
  ["addons/msw/apps/server/src/mocks/server.ts.hbs", `/**
 * MSW Node.js server setup for server-side testing
 *
 * This file sets up the MSW request interception for Node.js environments.
 * Use this in your test setup files (e.g., vitest.setup.ts or jest.setup.ts).
 *
 * @see https://mswjs.io/docs/integrations/node
 */
import { setupServer } from "msw/node";
import { handlers } from "./handlers";

export const server = setupServer(...handlers);
`],
  ["analytics/umami/web/react/src/lib/umami.tsx.hbs", `"use client";

import type { PropsWithChildren } from "react";
import { createContext, useContext, useEffect, useMemo, useCallback, useState, useRef } from "react";

// Umami configuration from environment variables
{{#if (eq frontend.[0] "next")}}
const umamiWebsiteId = process.env.NEXT_PUBLIC_UMAMI_WEBSITE_ID || "";
const umamiScriptUrl = process.env.NEXT_PUBLIC_UMAMI_SCRIPT_URL || "https://cloud.umami.is/script.js";
{{else if (eq frontend.[0] "nuxt")}}
const umamiWebsiteId = process.env.NUXT_PUBLIC_UMAMI_WEBSITE_ID || "";
const umamiScriptUrl = process.env.NUXT_PUBLIC_UMAMI_SCRIPT_URL || "https://cloud.umami.is/script.js";
{{else}}
const umamiWebsiteId = import.meta.env.VITE_UMAMI_WEBSITE_ID || "";
const umamiScriptUrl = import.meta.env.VITE_UMAMI_SCRIPT_URL || "https://cloud.umami.is/script.js";
{{/if}}

// Umami global types
declare global {
  interface Window {
    umami?: {
      track: {
        (): void;
        (eventName: string): void;
        (eventName: string, eventData: Record<string, string | number | boolean>): void;
        (callback: (props: UmamiPayload) => UmamiPayload): void;
      };
      identify: {
        (uniqueId: string): void;
        (uniqueId: string, data: Record<string, string | number | boolean>): void;
        (data: Record<string, string | number | boolean>): void;
      };
    };
  }
}

interface UmamiPayload {
  hostname: string;
  language: string;
  referrer: string;
  screen: string;
  title: string;
  url: string;
  website: string;
}

interface UmamiContextValue {
  isReady: boolean;
  isConfigured: boolean;
  websiteId: string;
  scriptUrl: string;
}

// Context for Umami state
const UmamiContext = createContext<UmamiContextValue | null>(null);

interface UmamiProviderProps extends PropsWithChildren {
  /**
   * Enable automatic pageview tracking
   * @default true
   */
  autoPageviews?: boolean;
  /**
   * Domains to track (comma-separated). If set, only these domains will be tracked.
   */
  domains?: string;
  /**
   * Respect user's Do Not Track browser setting
   * @default false
   */
  doNotTrack?: boolean;
  /**
   * Tag to categorize events in the Umami dashboard
   */
  tag?: string;
}

/**
 * Umami Analytics Provider component
 * Wrap your app with this provider to enable privacy-focused analytics
 *
 * @example
 * function App() {
 *   return (
 *     <UmamiProvider>
 *       <YourApp />
 *     </UmamiProvider>
 *   );
 * }
 */
export function UmamiProvider({
  children,
  autoPageviews = true,
  domains,
  doNotTrack = false,
  tag,
}: UmamiProviderProps) {
  const [ready, setReady] = useState(false);
  const scriptLoaded = useRef(false);

  useEffect(() => {
    if (!umamiWebsiteId) {
      console.warn("[Umami] Website ID not configured, analytics disabled");
      return;
    }

    if (scriptLoaded.current) {
      return;
    }

    // Check if script already exists
    const existingScript = document.querySelector(\`script[src="\${umamiScriptUrl}"]\`);
    if (existingScript) {
      scriptLoaded.current = true;
      setReady(true);
      return;
    }

    // Create and inject script
    const script = document.createElement("script");
    script.src = umamiScriptUrl;
    script.defer = true;
    script.setAttribute("data-website-id", umamiWebsiteId);

    if (!autoPageviews) {
      script.setAttribute("data-auto-track", "false");
    }

    if (domains) {
      script.setAttribute("data-domains", domains);
    }

    if (doNotTrack) {
      script.setAttribute("data-do-not-track", "true");
    }

    if (tag) {
      script.setAttribute("data-tag", tag);
    }

    script.onload = () => {
      scriptLoaded.current = true;
      setReady(true);
    };

    script.onerror = () => {
      console.error("[Umami] Failed to load analytics script");
    };

    document.head.appendChild(script);

    return () => {
      // Don't remove the script on unmount as it may be needed by other components
    };
  }, [autoPageviews, domains, doNotTrack, tag]);

  const contextValue = useMemo<UmamiContextValue>(
    () => ({
      isReady: ready,
      isConfigured: !!umamiWebsiteId,
      websiteId: umamiWebsiteId,
      scriptUrl: umamiScriptUrl,
    }),
    [ready]
  );

  return (
    <UmamiContext.Provider value={contextValue}>
      {children}
    </UmamiContext.Provider>
  );
}

/**
 * Hook to access the Umami context
 */
export function useUmami() {
  const context = useContext(UmamiContext);
  return context;
}

/**
 * Hook to track custom events
 *
 * @example
 * function SignupButton() {
 *   const trackEvent = useTrackEvent();
 *
 *   const handleClick = () => {
 *     trackEvent("signup", { plan: "premium" });
 *   };
 *
 *   return <button onClick={handleClick}>Sign Up</button>;
 * }
 */
export function useTrackEvent() {
  return useCallback(
    (
      eventName: string,
      eventData?: Record<string, string | number | boolean>
    ) => {
      if (!umamiWebsiteId || typeof window === "undefined" || !window.umami) return;

      if (eventData) {
        window.umami.track(eventName, eventData);
      } else {
        window.umami.track(eventName);
      }
    },
    []
  );
}

/**
 * Hook to manually track pageviews
 * Useful when you need to track virtual pageviews or custom URLs
 *
 * @example
 * function ProductPage({ product }) {
 *   const trackPageview = useTrackPageview();
 *
 *   useEffect(() => {
 *     trackPageview({ url: \`/products/\${product.id}\`, title: product.name });
 *   }, [product.id, trackPageview]);
 * }
 */
export function useTrackPageview() {
  return useCallback(
    (options?: { url?: string; title?: string; referrer?: string }) => {
      if (!umamiWebsiteId || typeof window === "undefined" || !window.umami) return;

      if (options) {
        window.umami.track((props) => ({
          ...props,
          ...(options.url && { url: options.url }),
          ...(options.title && { title: options.title }),
          ...(options.referrer && { referrer: options.referrer }),
        }));
      } else {
        window.umami.track();
      }
    },
    []
  );
}

/**
 * Hook to identify users across sessions
 *
 * @example
 * function UserProfile({ user }) {
 *   const identify = useIdentify();
 *
 *   useEffect(() => {
 *     identify(user.id, { name: user.name, plan: user.plan });
 *   }, [user.id, identify]);
 * }
 */
export function useIdentify() {
  return useCallback(
    (
      uniqueIdOrData: string | Record<string, string | number | boolean>,
      data?: Record<string, string | number | boolean>
    ) => {
      if (!umamiWebsiteId || typeof window === "undefined" || !window.umami) return;

      if (typeof uniqueIdOrData === "string") {
        if (data) {
          window.umami.identify(uniqueIdOrData, data);
        } else {
          window.umami.identify(uniqueIdOrData);
        }
      } else {
        window.umami.identify(uniqueIdOrData);
      }
    },
    []
  );
}

/**
 * Hook to get the Umami configuration status
 */
export function useUmamiStatus() {
  return useMemo(
    () => ({
      isConfigured: !!umamiWebsiteId,
      websiteId: umamiWebsiteId,
      scriptUrl: umamiScriptUrl,
    }),
    []
  );
}

/**
 * Environment Variables:
 *
{{#if (eq frontend.[0] "next")}}
 * NEXT_PUBLIC_UMAMI_WEBSITE_ID - Your Umami website ID (required)
 * NEXT_PUBLIC_UMAMI_SCRIPT_URL - Umami script URL (default: https://cloud.umami.is/script.js)
{{else if (eq frontend.[0] "nuxt")}}
 * NUXT_PUBLIC_UMAMI_WEBSITE_ID - Your Umami website ID (required)
 * NUXT_PUBLIC_UMAMI_SCRIPT_URL - Umami script URL (default: https://cloud.umami.is/script.js)
{{else}}
 * VITE_UMAMI_WEBSITE_ID - Your Umami website ID (required)
 * VITE_UMAMI_SCRIPT_URL - Umami script URL (default: https://cloud.umami.is/script.js)
{{/if}}
 *
 * Getting started:
 * 1. Sign up at https://umami.is (or self-host)
 * 2. Add your website in the Umami dashboard
 * 3. Copy your website ID to your .env file
 * 4. If self-hosting, update the script URL accordingly
 * 5. Wrap your app with <UmamiProvider>
 *
 * Example usage:
 * \`\`\`tsx
 * // In your app entry point
 * import { UmamiProvider } from "./lib/umami";
 *
 * function App() {
 *   return (
 *     <UmamiProvider>
 *       <Router />
 *     </UmamiProvider>
 *   );
 * }
 *
 * // In any component - track custom events
 * import { useTrackEvent } from "./lib/umami";
 *
 * function PurchaseButton({ product }) {
 *   const trackEvent = useTrackEvent();
 *
 *   const handlePurchase = () => {
 *     trackEvent("purchase", {
 *       productId: product.id,
 *       price: product.price
 *     });
 *   };
 *
 *   return <button onClick={handlePurchase}>Buy Now</button>;
 * }
 *
 * // Identify users
 * import { useIdentify } from "./lib/umami";
 *
 * function AuthProvider({ children, user }) {
 *   const identify = useIdentify();
 *
 *   useEffect(() => {
 *     if (user) {
 *       identify(user.id, { plan: user.plan });
 *     }
 *   }, [user, identify]);
 *
 *   return children;
 * }
 * \`\`\`
 *
 * Features:
 * - Automatic pageview tracking for SPAs
 * - Custom event tracking with properties
 * - User identification across sessions
 * - Privacy-focused: No cookies, GDPR/CCPA compliant
 * - Lightweight: ~1KB gzipped
 * - Open source: Self-hostable
 */
`],
  ["payments/stripe/server/base/src/lib/stripe.ts.hbs", `import Stripe from "stripe";
import { env } from "@{{projectName}}/env/server";

export const stripe = new Stripe(env.STRIPE_SECRET_KEY, {
	apiVersion: "2024-12-18",
});

export async function createCheckoutSession(params: {
	priceId: string;
	successUrl: string;
	cancelUrl: string;
	customerId?: string;
	metadata?: Record<string, string>;
}) {
	const session = await stripe.checkout.sessions.create({
		mode: "payment",
		payment_method_types: ["card"],
		line_items: [
			{
				price: params.priceId,
				quantity: 1,
			},
		],
		success_url: params.successUrl,
		cancel_url: params.cancelUrl,
		customer: params.customerId,
		metadata: params.metadata,
	});

	return session;
}

export async function createSubscriptionCheckout(params: {
	priceId: string;
	successUrl: string;
	cancelUrl: string;
	customerId?: string;
	metadata?: Record<string, string>;
}) {
	const session = await stripe.checkout.sessions.create({
		mode: "subscription",
		payment_method_types: ["card"],
		line_items: [
			{
				price: params.priceId,
				quantity: 1,
			},
		],
		success_url: params.successUrl,
		cancel_url: params.cancelUrl,
		customer: params.customerId,
		metadata: params.metadata,
	});

	return session;
}

export async function constructWebhookEvent(
	payload: string | Buffer,
	signature: string,
) {
	return stripe.webhooks.constructEvent(
		payload,
		signature,
		env.STRIPE_WEBHOOK_SECRET,
	);
}
`],
  ["payments/stripe/web/nuxt/app/pages/success.vue.hbs", `<script setup lang="ts">
const route = useRoute()
const session_id = route.query.session_id as string
</script>

<template>
  <div class="container mx-auto px-4 py-8">
    <h1 class="text-2xl font-bold mb-4">Payment Successful!</h1>
    <p class="text-gray-600 mb-4">
      Thank you for your purchase. Your payment has been processed successfully.
    </p>
    <p v-if="session_id" class="text-sm text-gray-500">
      Session ID: \\{{ session_id }}
    </p>
  </div>
</template>
`],
  ["payments/polar/web/nuxt/app/pages/success.vue.hbs", `<script setup lang="ts">
const route = useRoute()
const checkout_id = route.query.checkout_id as string
</script>

<template>
  <div class="container mx-auto px-4 py-8">
    <h1 class="text-2xl font-bold mb-4">Payment Successful!</h1>
    <p v-if="checkout_id">Checkout ID: \\{{ checkout_id }}</p>
  </div>
</template>
`],
  ["payments/stripe/web/solid/src/routes/success.tsx.hbs", `import { createFileRoute } from "@tanstack/solid-router";
import { Show } from "solid-js";

export const Route = createFileRoute("/success")({
	component: SuccessPage,
	validateSearch: (search) => ({
		session_id: search.session_id as string,
	}),
});

function SuccessPage() {
	const searchParams = Route.useSearch();
	const session_id = searchParams().session_id;

	return (
		<div class="container mx-auto px-4 py-8">
			<h1 class="text-2xl font-bold mb-4">Payment Successful!</h1>
			<p class="text-gray-600 mb-4">
				Thank you for your purchase. Your payment has been processed successfully.
			</p>
			<Show when={session_id}>
				<p class="text-sm text-gray-500">Session ID: {session_id}</p>
			</Show>
		</div>
	);
}
`],
  ["payments/paddle/server/base/src/lib/paddle.ts.hbs", `import {
	Paddle,
	Environment,
	type Product,
	type Price,
	type Subscription,
	type Customer,
	type Transaction,
	type EventEntity,
} from "@paddle/paddle-node-sdk";
import { env } from "@{{projectName}}/env/server";

// Initialize Paddle with your API key
const paddle = new Paddle(env.PADDLE_API_KEY, {
	environment: env.PADDLE_ENVIRONMENT === "production" ? Environment.production : Environment.sandbox,
});

export { paddle };

// Products
export async function listProducts(): Promise<Product[]> {
	const products: Product[] = [];
	const productCollection = paddle.products.list();

	for await (const product of productCollection) {
		products.push(product);
	}

	return products;
}

export async function getProduct(productId: string): Promise<Product> {
	return paddle.products.get(productId);
}

// Prices
export async function listPrices(productId?: string): Promise<Price[]> {
	const prices: Price[] = [];
	const priceCollection = paddle.prices.list(productId ? { productId: [productId] } : undefined);

	for await (const price of priceCollection) {
		prices.push(price);
	}

	return prices;
}

export async function getPrice(priceId: string): Promise<Price> {
	return paddle.prices.get(priceId);
}

// Customers
export async function listCustomers(email?: string): Promise<Customer[]> {
	const customers: Customer[] = [];
	const customerCollection = paddle.customers.list(email ? { email: [email] } : undefined);

	for await (const customer of customerCollection) {
		customers.push(customer);
	}

	return customers;
}

export async function getCustomer(customerId: string): Promise<Customer> {
	return paddle.customers.get(customerId);
}

export async function createCustomer(params: {
	email: string;
	name?: string;
	locale?: string;
}): Promise<Customer> {
	return paddle.customers.create(params);
}

// Subscriptions
export async function listSubscriptions(customerId?: string): Promise<Subscription[]> {
	const subscriptions: Subscription[] = [];
	const subscriptionCollection = paddle.subscriptions.list(
		customerId ? { customerId: [customerId] } : undefined
	);

	for await (const subscription of subscriptionCollection) {
		subscriptions.push(subscription);
	}

	return subscriptions;
}

export async function getSubscription(subscriptionId: string): Promise<Subscription> {
	return paddle.subscriptions.get(subscriptionId);
}

export async function cancelSubscription(
	subscriptionId: string,
	effectiveFrom?: "immediately" | "next_billing_period"
): Promise<Subscription> {
	return paddle.subscriptions.cancel(subscriptionId, {
		effectiveFrom: effectiveFrom ?? "next_billing_period",
	});
}

export async function pauseSubscription(subscriptionId: string): Promise<Subscription> {
	return paddle.subscriptions.pause(subscriptionId, {});
}

export async function resumeSubscription(subscriptionId: string): Promise<Subscription> {
	return paddle.subscriptions.resume(subscriptionId, {
		effectiveFrom: "immediately",
	});
}

// Transactions
export async function listTransactions(customerId?: string): Promise<Transaction[]> {
	const transactions: Transaction[] = [];
	const transactionCollection = paddle.transactions.list(
		customerId ? { customerId: [customerId] } : undefined
	);

	for await (const transaction of transactionCollection) {
		transactions.push(transaction);
	}

	return transactions;
}

export async function getTransaction(transactionId: string): Promise<Transaction> {
	return paddle.transactions.get(transactionId);
}

// Webhook verification
export function verifyWebhookSignature(
	requestBody: string,
	signature: string
): EventEntity | null {
	try {
		// Paddle SDK handles webhook verification internally
		const event = paddle.webhooks.unmarshal(requestBody, env.PADDLE_WEBHOOK_SECRET, signature);
		return event;
	} catch (error) {
		console.error("Webhook verification failed:", error);
		return null;
	}
}

// Webhook event types
export type WebhookEventType =
	| "transaction.billed"
	| "transaction.canceled"
	| "transaction.completed"
	| "transaction.created"
	| "transaction.paid"
	| "transaction.past_due"
	| "transaction.payment_failed"
	| "transaction.ready"
	| "transaction.updated"
	| "subscription.activated"
	| "subscription.canceled"
	| "subscription.created"
	| "subscription.imported"
	| "subscription.past_due"
	| "subscription.paused"
	| "subscription.resumed"
	| "subscription.trialing"
	| "subscription.updated"
	| "customer.created"
	| "customer.imported"
	| "customer.updated"
	| "product.created"
	| "product.imported"
	| "product.updated"
	| "price.created"
	| "price.imported"
	| "price.updated";
`],
  ["payments/paddle/web/nuxt/app/pages/success.vue.hbs", `<script setup lang="ts">
const route = useRoute();
const transactionId = route.query.transaction_id as string | undefined;
</script>

<template>
	<div class="container mx-auto px-4 py-8">
		<h1 class="text-2xl font-bold mb-4">Payment Successful!</h1>
		<p class="text-gray-600 mb-4">
			Thank you for your purchase. Your payment has been processed successfully.
		</p>
		<p v-if="transactionId" class="text-sm text-gray-500">
			Transaction ID: {{ transactionId }}
		</p>
	</div>
</template>
`],
  ["file-storage/r2/server/base/src/lib/storage.ts.hbs", `import {
  S3Client,
  PutObjectCommand,
  GetObjectCommand,
  DeleteObjectCommand,
  ListObjectsV2Command,
  HeadObjectCommand,
  CopyObjectCommand,
  type PutObjectCommandInput,
  type GetObjectCommandInput,
  type ListObjectsV2CommandInput,
} from "@aws-sdk/client-s3";
import { getSignedUrl } from "@aws-sdk/s3-request-presigner";

/**
 * Cloudflare R2 client for file storage (S3-compatible)
 * @see https://developers.cloudflare.com/r2/api/s3/api/
 */
export const r2Client = new S3Client({
  region: "auto",
  endpoint: \`https://\${process.env.R2_ACCOUNT_ID!}.r2.cloudflarestorage.com\`,
  credentials: {
    accessKeyId: process.env.R2_ACCESS_KEY_ID!,
    secretAccessKey: process.env.R2_SECRET_ACCESS_KEY!,
  },
});

const BUCKET_NAME = process.env.R2_BUCKET_NAME!;

/**
 * Storage utilities for common R2 operations
 */

/**
 * Upload a file to R2
 */
export async function uploadFile(
  key: string,
  body: Buffer | Uint8Array | string | ReadableStream,
  options?: {
    contentType?: string;
    metadata?: Record<string, string>;
  }
): Promise<{ key: string; etag?: string }> {
  const input: PutObjectCommandInput = {
    Bucket: BUCKET_NAME,
    Key: key,
    Body: body,
    ContentType: options?.contentType,
    Metadata: options?.metadata,
  };

  const command = new PutObjectCommand(input);
  const response = await r2Client.send(command);

  return {
    key,
    etag: response.ETag,
  };
}

/**
 * Download a file from R2
 */
export async function downloadFile(key: string): Promise<{
  body: ReadableStream | null;
  contentType?: string;
  contentLength?: number;
  metadata?: Record<string, string>;
}> {
  const input: GetObjectCommandInput = {
    Bucket: BUCKET_NAME,
    Key: key,
  };

  const command = new GetObjectCommand(input);
  const response = await r2Client.send(command);

  return {
    body: response.Body?.transformToWebStream() ?? null,
    contentType: response.ContentType,
    contentLength: response.ContentLength,
    metadata: response.Metadata,
  };
}

/**
 * Download file as Buffer
 */
export async function downloadFileAsBuffer(key: string): Promise<Buffer> {
  const input: GetObjectCommandInput = {
    Bucket: BUCKET_NAME,
    Key: key,
  };

  const command = new GetObjectCommand(input);
  const response = await r2Client.send(command);

  if (!response.Body) {
    throw new Error(\`File not found: \${key}\`);
  }

  const bytes = await response.Body.transformToByteArray();
  return Buffer.from(bytes);
}

/**
 * Delete a file from R2
 */
export async function deleteFile(key: string): Promise<void> {
  const command = new DeleteObjectCommand({
    Bucket: BUCKET_NAME,
    Key: key,
  });

  await r2Client.send(command);
}

/**
 * Delete multiple files from R2
 */
export async function deleteFiles(keys: string[]): Promise<void> {
  await Promise.all(keys.map((key) => deleteFile(key)));
}

/**
 * List files in a directory/prefix
 */
export async function listFiles(
  prefix?: string,
  options?: {
    maxKeys?: number;
    continuationToken?: string;
  }
): Promise<{
  files: { key: string; size?: number; lastModified?: Date }[];
  isTruncated: boolean;
  nextContinuationToken?: string;
}> {
  const input: ListObjectsV2CommandInput = {
    Bucket: BUCKET_NAME,
    Prefix: prefix,
    MaxKeys: options?.maxKeys ?? 1000,
    ContinuationToken: options?.continuationToken,
  };

  const command = new ListObjectsV2Command(input);
  const response = await r2Client.send(command);

  return {
    files: (response.Contents ?? []).map((item) => ({
      key: item.Key!,
      size: item.Size,
      lastModified: item.LastModified,
    })),
    isTruncated: response.IsTruncated ?? false,
    nextContinuationToken: response.NextContinuationToken,
  };
}

/**
 * Check if a file exists
 */
export async function fileExists(key: string): Promise<boolean> {
  try {
    const command = new HeadObjectCommand({
      Bucket: BUCKET_NAME,
      Key: key,
    });

    await r2Client.send(command);
    return true;
  } catch {
    return false;
  }
}

/**
 * Get file metadata without downloading the file
 */
export async function getFileMetadata(key: string): Promise<{
  contentType?: string;
  contentLength?: number;
  lastModified?: Date;
  metadata?: Record<string, string>;
} | null> {
  try {
    const command = new HeadObjectCommand({
      Bucket: BUCKET_NAME,
      Key: key,
    });

    const response = await r2Client.send(command);

    return {
      contentType: response.ContentType,
      contentLength: response.ContentLength,
      lastModified: response.LastModified,
      metadata: response.Metadata,
    };
  } catch {
    return null;
  }
}

/**
 * Copy a file within R2
 */
export async function copyFile(
  sourceKey: string,
  destinationKey: string
): Promise<{ key: string; etag?: string }> {
  const command = new CopyObjectCommand({
    Bucket: BUCKET_NAME,
    CopySource: \`\${BUCKET_NAME}/\${sourceKey}\`,
    Key: destinationKey,
  });

  const response = await r2Client.send(command);

  return {
    key: destinationKey,
    etag: response.CopyObjectResult?.ETag,
  };
}

/**
 * Move a file within R2 (copy then delete)
 */
export async function moveFile(
  sourceKey: string,
  destinationKey: string
): Promise<{ key: string; etag?: string }> {
  const result = await copyFile(sourceKey, destinationKey);
  await deleteFile(sourceKey);
  return result;
}

/**
 * Generate a presigned URL for uploading a file
 */
export async function getUploadUrl(
  key: string,
  options?: {
    expiresIn?: number; // seconds, default 3600 (1 hour)
    contentType?: string;
  }
): Promise<string> {
  const command = new PutObjectCommand({
    Bucket: BUCKET_NAME,
    Key: key,
    ContentType: options?.contentType,
  });

  return getSignedUrl(r2Client, command, {
    expiresIn: options?.expiresIn ?? 3600,
  });
}

/**
 * Generate a presigned URL for downloading a file
 */
export async function getDownloadUrl(
  key: string,
  options?: {
    expiresIn?: number; // seconds, default 3600 (1 hour)
    responseContentDisposition?: string;
  }
): Promise<string> {
  const command = new GetObjectCommand({
    Bucket: BUCKET_NAME,
    Key: key,
    ResponseContentDisposition: options?.responseContentDisposition,
  });

  return getSignedUrl(r2Client, command, {
    expiresIn: options?.expiresIn ?? 3600,
  });
}

/**
 * Get the public URL for a file (requires public bucket or custom domain)
 * @param key - The file key
 * @param customDomain - Optional custom domain for public access (e.g., "files.example.com")
 */
export function getPublicUrl(key: string, customDomain?: string): string {
  if (customDomain) {
    return \`https://\${customDomain}/\${key}\`;
  }
  // R2 public buckets use the format: https://pub-<hash>.r2.dev/<key>
  // This requires setting up public access in Cloudflare dashboard
  return \`https://\${BUCKET_NAME}.\${process.env.R2_ACCOUNT_ID}.r2.dev/\${key}\`;
}
`],
  ["payments/lemon-squeezy/web/nuxt/app/pages/success.vue.hbs", `<script setup lang="ts">
const route = useRoute();
const checkoutId = computed(() => route.query.checkout_id as string | undefined);
</script>

<template>
	<div class="container mx-auto px-4 py-8">
		<h1 class="text-2xl font-bold mb-4">Payment Successful!</h1>
		<p class="text-gray-600 mb-4">
			Thank you for your purchase. Your payment has been processed successfully.
		</p>
		<p v-if="checkoutId" class="text-sm text-gray-500">
			Checkout ID: {{ checkoutId }}
		</p>
	</div>
</template>
`],
  ["examples/ai/native/bare/app/(drawer)/ai.tsx.hbs", `{{#if (eq backend "convex")}}
import { Ionicons } from "@expo/vector-icons";
import {
  useUIMessages,
  useSmoothText,
  type UIMessage,
} from "@convex-dev/agent/react";
import { api } from "@{{projectName}}/backend/convex/_generated/api";
import { useMutation } from "convex/react";
import { useRef, useEffect, useState } from "react";
import {
  View,
  Text,
  TextInput,
  TouchableOpacity,
  ScrollView,
  KeyboardAvoidingView,
  Platform,
  StyleSheet,
  ActivityIndicator,
} from "react-native";

import { Container } from "@/components/container";
import { useColorScheme } from "@/lib/use-color-scheme";
import { NAV_THEME } from "@/lib/constants";

function MessageContent({
  text,
  isStreaming,
  textColor,
}: {
  text: string;
  isStreaming: boolean;
  textColor: string;
}) {
  const [visibleText] = useSmoothText(text, {
    startStreaming: isStreaming,
  });
  return <Text style={[styles.messageText, { color: textColor }]}>{visibleText}</Text>;
}

export default function AIScreen() {
  const { colorScheme } = useColorScheme();
  const theme = colorScheme === "dark" ? NAV_THEME.dark : NAV_THEME.light;
  const [input, setInput] = useState("");
  const [threadId, setThreadId] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const scrollViewRef = useRef<ScrollView>(null);

  const createThread = useMutation(api.chat.createNewThread);
  const sendMessage = useMutation(api.chat.sendMessage);

  const { results: messages } = useUIMessages(
    api.chat.listMessages,
    threadId ? { threadId } : "skip",
    { initialNumItems: 50, stream: true },
  );

  const hasStreamingMessage = messages?.some(
    (m: UIMessage) => m.status === "streaming",
  );

  useEffect(() => {
    scrollViewRef.current?.scrollToEnd({ animated: true });
  }, [messages]);

  async function onSubmit() {
    const value = input.trim();
    if (!value || isLoading) return;

    setIsLoading(true);
    setInput("");

    try {
      let currentThreadId = threadId;
      if (!currentThreadId) {
        currentThreadId = await createThread();
        setThreadId(currentThreadId);
      }

      await sendMessage({ threadId: currentThreadId, prompt: value });
    } catch (error) {
      console.error("Failed to send message:", error);
    } finally {
      setIsLoading(false);
    }
  }

  return (
    <Container>
      <KeyboardAvoidingView
        style={styles.container}
        behavior={Platform.OS === "ios" ? "padding" : "height"}
      >
        <View style={styles.content}>
          <View style={styles.header}>
            <Text style={[styles.headerTitle, { color: theme.text }]}>
              AI Chat
            </Text>
            <Text style={[styles.headerSubtitle, { color: theme.text, opacity: 0.7 }]}>
              Chat with our AI assistant
            </Text>
          </View>
          <ScrollView
            ref={scrollViewRef}
            style={styles.scrollView}
            showsVerticalScrollIndicator={false}
          >
            {!messages || messages.length === 0 ? (
              <View style={styles.emptyContainer}>
                <Text style={[styles.emptyText, { color: theme.text, opacity: 0.7 }]}>
                  Ask me anything to get started!
                </Text>
              </View>
            ) : (
              <View style={styles.messagesList}>
                {messages.map((message: UIMessage) => (
                  <View
                    key={message.key}
                    style={[
                      styles.messageCard,
                      {
                        backgroundColor: message.role === "user"
                          ? theme.primary + "20"
                          : theme.card,
                        borderColor: theme.border,
                        alignSelf: message.role === "user" ? "flex-end" : "flex-start",
                        marginLeft: message.role === "user" ? 32 : 0,
                        marginRight: message.role === "user" ? 0 : 32,
                      },
                    ]}
                  >
                    <Text style={[styles.messageRole, { color: theme.text }]}>
                      {message.role === "user" ? "You" : "AI Assistant"}
                    </Text>
                    <MessageContent
                      text={message.text ?? ""}
                      isStreaming={message.status === "streaming"}
                      textColor={theme.text}
                    />
                  </View>
                ))}
                {isLoading && !hasStreamingMessage && (
                  <View
                    style={[
                      styles.messageCard,
                      {
                        backgroundColor: theme.card,
                        borderColor: theme.border,
                        alignSelf: "flex-start",
                        marginRight: 32,
                      },
                    ]}
                  >
                    <Text style={[styles.messageRole, { color: theme.text }]}>
                      AI Assistant
                    </Text>
                    <View style={styles.loadingContainer}>
                      <ActivityIndicator size="small" color={theme.primary} />
                      <Text style={[styles.loadingText, { color: theme.text, opacity: 0.7 }]}>
                        Thinking...
                      </Text>
                    </View>
                  </View>
                )}
              </View>
            )}
          </ScrollView>
          <View style={[styles.inputContainer, { borderTopColor: theme.border }]}>
            <View style={styles.inputRow}>
              <TextInput
                value={input}
                onChangeText={setInput}
                placeholder="Type your message..."
                placeholderTextColor={theme.text}
                style={[
                  styles.input,
                  {
                    color: theme.text,
                    borderColor: theme.border,
                    backgroundColor: theme.background,
                  },
                ]}
                onSubmitEditing={(e) => {
                  e.preventDefault();
                  onSubmit();
                }}
                editable={!isLoading}
                autoFocus={true}
                multiline
              />
              <TouchableOpacity
                onPress={onSubmit}
                disabled={!input.trim() || isLoading}
                style={[
                  styles.sendButton,
                  {
                    backgroundColor: input.trim() && !isLoading ? theme.primary : theme.border,
                    opacity: input.trim() && !isLoading ? 1 : 0.5,
                  },
                ]}
              >
                <Ionicons
                  name="send"
                  size={20}
                  color="#ffffff"
                />
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </KeyboardAvoidingView>
    </Container>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  content: {
    flex: 1,
    padding: 16,
  },
  header: {
    marginBottom: 16,
  },
  headerTitle: {
    fontSize: 20,
    fontWeight: "bold",
    marginBottom: 4,
  },
  headerSubtitle: {
    fontSize: 14,
  },
  scrollView: {
    flex: 1,
    marginBottom: 16,
  },
  emptyContainer: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
  },
  emptyText: {
    fontSize: 16,
    textAlign: "center",
  },
  messagesList: {
    gap: 8,
    paddingBottom: 16,
  },
  messageCard: {
    borderWidth: 1,
    padding: 12,
    maxWidth: "80%",
  },
  messageRole: {
    fontSize: 12,
    fontWeight: "bold",
    marginBottom: 4,
  },
  messageText: {
    fontSize: 14,
    lineHeight: 20,
  },
  loadingContainer: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
  },
  loadingText: {
    fontSize: 14,
  },
  inputContainer: {
    borderTopWidth: 1,
    paddingTop: 12,
  },
  inputRow: {
    flexDirection: "row",
    alignItems: "flex-end",
    gap: 8,
  },
  input: {
    flex: 1,
    borderWidth: 1,
    padding: 8,
    fontSize: 14,
    minHeight: 36,
    maxHeight: 100,
  },
  sendButton: {
    padding: 8,
    justifyContent: "center",
    alignItems: "center",
  },
});
{{else}}
import { useRef, useEffect, useState } from "react";
import {
  View,
  Text,
  TextInput,
  TouchableOpacity,
  ScrollView,
  KeyboardAvoidingView,
  Platform,
  StyleSheet,
} from "react-native";
import { useChat } from "@ai-sdk/react";
import { DefaultChatTransport } from "ai";
import { fetch as expoFetch } from "expo/fetch";
import { Ionicons } from "@expo/vector-icons";
import { Container } from "@/components/container";
import { useColorScheme } from "@/lib/use-color-scheme";
import { NAV_THEME } from "@/lib/constants";
import { env } from "@{{projectName}}/env/native";

const generateAPIUrl = (relativePath: string) => {
  const serverUrl = env.EXPO_PUBLIC_SERVER_URL;
  if (!serverUrl) {
    throw new Error(
      "EXPO_PUBLIC_SERVER_URL environment variable is not defined"
    );
  }
  const path = relativePath.startsWith("/") ? relativePath : \`/\${relativePath}\`;
  return serverUrl.concat(path);
};

export default function AIScreen() {
  const { colorScheme } = useColorScheme();
  const theme = colorScheme === "dark" ? NAV_THEME.dark : NAV_THEME.light;
  const [input, setInput] = useState("");
  const { messages, error, sendMessage } = useChat({
    transport: new DefaultChatTransport({
      fetch: expoFetch as unknown as typeof globalThis.fetch,
      api: generateAPIUrl("/ai"),
    }),
    onError: (error) => console.error(error, "AI Chat Error"),
  });
  const scrollViewRef = useRef<ScrollView>(null);

  useEffect(() => {
    scrollViewRef.current?.scrollToEnd({ animated: true });
  }, [messages]);

  function onSubmit() {
    const value = input.trim();
    if (value) {
      sendMessage({ text: value });
      setInput("");
    }
  }

  if (error) {
    return (
      <Container>
        <View style={styles.errorContainer}>
          <View style={[styles.errorCard, { backgroundColor: theme.notification + "20", borderColor: theme.notification }]}>
            <Text style={[styles.errorTitle, { color: theme.notification }]}>
              Error: {error.message}
            </Text>
            <Text style={[styles.errorText, { color: theme.text, opacity: 0.7 }]}>
              Please check your connection and try again.
            </Text>
          </View>
        </View>
      </Container>
    );
  }

  return (
    <Container>
      <KeyboardAvoidingView
        style={styles.container}
        behavior={Platform.OS === "ios" ? "padding" : "height"}
      >
        <View style={styles.content}>
          <View style={styles.header}>
            <Text style={[styles.headerTitle, { color: theme.text }]}>
              AI Chat
            </Text>
            <Text style={[styles.headerSubtitle, { color: theme.text, opacity: 0.7 }]}>
              Chat with our AI assistant
            </Text>
          </View>
          <ScrollView
            ref={scrollViewRef}
            style={styles.scrollView}
            showsVerticalScrollIndicator={false}
          >
            {messages.length === 0 ? (
              <View style={styles.emptyContainer}>
                <Text style={[styles.emptyText, { color: theme.text, opacity: 0.7 }]}>
                  Ask me anything to get started!
                </Text>
              </View>
            ) : (
              <View style={styles.messagesList}>
                {messages.map((message) => (
                  <View
                    key={message.id}
                    style={[
                      styles.messageCard,
                      {
                        backgroundColor: message.role === "user"
                          ? theme.primary + "20"
                          : theme.card,
                        borderColor: theme.border,
                        alignSelf: message.role === "user" ? "flex-end" : "flex-start",
                        marginLeft: message.role === "user" ? 32 : 0,
                        marginRight: message.role === "user" ? 0 : 32,
                      },
                    ]}
                  >
                    <Text style={[styles.messageRole, { color: theme.text }]}>
                      {message.role === "user" ? "You" : "AI Assistant"}
                    </Text>
                    <View style={styles.messageParts}>
                      {message.parts.map((part, i) =>
                        part.type === "text" ? (
                          <Text
                            key={\`\${message.id}-\${i}\`}
                            style={[styles.messageText, { color: theme.text }]}
                          >
                            {part.text}
                          </Text>
                        ) : (
                          <Text
                            key={\`\${message.id}-\${i}\`}
                            style={[styles.messageText, { color: theme.text }]}
                          >
                            {JSON.stringify(part)}
                          </Text>
                        )
                      )}
                    </View>
                  </View>
                ))}
              </View>
            )}
          </ScrollView>
          <View style={[styles.inputContainer, { borderTopColor: theme.border }]}>
            <View style={styles.inputRow}>
              <TextInput
                value={input}
                onChangeText={setInput}
                placeholder="Type your message..."
                placeholderTextColor={theme.text}
                style={[
                  styles.input,
                  {
                    color: theme.text,
                    borderColor: theme.border,
                    backgroundColor: theme.background,
                  },
                ]}
                onSubmitEditing={(e) => {
                  e.preventDefault();
                  onSubmit();
                }}
                autoFocus={true}
                multiline
              />
              <TouchableOpacity
                onPress={onSubmit}
                disabled={!input.trim()}
                style={[
                  styles.sendButton,
                  {
                    backgroundColor: input.trim() ? theme.primary : theme.border,
                    opacity: input.trim() ? 1 : 0.5,
                  },
                ]}
              >
                <Ionicons
                  name="send"
                  size={20}
                  color="#ffffff"
                />
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </KeyboardAvoidingView>
    </Container>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  content: {
    flex: 1,
    padding: 16,
  },
  header: {
    marginBottom: 16,
  },
  headerTitle: {
    fontSize: 20,
    fontWeight: "bold",
    marginBottom: 4,
  },
  headerSubtitle: {
    fontSize: 14,
  },
  scrollView: {
    flex: 1,
    marginBottom: 16,
  },
  emptyContainer: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
  },
  emptyText: {
    fontSize: 16,
    textAlign: "center",
  },
  messagesList: {
    gap: 8,
    paddingBottom: 16,
  },
  messageCard: {
    borderWidth: 1,
    padding: 12,
    maxWidth: "80%",
  },
  messageRole: {
    fontSize: 12,
    fontWeight: "bold",
    marginBottom: 4,
  },
  messageParts: {
    gap: 4,
  },
  messageText: {
    fontSize: 14,
    lineHeight: 20,
  },
  inputContainer: {
    borderTopWidth: 1,
    paddingTop: 12,
  },
  inputRow: {
    flexDirection: "row",
    alignItems: "flex-end",
    gap: 8,
  },
  input: {
    flex: 1,
    borderWidth: 1,
    padding: 8,
    fontSize: 14,
    minHeight: 36,
    maxHeight: 100,
  },
  sendButton: {
    padding: 8,
    justifyContent: "center",
    alignItems: "center",
  },
  errorContainer: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    padding: 16,
  },
  errorCard: {
    borderWidth: 1,
    padding: 16,
  },
  errorTitle: {
    fontSize: 16,
    fontWeight: "bold",
    marginBottom: 8,
    textAlign: "center",
  },
  errorText: {
    fontSize: 14,
    textAlign: "center",
  },
});
{{/if}}
`],
  ["examples/ai/native/uniwind/app/(drawer)/ai.tsx.hbs", `{{#if (eq backend "convex")}}
import { Ionicons } from "@expo/vector-icons";
import {
  useUIMessages,
  useSmoothText,
  type UIMessage,
} from "@convex-dev/agent/react";
import { api } from "@{{projectName}}/backend/convex/_generated/api";
import { useMutation } from "convex/react";
import { Button, Divider, Spinner, Surface, TextField, useThemeColor } from "heroui-native";
import { useRef, useEffect, useState } from "react";
import {
  View,
  Text,
  ScrollView,
  KeyboardAvoidingView,
  Platform,
} from "react-native";

import { Container } from "@/components/container";

function MessageContent({
  text,
  isStreaming,
}: {
  text: string;
  isStreaming: boolean;
}) {
  const [visibleText] = useSmoothText(text, {
    startStreaming: isStreaming,
  });
  return <Text className="text-foreground text-sm leading-relaxed">{visibleText}</Text>;
}

export default function AIScreen() {
  const [input, setInput] = useState("");
  const [threadId, setThreadId] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const scrollViewRef = useRef<ScrollView>(null);
  const mutedColor = useThemeColor("muted");
  const foregroundColor = useThemeColor("foreground");

  const createThread = useMutation(api.chat.createNewThread);
  const sendMessage = useMutation(api.chat.sendMessage);

  const { results: messages } = useUIMessages(
    api.chat.listMessages,
    threadId ? { threadId } : "skip",
    { initialNumItems: 50, stream: true },
  );

  const hasStreamingMessage = messages?.some(
    (m: UIMessage) => m.status === "streaming",
  );

  useEffect(() => {
    scrollViewRef.current?.scrollToEnd({ animated: true });
  }, [messages]);

  const onSubmit = async () => {
    const value = input.trim();
    if (!value || isLoading) return;

    setIsLoading(true);
    setInput("");

    try {
      let currentThreadId = threadId;
      if (!currentThreadId) {
        currentThreadId = await createThread();
        setThreadId(currentThreadId);
      }

      await sendMessage({ threadId: currentThreadId, prompt: value });
    } catch (error) {
      console.error("Failed to send message:", error);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <Container>
      <KeyboardAvoidingView
        className="flex-1"
        behavior={Platform.OS === "ios" ? "padding" : "height"}
      >
        <View className="flex-1 px-4 py-4">
          <View className="py-4 mb-4">
            <Text className="text-2xl font-semibold text-foreground tracking-tight">AI Chat</Text>
            <Text className="text-muted text-sm mt-1">Chat with our AI assistant</Text>
          </View>

          <ScrollView
            ref={scrollViewRef}
            className="flex-1 mb-4"
            showsVerticalScrollIndicator={false}
          >
            {!messages || messages.length === 0 ? (
              <View className="flex-1 justify-center items-center py-10">
                <Ionicons name="chatbubble-ellipses-outline" size={32} color={mutedColor} />
                <Text className="text-muted text-sm mt-3">Ask me anything to get started</Text>
              </View>
            ) : (
              <View className="gap-2">
                {messages.map((message: UIMessage) => (
                  <Surface
                    key={message.key}
                    variant={message.role === "user" ? "tertiary" : "secondary"}
                    className={\`p-3 rounded-lg \${message.role === "user" ? "ml-10" : "mr-10"}\`}
                  >
                    <Text className="text-xs font-medium mb-1 text-muted">
                      {message.role === "user" ? "You" : "AI"}
                    </Text>
                    <MessageContent
                      text={message.text ?? ""}
                      isStreaming={message.status === "streaming"}
                    />
                  </Surface>
                ))}
                {isLoading && !hasStreamingMessage && (
                  <Surface variant="secondary" className="p-3 mr-10 rounded-lg">
                    <Text className="text-xs font-medium mb-1 text-muted">AI</Text>
                    <View className="flex-row items-center gap-2">
                      <Spinner size="sm" />
                      <Text className="text-muted text-sm">Thinking...</Text>
                    </View>
                  </Surface>
                )}
              </View>
            )}
          </ScrollView>

          <Divider className="mb-3" />

          <View className="flex-row items-center gap-2">
            <View className="flex-1">
              <TextField>
                <TextField.Input
                  value={input}
                  onChangeText={setInput}
                  placeholder="Type a message..."
                  onSubmitEditing={onSubmit}
                  editable={!isLoading}
                  autoFocus
                />
              </TextField>
            </View>
            <Button
              isIconOnly
              variant={input.trim() && !isLoading ? "primary" : "secondary"}
              onPress={onSubmit}
              isDisabled={!input.trim() || isLoading}
              size="sm"
            >
              <Ionicons
                name="arrow-up"
                size={18}
                color={input.trim() && !isLoading ? foregroundColor : mutedColor}
              />
            </Button>
          </View>
        </View>
      </KeyboardAvoidingView>
    </Container>
  );
}
{{else}}
import { useRef, useEffect, useState } from "react";
import {
  View,
  Text,
  ScrollView,
  KeyboardAvoidingView,
  Platform,
} from "react-native";
import { useChat } from "@ai-sdk/react";
import { DefaultChatTransport } from "ai";
import { fetch as expoFetch } from "expo/fetch";
import { Ionicons } from "@expo/vector-icons";
import { Container } from "@/components/container";
import { Button, Divider, ErrorView, Spinner, Surface, TextField, useThemeColor } from "heroui-native";
import { env } from "@{{projectName}}/env/native";

const generateAPIUrl = (relativePath: string) => {
  const serverUrl = env.EXPO_PUBLIC_SERVER_URL;
  if (!serverUrl) {
    throw new Error(
      "EXPO_PUBLIC_SERVER_URL environment variable is not defined"
    );
  }
  const path = relativePath.startsWith("/") ? relativePath : \`/\${relativePath}\`;
  return serverUrl.concat(path);
};

export default function AIScreen() {
  const [input, setInput] = useState("");
  const { messages, error, sendMessage } = useChat({
    transport: new DefaultChatTransport({
      fetch: expoFetch as unknown as typeof globalThis.fetch,
      api: generateAPIUrl("/ai"),
    }),
    onError: (error) => console.error(error, "AI Chat Error"),
  });
  const scrollViewRef = useRef<ScrollView>(null);
  const foregroundColor = useThemeColor("foreground");
  const mutedColor = useThemeColor("muted");

  useEffect(() => {
    scrollViewRef.current?.scrollToEnd({ animated: true });
  }, [messages]);

  const onSubmit = () => {
    const value = input.trim();
    if (value) {
      sendMessage({ text: value });
      setInput("");
    }
  };

  if (error) {
    return (
      <Container>
        <View className="flex-1 justify-center items-center px-4">
          <Surface variant="secondary" className="p-4 rounded-lg">
            <ErrorView isInvalid>
              <Text className="text-danger text-center font-medium mb-1">
                {error.message}
              </Text>
              <Text className="text-muted text-center text-xs">
                Please check your connection and try again.
              </Text>
            </ErrorView>
          </Surface>
        </View>
      </Container>
    );
  }

  return (
    <Container>
      <KeyboardAvoidingView
        className="flex-1"
        behavior={Platform.OS === "ios" ? "padding" : "height"}
      >
        <View className="flex-1 px-4 py-4">
          <View className="py-4 mb-4">
            <Text className="text-2xl font-semibold text-foreground tracking-tight">AI Chat</Text>
            <Text className="text-muted text-sm mt-1">Chat with our AI assistant</Text>
          </View>

          <ScrollView
            ref={scrollViewRef}
            className="flex-1 mb-4"
            showsVerticalScrollIndicator={false}
          >
            {messages.length === 0 ? (
              <View className="flex-1 justify-center items-center py-10">
                <Ionicons name="chatbubble-ellipses-outline" size={32} color={mutedColor} />
                <Text className="text-muted text-sm mt-3">Ask me anything to get started</Text>
              </View>
            ) : (
              <View className="gap-2">
                {messages.map((message) => (
                  <Surface
                    key={message.id}
                    variant={message.role === "user" ? "tertiary" : "secondary"}
                    className={\`p-3 rounded-lg \${message.role === "user" ? "ml-10" : "mr-10"}\`}
                  >
                    <Text className="text-xs font-medium mb-1 text-muted">
                      {message.role === "user" ? "You" : "AI"}
                    </Text>
                    <View className="gap-1">
                      {message.parts.map((part, i) =>
                        part.type === "text" ? (
                          <Text
                            key={\`\${message.id}-\${i}\`}
                            className="text-foreground text-sm leading-relaxed"
                          >
                            {part.text}
                          </Text>
                        ) : (
                          <Text
                            key={\`\${message.id}-\${i}\`}
                            className="text-foreground text-sm leading-relaxed"
                          >
                            {JSON.stringify(part)}
                          </Text>
                        )
                      )}
                    </View>
                  </Surface>
                ))}
              </View>
            )}
          </ScrollView>

          <Divider className="mb-3" />

          <View className="flex-row items-center gap-2">
            <View className="flex-1">
              <TextField>
                <TextField.Input
                  value={input}
                  onChangeText={setInput}
                  placeholder="Type a message..."
                  onSubmitEditing={onSubmit}
                  autoFocus
                />
              </TextField>
            </View>
            <Button
              isIconOnly
              variant={input.trim() ? "primary" : "secondary"}
              onPress={onSubmit}
              isDisabled={!input.trim()}
              size="sm"
            >
              <Ionicons
                name="arrow-up"
                size={18}
                color={input.trim() ? foregroundColor : mutedColor}
              />
            </Button>
          </View>
        </View>
      </KeyboardAvoidingView>
    </Container>
  );
}
{{/if}}
`],
  ["file-storage/s3/server/base/src/lib/storage.ts.hbs", `import {
  S3Client,
  PutObjectCommand,
  GetObjectCommand,
  DeleteObjectCommand,
  ListObjectsV2Command,
  HeadObjectCommand,
  CopyObjectCommand,
  type PutObjectCommandInput,
  type GetObjectCommandInput,
  type ListObjectsV2CommandInput,
} from "@aws-sdk/client-s3";
import { getSignedUrl } from "@aws-sdk/s3-request-presigner";

/**
 * AWS S3 client for file storage
 * @see https://docs.aws.amazon.com/AWSJavaScriptSDK/v3/latest/client/s3/
 */
export const s3Client = new S3Client({
  region: process.env.AWS_S3_REGION!,
  credentials: {
    accessKeyId: process.env.AWS_S3_ACCESS_KEY_ID!,
    secretAccessKey: process.env.AWS_S3_SECRET_ACCESS_KEY!,
  },
});

const BUCKET_NAME = process.env.AWS_S3_BUCKET_NAME!;

/**
 * Storage utilities for common S3 operations
 */

/**
 * Upload a file to S3
 */
export async function uploadFile(
  key: string,
  body: Buffer | Uint8Array | string | ReadableStream,
  options?: {
    contentType?: string;
    metadata?: Record<string, string>;
    acl?: "private" | "public-read";
  }
): Promise<{ key: string; etag?: string }> {
  const input: PutObjectCommandInput = {
    Bucket: BUCKET_NAME,
    Key: key,
    Body: body,
    ContentType: options?.contentType,
    Metadata: options?.metadata,
    ACL: options?.acl,
  };

  const command = new PutObjectCommand(input);
  const response = await s3Client.send(command);

  return {
    key,
    etag: response.ETag,
  };
}

/**
 * Download a file from S3
 */
export async function downloadFile(key: string): Promise<{
  body: ReadableStream | null;
  contentType?: string;
  contentLength?: number;
  metadata?: Record<string, string>;
}> {
  const input: GetObjectCommandInput = {
    Bucket: BUCKET_NAME,
    Key: key,
  };

  const command = new GetObjectCommand(input);
  const response = await s3Client.send(command);

  return {
    body: response.Body?.transformToWebStream() ?? null,
    contentType: response.ContentType,
    contentLength: response.ContentLength,
    metadata: response.Metadata,
  };
}

/**
 * Download file as Buffer
 */
export async function downloadFileAsBuffer(key: string): Promise<Buffer> {
  const input: GetObjectCommandInput = {
    Bucket: BUCKET_NAME,
    Key: key,
  };

  const command = new GetObjectCommand(input);
  const response = await s3Client.send(command);

  if (!response.Body) {
    throw new Error(\`File not found: \${key}\`);
  }

  const bytes = await response.Body.transformToByteArray();
  return Buffer.from(bytes);
}

/**
 * Delete a file from S3
 */
export async function deleteFile(key: string): Promise<void> {
  const command = new DeleteObjectCommand({
    Bucket: BUCKET_NAME,
    Key: key,
  });

  await s3Client.send(command);
}

/**
 * Delete multiple files from S3
 */
export async function deleteFiles(keys: string[]): Promise<void> {
  await Promise.all(keys.map((key) => deleteFile(key)));
}

/**
 * List files in a directory/prefix
 */
export async function listFiles(
  prefix?: string,
  options?: {
    maxKeys?: number;
    continuationToken?: string;
  }
): Promise<{
  files: { key: string; size?: number; lastModified?: Date }[];
  isTruncated: boolean;
  nextContinuationToken?: string;
}> {
  const input: ListObjectsV2CommandInput = {
    Bucket: BUCKET_NAME,
    Prefix: prefix,
    MaxKeys: options?.maxKeys ?? 1000,
    ContinuationToken: options?.continuationToken,
  };

  const command = new ListObjectsV2Command(input);
  const response = await s3Client.send(command);

  return {
    files: (response.Contents ?? []).map((item) => ({
      key: item.Key!,
      size: item.Size,
      lastModified: item.LastModified,
    })),
    isTruncated: response.IsTruncated ?? false,
    nextContinuationToken: response.NextContinuationToken,
  };
}

/**
 * Check if a file exists
 */
export async function fileExists(key: string): Promise<boolean> {
  try {
    const command = new HeadObjectCommand({
      Bucket: BUCKET_NAME,
      Key: key,
    });

    await s3Client.send(command);
    return true;
  } catch {
    return false;
  }
}

/**
 * Get file metadata without downloading the file
 */
export async function getFileMetadata(key: string): Promise<{
  contentType?: string;
  contentLength?: number;
  lastModified?: Date;
  metadata?: Record<string, string>;
} | null> {
  try {
    const command = new HeadObjectCommand({
      Bucket: BUCKET_NAME,
      Key: key,
    });

    const response = await s3Client.send(command);

    return {
      contentType: response.ContentType,
      contentLength: response.ContentLength,
      lastModified: response.LastModified,
      metadata: response.Metadata,
    };
  } catch {
    return null;
  }
}

/**
 * Copy a file within S3
 */
export async function copyFile(
  sourceKey: string,
  destinationKey: string
): Promise<{ key: string; etag?: string }> {
  const command = new CopyObjectCommand({
    Bucket: BUCKET_NAME,
    CopySource: \`\${BUCKET_NAME}/\${sourceKey}\`,
    Key: destinationKey,
  });

  const response = await s3Client.send(command);

  return {
    key: destinationKey,
    etag: response.CopyObjectResult?.ETag,
  };
}

/**
 * Move a file within S3 (copy then delete)
 */
export async function moveFile(
  sourceKey: string,
  destinationKey: string
): Promise<{ key: string; etag?: string }> {
  const result = await copyFile(sourceKey, destinationKey);
  await deleteFile(sourceKey);
  return result;
}

/**
 * Generate a presigned URL for uploading a file
 */
export async function getUploadUrl(
  key: string,
  options?: {
    expiresIn?: number; // seconds, default 3600 (1 hour)
    contentType?: string;
  }
): Promise<string> {
  const command = new PutObjectCommand({
    Bucket: BUCKET_NAME,
    Key: key,
    ContentType: options?.contentType,
  });

  return getSignedUrl(s3Client, command, {
    expiresIn: options?.expiresIn ?? 3600,
  });
}

/**
 * Generate a presigned URL for downloading a file
 */
export async function getDownloadUrl(
  key: string,
  options?: {
    expiresIn?: number; // seconds, default 3600 (1 hour)
    responseContentDisposition?: string;
  }
): Promise<string> {
  const command = new GetObjectCommand({
    Bucket: BUCKET_NAME,
    Key: key,
    ResponseContentDisposition: options?.responseContentDisposition,
  });

  return getSignedUrl(s3Client, command, {
    expiresIn: options?.expiresIn ?? 3600,
  });
}

/**
 * Get the public URL for a file (only works if bucket/file has public access)
 */
export function getPublicUrl(key: string): string {
  return \`https://\${BUCKET_NAME}.s3.\${process.env.AWS_S3_REGION}.amazonaws.com/\${key}\`;
}
`],
  ["payments/polar/server/base/src/lib/payments.ts.hbs", `import { Polar } from "@polar-sh/sdk";
import { env } from "@{{projectName}}/env/server";

export const polarClient = new Polar({
	accessToken: env.POLAR_ACCESS_TOKEN,
	server: "sandbox",
});
`],
  ["payments/paddle/web/solid/src/routes/success.tsx.hbs", `import { useSearchParams } from "@solidjs/router";

export default function SuccessPage() {
	const [searchParams] = useSearchParams();
	const transactionId = () => searchParams.transaction_id;

	return (
		<div class="container mx-auto px-4 py-8">
			<h1 class="text-2xl font-bold mb-4">Payment Successful!</h1>
			<p class="text-gray-600 mb-4">
				Thank you for your purchase. Your payment has been processed successfully.
			</p>
			{transactionId() && (
				<p class="text-sm text-gray-500">Transaction ID: {transactionId()}</p>
			)}
		</div>
	);
}
`],
  ["examples/ai/web/nuxt/app/pages/ai.vue.hbs", `<script setup lang="ts">
import { Chat } from '@ai-sdk/vue'
import type { UIMessage } from 'ai'
import { getTextFromMessage } from '@nuxt/ui/utils/ai'
import { DefaultChatTransport } from 'ai'
import { ref } from 'vue'

const config = useRuntimeConfig()
const messages: UIMessage[] = []
const input = ref('')

const chat = new Chat({
  messages,
  transport: new DefaultChatTransport({
    api: \`\${config.public.serverUrl}/ai\`,
  }),
  onError(error) {
    console.error('Chat error:', error)
  }
})

async function handleSubmit(e: Event) {
  e.preventDefault()
  const userInput = input.value
  input.value = ''

  if (!userInput.trim()) return

  chat.sendMessage({ text: userInput })
}
</script>

<template>
  <UContainer class="h-full flex flex-col overflow-hidden py-4">
    <div class="flex-1 min-h-0 overflow-y-auto">
      <UChatMessages :messages="chat.messages" :status="chat.status">
        <template #content="{ message }">
          <div class="whitespace-pre-wrap">\\{{ getTextFromMessage(message) }}</div>
        </template>
      </UChatMessages>
    </div>

    <div class="shrink-0 pt-4 border-t border-gray-200 dark:border-gray-800">
      <UChatPrompt
        v-model="input"
        :error="chat.error"
        @submit="handleSubmit"
        placeholder="Type your message..."
      >
        <UChatPromptSubmit :status="chat.status" @stop="() => chat.stop()" @reload="() => chat.regenerate()" />
      </UChatPrompt>
    </div>
  </UContainer>
</template>`],
  ["examples/ai/native/unistyles/app/(drawer)/ai.tsx.hbs", `{{#if (eq backend "convex")}}
import { Ionicons } from "@expo/vector-icons";
import {
  useUIMessages,
  useSmoothText,
  type UIMessage,
} from "@convex-dev/agent/react";
import { api } from "@{{projectName}}/backend/convex/_generated/api";
import { useMutation } from "convex/react";
import React, { useRef, useEffect, useState } from "react";
import {
  View,
  Text,
  TextInput,
  TouchableOpacity,
  ScrollView,
  KeyboardAvoidingView,
  Platform,
  ActivityIndicator,
} from "react-native";
import { StyleSheet, useUnistyles } from "react-native-unistyles";

import { Container } from "@/components/container";

function MessageContent({
  text,
  isStreaming,
  style,
}: {
  text: string;
  isStreaming: boolean;
  style: object;
}) {
  const [visibleText] = useSmoothText(text, {
    startStreaming: isStreaming,
  });
  return <Text style={style}>{visibleText}</Text>;
}

export default function AIScreen() {
  const { theme } = useUnistyles();
  const [input, setInput] = useState("");
  const [threadId, setThreadId] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const scrollViewRef = useRef<ScrollView>(null);

  const createThread = useMutation(api.chat.createNewThread);
  const sendMessage = useMutation(api.chat.sendMessage);

  const { results: messages } = useUIMessages(
    api.chat.listMessages,
    threadId ? { threadId } : "skip",
    { initialNumItems: 50, stream: true },
  );

  const hasStreamingMessage = messages?.some(
    (m: UIMessage) => m.status === "streaming",
  );

  useEffect(() => {
    scrollViewRef.current?.scrollToEnd({ animated: true });
  }, [messages]);

  const onSubmit = async () => {
    const value = input.trim();
    if (!value || isLoading) return;

    setIsLoading(true);
    setInput("");

    try {
      let currentThreadId = threadId;
      if (!currentThreadId) {
        currentThreadId = await createThread();
        setThreadId(currentThreadId);
      }

      await sendMessage({ threadId: currentThreadId, prompt: value });
    } catch (error) {
      console.error("Failed to send message:", error);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <Container>
      <KeyboardAvoidingView
        style={styles.container}
        behavior={Platform.OS === "ios" ? "padding" : "height"}
      >
        <View style={styles.content}>
          <View style={styles.header}>
            <Text style={styles.headerTitle}>AI Chat</Text>
            <Text style={styles.headerSubtitle}>
              Chat with our AI assistant
            </Text>
          </View>

          <ScrollView
            ref={scrollViewRef}
            style={styles.messagesContainer}
            showsVerticalScrollIndicator={false}
          >
            {!messages || messages.length === 0 ? (
              <View style={styles.emptyContainer}>
                <Text style={styles.emptyText}>
                  Ask me anything to get started!
                </Text>
              </View>
            ) : (
              <View style={styles.messagesWrapper}>
                {messages.map((message: UIMessage) => (
                  <View
                    key={message.key}
                    style={[
                      styles.messageContainer,
                      message.role === "user"
                        ? styles.userMessage
                        : styles.assistantMessage,
                    ]}
                  >
                    <Text style={styles.messageRole}>
                      {message.role === "user" ? "You" : "AI Assistant"}
                    </Text>
                    <MessageContent
                      text={message.text ?? ""}
                      isStreaming={message.status === "streaming"}
                      style={styles.messageContent}
                    />
                  </View>
                ))}
                {isLoading && !hasStreamingMessage && (
                  <View style={[styles.messageContainer, styles.assistantMessage]}>
                    <Text style={styles.messageRole}>AI Assistant</Text>
                    <View style={styles.loadingContainer}>
                      <ActivityIndicator size="small" color={theme.colors.primary} />
                      <Text style={styles.loadingText}>Thinking...</Text>
                    </View>
                  </View>
                )}
              </View>
            )}
          </ScrollView>

          <View style={styles.inputSection}>
            <View style={styles.inputContainer}>
              <TextInput
                value={input}
                onChangeText={setInput}
                placeholder="Type your message..."
                placeholderTextColor={theme.colors.border}
                style={styles.textInput}
                onSubmitEditing={(e) => {
                  e.preventDefault();
                  onSubmit();
                }}
                editable={!isLoading}
                autoFocus={true}
              />
              <TouchableOpacity
                onPress={onSubmit}
                disabled={!input.trim() || isLoading}
                style={[
                  styles.sendButton,
                  (!input.trim() || isLoading) && styles.sendButtonDisabled,
                ]}
              >
                <Ionicons
                  name="send"
                  size={20}
                  color={
                    input.trim() && !isLoading
                      ? theme.colors.background
                      : theme.colors.border
                  }
                />
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </KeyboardAvoidingView>
    </Container>
  );
}

const styles = StyleSheet.create((theme) => ({
  container: {
    flex: 1,
  },
  content: {
    flex: 1,
    paddingHorizontal: theme.spacing.md,
    paddingVertical: theme.spacing.lg,
  },
  header: {
    marginBottom: theme.spacing.lg,
  },
  headerTitle: {
    fontSize: 28,
    fontWeight: "bold",
    color: theme.colors.typography,
    marginBottom: theme.spacing.sm,
  },
  headerSubtitle: {
    fontSize: 16,
    color: theme.colors.typography,
  },
  messagesContainer: {
    flex: 1,
    marginBottom: theme.spacing.md,
  },
  emptyContainer: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
  },
  emptyText: {
    textAlign: "center",
    color: theme.colors.typography,
    fontSize: 18,
  },
  messagesWrapper: {
    gap: theme.spacing.md,
  },
  messageContainer: {
    padding: theme.spacing.md,
    borderRadius: 8,
  },
  userMessage: {
    backgroundColor: theme.colors.primary + "20",
    marginLeft: theme.spacing.xl,
    alignSelf: "flex-end",
  },
  assistantMessage: {
    backgroundColor: theme.colors.background,
    marginRight: theme.spacing.xl,
    borderWidth: 1,
    borderColor: theme.colors.border,
  },
  messageRole: {
    fontSize: 14,
    fontWeight: "600",
    marginBottom: theme.spacing.sm,
    color: theme.colors.typography,
  },
  messageContent: {
    color: theme.colors.typography,
    lineHeight: 20,
  },
  loadingContainer: {
    flexDirection: "row",
    alignItems: "center",
    gap: theme.spacing.sm,
  },
  loadingText: {
    color: theme.colors.typography,
    opacity: 0.7,
  },
  inputSection: {
    borderTopWidth: 1,
    borderTopColor: theme.colors.border,
    paddingTop: theme.spacing.md,
  },
  inputContainer: {
    flexDirection: "row",
    alignItems: "flex-end",
    gap: theme.spacing.sm,
  },
  textInput: {
    flex: 1,
    borderWidth: 1,
    borderColor: theme.colors.border,
    borderRadius: 8,
    paddingHorizontal: theme.spacing.md,
    paddingVertical: theme.spacing.sm,
    color: theme.colors.typography,
    backgroundColor: theme.colors.background,
    fontSize: 16,
    minHeight: 40,
    maxHeight: 120,
  },
  sendButton: {
    backgroundColor: theme.colors.primary,
    padding: theme.spacing.sm,
    borderRadius: 8,
    justifyContent: "center",
    alignItems: "center",
  },
  sendButtonDisabled: {
    backgroundColor: theme.colors.border,
  },
}));
{{else}}
import React, { useRef, useEffect, useState } from "react";
import {
  View,
  Text,
  TextInput,
  TouchableOpacity,
  ScrollView,
  KeyboardAvoidingView,
  Platform,
} from "react-native";
import { useChat } from "@ai-sdk/react";
import { DefaultChatTransport } from "ai";
import { fetch as expoFetch } from "expo/fetch";
import { Ionicons } from "@expo/vector-icons";
import { StyleSheet, useUnistyles } from "react-native-unistyles";
import { Container } from "@/components/container";
import { env } from "@{{projectName}}/env/native";

const generateAPIUrl = (relativePath: string) => {
  const serverUrl = env.EXPO_PUBLIC_SERVER_URL;
  if (!serverUrl) {
    throw new Error(
      "EXPO_PUBLIC_SERVER_URL environment variable is not defined"
    );
  }
  const path = relativePath.startsWith("/") ? relativePath : \`/\${relativePath}\`;
  return serverUrl.concat(path);
};

export default function AIScreen() {
  const { theme } = useUnistyles();
  const [input, setInput] = useState("");
  const { messages, error, sendMessage } = useChat({
    transport: new DefaultChatTransport({
      fetch: expoFetch as unknown as typeof globalThis.fetch,
      api: generateAPIUrl("/ai"),
    }),
    onError: (error) => console.error(error, "AI Chat Error"),
  });

  const scrollViewRef = useRef<ScrollView>(null);

  useEffect(() => {
    scrollViewRef.current?.scrollToEnd({ animated: true });
  }, [messages]);

  const onSubmit = () => {
    const value = input.trim();
    if (value) {
      sendMessage({ text: value });
      setInput("");
    }
  };

  if (error) {
    return (
      <Container>
        <View style={styles.errorContainer}>
          <Text style={styles.errorText}>Error: {error.message}</Text>
          <Text style={styles.errorSubtext}>
            Please check your connection and try again.
          </Text>
        </View>
      </Container>
    );
  }

  return (
    <Container>
      <KeyboardAvoidingView
        style={styles.container}
        behavior={Platform.OS === "ios" ? "padding" : "height"}
      >
        <View style={styles.content}>
          <View style={styles.header}>
            <Text style={styles.headerTitle}>AI Chat</Text>
            <Text style={styles.headerSubtitle}>
              Chat with our AI assistant
            </Text>
          </View>

          <ScrollView
            ref={scrollViewRef}
            style={styles.messagesContainer}
            showsVerticalScrollIndicator={false}
          >
            {messages.length === 0 ? (
              <View style={styles.emptyContainer}>
                <Text style={styles.emptyText}>
                  Ask me anything to get started!
                </Text>
              </View>
            ) : (
              <View style={styles.messagesWrapper}>
                {messages.map((message) => (
                  <View
                    key={message.id}
                    style={[
                      styles.messageContainer,
                      message.role === "user"
                        ? styles.userMessage
                        : styles.assistantMessage,
                    ]}
                  >
                    <Text style={styles.messageRole}>
                      {message.role === "user" ? "You" : "AI Assistant"}
                    </Text>
                    <View style={styles.messageContentWrapper}>
                      {message.parts.map((part, i) => {
                        if (part.type === "text") {
                          return (
                            <Text
                              key={\`\${message.id}-\${i}\`}
                              style={styles.messageContent}
                            >
                              {part.text}
                            </Text>
                          );
                        }
                        return (
                          <Text
                            key={\`\${message.id}-\${i}\`}
                            style={styles.messageContent}
                          >
                            {JSON.stringify(part)}
                          </Text>
                        );
                      })}
                    </View>
                  </View>
                ))}
              </View>
            )}
          </ScrollView>

          <View style={styles.inputSection}>
            <View style={styles.inputContainer}>
              <TextInput
                value={input}
                onChangeText={setInput}
                placeholder="Type your message..."
                placeholderTextColor={theme.colors.border}
                style={styles.textInput}
                onSubmitEditing={(e) => {
                  e.preventDefault();
                  onSubmit();
                }}
                autoFocus={true}
              />
              <TouchableOpacity
                onPress={onSubmit}
                disabled={!input.trim()}
                style={[
                  styles.sendButton,
                  !input.trim() && styles.sendButtonDisabled,
                ]}
              >
                <Ionicons
                  name="send"
                  size={20}
                  color={
                    input.trim()
                      ? theme.colors.background
                      : theme.colors.border
                  }
                />
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </KeyboardAvoidingView>
    </Container>
  );
}

const styles = StyleSheet.create((theme) => ({
  container: {
    flex: 1,
  },
  content: {
    flex: 1,
    paddingHorizontal: theme.spacing.md,
    paddingVertical: theme.spacing.lg,
  },
  errorContainer: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    paddingHorizontal: theme.spacing.md,
  },
  errorText: {
    color: theme.colors.destructive,
    textAlign: "center",
    fontSize: 18,
    marginBottom: theme.spacing.md,
  },
  errorSubtext: {
    color: theme.colors.typography,
    textAlign: "center",
    fontSize: 16,
  },
  header: {
    marginBottom: theme.spacing.lg,
  },
  headerTitle: {
    fontSize: 28,
    fontWeight: "bold",
    color: theme.colors.typography,
    marginBottom: theme.spacing.sm,
  },
  headerSubtitle: {
    fontSize: 16,
    color: theme.colors.typography,
  },
  messagesContainer: {
    flex: 1,
    marginBottom: theme.spacing.md,
  },
  emptyContainer: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
  },
  emptyText: {
    textAlign: "center",
    color: theme.colors.typography,
    fontSize: 18,
  },
  messagesWrapper: {
    gap: theme.spacing.md,
  },
  messageContainer: {
    padding: theme.spacing.md,
    borderRadius: 8,
  },
  userMessage: {
    backgroundColor: theme.colors.primary + "20",
    marginLeft: theme.spacing.xl,
    alignSelf: "flex-end",
  },
  assistantMessage: {
    backgroundColor: theme.colors.background,
    marginRight: theme.spacing.xl,
    borderWidth: 1,
    borderColor: theme.colors.border,
  },
  messageRole: {
    fontSize: 14,
    fontWeight: "600",
    marginBottom: theme.spacing.sm,
    color: theme.colors.typography,
  },
  messageContentWrapper: {
    gap: theme.spacing.xs,
  },
  messageContent: {
    color: theme.colors.typography,
    lineHeight: 20,
  },
  inputSection: {
    borderTopWidth: 1,
    borderTopColor: theme.colors.border,
    paddingTop: theme.spacing.md,
  },
  inputContainer: {
    flexDirection: "row",
    alignItems: "flex-end",
    gap: theme.spacing.sm,
  },
  textInput: {
    flex: 1,
    borderWidth: 1,
    borderColor: theme.colors.border,
    borderRadius: 8,
    paddingHorizontal: theme.spacing.md,
    paddingVertical: theme.spacing.sm,
    color: theme.colors.typography,
    backgroundColor: theme.colors.background,
    fontSize: 16,
    minHeight: 40,
    maxHeight: 120,
  },
  sendButton: {
    backgroundColor: theme.colors.primary,
    padding: theme.spacing.sm,
    borderRadius: 8,
    justifyContent: "center",
    alignItems: "center",
  },
  sendButtonDisabled: {
    backgroundColor: theme.colors.border,
  },
}));
{{/if}}
`],
  ["examples/todo/web/solid/src/routes/todos.tsx.hbs", `import { createFileRoute } from "@tanstack/solid-router";
import { Loader2, Trash2 } from "lucide-solid";
import { createSignal, For, Show } from "solid-js";
import { orpc } from "@/utils/orpc";
import { useQuery, useMutation } from "@tanstack/solid-query";

export const Route = createFileRoute("/todos")({
  component: TodosRoute,
});

function TodosRoute() {
  const [newTodoText, setNewTodoText] = createSignal("");

  const todos = useQuery(() => orpc.todo.getAll.queryOptions());

  const createMutation = useMutation(() =>
    orpc.todo.create.mutationOptions({
      onSuccess: () => {
        todos.refetch();
        setNewTodoText("");
      },
    }),
  );

  const toggleMutation = useMutation(() =>
    orpc.todo.toggle.mutationOptions({
      onSuccess: () => { todos.refetch() },
    }),
  );

  const deleteMutation = useMutation(() =>
    orpc.todo.delete.mutationOptions({
      onSuccess: () => { todos.refetch() },
    }),
  );

  const handleAddTodo = (e: Event) => {
    e.preventDefault();
    if (newTodoText().trim()) {
      createMutation.mutate({ text: newTodoText() });
    }
  };

  const handleToggleTodo = (id: number, completed: boolean) => {
    toggleMutation.mutate({ id, completed: !completed });
  };

  const handleDeleteTodo = (id: number) => {
    deleteMutation.mutate({ id });
  };

  return (
    <div class="mx-auto w-full max-w-md py-10">
      <div class="rounded-lg border p-6 shadow-sm">
        <div class="mb-4">
          <h2 class="text-xl font-semibold">Todo List</h2>
          <p class="text-sm">Manage your tasks efficiently</p>
        </div>
        <div>
          <form
            onSubmit={handleAddTodo}
            class="mb-6 flex items-center space-x-2"
          >
            <input
              type="text"
              value={newTodoText()}
              onInput={(e) => setNewTodoText(e.currentTarget.value)}
              placeholder="Add a new task..."
              disabled={createMutation.isPending}
              class="w-full rounded-md border p-2 text-sm"
            />
            <button
              type="submit"
              disabled={createMutation.isPending || !newTodoText().trim()}
              class="rounded-md bg-blue-600 px-4 py-2 text-sm text-white disabled:opacity-50"
            >
              <Show when={createMutation.isPending} fallback="Add">
                <Loader2 class="h-4 w-4 animate-spin" />
              </Show>
            </button>
          </form>

          <Show when={todos.isLoading}>
            <div class="flex justify-center py-4">
              <Loader2 class="h-6 w-6 animate-spin" />
            </div>
          </Show>

          <Show when={!todos.isLoading && todos.data?.length === 0}>
            <p class="py-4 text-center">No todos yet. Add one above!</p>
          </Show>

          <Show when={!todos.isLoading}>
            <ul class="space-y-2">
              <For each={todos.data}>
                {(todo) => (
                  <li class="flex items-center justify-between rounded-md border p-2">
                    <div class="flex items-center space-x-2">
                      <input
                        type="checkbox"
                        checked={todo.completed}
                        onChange={() =>
                          handleToggleTodo(todo.id, todo.completed)
                        }
                        id={\`todo-\${todo.id}\`}
                        class="h-4 w-4"
                      />
                      <label
                        for={\`todo-\${todo.id}\`}
                        class={todo.completed ? "line-through" : ""}
                      >
                        {todo.text}
                      </label>
                    </div>
                    <button
                      type="button"
                      onClick={() => handleDeleteTodo(todo.id)}
                      aria-label="Delete todo"
                      class="ml-2 rounded-md p-1"
                    >
                      <Trash2 class="h-4 w-4" />
                    </button>
                  </li>
                )}
              </For>
            </ul>
          </Show>
        </div>
      </div>
    </div>
  );
}
`],
  ["examples/todo/convex/packages/backend/convex/todos.ts.hbs", `import { query, mutation } from "./_generated/server";
import { v } from "convex/values";

export const getAll = query({
    handler: async (ctx) => {
        return await ctx.db.query("todos").collect();
    },
});

export const create = mutation({
    args: {
        text: v.string(),
    },
    handler: async (ctx, args) => {
        const newTodoId = await ctx.db.insert("todos", {
            text: args.text,
            completed: false,
        });
        return await ctx.db.get("todos", newTodoId);
    },
});

export const toggle = mutation({
    args: {
        id: v.id("todos"),
        completed: v.boolean(),
    },
    handler: async (ctx, args) => {
        await ctx.db.patch("todos", args.id, { completed: args.completed });
        return { success: true };
    },
});

export const deleteTodo = mutation({
    args: {
        id: v.id("todos"),
    },
    handler: async (ctx, args) => {
        await ctx.db.delete("todos", args.id);
        return { success: true };
    },
});`],
  ["examples/ai/convex/packages/backend/convex/chat.ts.hbs", `import {
  createThread,
  listUIMessages,
  saveMessage,
  syncStreams,
  vStreamArgs,
} from "@convex-dev/agent";
import { paginationOptsValidator } from "convex/server";
import { v } from "convex/values";

import { components, internal } from "./_generated/api";
import { internalAction, mutation, query } from "./_generated/server";
import { chatAgent } from "./agent";

export const createNewThread = mutation({
  args: {},
  handler: async (ctx) => {
    const threadId = await createThread(ctx, components.agent, {});
    return threadId;
  },
});

export const listMessages = query({
  args: {
    threadId: v.string(),
    paginationOpts: paginationOptsValidator,
    streamArgs: vStreamArgs,
  },
  handler: async (ctx, args) => {
    const paginated = await listUIMessages(ctx, components.agent, args);
    const streams = await syncStreams(ctx, components.agent, args);
    return { ...paginated, streams };
  },
});

export const sendMessage = mutation({
  args: {
    threadId: v.string(),
    prompt: v.string(),
  },
  handler: async (ctx, { threadId, prompt }) => {
    const { messageId } = await saveMessage(ctx, components.agent, {
      threadId,
      prompt,
    });
    await ctx.scheduler.runAfter(0, internal.chat.generateResponseAsync, {
      threadId,
      promptMessageId: messageId,
    });
    return messageId;
  },
});

export const generateResponseAsync = internalAction({
  args: {
    threadId: v.string(),
    promptMessageId: v.string(),
  },
  handler: async (ctx, { threadId, promptMessageId }) => {
    await chatAgent.streamText(
      ctx,
      { threadId },
      { promptMessageId },
      { saveStreamDeltas: true },
    );
  },
});
`],
  ["examples/ai/convex/packages/backend/convex/agent.ts.hbs", `import { Agent } from "@convex-dev/agent";
import { google } from "@ai-sdk/google";
import { components } from "./_generated/api";

export const chatAgent = new Agent(components.agent, {
  name: "Chat Agent",
  languageModel: google("gemini-2.5-flash"),
  instructions: "You are a helpful AI assistant. Be concise and friendly in your responses.",
});
`],
  ["auth/nextauth/fullstack/next/src/lib/auth.ts.hbs", `import NextAuth from "next-auth";
import Credentials from "next-auth/providers/credentials";
import GitHub from "next-auth/providers/github";
import Google from "next-auth/providers/google";
{{#if (eq orm "drizzle")}}
import { DrizzleAdapter } from "@auth/drizzle-adapter";
import { db } from "@{{projectName}}/db";
import * as schema from "@{{projectName}}/db/schema/auth";
{{/if}}
{{#if (eq orm "prisma")}}
import { PrismaAdapter } from "@auth/prisma-adapter";
import prisma from "@{{projectName}}/db";
{{/if}}

export const { handlers, auth, signIn, signOut } = NextAuth({
{{#if (eq orm "drizzle")}}
  adapter: DrizzleAdapter(db, {
    usersTable: schema.users,
    accountsTable: schema.accounts,
    sessionsTable: schema.sessions,
    verificationTokensTable: schema.verificationTokens,
  }),
{{/if}}
{{#if (eq orm "prisma")}}
  adapter: PrismaAdapter(prisma),
{{/if}}
  session: {
    strategy: "{{#if (or (eq orm "drizzle") (eq orm "prisma"))}}database{{else}}jwt{{/if}}",
  },
  providers: [
    // OAuth providers - configure in your .env file
    GitHub({
      clientId: process.env.AUTH_GITHUB_ID,
      clientSecret: process.env.AUTH_GITHUB_SECRET,
    }),
    Google({
      clientId: process.env.AUTH_GOOGLE_ID,
      clientSecret: process.env.AUTH_GOOGLE_SECRET,
    }),
    // Email/Password authentication
    Credentials({
      name: "credentials",
      credentials: {
        email: { label: "Email", type: "email" },
        password: { label: "Password", type: "password" },
      },
      async authorize(credentials) {
        // Add your own authentication logic here
        // This is a placeholder - implement proper password validation
        if (!credentials?.email || !credentials?.password) {
          return null;
        }

        // Example: Replace with your actual user lookup and password verification
        // const user = await db.query.users.findFirst({
        //   where: eq(users.email, credentials.email),
        // });
        // if (user && await verifyPassword(credentials.password, user.password)) {
        //   return { id: user.id, email: user.email, name: user.name };
        // }

        return null;
      },
    }),
  ],
  pages: {
    signIn: "/login",
  },
  callbacks: {
    async session({ session, user, token }) {
      if (session.user) {
        session.user.id = user?.id ?? token?.sub ?? "";
      }
      return session;
    },
    async jwt({ token, user }) {
      if (user) {
        token.sub = user.id;
      }
      return token;
    },
  },
  trustHost: true,
});
`],
  ["examples/todo/web/nuxt/app/pages/todos.vue.hbs", `<script setup lang="ts">
import { ref } from 'vue'
{{#if (eq backend "convex")}}
import { api } from "@{{ projectName }}/backend/convex/_generated/api";
import type { Id } from "@{{ projectName }}/backend/convex/_generated/dataModel";
import { useConvexMutation, useConvexQuery } from "convex-vue";

const { data, error, isPending } = useConvexQuery(api.todos.getAll, {});

const newTodoText = ref("");
const { mutate: createTodo, isPending: isCreatePending } = useConvexMutation(api.todos.create);

const { mutate: toggleTodo } = useConvexMutation(api.todos.toggle);
const { mutate: deleteTodo, error: deleteError } = useConvexMutation(
  api.todos.deleteTodo,
);

function handleAddTodo() {
  const text = newTodoText.value.trim();
  if (!text) return;

  createTodo({ text });
  newTodoText.value = "";
}

function handleToggleTodo(id: Id<"todos">, completed: boolean) {
  toggleTodo({ id, completed: !completed });
}

function handleDeleteTodo(id: Id<"todos">) {
  deleteTodo({ id });
}
{{else}}
import { useQuery, useMutation, useQueryClient } from '@tanstack/vue-query'

const { $orpc } = useNuxtApp()

const newTodoText = ref('')
const queryClient = useQueryClient()

const todos = useQuery($orpc.todo.getAll.queryOptions())

const createMutation = useMutation($orpc.todo.create.mutationOptions({
  onSuccess: () => {
    queryClient.invalidateQueries()
    newTodoText.value = ''
  }
}))

const toggleMutation = useMutation($orpc.todo.toggle.mutationOptions({
  onSuccess: () => queryClient.invalidateQueries()
}))

const deleteMutation = useMutation($orpc.todo.delete.mutationOptions({
  onSuccess: () => queryClient.invalidateQueries()
}))

function handleAddTodo() {
  if (newTodoText.value.trim()) {
    createMutation.mutate({ text: newTodoText.value })
  }
}

function handleToggleTodo(id: number, completed: boolean) {
  toggleMutation.mutate({ id, completed: !completed })
}

function handleDeleteTodo(id: number) {
  deleteMutation.mutate({ id })
}
{{/if}}
</script>

<template>
  <UContainer class="py-8 max-w-md">
    <UCard>
      <template #header>
        <div>
          <div class="text-xl font-bold">Todo List</div>
          <div class="text-muted text-sm">Manage your tasks efficiently</div>
        </div>
      </template>

      <form @submit.prevent="handleAddTodo" class="mb-6 flex items-center gap-2">
        <UInput
          v-model="newTodoText"
          placeholder="Add a new task..."
          autocomplete="off"
          class="flex-1"
          {{#if (eq backend "convex")}}
          :disabled="isCreatePending"
          {{/if}}
        />
        <UButton
          type="submit"
          {{#if (eq backend "convex")}}
          :loading="isCreatePending"
          :disabled="!newTodoText.trim()"
          {{else}}
          :loading="createMutation.isPending.value"
          {{/if}}
        >
          Add
        </UButton>
      </form>

      {{#if (eq backend "convex")}}
      <!-- Loading State -->
      <div v-if="isPending" class="space-y-2">
        <USkeleton v-for="i in 3" :key="i" class="h-12 w-full" />
      </div>

      <!-- Error State -->
      <UAlert
        v-else-if="error || deleteError"
        color="error"
        icon="i-lucide-alert-circle"
        title="Error"
        :description="error?.message || deleteError?.message"
      />

      <!-- Empty State -->
      <UEmpty
        v-else-if="data?.length === 0"
        icon="i-lucide-clipboard-list"
        title="No todos yet"
        description="Add your first task above!"
      />

      <!-- Todo List -->
      <ul v-else-if="data" class="space-y-2">
        <li
          v-for="todo in data"
          :key="todo._id"
          class="flex items-center justify-between rounded-md border p-3"
        >
          <div class="flex items-center gap-3">
            <UCheckbox
              :model-value="todo.completed"
              @update:model-value="() => handleToggleTodo(todo._id, todo.completed)"
              :id="\`todo-\${todo._id}\`"
            />
            <label
              :for="\`todo-\${todo._id}\`"
              :class="{ 'line-through text-muted': todo.completed }"
              class="cursor-pointer"
            >
              \\{{ todo.text }}
            </label>
          </div>
          <UButton
            color="error"
            variant="ghost"
            size="sm"
            square
            @click="handleDeleteTodo(todo._id)"
            aria-label="Delete todo"
            icon="i-lucide-trash-2"
          />
        </li>
      </ul>
      {{else}}
      <!-- Loading State -->
      <div v-if="todos.status.value === 'pending'" class="space-y-2">
        <USkeleton v-for="i in 3" :key="i" class="h-12 w-full" />
      </div>

      <!-- Error State -->
      <UAlert
        v-else-if="todos.status.value === 'error'"
        color="error"
        icon="i-lucide-alert-circle"
        title="Failed to load todos"
        :description="todos.error.value?.message"
      />

      <!-- Empty State -->
      <UEmpty
        v-else-if="todos.data.value?.length === 0"
        icon="i-lucide-clipboard-list"
        title="No todos yet"
        description="Add your first task above!"
      />

      <!-- Todo List -->
      <ul v-else class="space-y-2">
        <li
          v-for="todo in todos.data.value"
          :key="todo.id"
          class="flex items-center justify-between rounded-md border p-3"
        >
          <div class="flex items-center gap-3">
            <UCheckbox
              :model-value="todo.completed"
              @update:model-value="() => handleToggleTodo(todo.id, todo.completed)"
              :id="\`todo-\${todo.id}\`"
            />
            <label
              :for="\`todo-\${todo.id}\`"
              :class="{ 'line-through text-muted': todo.completed }"
              class="cursor-pointer"
            >
              \\{{ todo.text }}
            </label>
          </div>
          <UButton
            color="error"
            variant="ghost"
            size="sm"
            square
            @click="handleDeleteTodo(todo.id)"
            aria-label="Delete todo"
            icon="i-lucide-trash-2"
          />
        </li>
      </ul>
      {{/if}}
    </UCard>
  </UContainer>
</template>
`],
  ["auth/stack-auth/fullstack/next/src/app/loading.tsx.hbs", `export default function Loading() {
  return (
    <div className="flex items-center justify-center min-h-screen">
      <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary" />
    </div>
  );
}
`],
  ["auth/stack-auth/fullstack/next/src/stack/server.ts.hbs", `import "server-only";
import { StackServerApp } from "@stackframe/stack";

export const stackServerApp = new StackServerApp({
  tokenStore: "nextjs-cookie",
});
`],
  ["auth/better-auth/web/solid/src/lib/auth-client.ts.hbs", `import { createAuthClient } from "better-auth/solid";
{{#if (eq payments "polar")}}
import { polarClient } from "@polar-sh/better-auth";
{{/if}}
import { env } from "@{{projectName}}/env/web";

export const authClient = createAuthClient({
	baseURL: env.VITE_SERVER_URL,
{{#if (eq payments "polar")}}
	plugins: [polarClient()]
{{/if}}
});
`],
  ["auth/better-auth/web/solid/src/routes/login.tsx.hbs", `import SignInForm from "@/components/sign-in-form";
import SignUpForm from "@/components/sign-up-form";
import { createFileRoute } from "@tanstack/solid-router";
import { createSignal, Match, Switch } from "solid-js";

export const Route = createFileRoute("/login")({
  component: RouteComponent,
});

function RouteComponent() {
  const [showSignIn, setShowSignIn] = createSignal(false);

  return (
    <Switch>
      <Match when={showSignIn()}>
        <SignInForm onSwitchToSignUp={() => setShowSignIn(false)} />
      </Match>
      <Match when={!showSignIn()}>
        <SignUpForm onSwitchToSignIn={() => setShowSignIn(true)} />
      </Match>
    </Switch>
  );
}
`],
  ["auth/better-auth/web/solid/src/routes/dashboard.tsx.hbs", `import { authClient } from "@/lib/auth-client";
{{#if (eq api "orpc")}}
import { orpc } from "@/utils/orpc";
import { useQuery } from "@tanstack/solid-query";
{{/if}}
import { createFileRoute, redirect } from "@tanstack/solid-router";

export const Route = createFileRoute("/dashboard")({
	component: RouteComponent,
	beforeLoad: async () => {
		const session = await authClient.getSession();
		if (!session.data) {
			redirect({
				to: "/login",
				throw: true,
			});
		}
		{{#if (eq payments "polar")}}
		const { data: customerState } = await authClient.customer.state();
		return { session, customerState };
		{{else}}
		return { session };
		{{/if}}
	},
});

function RouteComponent() {
	const context = Route.useRouteContext();

	const session = context().session;
	{{#if (eq payments "polar")}}
	const customerState = context().customerState;
	{{/if}}

	{{#if (eq api "orpc")}}
	const privateData = useQuery(() => orpc.privateData.queryOptions());
	{{/if}}

	{{#if (eq payments "polar")}}
	const hasProSubscription = () =>
		customerState?.activeSubscriptions?.length! > 0;
	{{/if}}

	return (
		<div>
			<h1>Dashboard</h1>
			<p>Welcome {session.data?.user.name}</p>
			{{#if (eq api "orpc")}}
			<p>API: {privateData.data?.message}</p>
			{{/if}}
			{{#if (eq payments "polar")}}
			<p>Plan: {hasProSubscription() ? "Pro" : "Free"}</p>
			{hasProSubscription() ? (
				<button onClick={async () => await authClient.customer.portal()}>
					Manage Subscription
				</button>
			) : (
				<button
					onClick={async () => await authClient.checkout({ slug: "pro" })}
				>
					Upgrade to Pro
				</button>
			)}
			{{/if}}
		</div>
	);
}
`],
  ["auth/better-auth/web/svelte/src/lib/auth-client.ts.hbs", `import { PUBLIC_SERVER_URL } from "$env/static/public";
import { createAuthClient } from "better-auth/svelte";
{{#if (eq payments "polar")}}
import { polarClient } from "@polar-sh/better-auth";
{{/if}}

export const authClient = createAuthClient({
	baseURL: PUBLIC_SERVER_URL,
{{#if (eq payments "polar")}}
	plugins: [polarClient()]
{{/if}}
});
`],
  ["auth/better-auth/web/solid/src/components/user-menu.tsx.hbs", `import { authClient } from "@/lib/auth-client";
import { useNavigate, Link } from "@tanstack/solid-router";
import { createSignal, Show } from "solid-js";

export default function UserMenu() {
  const navigate = useNavigate();
  const session = authClient.useSession();
  const [isMenuOpen, setIsMenuOpen] = createSignal(false);

  return (
    <div class="relative inline-block text-left">
      <Show when={session().isPending}>
        <div class="h-9 w-24 animate-pulse rounded" />
      </Show>

      <Show when={!session().isPending && !session().data}>
        <Link to="/login" class="inline-block border rounded px-4  text-sm">
          Sign In
        </Link>
      </Show>

      <Show when={!session().isPending && session().data}>
        <button
          type="button"
          class="inline-block border rounded px-4  text-sm"
          onClick={() => setIsMenuOpen(!isMenuOpen())}
        >
          {session().data?.user.name}
        </button>

        <Show when={isMenuOpen()}>
          <div class="absolute right-0 mt-2 w-56 rounded p-1 shadow-sm">
            <div class="px-4  text-sm">{session().data?.user.email}</div>
            <button
              type="button"
              class="mt-1 w-full border rounded px-4  text-center text-sm"
              onClick={() => {
                setIsMenuOpen(false);
                authClient.signOut({
                  fetchOptions: {
                    onSuccess: () => {
                      navigate({ to: "/" });
                    },
                  },
                });
              }}
            >
              Sign Out
            </button>
          </div>
        </Show>
      </Show>
    </div>
  );
}
`],
  ["auth/better-auth/web/solid/src/components/sign-in-form.tsx.hbs", `import { authClient } from "@/lib/auth-client";
import { createForm } from "@tanstack/solid-form";
import { useNavigate } from "@tanstack/solid-router";
import z from "zod";
import { For } from "solid-js";

export default function SignInForm({ onSwitchToSignUp }: { onSwitchToSignUp: () => void }) {
  const navigate = useNavigate({
    from: "/",
  });

  const form = createForm(() => ({
    defaultValues: {
      email: "",
      password: "",
    },
    onSubmit: async ({ value }) => {
      await authClient.signIn.email(
        {
          email: value.email,
          password: value.password,
        },
        {
          onSuccess: () => {
            navigate({
              to: "/dashboard",
            });
            console.log("Sign in successful");
          },
          onError: (error) => {
            console.error(error.error.message);
          },
        },
      );
    },
    validators: {
      onSubmit: z.object({
        email: z.email("Invalid email address"),
        password: z.string().min(8, "Password must be at least 8 characters"),
      }),
    },
  }));

  return (
    <div class="mx-auto w-full mt-10 max-w-md p-6">
      <h1 class="mb-6 text-center text-3xl font-bold">Welcome Back</h1>

      <form
        onSubmit={(e) => {
          e.preventDefault();
          e.stopPropagation();
          form.handleSubmit();
        }}
        class="space-y-4"
      >
        <div>
          <form.Field name="email">
            {(field) => (
              <div class="space-y-2">
                <label for={field().name}>Email</label>
                <input
                  id={field().name}
                  name={field().name}
                  type="email"
                  value={field().state.value}
                  onBlur={field().handleBlur}
                  onInput={(e) => field().handleChange(e.currentTarget.value)}
                  class="w-full rounded border p-2"
                />
                <For each={field().state.meta.errors}>
                  {(error) => <p class="text-sm text-red-600">{error?.message}</p>}
                </For>
              </div>
            )}
          </form.Field>
        </div>

        <div>
          <form.Field name="password">
            {(field) => (
              <div class="space-y-2">
                <label for={field().name}>Password</label>
                <input
                  id={field().name}
                  name={field().name}
                  type="password"
                  value={field().state.value}
                  onBlur={field().handleBlur}
                  onInput={(e) => field().handleChange(e.currentTarget.value)}
                  class="w-full rounded border p-2"
                />
                <For each={field().state.meta.errors}>
                  {(error) => <p class="text-sm text-red-600">{error?.message}</p>}
                </For>
              </div>
            )}
          </form.Field>
        </div>

        <form.Subscribe>
          {(state) => (
            <button
              type="submit"
              class="w-full rounded bg-indigo-600 p-2 text-white hover:bg-indigo-700 disabled:opacity-50"
              disabled={!state().canSubmit || state().isSubmitting}
            >
              {state().isSubmitting ? "Submitting..." : "Sign In"}
            </button>
          )}
        </form.Subscribe>
      </form>

      <div class="mt-4 text-center">
        <button
          type="button"
          onClick={onSwitchToSignUp}
          class="text-sm text-indigo-600 hover:text-indigo-800 hover:underline"
        >
          Need an account? Sign Up
        </button>
      </div>
    </div>
  );
}
`],
  ["auth/better-auth/web/solid/src/components/sign-up-form.tsx.hbs", `import { authClient } from "@/lib/auth-client";
import { createForm } from "@tanstack/solid-form";
import { useNavigate } from "@tanstack/solid-router";
import z from "zod";
import { For } from "solid-js";

export default function SignUpForm({ onSwitchToSignIn }: { onSwitchToSignIn: () => void }) {
  const navigate = useNavigate({
    from: "/",
  });

  const form = createForm(() => ({
    defaultValues: {
      email: "",
      password: "",
      name: "",
    },
    onSubmit: async ({ value }) => {
      await authClient.signUp.email(
        {
          email: value.email,
          password: value.password,
          name: value.name,
        },
        {
          onSuccess: () => {
            navigate({
              to: "/dashboard",
            });
            console.log("Sign up successful");
          },
          onError: (error) => {
            console.error(error.error.message);
          },
        },
      );
    },
    validators: {
      onSubmit: z.object({
        name: z.string().min(2, "Name must be at least 2 characters"),
        email: z.email("Invalid email address"),
        password: z.string().min(8, "Password must be at least 8 characters"),
      }),
    },
  }));

  return (
    <div class="mx-auto w-full mt-10 max-w-md p-6">
      <h1 class="mb-6 text-center text-3xl font-bold">Create Account</h1>

      <form
        onSubmit={(e) => {
          e.preventDefault();
          e.stopPropagation();
          form.handleSubmit();
        }}
        class="space-y-4"
      >
        <div>
          <form.Field name="name">
            {(field) => (
              <div class="space-y-2">
                <label for={field().name}>Name</label>
                <input
                  id={field().name}
                  name={field().name}
                  value={field().state.value}
                  onBlur={field().handleBlur}
                  onInput={(e) => field().handleChange(e.currentTarget.value)}
                  class="w-full rounded border p-2"
                />
                <For each={field().state.meta.errors}>
                  {(error) => <p class="text-sm text-red-600">{error?.message}</p>}
                </For>
              </div>
            )}
          </form.Field>
        </div>

        <div>
          <form.Field name="email">
            {(field) => (
              <div class="space-y-2">
                <label for={field().name}>Email</label>
                <input
                  id={field().name}
                  name={field().name}
                  type="email"
                  value={field().state.value}
                  onBlur={field().handleBlur}
                  onInput={(e) => field().handleChange(e.currentTarget.value)}
                  class="w-full rounded border p-2"
                />
                <For each={field().state.meta.errors}>
                  {(error) => <p class="text-sm text-red-600">{error?.message}</p>}
                </For>
              </div>
            )}
          </form.Field>
        </div>

        <div>
          <form.Field name="password">
            {(field) => (
              <div class="space-y-2">
                <label for={field().name}>Password</label>
                <input
                  id={field().name}
                  name={field().name}
                  type="password"
                  value={field().state.value}
                  onBlur={field().handleBlur}
                  onInput={(e) => field().handleChange(e.currentTarget.value)}
                  class="w-full rounded border p-2"
                />
                <For each={field().state.meta.errors}>
                  {(error) => <p class="text-sm text-red-600">{error?.message}</p>}
                </For>
              </div>
            )}
          </form.Field>
        </div>

        <form.Subscribe>
          {(state) => (
            <button
              type="submit"
              class="w-full rounded bg-indigo-600 p-2 text-white hover:bg-indigo-700 disabled:opacity-50"
              disabled={!state().canSubmit || state().isSubmitting}
            >
              {state().isSubmitting ? "Submitting..." : "Sign Up"}
            </button>
          )}
        </form.Subscribe>
      </form>

      <div class="mt-4 text-center">
        <button
          type="button"
          onClick={onSwitchToSignIn}
          class="text-sm text-indigo-600 hover:text-indigo-800 hover:underline"
        >
          Already have an account? Sign In
        </button>
      </div>
    </div>
  );
}
`],
  ["auth/better-auth/web/svelte/src/components/SignInForm.svelte.hbs", `<script lang="ts">
	import { createForm } from '@tanstack/svelte-form';
	import { z } from 'zod';
	import { authClient } from '$lib/auth-client';
	import { goto } from '$app/navigation';

	let { switchToSignUp } = $props<{ switchToSignUp: () => void }>();

	const validationSchema = z.object({
		email: z.email('Invalid email address'),
		password: z.string().min(1, 'Password is required'),
	});

	const form = createForm(() => ({
		defaultValues: { email: '', password: '' },
		onSubmit: async ({ value }) => {
				await authClient.signIn.email(
					{ email: value.email, password: value.password },
					{
						onSuccess: () => goto('/dashboard'),
						onError: (error) => {
							console.log(error.error.message || 'Sign in failed. Please try again.');
						},
					}
				);

		},
		validators: {
			onSubmit: validationSchema,
		},
	}));
</script>

<div class="mx-auto mt-10 w-full max-w-md p-6">
	<h1 class="mb-6 text-center font-bold text-3xl">Welcome Back</h1>

	<form
		class="space-y-4"
		onsubmit={(e) => {
			e.preventDefault();
			e.stopPropagation();
			form.handleSubmit();
		}}
	>
		<form.Field name="email">
			{#snippet children(field)}
				<div class="space-y-1">
					<label for={field.name}>Email</label>
					<input
						id={field.name}
						name={field.name}
						type="email"
						class="w-full border"
						onblur={field.handleBlur}
						value={field.state.value}
						oninput={(e: Event) => {
							const target = e.target as HTMLInputElement;
							field.handleChange(target.value);
						}}
					/>
					{#if field.state.meta.isTouched}
						{#each field.state.meta.errors as error}
							<p class="text-sm text-red-500" role="alert">{error}</p>
						{/each}
					{/if}
				</div>
			{/snippet}
		</form.Field>

		<form.Field name="password">
			{#snippet children(field)}
				<div class="space-y-1">
					<label for={field.name}>Password</label>
					<input
						id={field.name}
						name={field.name}
						type="password"
						class="w-full border"
						onblur={field.handleBlur}
						value={field.state.value}
						oninput={(e: Event) => {
							const target = e.target as HTMLInputElement;
							field.handleChange(target.value);
						}}
					/>
					{#if field.state.meta.isTouched}
						{#each field.state.meta.errors as error}
							<p class="text-sm text-red-500" role="alert">{error}</p>
						{/each}
					{/if}
				</div>
			{/snippet}
		</form.Field>

		<form.Subscribe selector={(state) => ({ canSubmit: state.canSubmit, isSubmitting: state.isSubmitting })}>
			{#snippet children(state)}
				<button type="submit" class="w-full" disabled={!state.canSubmit || state.isSubmitting}>
					{state.isSubmitting ? 'Submitting...' : 'Sign In'}
				</button>
			{/snippet}
		</form.Subscribe>
	</form>

	<div class="mt-4 text-center">
		<button type="button" class="text-indigo-600 hover:text-indigo-800" onclick={switchToSignUp}>
			Need an account? Sign Up
		</button>
	</div>
</div>
`],
  ["auth/better-auth/web/svelte/src/components/UserMenu.svelte.hbs", `<script lang="ts">
	import { authClient } from '$lib/auth-client';
	import { goto } from '$app/navigation';

	const sessionQuery = authClient.useSession();

	async function handleSignOut() {
		await authClient.signOut({
		fetchOptions: {
			onSuccess: () => {
				goto('/');
			},
			onError: (error) => {
				console.error('Sign out failed:', error);
			}
		}
		});
	}

	function goToLogin() {
		goto('/login');
	}

</script>

<div class="relative">
	{#if $sessionQuery.isPending}
		<div class="h-8 w-24 animate-pulse rounded bg-neutral-700"></div>
	{:else if $sessionQuery.data?.user}
		{@const user = $sessionQuery.data.user}
		<div class="flex items-center gap-3">
			<span class="text-sm text-neutral-300 hidden sm:inline" title={user.email}>
				{user.name || user.email?.split('@')[0] || 'User'}
			</span>
			<button
				onclick={handleSignOut}
				class="rounded px-3 py-1 text-sm bg-red-600 hover:bg-red-700 text-white transition-colors"
			>
				Sign Out
			</button>
		</div>
	{:else}
		<div class="flex items-center gap-2">
			<button
				onclick={goToLogin}
				class="rounded px-3 py-1 text-sm bg-indigo-600 hover:bg-indigo-700 text-white transition-colors"
			>
				Sign In
			</button>
		</div>
	{/if}
</div>
`],
  ["auth/better-auth/web/svelte/src/components/SignUpForm.svelte.hbs", `<script lang="ts">
	import { createForm } from '@tanstack/svelte-form';
	import { z } from 'zod';
	import { authClient } from '$lib/auth-client';
	import { goto } from '$app/navigation';

	let { switchToSignIn } = $props<{ switchToSignIn: () => void }>();

	const validationSchema = z.object({
		name: z.string().min(2, 'Name must be at least 2 characters'),
		email: z.email('Invalid email address'),
		password: z.string().min(8, 'Password must be at least 8 characters'),
	});


	const form = createForm(() => ({
		defaultValues: { name: '', email: '', password: '' },
		onSubmit: async ({ value }) => {
				await authClient.signUp.email(
					{
						email: value.email,
						password: value.password,
						name: value.name,
					},
					{
						onSuccess: () => {
							goto('/dashboard');
						},
						onError: (error) => {
							console.log(error.error.message || 'Sign up failed. Please try again.');
						},
					}
				);

		},
		validators: {
			onSubmit: validationSchema,
		},
	}));
</script>

<div class="mx-auto mt-10 w-full max-w-md p-6">
	<h1 class="mb-6 text-center font-bold text-3xl">Create Account</h1>

	<form
		id="form"
		class="space-y-4"
		onsubmit={(e) => {
			e.preventDefault();
			e.stopPropagation();
			form.handleSubmit();
		}}
	>
		<form.Field name="name">
			{#snippet children(field)}
				<div class="space-y-1">
					<label for={field.name}>Name</label>
					<input
						id={field.name}
						name={field.name}
						class="w-full border"
						onblur={field.handleBlur}
						value={field.state.value}
						oninput={(e: Event) => {
							const target = e.target as HTMLInputElement;
							field.handleChange(target.value);
						}}
					/>
					{#if field.state.meta.isTouched}
						{#each field.state.meta.errors as error}
							<p class="text-sm text-red-500" role="alert">{error}</p>
						{/each}
					{/if}
				</div>
			{/snippet}
		</form.Field>

		<form.Field name="email">
			{#snippet children(field)}
				<div class="space-y-1">
					<label for={field.name}>Email</label>
					<input
						id={field.name}
						name={field.name}
						type="email"
						class="w-full border"
						onblur={field.handleBlur}
						value={field.state.value}
						oninput={(e: Event) => {
							const target = e.target as HTMLInputElement;
							field.handleChange(target.value);
						}}
					/>
					{#if field.state.meta.isTouched}
						{#each field.state.meta.errors as error}
							<p class="text-sm text-red-500" role="alert">{error}</p>
						{/each}
					{/if}
				</div>
			{/snippet}
		</form.Field>

		<form.Field name="password">
			{#snippet children(field)}
				<div class="space-y-1">
					<label for={field.name}>Password</label>
					<input
						id={field.name}
						name={field.name}
						type="password"
						class="w-full border"
						onblur={field.handleBlur}
						value={field.state.value}
						oninput={(e: Event) => {
							const target = e.target as HTMLInputElement;
							field.handleChange(target.value);
						}}
					/>
					{#if field.state.meta.isTouched}
						{#each field.state.meta.errors as error}
							<p class="text-sm text-red-500" role="alert">{error}</p>
						{/each}
					{/if}
				</div>
			{/snippet}
		</form.Field>

		<form.Subscribe selector={(state) => ({ canSubmit: state.canSubmit, isSubmitting: state.isSubmitting })}>
			{#snippet children(state)}
				<button type="submit" class="w-full" disabled={!state.canSubmit || state.isSubmitting}>
					{state.isSubmitting ? 'Submitting...' : 'Sign Up'}
				</button>
			{/snippet}
		</form.Subscribe>
	</form>

	<div class="mt-4 text-center">
		<button type="button" class="text-indigo-600 hover:text-indigo-800" onclick={switchToSignIn}>
			Already have an account? Sign In
		</button>
	</div>
</div>
`],
  ["auth/clerk/convex/native/base/components/sign-out-button.tsx.hbs", `import { useClerk } from "@clerk/clerk-expo";
import { useRouter } from "expo-router";
import { Text, TouchableOpacity } from "react-native";

export const SignOutButton = () => {
  // Use \`useClerk()\` to access the \`signOut()\` function
  const { signOut } = useClerk();
  const router = useRouter();

  const handleSignOut = async () => {
    try {
      await signOut();
      // Redirect to your desired page
      router.replace("/");
    } catch (err) {
      // See https://clerk.com/docs/custom-flows/error-handling
      // for more info on error handling
      console.error(JSON.stringify(err, null, 2));
    }
  };

  return (
    <TouchableOpacity onPress={handleSignOut}>
      <Text>Sign out</Text>
    </TouchableOpacity>
  );
};
`],
  ["auth/better-auth/web/nuxt/app/pages/login.vue.hbs", `<script setup lang="ts">
const { $authClient } = useNuxtApp();
import SignInForm from "~/components/SignInForm.vue";
import SignUpForm from "~/components/SignUpForm.vue";

const session = $authClient.useSession();
const showSignIn = ref(true);

watchEffect(() => {
  if (!session?.value.isPending && session?.value.data) {
    navigateTo("/dashboard", { replace: true });
  }
});
</script>

<template>
  <UContainer class="py-8">
    <div v-if="session.isPending" class="flex flex-col items-center justify-center gap-4 py-12">
      <UIcon name="i-lucide-loader-2" class="animate-spin text-4xl text-primary" />
      <span class="text-muted">Loading...</span>
    </div>
    <div v-else-if="!session.data">
      <SignInForm v-if="showSignIn" @switch-to-sign-up="showSignIn = false" />
      <SignUpForm v-else @switch-to-sign-in="showSignIn = true" />
    </div>
  </UContainer>
</template>
`],
  ["auth/better-auth/web/nuxt/app/pages/dashboard.vue.hbs", `<script setup lang="ts">
{{#if (eq api "orpc")}}
import { useQuery } from '@tanstack/vue-query'
{{/if}}

const { $authClient, $orpc } = useNuxtApp()

definePageMeta({
  middleware: ['auth']
})

const session = $authClient.useSession()

{{#if (eq payments "polar")}}
const customerState = ref<any>(null)
{{/if}}

{{#if (eq api "orpc")}}
const privateData = useQuery({
  ...$orpc.privateData.queryOptions(),
  enabled: computed(() => !!session.value?.data?.user)
})
{{/if}}

{{#if (eq payments "polar")}}
onMounted(async () => {
  if (session.value?.data) {
    const { data } = await $authClient.customer.state()
    customerState.value = data
  }
})

const hasProSubscription = computed(() => 
  customerState.value?.activeSubscriptions?.length! > 0
)
{{/if}}
</script>

<template>
  <UContainer class="py-8">
    <UPageHeader
      title="Dashboard"
      :description="session?.data?.user ? \`Welcome back, \${session.data.user.name}!\` : 'Loading...'"
    />

    <div class="mt-6 space-y-4">
      {{#if (eq api "orpc")}}
      <UCard>
        <template #header>
          <div class="font-medium">Private Data</div>
        </template>

        <USkeleton v-if="privateData.status.value === 'pending'" class="h-6 w-48" />

        <UAlert
          v-else-if="privateData.status.value === 'error'"
          color="error"
          icon="i-lucide-alert-circle"
          title="Error loading data"
          :description="privateData.error.value?.message || 'Failed to load private data'"
        />

        <div v-else-if="privateData.data.value" class="flex items-center gap-2">
          <UIcon name="i-lucide-check-circle" class="text-success" />
          <span>\\{{ privateData.data.value.message }}</span>
        </div>
      </UCard>
      {{/if}}

      {{#if (eq payments "polar")}}
      <UCard>
        <template #header>
          <div class="font-medium">Subscription</div>
        </template>

        <div class="flex items-center justify-between">
          <div class="flex items-center gap-2">
            <UIcon :name="hasProSubscription ? 'i-lucide-crown' : 'i-lucide-user'" :class="hasProSubscription ? 'text-warning' : 'text-muted'" />
            <span>Plan: \\{{ hasProSubscription ? "Pro" : "Free" }}</span>
          </div>
          <UButton 
            v-if="hasProSubscription"
            variant="outline"
            @click="() => { $authClient.customer.portal() }"
          >
            Manage Subscription
          </UButton>
          <UButton 
            v-else
            @click="() => { $authClient.checkout({ slug: 'pro' }) }"
          >
            Upgrade to Pro
          </UButton>
        </div>
      </UCard>
      {{/if}}
    </div>
  </UContainer>
</template>
`],
  ["auth/better-auth/web/nuxt/app/components/SignInForm.vue.hbs", `<script setup lang="ts">
import * as z from 'zod'
import type { FormSubmitEvent, AuthFormField } from '@nuxt/ui'

const { $authClient } = useNuxtApp()

const emit = defineEmits(['switchToSignUp'])

const toast = useToast()
const loading = ref(false)

const fields: AuthFormField[] = [
  {
    name: 'email',
    type: 'email',
    label: 'Email',
    placeholder: 'Enter your email',
    required: true
  },
  {
    name: 'password',
    type: 'password',
    label: 'Password',
    placeholder: 'Enter your password',
    required: true
  }
]

const schema = z.object({
  email: z.email('Invalid email address'),
  password: z.string().min(8, 'Password must be at least 8 characters'),
})

type Schema = z.output<typeof schema>

async function onSubmit(event: FormSubmitEvent<Schema>) {
  loading.value = true
  try {
    await $authClient.signIn.email(
      {
        email: event.data.email,
        password: event.data.password,
      },
      {
        onSuccess: () => {
          toast.add({ title: 'Sign in successful' })
          navigateTo('/dashboard', { replace: true })
        },
        onError: (error) => {
          toast.add({ title: 'Sign in failed', description: error.error.message })
        },
      },
    )
  } catch (error: any) {
    toast.add({ title: 'An unexpected error occurred', description: error.message || 'Please try again.' })
  } finally {
    loading.value = false
  }
}
</script>

<template>
  <div class="flex flex-col items-center justify-center gap-4 p-4">
    <UPageCard class="w-full max-w-md">
      <UAuthForm
        :schema="schema"
        :fields="fields"
        title="Welcome Back"
        icon="i-lucide-log-in"
        :submit="{ label: 'Sign In', loading }"
        @submit="onSubmit"
      >
        <template #description>
          Need an account?
          <ULink class="text-primary font-medium" @click="$emit('switchToSignUp')">
            Sign Up
          </ULink>
        </template>
      </UAuthForm>
    </UPageCard>
  </div>
</template>
`],
  ["auth/better-auth/web/nuxt/app/components/UserMenu.vue.hbs", `<script setup lang="ts">

const {$authClient} = useNuxtApp()
const session = $authClient.useSession()
const toast = useToast()

const handleSignOut = async () => {
  try {
    await $authClient.signOut({
      fetchOptions: {
        onSuccess: async () => {
          toast.add({ title: 'Signed out successfully' })
          await navigateTo('/', { replace: true, external: true })
        },
        onError: (error) => {
           toast.add({ title: 'Sign out failed', description: error?.error?.message || 'Unknown error'})
        }
      },
    })
  } catch (error: any) {
     toast.add({ title: 'An unexpected error occurred during sign out', description: error.message || 'Please try again.'})
  }
}
</script>

<template>
  <div>
    <USkeleton v-if="session.isPending" class="h-9 w-24" />

    <UButton v-else-if="!session.data" variant="outline" to="/login">
      Sign In
    </UButton>

    <UButton
      v-else
      variant="solid"
      icon="i-lucide-log-out"
      label="Sign out"
      @click="handleSignOut()"
    />
  </div>
</template>
`],
  ["auth/better-auth/web/nuxt/app/components/SignUpForm.vue.hbs", `<script setup lang="ts">
import * as z from 'zod'
import type { FormSubmitEvent, AuthFormField } from '@nuxt/ui'

const { $authClient } = useNuxtApp()

const emit = defineEmits(['switchToSignIn'])

const toast = useToast()
const loading = ref(false)

const fields: AuthFormField[] = [
  {
    name: 'name',
    type: 'text',
    label: 'Name',
    placeholder: 'Enter your name',
    required: true
  },
  {
    name: 'email',
    type: 'email',
    label: 'Email',
    placeholder: 'Enter your email',
    required: true
  },
  {
    name: 'password',
    type: 'password',
    label: 'Password',
    placeholder: 'Enter your password',
    required: true
  }
]

const schema = z.object({
  name: z.string().min(2, 'Name must be at least 2 characters'),
  email: z.email('Invalid email address'),
  password: z.string().min(8, 'Password must be at least 8 characters'),
})

type Schema = z.output<typeof schema>

async function onSubmit(event: FormSubmitEvent<Schema>) {
  loading.value = true
  try {
    await $authClient.signUp.email(
      {
        name: event.data.name,
        email: event.data.email,
        password: event.data.password,
      },
      {
        onSuccess: () => {
          toast.add({ title: 'Sign up successful' })
          navigateTo('/dashboard', { replace: true })
        },
        onError: (error) => {
          toast.add({ title: 'Sign up failed', description: error.error.message })
        },
      },
    )
  } catch (error: any) {
    toast.add({ title: 'An unexpected error occurred', description: error.message || 'Please try again.' })
  } finally {
    loading.value = false
  }
}
</script>

<template>
  <div class="flex flex-col items-center justify-center gap-4 p-4">
    <UPageCard class="w-full max-w-md">
      <UAuthForm
        :schema="schema"
        :fields="fields"
        title="Create Account"
        icon="i-lucide-user-plus"
        :submit="{ label: 'Sign Up', loading }"
        @submit="onSubmit"
      >
        <template #description>
          Already have an account?
          <ULink class="text-primary font-medium" @click="$emit('switchToSignIn')">
            Sign In
          </ULink>
        </template>
      </UAuthForm>
    </UPageCard>
  </div>
</template>
`],
  ["examples/todo/native/unistyles/app/(drawer)/todos.tsx.hbs", `import { useState } from "react";
import {
  View,
  Text,
  TextInput,
  TouchableOpacity,
  ScrollView,
  ActivityIndicator,
  Alert,
} from "react-native";
import { Ionicons } from "@expo/vector-icons";
import { StyleSheet, useUnistyles } from "react-native-unistyles";

{{#if (eq backend "convex")}}
import { useMutation, useQuery } from "convex/react";
import { api } from "@{{projectName}}/backend/convex/_generated/api";
import type { Id } from "@{{projectName}}/backend/convex/_generated/dataModel";
{{else}}
import { useMutation, useQuery } from "@tanstack/react-query";
{{/if}}

import { Container } from "@/components/container";
{{#unless (eq backend "convex")}}
{{#if (eq api "orpc")}}
import { orpc } from "@/utils/orpc";
{{/if}}
{{#if (eq api "trpc")}}
import { trpc } from "@/utils/trpc";
{{/if}}
{{/unless}}

export default function TodosScreen() {
  const [newTodoText, setNewTodoText] = useState("");
  const { theme } = useUnistyles();

  {{#if (eq backend "convex")}}
  const todos = useQuery(api.todos.getAll);
  const createTodoMutation = useMutation(api.todos.create);
  const toggleTodoMutation = useMutation(api.todos.toggle);
  const deleteTodoMutation = useMutation(api.todos.deleteTodo);

  const handleAddTodo = async () => {
    const text = newTodoText.trim();
    if (!text) return;
    await createTodoMutation({ text });
    setNewTodoText("");
  };

  const handleToggleTodo = (id: Id<"todos">, currentCompleted: boolean) => {
    toggleTodoMutation({ id, completed: !currentCompleted });
  };

  const handleDeleteTodo = (id: Id<"todos">) => {
    Alert.alert("Delete Todo", "Are you sure you want to delete this todo?", [
      { text: "Cancel", style: "cancel" },
      {
        text: "Delete",
        style: "destructive",
        onPress: () => deleteTodoMutation({ id }),
      },
    ]);
  };
  {{else}}
    {{#if (eq api "orpc")}}
    const todos = useQuery(orpc.todo.getAll.queryOptions());
    const createMutation = useMutation(
      orpc.todo.create.mutationOptions({
        onSuccess: () => {
          todos.refetch();
          setNewTodoText("");
        },
      })
    );
    const toggleMutation = useMutation(
      orpc.todo.toggle.mutationOptions({
        onSuccess: () => { todos.refetch() },
      })
    );
    const deleteMutation = useMutation(
      orpc.todo.delete.mutationOptions({
        onSuccess: () => { todos.refetch() },
      })
    );
    {{/if}}
    {{#if (eq api "trpc")}}
    const todos = useQuery(trpc.todo.getAll.queryOptions());
    const createMutation = useMutation(
      trpc.todo.create.mutationOptions({
        onSuccess: () => {
          todos.refetch();
          setNewTodoText("");
        },
      })
    );
    const toggleMutation = useMutation(
      trpc.todo.toggle.mutationOptions({
        onSuccess: () => { todos.refetch() },
      })
    );
    const deleteMutation = useMutation(
      trpc.todo.delete.mutationOptions({
        onSuccess: () => { todos.refetch() },
      })
    );
    {{/if}}

  const handleAddTodo = () => {
    if (newTodoText.trim()) {
      createMutation.mutate({ text: newTodoText });
    }
  };

  const handleToggleTodo = (id: number, completed: boolean) => {
    toggleMutation.mutate({ id, completed: !completed });
  };

  const handleDeleteTodo = (id: number) => {
    Alert.alert("Delete Todo", "Are you sure you want to delete this todo?", [
      { text: "Cancel", style: "cancel" },
      {
        text: "Delete",
        style: "destructive",
        onPress: () => deleteMutation.mutate({ id }),
      },
    ]);
  };
  {{/if}}

  const isLoading = {{#if (eq backend "convex")}}!todos{{else}}todos.isLoading{{/if}};
  const isCreating = {{#if (eq backend "convex")}}false{{else}}createMutation.isPending{{/if}};
  const primaryButtonTextColor = theme.colors.background;

  return (
    <Container>
      <ScrollView style={styles.scrollView}>
        <View style={styles.headerContainer}>
          <Text style={styles.headerTitle}>Todo List</Text>
          <Text style={styles.headerSubtitle}>
            Manage your tasks efficiently
          </Text>

          <View style={styles.inputContainer}>
            <TextInput
              value={newTodoText}
              onChangeText={setNewTodoText}
              placeholder="Add a new task..."
              placeholderTextColor={theme.colors.border}
              editable={!isCreating}
              style={styles.textInput}
              onSubmitEditing={handleAddTodo}
              returnKeyType="done"
            />
            <TouchableOpacity
              onPress={handleAddTodo}
              disabled={isCreating || !newTodoText.trim()}
              style={[
                styles.addButton,
                (isCreating || !newTodoText.trim()) && styles.addButtonDisabled,
              ]}
            >
              {isCreating ? (
                <ActivityIndicator size="small" color={primaryButtonTextColor} />
              ) : (
                <Ionicons
                  name="add"
                  size={24}
                  color={primaryButtonTextColor}
                />
              )}
            </TouchableOpacity>
          </View>
        </View>

        {isLoading && (
          <View style={styles.loadingContainer}>
            <ActivityIndicator size="large" color={theme.colors.primary} />
            <Text style={styles.loadingText}>Loading todos...</Text>
          </View>
        )}

        {{#if (eq backend "convex")}}
          {todos && todos.length === 0 && !isLoading && (
            <Text style={styles.emptyText}>No todos yet. Add one!</Text>
          )}
          {todos?.map((todo) => (
            <View key={todo._id} style={styles.todoItem}>
              <TouchableOpacity
                onPress={() => handleToggleTodo(todo._id, todo.completed)}
                style={styles.todoContent}
              >
                <Ionicons
                  name={todo.completed ? "checkbox" : "square-outline"}
                  size={24}
                  color={todo.completed ? theme.colors.primary : theme.colors.typography}
                  style={styles.checkbox}
                />
                <Text
                  style={[
                    styles.todoText,
                    todo.completed && styles.todoTextCompleted,
                  ]}
                >
                  {todo.text}
                </Text>
              </TouchableOpacity>
              <TouchableOpacity onPress={() => handleDeleteTodo(todo._id)}>
                <Ionicons name="trash-outline" size={24} color={theme.colors.destructive} />
              </TouchableOpacity>
            </View>
          ))}
        {{else}}
          {todos.data && todos.data.length === 0 && !isLoading && (
             <Text style={styles.emptyText}>No todos yet. Add one!</Text>
          )}
          {todos.data?.map((todo: { id: number; text: string; completed: boolean }) => (
            <View key={todo.id} style={styles.todoItem}>
              <TouchableOpacity
                onPress={() => handleToggleTodo(todo.id, todo.completed)}
                style={styles.todoContent}
              >
                <Ionicons
                  name={todo.completed ? "checkbox" : "square-outline"}
                  size={24}
                  color={todo.completed ? theme.colors.primary : theme.colors.typography}
                  style={styles.checkbox}
                />
                <Text
                  style={[
                    styles.todoText,
                    todo.completed && styles.todoTextCompleted,
                  ]}
                >
                  {todo.text}
                </Text>
              </TouchableOpacity>
              <TouchableOpacity onPress={() => handleDeleteTodo(todo.id)}>
                <Ionicons name="trash-outline" size={24} color={theme.colors.destructive} />
              </TouchableOpacity>
            </View>
          ))}
        {{/if}}
      </ScrollView>
    </Container>
  );
}

const styles = StyleSheet.create((theme) => ({
  scrollView: {
    flex: 1,
  },
  headerContainer: {
    paddingHorizontal: theme.spacing.md,
    paddingVertical: theme.spacing.lg,
    borderBottomWidth: 1,
    borderBottomColor: theme.colors.border,
    backgroundColor: theme.colors.background,
  },
  headerTitle: {
    fontSize: 28,
    fontWeight: "bold",
    color: theme.colors.typography,
    marginBottom: theme.spacing.sm,
  },
  headerSubtitle: {
    fontSize: 16,
    color: theme.colors.typography,
    marginBottom: theme.spacing.md,
  },
  inputContainer: {
    flexDirection: "row",
    alignItems: "center",
    marginBottom: theme.spacing.md,
  },
  textInput: {
    flex: 1,
    borderWidth: 1,
    borderColor: theme.colors.border,
    borderRadius: 8,
    paddingHorizontal: theme.spacing.md,
    paddingVertical: theme.spacing.sm,
    color: theme.colors.typography,
    backgroundColor: theme.colors.background,
    marginRight: theme.spacing.sm,
    fontSize: 16,
  },
  addButton: {
    backgroundColor: theme.colors.primary,
    padding: theme.spacing.sm,
    borderRadius: 8,
    justifyContent: "center",
    alignItems: "center",
  },
  addButtonDisabled: {
    backgroundColor: theme.colors.border,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    padding: theme.spacing.lg,
  },
  loadingText: {
    marginTop: theme.spacing.sm,
    fontSize: 16,
    color: theme.colors.typography,
  },
  emptyText: {
    textAlign: "center",
    marginTop: theme.spacing.xl,
    fontSize: 16,
    color: theme.colors.typography,
  },
  todoItem: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    paddingVertical: theme.spacing.md,
    paddingHorizontal: theme.spacing.md,
    borderBottomWidth: 1,
    borderBottomColor: theme.colors.border,
    backgroundColor: theme.colors.background,
  },
  todoContent: {
    flexDirection: "row",
    alignItems: "center",
    flex: 1,
  },
  checkbox: {
    marginRight: theme.spacing.md,
  },
  todoText: {
    fontSize: 16,
    color: theme.colors.typography,
    flex: 1,
  },
  todoTextCompleted: {
    textDecorationLine: "line-through",
    color: theme.colors.border,
  },
}));
`],
  ["auth/better-auth/web/nuxt/app/middleware/auth.ts.hbs", `export default defineNuxtRouteMiddleware(async (to, from) => {
  if (import.meta.server) return;

  const { $authClient } = useNuxtApp();
  const session = $authClient.useSession();

  if (session.value.isPending) {
    return;
  }

  if (!session.value.data) {
    return navigateTo("/login");
  }
});
`],
  ["examples/todo/native/bare/app/(drawer)/todos.tsx.hbs", `import { useState } from "react";
import {
  View,
  Text,
  TextInput,
  ScrollView,
  ActivityIndicator,
  Alert,
  TouchableOpacity,
  StyleSheet,
} from "react-native";
import { Ionicons } from "@expo/vector-icons";
{{#if (eq backend "convex")}}
import { useMutation, useQuery } from "convex/react";
import { api } from "@{{projectName}}/backend/convex/_generated/api";
import type { Id } from "@{{projectName}}/backend/convex/_generated/dataModel";
{{else}}
import { useMutation, useQuery } from "@tanstack/react-query";
{{/if}}
import { Container } from "@/components/container";
import { useColorScheme } from "@/lib/use-color-scheme";
import { NAV_THEME } from "@/lib/constants";
{{#unless (eq backend "convex")}}
  {{#if (eq api "orpc")}}
import { orpc } from "@/utils/orpc";
  {{/if}}
  {{#if (eq api "trpc")}}
import { trpc } from "@/utils/trpc";
  {{/if}}
{{/unless}}

export default function TodosScreen() {
  const { colorScheme } = useColorScheme();
  const theme = colorScheme === "dark" ? NAV_THEME.dark : NAV_THEME.light;
  const [newTodoText, setNewTodoText] = useState("");

  {{#if (eq backend "convex")}}
  const todos = useQuery(api.todos.getAll);
  const createTodoMutation = useMutation(api.todos.create);
  const toggleTodoMutation = useMutation(api.todos.toggle);
  const deleteTodoMutation = useMutation(api.todos.deleteTodo);

  async function handleAddTodo() {
    const text = newTodoText.trim();
    if (!text) return;
    await createTodoMutation({ text });
    setNewTodoText("");
  }

  function handleToggleTodo(id: Id<"todos">, currentCompleted: boolean) {
    toggleTodoMutation({ id, completed: !currentCompleted });
  }

  function handleDeleteTodo(id: Id<"todos">) {
    Alert.alert("Delete Todo", "Are you sure you want to delete this todo?", [
      { text: "Cancel", style: "cancel" },
      {
        text: "Delete",
        style: "destructive",
        onPress: () => deleteTodoMutation({ id }),
      },
    ]);
  }

  const isLoading = !todos;
  const completedCount = todos?.filter((t) => t.completed).length || 0;
  const totalCount = todos?.length || 0;
  {{else}}
    {{#if (eq api "orpc")}}
  const todos = useQuery(orpc.todo.getAll.queryOptions());
  const createMutation = useMutation(
    orpc.todo.create.mutationOptions({
      onSuccess: () => {
        todos.refetch();
        setNewTodoText("");
      },
    })
  );
  const toggleMutation = useMutation(
    orpc.todo.toggle.mutationOptions({
      onSuccess: () => {
        todos.refetch();
      },
    })
  );
  const deleteMutation = useMutation(
    orpc.todo.delete.mutationOptions({
      onSuccess: () => {
        todos.refetch();
      },
    })
  );
    {{/if}}
    {{#if (eq api "trpc")}}
  const todos = useQuery(trpc.todo.getAll.queryOptions());
  const createMutation = useMutation(
    trpc.todo.create.mutationOptions({
      onSuccess: () => {
        todos.refetch();
        setNewTodoText("");
      },
    })
  );
  const toggleMutation = useMutation(
    trpc.todo.toggle.mutationOptions({
      onSuccess: () => {
        todos.refetch();
      },
    })
  );
  const deleteMutation = useMutation(
    trpc.todo.delete.mutationOptions({
      onSuccess: () => {
        todos.refetch();
      },
    })
  );
    {{/if}}

  function handleAddTodo() {
    if (newTodoText.trim()) {
      createMutation.mutate({ text: newTodoText });
    }
  }

  function handleToggleTodo(id: number, completed: boolean) {
    toggleMutation.mutate({ id, completed: !completed });
  }

  function handleDeleteTodo(id: number) {
    Alert.alert("Delete Todo", "Are you sure you want to delete this todo?", [
      { text: "Cancel", style: "cancel" },
      {
        text: "Delete",
        style: "destructive",
        onPress: () => deleteMutation.mutate({ id }),
      },
    ]);
  }

  const isLoading = todos?.isLoading;
  const completedCount = todos?.data?.filter((t) => t.completed).length || 0;
  const totalCount = todos?.data?.length || 0;
  {{/if}}

  return (
    <Container>
      <ScrollView
        style={styles.scrollView}
        contentContainerStyle={styles.contentContainer}
      >
        <View style={styles.header}>
          <View style={styles.headerRow}>
            <Text style={[styles.title, { color: theme.text }]}>
              Todo List
            </Text>
            {totalCount > 0 && (
              <View style={[styles.badge, { backgroundColor: theme.primary }]}>
                <Text style={styles.badgeText}>
                  {completedCount}/{totalCount}
                </Text>
              </View>
            )}
          </View>
        </View>
        <View
          style={[
            styles.inputCard,
            { backgroundColor: theme.card, borderColor: theme.border },
          ]}
        >
          <View style={styles.inputRow}>
            <View style={styles.inputContainer}>
              <TextInput
                value={newTodoText}
                onChangeText={setNewTodoText}
                placeholder="Add a new task..."
                placeholderTextColor={theme.text}
                {{#unless (eq backend "convex")}}
                editable={!createMutation.isPending}
                {{/unless}}
                onSubmitEditing={handleAddTodo}
                returnKeyType="done"
                style={[
                  styles.input,
                  {
                    color: theme.text,
                    borderColor: theme.border,
                    backgroundColor: theme.background,
                  },
                ]}
              />
            </View>
            <TouchableOpacity
              onPress={handleAddTodo}
              {{#if (eq backend "convex")}}
              disabled={!newTodoText.trim()}
              style={[
                styles.addButton,
                {
                  backgroundColor: !newTodoText.trim()
                    ? theme.border
                    : theme.primary,
                  opacity: !newTodoText.trim() ? 0.5 : 1,
                },
              ]}
            >
              <Ionicons
                name="add"
                size={24}
                color={newTodoText.trim() ? "#ffffff" : theme.text}
              />
              {{else}}
              disabled={createMutation.isPending || !newTodoText.trim()}
              style={[
                styles.addButton,
                {
                  backgroundColor:
                    createMutation.isPending || !newTodoText.trim()
                      ? theme.border
                      : theme.primary,
                  opacity:
                    createMutation.isPending || !newTodoText.trim() ? 0.5 : 1,
                },
              ]}
            >
              {createMutation.isPending ? (
                <ActivityIndicator size="small" color="#ffffff" />
              ) : (
                <Ionicons name="add" size={24} color="#ffffff" />
              )}
              {{/if}}
            </TouchableOpacity>
          </View>
        </View>

        {{#if (eq backend "convex")}}
        {isLoading && (
          <View style={styles.centerContainer}>
            <ActivityIndicator size="large" color={theme.primary} />
            <Text
              style={[styles.loadingText, { color: theme.text, opacity: 0.7 }]}
            >
              Loading todos...
            </Text>
          </View>
        )}

        {todos && todos.length === 0 && !isLoading && (
          <View
            style={[
              styles.emptyCard,
              { backgroundColor: theme.card, borderColor: theme.border },
            ]}
          >
            <Ionicons
              name="checkbox-outline"
              size={64}
              color={theme.text}
              style=\\{{ opacity: 0.5, marginBottom: 16 }}
            />
            <Text style={[styles.emptyTitle, { color: theme.text }]}>
              No todos yet
            </Text>
            <Text
              style={[styles.emptyText, { color: theme.text, opacity: 0.7 }]}
            >
              Add your first task to get started!
            </Text>
          </View>
        )}

        {todos && todos.length > 0 && (
          <View style={styles.todosList}>
            {todos.map((todo) => (
              <View
                key={todo._id}
                style={[
                  styles.todoCard,
                  { backgroundColor: theme.card, borderColor: theme.border },
                ]}
              >
                <View style={styles.todoRow}>
                  <TouchableOpacity
                    onPress={() => handleToggleTodo(todo._id, todo.completed)}
                    style={[styles.checkbox, { borderColor: theme.border }]}
                  >
                    {todo.completed && (
                      <Ionicons
                        name="checkmark"
                        size={16}
                        color={theme.primary}
                      />
                    )}
                  </TouchableOpacity>
                  <View style={styles.todoTextContainer}>
                    <Text
                      style={[
                        styles.todoText,
                        { color: theme.text },
                        todo.completed && {
                          textDecorationLine: "line-through",
                          opacity: 0.5,
                        },
                      ]}
                    >
                      {todo.text}
                    </Text>
                  </View>
                  <TouchableOpacity
                    onPress={() => handleDeleteTodo(todo._id)}
                    style={styles.deleteButton}
                  >
                    <Ionicons
                      name="trash-outline"
                      size={24}
                      color={theme.notification}
                    />
                  </TouchableOpacity>
                </View>
              </View>
            ))}
          </View>
        )}
        {{else}}
        {isLoading && (
          <View style={styles.centerContainer}>
            <ActivityIndicator size="large" color={theme.primary} />
            <Text
              style={[styles.loadingText, { color: theme.text, opacity: 0.7 }]}
            >
              Loading todos...
            </Text>
          </View>
        )}

        {todos?.data && todos.data.length === 0 && !isLoading && (
          <View
            style={[
              styles.emptyCard,
              { backgroundColor: theme.card, borderColor: theme.border },
            ]}
          >
            <Ionicons
              name="checkbox-outline"
              size={64}
              color={theme.text}
              style=\\{{ opacity: 0.5, marginBottom: 16 }}
            />
            <Text style={[styles.emptyTitle, { color: theme.text }]}>
              No todos yet
            </Text>
            <Text
              style={[styles.emptyText, { color: theme.text, opacity: 0.7 }]}
            >
              Add your first task to get started!
            </Text>
          </View>
        )}

        {todos?.data && todos.data.length > 0 && (
          <View style={styles.todosList}>
            {todos.data.map((todo) => (
              <View
                key={todo.id}
                style={[
                  styles.todoCard,
                  { backgroundColor: theme.card, borderColor: theme.border },
                ]}
              >
                <View style={styles.todoRow}>
                  <TouchableOpacity
                    onPress={() => handleToggleTodo(todo.id, todo.completed)}
                    style={[styles.checkbox, { borderColor: theme.border }]}
                  >
                    {todo.completed && (
                      <Ionicons
                        name="checkmark"
                        size={16}
                        color={theme.primary}
                      />
                    )}
                  </TouchableOpacity>
                  <View style={styles.todoTextContainer}>
                    <Text
                      style={[
                        styles.todoText,
                        { color: theme.text },
                        todo.completed && {
                          textDecorationLine: "line-through",
                          opacity: 0.5,
                        },
                      ]}
                    >
                      {todo.text}
                    </Text>
                  </View>
                  <TouchableOpacity
                    onPress={() => handleDeleteTodo(todo.id)}
                    style={styles.deleteButton}
                  >
                    <Ionicons
                      name="trash-outline"
                      size={24}
                      color={theme.notification}
                    />
                  </TouchableOpacity>
                </View>
              </View>
            ))}
          </View>
        )}
        {{/if}}
      </ScrollView>
    </Container>
  );
}

const styles = StyleSheet.create({
  scrollView: {
    flex: 1,
  },
  contentContainer: {
    padding: 16,
  },
  header: {
    marginBottom: 16,
  },
  headerRow: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
  },
  title: {
    fontSize: 24,
    fontWeight: "bold",
  },
  badge: {
    paddingHorizontal: 8,
    paddingVertical: 4,
  },
  badgeText: {
    color: "#ffffff",
    fontSize: 12,
  },
  inputCard: {
    borderWidth: 1,
    padding: 12,
    marginBottom: 16,
  },
  inputRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
  },
  inputContainer: {
    flex: 1,
  },
  input: {
    borderWidth: 1,
    padding: 12,
    fontSize: 16,
  },
  addButton: {
    padding: 12,
    justifyContent: "center",
    alignItems: "center",
  },
  centerContainer: {
    alignItems: "center",
    justifyContent: "center",
    paddingVertical: 32,
  },
  loadingText: {
    marginTop: 16,
    fontSize: 14,
  },
  emptyCard: {
    borderWidth: 1,
    padding: 32,
    alignItems: "center",
    justifyContent: "center",
  },
  emptyTitle: {
    fontSize: 16,
    fontWeight: "bold",
    marginBottom: 8,
  },
  emptyText: {
    fontSize: 14,
    textAlign: "center",
  },
  todosList: {
    gap: 8,
  },
  todoCard: {
    borderWidth: 1,
    padding: 12,
  },
  todoRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 12,
  },
  checkbox: {
    width: 20,
    height: 20,
    borderWidth: 2,
    justifyContent: "center",
    alignItems: "center",
  },
  todoTextContainer: {
    flex: 1,
  },
  todoText: {
    fontSize: 16,
  },
  deleteButton: {
    padding: 8,
  },
});`],
  ["auth/better-auth/web/nuxt/app/plugins/auth-client.ts.hbs", `import { createAuthClient } from "better-auth/vue";
{{#if (eq payments "polar")}}
import { polarClient } from "@polar-sh/better-auth";
{{/if}}

export default defineNuxtPlugin(() => {
  const config = useRuntimeConfig();

  const authClient = createAuthClient({
    baseURL: config.public.serverUrl,
    {{#if (eq payments "polar")}}
    plugins: [polarClient()],
    {{/if}}
  });

  return {
    provide: {
      authClient: authClient,
    },
  };
});
`],
  ["email/resend/server/base/src/lib/email.ts.hbs", `import { Resend } from "resend";

// Initialize Resend client
const resend = new Resend(process.env.RESEND_API_KEY);

export interface SendEmailOptions {
  to: string | string[];
  subject: string;
  html?: string;
  text?: string;
  react?: React.ReactElement;
  from?: string;
  replyTo?: string;
}

/**
 * Send an email using Resend
 * @see https://resend.com/docs/send-with-nodejs
 */
export async function sendEmail(options: SendEmailOptions) {
  const { to, subject, html, text, react, from, replyTo } = options;

  const fromAddress = from || process.env.RESEND_FROM_EMAIL || "onboarding@resend.dev";

  try {
    const { data, error } = await resend.emails.send({
      from: fromAddress,
      to: Array.isArray(to) ? to : [to],
      subject,
      html,
      text,
      react,
      replyTo,
    });

    if (error) {
      console.error("Failed to send email:", error);
      throw new Error(\`Failed to send email: \${error.message}\`);
    }

    return { success: true, data };
  } catch (error) {
    console.error("Email sending error:", error);
    throw error;
  }
}

/**
 * Get the Resend client instance for advanced usage
 */
export function getResendClient() {
  return resend;
}

export { resend };
`],
  ["auth/better-auth/convex/native/bare/components/sign-up.tsx.hbs", `import { authClient } from "@/lib/auth-client";
import { useState } from "react";
import {
  ActivityIndicator,
  Text,
  TextInput,
  TouchableOpacity,
  View,
  StyleSheet,
} from "react-native";
import { useColorScheme } from "@/lib/use-color-scheme";
import { NAV_THEME } from "@/lib/constants";

function SignUp() {
  const { colorScheme } = useColorScheme();
  const theme = colorScheme === "dark" ? NAV_THEME.dark : NAV_THEME.light;
  const [name, setName] = useState("");
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  async function handleSignUp() {
    setIsLoading(true);
    setError(null);

    await authClient.signUp.email(
      {
        name,
        email,
        password,
      },
      {
        onError(error) {
          setError(error.error?.message || "Failed to sign up");
          setIsLoading(false);
        },
        onSuccess() {
          setName("");
          setEmail("");
          setPassword("");
        },
        onFinished() {
          setIsLoading(false);
        },
      }
    );
  }

  return (
    <View style={[styles.card, { backgroundColor: theme.card, borderColor: theme.border }]}>
      <Text style={[styles.title, { color: theme.text }]}>Create Account</Text>

      {error ? (
        <View style={[styles.errorContainer, { backgroundColor: theme.notification + "20" }]}>
          <Text style={[styles.errorText, { color: theme.notification }]}>{error}</Text>
        </View>
      ) : null}

      <TextInput
        style={[styles.input, { color: theme.text, borderColor: theme.border, backgroundColor: theme.background }]}
        placeholder="Name"
        placeholderTextColor={theme.text}
        value={name}
        onChangeText={setName}
      />

      <TextInput
        style={[styles.input, { color: theme.text, borderColor: theme.border, backgroundColor: theme.background }]}
        placeholder="Email"
        placeholderTextColor={theme.text}
        value={email}
        onChangeText={setEmail}
        keyboardType="email-address"
        autoCapitalize="none"
      />

      <TextInput
        style={[styles.input, { color: theme.text, borderColor: theme.border, backgroundColor: theme.background }]}
        placeholder="Password"
        placeholderTextColor={theme.text}
        value={password}
        onChangeText={setPassword}
        secureTextEntry
      />

      <TouchableOpacity
        onPress={handleSignUp}
        disabled={isLoading}
        style={[styles.button, { backgroundColor: theme.primary, opacity: isLoading ? 0.5 : 1 }]}
      >
        {isLoading ? (
          <ActivityIndicator size="small" color="#ffffff" />
        ) : (
          <Text style={styles.buttonText}>Sign Up</Text>
        )}
      </TouchableOpacity>
    </View>
  );
}

const styles = StyleSheet.create({
  card: {
    marginTop: 16,
    padding: 16,
    borderWidth: 1,
  },
  title: {
    fontSize: 18,
    fontWeight: "bold",
    marginBottom: 12,
  },
  errorContainer: {
    marginBottom: 12,
    padding: 8,
  },
  errorText: {
    fontSize: 14,
  },
  input: {
    borderWidth: 1,
    padding: 12,
    fontSize: 16,
    marginBottom: 12,
  },
  button: {
    padding: 12,
    alignItems: "center",
    justifyContent: "center",
  },
  buttonText: {
    color: "#ffffff",
    fontSize: 16,
  },
});

export { SignUp };

`],
  ["auth/better-auth/convex/native/bare/components/sign-in.tsx.hbs", `import { authClient } from "@/lib/auth-client";
import { useState } from "react";
import {
  ActivityIndicator,
  Text,
  TextInput,
  TouchableOpacity,
  View,
  StyleSheet,
} from "react-native";
import { useColorScheme } from "@/lib/use-color-scheme";
import { NAV_THEME } from "@/lib/constants";

function SignIn() {
  const { colorScheme } = useColorScheme();
  const theme = colorScheme === "dark" ? NAV_THEME.dark : NAV_THEME.light;
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  async function handleLogin() {
    setIsLoading(true);
    setError(null);

    await authClient.signIn.email(
      {
        email,
        password,
      },
      {
        onError(error) {
          setError(error.error?.message || "Failed to sign in");
          setIsLoading(false);
        },
        onSuccess() {
          setEmail("");
          setPassword("");
        },
        onFinished() {
          setIsLoading(false);
        },
      }
    );
  }

  return (
    <View style={[styles.card, { backgroundColor: theme.card, borderColor: theme.border }]}>
      <Text style={[styles.title, { color: theme.text }]}>Sign In</Text>

      {error ? (
        <View style={[styles.errorContainer, { backgroundColor: theme.notification + "20" }]}>
          <Text style={[styles.errorText, { color: theme.notification }]}>{error}</Text>
        </View>
      ) : null}

      <TextInput
        style={[styles.input, { color: theme.text, borderColor: theme.border, backgroundColor: theme.background }]}
        placeholder="Email"
        placeholderTextColor={theme.text}
        value={email}
        onChangeText={setEmail}
        keyboardType="email-address"
        autoCapitalize="none"
      />

      <TextInput
        style={[styles.input, { color: theme.text, borderColor: theme.border, backgroundColor: theme.background }]}
        placeholder="Password"
        placeholderTextColor={theme.text}
        value={password}
        onChangeText={setPassword}
        secureTextEntry
      />

      <TouchableOpacity
        onPress={handleLogin}
        disabled={isLoading}
        style={[styles.button, { backgroundColor: theme.primary, opacity: isLoading ? 0.5 : 1 }]}
      >
        {isLoading ? (
          <ActivityIndicator size="small" color="#ffffff" />
        ) : (
          <Text style={styles.buttonText}>Sign In</Text>
        )}
      </TouchableOpacity>
    </View>
  );
}

const styles = StyleSheet.create({
  card: {
    marginTop: 16,
    padding: 16,
    borderWidth: 1,
  },
  title: {
    fontSize: 18,
    fontWeight: "bold",
    marginBottom: 12,
  },
  errorContainer: {
    marginBottom: 12,
    padding: 8,
  },
  errorText: {
    fontSize: 14,
  },
  input: {
    borderWidth: 1,
    padding: 12,
    fontSize: 16,
    marginBottom: 12,
  },
  button: {
    padding: 12,
    alignItems: "center",
    justifyContent: "center",
  },
  buttonText: {
    color: "#ffffff",
    fontSize: 16,
  },
});

export { SignIn };

`],
  ["examples/todo/native/uniwind/app/(drawer)/todos.tsx.hbs", `import { useState } from "react";
import { View, Text, ScrollView, Alert } from "react-native";
import { Ionicons } from "@expo/vector-icons";
{{#if (eq backend "convex")}}
import { useMutation, useQuery } from "convex/react";
import { api } from "@{{projectName}}/backend/convex/_generated/api";
import type { Id } from "@{{projectName}}/backend/convex/_generated/dataModel";
{{else}}
import { useMutation, useQuery } from "@tanstack/react-query";
{{/if}}
import { Container } from "@/components/container";
{{#unless (eq backend "convex")}}
  {{#if (eq api "orpc")}}
    import { orpc } from "@/utils/orpc";
  {{/if}}
  {{#if (eq api "trpc")}}
    import { trpc } from "@/utils/trpc";
  {{/if}}
{{/unless}}
import { Button, Checkbox, Chip, Spinner, Surface, TextField, useThemeColor } from "heroui-native";

export default function TodosScreen() {
  const [newTodoText, setNewTodoText] = useState("");
  {{#if (eq backend "convex")}}
    const todos = useQuery(api.todos.getAll);
    const createTodoMutation = useMutation(api.todos.create);
    const toggleTodoMutation = useMutation(api.todos.toggle);
    const deleteTodoMutation = useMutation(api.todos.deleteTodo);
  {{else}}
    {{#if (eq api "orpc")}}
      const todos = useQuery(orpc.todo.getAll.queryOptions());
      const createMutation = useMutation(orpc.todo.create.mutationOptions({
        onSuccess: () => {
          todos.refetch();
          setNewTodoText("");
        },
      }));
      const toggleMutation = useMutation(orpc.todo.toggle.mutationOptions({
        onSuccess: () => {
          todos.refetch();
        },
      }));
      const deleteMutation = useMutation(orpc.todo.delete.mutationOptions({
        onSuccess: () => {
          todos.refetch();
        },
      }));
    {{/if}}
    {{#if (eq api "trpc")}}
      const todos = useQuery(trpc.todo.getAll.queryOptions());
      const createMutation = useMutation(trpc.todo.create.mutationOptions({
        onSuccess: () => {
          todos.refetch();
          setNewTodoText("");
        },
      }));
      const toggleMutation = useMutation(trpc.todo.toggle.mutationOptions({
        onSuccess: () => {
          todos.refetch();
        },
      }));
      const deleteMutation = useMutation(trpc.todo.delete.mutationOptions({
        onSuccess: () => {
          todos.refetch();
        },
      }));
    {{/if}}
  {{/if}}

  const mutedColor = useThemeColor("muted");
  const dangerColor = useThemeColor("danger");
  const foregroundColor = useThemeColor("foreground");

  {{#if (eq backend "convex")}}
    const handleAddTodo = async () => {
      const text = newTodoText.trim();
      if (!text) return;
      await createTodoMutation({ text });
      setNewTodoText("");
    };

    const handleToggleTodo = (id: Id<"todos">, currentCompleted: boolean) => {
      toggleTodoMutation({ id, completed: !currentCompleted });
    };

    const handleDeleteTodo = (id: Id<"todos">) => {
      Alert.alert("Delete Todo", "Are you sure you want to delete this todo?", [
        { text: "Cancel", style: "cancel" },
        {
          text: "Delete",
          style: "destructive",
          onPress: () => deleteTodoMutation({ id }),
        },
      ]);
    };

    const isLoading = !todos;
    const completedCount = todos?.filter((t) => t.completed).length || 0;
    const totalCount = todos?.length || 0;
  {{else}}
    const handleAddTodo = () => {
      if (newTodoText.trim()) {
        createMutation.mutate({ text: newTodoText });
      }
    };

    const handleToggleTodo = (id: number, completed: boolean) => {
      toggleMutation.mutate({ id, completed: !completed });
    };

    const handleDeleteTodo = (id: number) => {
      Alert.alert("Delete Todo", "Are you sure you want to delete this todo?", [
        { text: "Cancel", style: "cancel" },
        {
          text: "Delete",
          style: "destructive",
          onPress: () => deleteMutation.mutate({ id }),
        },
      ]);
    };

    const isLoading = todos?.isLoading;
    const completedCount = todos?.data?.filter((t) => t.completed).length || 0;
    const totalCount = todos?.data?.length || 0;
  {{/if}}

  return (
    <Container>
      <ScrollView className="flex-1" contentContainerClassName="p-4">
        <View className="py-4 mb-4">
          <View className="flex-row items-center justify-between">
            <Text className="text-2xl font-semibold text-foreground tracking-tight">Tasks</Text>
            {totalCount > 0 && (
              <Chip variant="secondary" color="accent" size="sm">
                <Chip.Label>
                  {completedCount}/{totalCount}
                </Chip.Label>
              </Chip>
            )}
          </View>
        </View>

        <Surface variant="secondary" className="mb-4 p-3 rounded-lg">
          <View className="flex-row items-center gap-2">
            <View className="flex-1">
              <TextField>
                <TextField.Input
                  value={newTodoText}
                  onChangeText={setNewTodoText}
                  placeholder="Add a new task..."
                  {{#unless (eq backend "convex")}}
                    editable={!createMutation.isPending}
                  {{/unless}}
                  onSubmitEditing={handleAddTodo}
                  returnKeyType="done"
                />
              </TextField>
            </View>
            <Button
              isIconOnly
              {{#if (eq backend "convex")}}
                variant={!newTodoText.trim() ? "secondary" : "primary"}
                isDisabled={!newTodoText.trim()}
              {{else}}
                variant={createMutation.isPending || !newTodoText.trim() ? "secondary" : "primary"}
                isDisabled={createMutation.isPending || !newTodoText.trim()}
              {{/if}}
              onPress={handleAddTodo}
              size="sm"
            >
              {{#if (eq backend "convex")}}
                <Ionicons
                  name="add"
                  size={20}
                  color={newTodoText.trim() ? foregroundColor : mutedColor}
                />
              {{else}}
                {createMutation.isPending ? (
                  <Spinner size="sm" color="default" />
                ) : (
                  <Ionicons
                    name="add"
                    size={20}
                    color={(createMutation.isPending || !newTodoText.trim()) ? mutedColor : foregroundColor}
                  />
                )}
              {{/if}}
            </Button>
          </View>
        </Surface>

        {{#if (eq backend "convex")}}
          {isLoading && (
            <View className="items-center justify-center py-12">
              <Spinner size="lg" />
              <Text className="text-muted text-sm mt-3">Loading tasks...</Text>
            </View>
          )}

          {todos && todos.length === 0 && !isLoading && (
            <Surface variant="secondary" className="items-center justify-center py-10 rounded-lg">
              <Ionicons name="checkbox-outline" size={40} color={mutedColor} />
              <Text className="text-foreground font-medium mt-3">No tasks yet</Text>
              <Text className="text-muted text-xs mt-1">Add your first task to get started</Text>
            </Surface>
          )}

          {todos && todos.length > 0 && (
            <View className="gap-2">
              {todos.map((todo) => (
                <Surface key={todo._id} variant="secondary" className="p-3 rounded-lg">
                  <View className="flex-row items-center gap-3">
                    <Checkbox
                      isSelected={todo.completed}
                      onSelectedChange={() => handleToggleTodo(todo._id, todo.completed)}
                    />
                    <View className="flex-1">
                      <Text className={\`text-sm \${todo.completed ? "text-muted line-through" : "text-foreground"}\`}>
                        {todo.text}
                      </Text>
                    </View>
                    <Button
                      isIconOnly
                      variant="ghost"
                      onPress={() => handleDeleteTodo(todo._id)}
                      size="sm"
                    >
                      <Ionicons name="trash-outline" size={16} color={dangerColor} />
                    </Button>
                  </View>
                </Surface>
              ))}
            </View>
          )}
        {{else}}
          {isLoading && (
            <View className="items-center justify-center py-12">
              <Spinner size="lg" />
              <Text className="text-muted text-sm mt-3">Loading tasks...</Text>
            </View>
          )}

          {todos?.data && todos.data.length === 0 && !isLoading && (
            <Surface variant="secondary" className="items-center justify-center py-10 rounded-lg">
              <Ionicons name="checkbox-outline" size={40} color={mutedColor} />
              <Text className="text-foreground font-medium mt-3">No tasks yet</Text>
              <Text className="text-muted text-xs mt-1">Add your first task to get started</Text>
            </Surface>
          )}

          {todos?.data && todos.data.length > 0 && (
            <View className="gap-2">
              {todos.data.map((todo) => (
                <Surface key={todo.id} variant="secondary" className="p-3 rounded-lg">
                  <View className="flex-row items-center gap-3">
                    <Checkbox
                      isSelected={todo.completed}
                      onSelectedChange={() => handleToggleTodo(todo.id, todo.completed)}
                    />
                    <View className="flex-1">
                      <Text className={\`text-sm \${todo.completed ? "text-muted line-through" : "text-foreground"}\`}>
                        {todo.text}
                      </Text>
                    </View>
                    <Button
                      isIconOnly
                      variant="ghost"
                      onPress={() => handleDeleteTodo(todo.id)}
                      size="sm"
                    >
                      <Ionicons name="trash-outline" size={16} color={dangerColor} />
                    </Button>
                  </View>
                </Surface>
              ))}
            </View>
          )}
        {{/if}}
      </ScrollView>
    </Container>
  );
}`],
  ["auth/better-auth/convex/native/unistyles/components/sign-up.tsx.hbs", `import { authClient } from "@/lib/auth-client";
import { useState } from "react";
import {
  ActivityIndicator,
  Text,
  TextInput,
  TouchableOpacity,
  View,
} from "react-native";
import { StyleSheet } from "react-native-unistyles";

export function SignUp() {
  const [name, setName] = useState("");
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const handleSignUp = async () => {
    setIsLoading(true);
    setError(null);

    await authClient.signUp.email(
      {
        name,
        email,
        password,
      },
      {
        onError: (error) => {
          setError(error.error?.message || "Failed to sign up");
          setIsLoading(false);
        },
        onSuccess: () => {
          setName("");
          setEmail("");
          setPassword("");
        },
        onFinished: () => {
          setIsLoading(false);
        },
      },
    );
  };

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Create Account</Text>

      {error && (
        <View style={styles.errorContainer}>
          <Text style={styles.errorText}>{error}</Text>
        </View>
      )}

      <TextInput
        style={styles.input}
        placeholder="Name"
        value={name}
        onChangeText={setName}
      />

      <TextInput
        style={styles.input}
        placeholder="Email"
        value={email}
        onChangeText={setEmail}
        keyboardType="email-address"
        autoCapitalize="none"
      />

      <TextInput
        style={styles.inputLast}
        placeholder="Password"
        value={password}
        onChangeText={setPassword}
        secureTextEntry
      />

      <TouchableOpacity
        onPress={handleSignUp}
        disabled={isLoading}
        style={styles.button}
      >
        {isLoading ? (
          <ActivityIndicator size="small" color="#fff" />
        ) : (
          <Text style={styles.buttonText}>Sign Up</Text>
        )}
      </TouchableOpacity>
    </View>
  );
}

const styles = StyleSheet.create((theme) => ({
  container: {
    marginTop: 24,
    padding: 16,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: theme.colors.border,
  },
  title: {
    fontSize: 18,
    fontWeight: "600",
    color: theme.colors.typography,
    marginBottom: 16,
  },
  errorContainer: {
    marginBottom: 16,
    padding: 12,
    borderRadius: 6,
  },
  errorText: {
    color: theme.colors.destructive,
    fontSize: 14,
  },
  input: {
    marginBottom: 12,
    padding: 16,
    borderRadius: 6,
    color: theme.colors.typography,
    borderWidth: 1,
    borderColor: theme.colors.border,
  },
  inputLast: {
    marginBottom: 16,
    padding: 16,
    borderRadius: 6,
    color: theme.colors.typography,
    borderWidth: 1,
    borderColor: theme.colors.border,
  },
  button: {
    backgroundColor: theme.colors.primary,
    padding: 16,
    borderRadius: 6,
    flexDirection: "row",
    justifyContent: "center",
    alignItems: "center",
  },
  buttonText: {
    fontWeight: "500",
  },
}));
`],
  ["auth/better-auth/convex/native/unistyles/components/sign-in.tsx.hbs", `import { authClient } from "@/lib/auth-client";
import { useState } from "react";
import {
  ActivityIndicator,
  Text,
  TextInput,
  TouchableOpacity,
  View,
} from "react-native";
import { StyleSheet } from "react-native-unistyles";

export function SignIn() {
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const handleLogin = async () => {
    setIsLoading(true);
    setError(null);

    await authClient.signIn.email(
      {
        email,
        password,
      },
      {
        onError: (error) => {
          setError(error.error?.message || "Failed to sign in");
          setIsLoading(false);
        },
        onSuccess: () => {
          setEmail("");
          setPassword("");
        },
        onFinished: () => {
          setIsLoading(false);
        },
      },
    );
  };

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Sign In</Text>

      {error && (
        <View style={styles.errorContainer}>
          <Text style={styles.errorText}>{error}</Text>
        </View>
      )}

      <TextInput
        style={styles.input}
        placeholder="Email"
        value={email}
        onChangeText={setEmail}
        keyboardType="email-address"
        autoCapitalize="none"
      />

      <TextInput
        style={styles.input}
        placeholder="Password"
        value={password}
        onChangeText={setPassword}
        secureTextEntry
      />

      <TouchableOpacity
        onPress={handleLogin}
        disabled={isLoading}
        style={styles.button}
      >
        {isLoading ? (
          <ActivityIndicator size="small" color="#fff" />
        ) : (
          <Text style={styles.buttonText}>Sign In</Text>
        )}
      </TouchableOpacity>
    </View>
  );
}

const styles = StyleSheet.create((theme) => ({
  container: {
    marginTop: 24,
    padding: 16,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: theme.colors.border,
  },
  title: {
    fontSize: 18,
    fontWeight: "600",
    color: theme.colors.typography,
    marginBottom: 16,
  },
  errorContainer: {
    marginBottom: 16,
    padding: 12,
    borderRadius: 6,
  },
  errorText: {
    color: theme.colors.destructive,
    fontSize: 14,
  },
  input: {
    marginBottom: 12,
    padding: 16,
    borderRadius: 6,
    color: theme.colors.typography,
    borderWidth: 1,
    borderColor: theme.colors.border,
  },
  button: {
    backgroundColor: theme.colors.primary,
    padding: 16,
    borderRadius: 6,
    flexDirection: "row",
    justifyContent: "center",
    alignItems: "center",
  },
  buttonText: {
    fontWeight: "500",
  },
}));
`],
  ["auth/better-auth/convex/native/uniwind/components/sign-up.tsx.hbs", `import { authClient } from "@/lib/auth-client";
import { useState } from "react";
import { Text, View } from "react-native";
import { Button, ErrorView, Spinner, Surface, TextField } from "heroui-native";

export function SignUp() {
  const [name, setName] = useState("");
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const handleSignUp = async () => {
    setIsLoading(true);
    setError(null);

    await authClient.signUp.email(
      {
        name,
        email,
        password,
      },
      {
        onError: (error) => {
          setError(error.error?.message || "Failed to sign up");
          setIsLoading(false);
        },
        onSuccess: () => {
          setName("");
          setEmail("");
          setPassword("");
        },
        onFinished: () => {
          setIsLoading(false);
        },
      },
    );
  };

  return (
    <Surface variant="secondary" className="p-4 rounded-lg">
      <Text className="text-foreground font-medium mb-4">Create Account</Text>

      <ErrorView isInvalid={!!error} className="mb-3">
        {error}
      </ErrorView>

      <View className="gap-3">
        <TextField>
          <TextField.Label>Name</TextField.Label>
          <TextField.Input value={name} onChangeText={setName} placeholder="John Doe" />
        </TextField>

        <TextField>
          <TextField.Label>Email</TextField.Label>
          <TextField.Input
            value={email}
            onChangeText={setEmail}
            placeholder="email@example.com"
            keyboardType="email-address"
            autoCapitalize="none"
          />
        </TextField>

        <TextField>
          <TextField.Label>Password</TextField.Label>
          <TextField.Input
            value={password}
            onChangeText={setPassword}
            placeholder=""
            secureTextEntry
          />
        </TextField>

        <Button onPress={handleSignUp} isDisabled={isLoading} className="mt-1">
          {isLoading ? (
            <Spinner size="sm" color="default" />
          ) : (
            <Button.Label>Create Account</Button.Label>
          )}
        </Button>
      </View>
    </Surface>
  );
}
`],
  ["auth/better-auth/convex/native/uniwind/components/sign-in.tsx.hbs", `import { authClient } from "@/lib/auth-client";
import { useState } from "react";
import { Text, View } from "react-native";
import { Button, ErrorView, Spinner, Surface, TextField } from "heroui-native";

export function SignIn() {
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const handleLogin = async () => {
    setIsLoading(true);
    setError(null);

    await authClient.signIn.email(
      {
        email,
        password,
      },
      {
        onError: (error) => {
          setError(error.error?.message || "Failed to sign in");
          setIsLoading(false);
        },
        onSuccess: () => {
          setEmail("");
          setPassword("");
        },
        onFinished: () => {
          setIsLoading(false);
        },
      },
    );
  };

  return (
    <Surface variant="secondary" className="p-4 rounded-lg">
      <Text className="text-foreground font-medium mb-4">Sign In</Text>

      <ErrorView isInvalid={!!error} className="mb-3">
        {error}
      </ErrorView>

      <View className="gap-3">
        <TextField>
          <TextField.Label>Email</TextField.Label>
          <TextField.Input
            value={email}
            onChangeText={setEmail}
            placeholder="email@example.com"
            keyboardType="email-address"
            autoCapitalize="none"
          />
        </TextField>

        <TextField>
          <TextField.Label>Password</TextField.Label>
          <TextField.Input
            value={password}
            onChangeText={setPassword}
            placeholder=""
            secureTextEntry
          />
        </TextField>

        <Button onPress={handleLogin} isDisabled={isLoading} className="mt-1">
          {isLoading ? <Spinner size="sm" color="default" /> : <Button.Label>Sign In</Button.Label>}
        </Button>
      </View>
    </Surface>
  );
}
`],
  ["auth/better-auth/native/unistyles/app/(drawer)/index.tsx.hbs", `import { authClient } from "@/lib/auth-client";
import { ScrollView, Text, TouchableOpacity, View } from "react-native";
import { StyleSheet } from "react-native-unistyles";

import { Container } from "@/components/container";
import { SignIn } from "@/components/sign-in";
import { SignUp } from "@/components/sign-up";
{{#if (eq api "orpc")}}
import { useQuery } from "@tanstack/react-query";
import { queryClient, orpc } from "@/utils/orpc";
{{/if}}
{{#if (eq api "trpc")}}
import { useQuery } from "@tanstack/react-query";
import { queryClient, trpc } from "@/utils/trpc";
{{/if}}

export default function Home() {
    {{#if (eq api "orpc")}}
    const healthCheck = useQuery(orpc.healthCheck.queryOptions());
    const privateData = useQuery(orpc.privateData.queryOptions());
    {{/if}}
    {{#if (eq api "trpc")}}
    const healthCheck = useQuery(trpc.healthCheck.queryOptions());
    const privateData = useQuery(trpc.privateData.queryOptions());
    {{/if}}
  const { data: session } = authClient.useSession();

  return (
    <Container>
      <ScrollView>
        <View style={styles.pageContainer}>
          <Text style={styles.headerTitle}>BETTER T STACK</Text>
          {session?.user ? (
            <View style={styles.sessionInfoCard}>
              <View style={styles.sessionUserRow}>
                <Text style={styles.welcomeText}>
                  Welcome,{" "}
                  <Text style={styles.userNameText}>{session.user.name}</Text>
                </Text>
              </View>
              <Text style={styles.emailText}>{session.user.email}</Text>

              <TouchableOpacity
                style={styles.signOutButton}
                onPress={() => {
                  authClient.signOut();
                  {{#if (eq api "orpc")}}
                  queryClient.invalidateQueries();
                  {{/if}}
                  {{#if (eq api "trpc")}}
                  queryClient.invalidateQueries();
                  {{/if}}
                }}
              >
                <Text style={styles.signOutButtonText}>Sign Out</Text>
              </TouchableOpacity>
            </View>
          ) : null}
          {{#unless (eq api "none")}}
          <View style={styles.apiStatusCard}>
            <Text style={styles.cardTitle}>API Status</Text>
            <View style={styles.apiStatusRow}>
              <View
                style={[
                  styles.statusIndicatorDot,
                  healthCheck.data
                    ? styles.statusIndicatorGreen
                    : styles.statusIndicatorRed,
                ]}
              />
              <Text style={styles.mutedText}>
                {healthCheck.isLoading
                  ? "Checking..."
                  : healthCheck.data
                    ? "Connected to API"
                    : "API Disconnected"}
              </Text>
            </View>
          </View>
          <View style={styles.privateDataCard}>
            <Text style={styles.cardTitle}>Private Data</Text>
            {privateData && (
              <View>
                <Text style={styles.mutedText}>
                  {privateData.data?.message}
                </Text>
              </View>
            )}
          </View>
          {{/unless}}
          {!session?.user && (
            <>
              <SignIn />
              <SignUp />
            </>
          )}
        </View>
      </ScrollView>
    </Container>
  );
}

const styles = StyleSheet.create((theme) => ({
  pageContainer: {
    paddingHorizontal: 8,
  },
  headerTitle: {
    color: theme?.colors?.typography,
    fontSize: 30,
    fontWeight: "bold",
    marginBottom: 16,
  },
  sessionInfoCard: {
    marginBottom: 24,
    padding: 16,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: theme?.colors?.border,
  },
  sessionUserRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    marginBottom: 8,
  },
  welcomeText: {
    color: theme?.colors?.typography,
    fontSize: 16,
  },
  userNameText: {
    fontWeight: "500",
    color: theme?.colors?.typography,
  },
  emailText: {
    color: theme?.colors?.typography,
    fontSize: 14,
    marginBottom: 16,
  },
  signOutButton: {
    backgroundColor: theme?.colors?.destructive,
    paddingVertical: 8,
    paddingHorizontal: 16,
    borderRadius: 6,
    alignSelf: "flex-start",
  },
  signOutButtonText: {
    fontWeight: "500",
  },
  apiStatusCard: {
    marginBottom: 24,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: theme?.colors?.border,
    padding: 16,
  },
  cardTitle: {
    marginBottom: 12,
    fontWeight: "500",
    color: theme?.colors?.typography,
  },
  apiStatusRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
  },
  statusIndicatorDot: {
    height: 12,
    width: 12,
    borderRadius: 9999,
  },
  statusIndicatorGreen: {
    backgroundColor: theme.colors.success,
  },
  statusIndicatorRed: {
    backgroundColor: theme.colors.destructive,
  },
  mutedText: {
    color: theme?.colors?.typography,
  },
  privateDataCard: {
    marginBottom: 24,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: theme?.colors?.border,
    padding: 16,
  },
}));
`],
  ["auth/better-auth/convex/native/base/lib/auth-client.ts.hbs", `import { createAuthClient } from "better-auth/react";
import { convexClient } from "@convex-dev/better-auth/client/plugins";
import { expoClient } from "@better-auth/expo/client";
import Constants from "expo-constants";
import * as SecureStore from "expo-secure-store";
import { env } from "@{{projectName}}/env/native";

export const authClient = createAuthClient({
	baseURL: env.EXPO_PUBLIC_CONVEX_SITE_URL,
	plugins: [
		expoClient({
			scheme: Constants.expoConfig?.scheme as string,
			storagePrefix: Constants.expoConfig?.scheme as string,
			storage: SecureStore,
		}),
		convexClient(),
	],
});
`],
  ["email/nodemailer/server/base/src/lib/email.ts.hbs", `import nodemailer from "nodemailer";

// Create reusable transporter object using SMTP transport
// For development, you can use services like Mailtrap, Ethereal, or a local SMTP server
// For production, configure with your SMTP provider (Gmail, SendGrid, AWS SES, etc.)
const transporter = nodemailer.createTransport({
  host: process.env.SMTP_HOST || "smtp.ethereal.email",
  port: Number(process.env.SMTP_PORT) || 587,
  secure: process.env.SMTP_SECURE === "true", // true for 465, false for other ports
  auth: {
    user: process.env.SMTP_USER,
    pass: process.env.SMTP_PASS,
  },
});

export interface SendEmailOptions {
  to: string | string[];
  subject: string;
  html?: string;
  text?: string;
  from?: string;
  replyTo?: string;
  attachments?: Array<{
    filename: string;
    content?: string | Buffer;
    path?: string;
    contentType?: string;
  }>;
}

/**
 * Send an email using Nodemailer
 * @see https://nodemailer.com/
 */
export async function sendEmail(options: SendEmailOptions) {
  const { to, subject, html, text, from, replyTo, attachments } = options;

  const fromAddress = from || process.env.SMTP_FROM_EMAIL || "noreply@example.com";

  try {
    const info = await transporter.sendMail({
      from: fromAddress,
      to: Array.isArray(to) ? to.join(", ") : to,
      subject,
      html,
      text,
      replyTo,
      attachments,
    });

    console.log("Email sent:", info.messageId);
    return { success: true, messageId: info.messageId };
  } catch (error) {
    console.error("Email sending error:", error);
    throw error;
  }
}

/**
 * Verify SMTP connection configuration
 * Call this on startup to ensure email sending will work
 */
export async function verifyEmailConnection(): Promise<boolean> {
  try {
    await transporter.verify();
    console.log("SMTP connection verified successfully");
    return true;
  } catch (error) {
    console.error("SMTP connection verification failed:", error);
    return false;
  }
}

/**
 * Get the nodemailer transporter instance for advanced usage
 */
export function getTransporter() {
  return transporter;
}

export { transporter };
`],
  ["feature-flags/posthog/web/react/src/lib/posthog.tsx.hbs", `import posthog from "posthog-js";
import type { PropsWithChildren } from "react";
import { useEffect, useState, useCallback, useMemo } from "react";

// PostHog configuration from environment variables
{{#if (eq frontend.[0] "next")}}
const posthogKey = process.env.NEXT_PUBLIC_POSTHOG_KEY || "";
const posthogHost = process.env.NEXT_PUBLIC_POSTHOG_HOST || "https://us.i.posthog.com";
{{else if (eq frontend.[0] "nuxt")}}
const posthogKey = process.env.NUXT_PUBLIC_POSTHOG_KEY || "";
const posthogHost = process.env.NUXT_PUBLIC_POSTHOG_HOST || "https://us.i.posthog.com";
{{else}}
const posthogKey = import.meta.env.VITE_POSTHOG_KEY || "";
const posthogHost = import.meta.env.VITE_POSTHOG_HOST || "https://us.i.posthog.com";
{{/if}}

// Initialize PostHog only once
let initialized = false;

function initPostHog() {
  if (initialized || !posthogKey || typeof window === "undefined") return;

  posthog.init(posthogKey, {
    api_host: posthogHost,
    // Capture pageviews automatically
    capture_pageview: true,
    // Capture pageleaves for session tracking
    capture_pageleave: true,
    // Enable session recording (optional - requires PostHog plan)
    disable_session_recording: false,
    // Enable autocapture for clicks, form submissions, etc.
    autocapture: true,
    // Persist user identity across sessions
    persistence: "localStorage+cookie",
    // Respect Do Not Track browser setting
    respect_dnt: true,
  });

  initialized = true;
}

interface PostHogProviderProps extends PropsWithChildren {
  /**
   * User properties for identification
   * @example { email: "user@example.com", plan: "premium" }
   */
  user?: {
    id?: string;
    email?: string;
    [key: string]: unknown;
  };
}

/**
 * PostHog Provider component
 * Wrap your app with this provider to enable feature flags and analytics
 *
 * @example
 * function App() {
 *   const user = useAuth();
 *   return (
 *     <PostHogProvider user=\\{{ id: user?.id, email: user?.email }}>
 *       <YourApp />
 *     </PostHogProvider>
 *   );
 * }
 */
export function PostHogProvider({ children, user }: PostHogProviderProps) {
  const [ready, setReady] = useState(false);

  useEffect(() => {
    initPostHog();
    setReady(true);
  }, []);

  useEffect(() => {
    if (user?.id && ready) {
      // Identify user with PostHog
      posthog.identify(user.id, {
        email: user.email,
        ...user,
      });
    }
  }, [user?.id, user?.email, ready]);

  if (!posthogKey) {
    console.warn("[PostHog] API key not configured, feature flags and analytics disabled");
  }

  return <>{children}</>;
}

/**
 * Hook to check if a feature flag is enabled
 *
 * @example
 * function MyComponent() {
 *   const showNewFeature = useFeatureFlag("new-feature");
 *   return showNewFeature ? <NewFeature /> : <OldFeature />;
 * }
 */
export function useFeatureFlag(flagKey: string): boolean {
  const [enabled, setEnabled] = useState(false);

  useEffect(() => {
    // Get initial value
    setEnabled(posthog.isFeatureEnabled(flagKey) ?? false);

    // Listen for changes
    const unsubscribe = posthog.onFeatureFlags(() => {
      setEnabled(posthog.isFeatureEnabled(flagKey) ?? false);
    });

    return () => {
      if (typeof unsubscribe === "function") {
        unsubscribe();
      }
    };
  }, [flagKey]);

  return enabled;
}

/**
 * Hook to get a feature flag value (for multivariate flags)
 *
 * @example
 * function MyComponent() {
 *   const buttonColor = useFeatureFlagValue("button-color", "blue");
 *   return <button style=\\{{ backgroundColor: buttonColor }}>Click me</button>;
 * }
 */
export function useFeatureFlagValue<T extends string | boolean | number>(
  flagKey: string,
  defaultValue: T,
): T {
  const [value, setValue] = useState<T>(defaultValue);

  useEffect(() => {
    // Get initial value
    const flagValue = posthog.getFeatureFlag(flagKey);
    setValue((flagValue as T) ?? defaultValue);

    // Listen for changes
    const unsubscribe = posthog.onFeatureFlags(() => {
      const newValue = posthog.getFeatureFlag(flagKey);
      setValue((newValue as T) ?? defaultValue);
    });

    return () => {
      if (typeof unsubscribe === "function") {
        unsubscribe();
      }
    };
  }, [flagKey, defaultValue]);

  return value;
}

/**
 * Hook to get feature flag payload (JSON data attached to a flag)
 *
 * @example
 * function MyComponent() {
 *   const config = useFeatureFlagPayload<{ maxItems: number }>("feature-config");
 *   return <List maxItems={config?.maxItems ?? 10} />;
 * }
 */
export function useFeatureFlagPayload<T = unknown>(flagKey: string): T | undefined {
  const [payload, setPayload] = useState<T | undefined>(undefined);

  useEffect(() => {
    // Get initial payload
    setPayload(posthog.getFeatureFlagPayload(flagKey) as T | undefined);

    // Listen for changes
    const unsubscribe = posthog.onFeatureFlags(() => {
      setPayload(posthog.getFeatureFlagPayload(flagKey) as T | undefined);
    });

    return () => {
      if (typeof unsubscribe === "function") {
        unsubscribe();
      }
    };
  }, [flagKey]);

  return payload;
}

/**
 * Hook to track events
 *
 * @example
 * function CheckoutButton() {
 *   const capture = useCapture();
 *
 *   const handleClick = () => {
 *     capture("checkout_started", { items: 3, total: 99.99 });
 *   };
 *
 *   return <button onClick={handleClick}>Checkout</button>;
 * }
 */
export function useCapture() {
  return useCallback((eventName: string, properties?: Record<string, unknown>) => {
    posthog.capture(eventName, properties);
  }, []);
}

/**
 * Hook to identify users
 *
 * @example
 * function LoginHandler() {
 *   const identify = useIdentify();
 *
 *   const onLogin = (user) => {
 *     identify(user.id, { email: user.email, plan: user.plan });
 *   };
 * }
 */
export function useIdentify() {
  return useCallback((userId: string, properties?: Record<string, unknown>) => {
    posthog.identify(userId, properties);
  }, []);
}

/**
 * Hook to reset user identity (for logout)
 *
 * @example
 * function LogoutButton() {
 *   const reset = useReset();
 *   return <button onClick={reset}>Logout</button>;
 * }
 */
export function useReset() {
  return useCallback(() => {
    posthog.reset();
  }, []);
}

/**
 * Hook to get the PostHog instance for advanced usage
 */
export function usePostHog() {
  return useMemo(() => posthog, []);
}

// Re-export PostHog for direct access
export { posthog };

/**
 * Environment Variables:
 *
{{#if (eq frontend.[0] "next")}}
 * NEXT_PUBLIC_POSTHOG_KEY - PostHog project API key
 * NEXT_PUBLIC_POSTHOG_HOST - PostHog API host (default: https://us.i.posthog.com)
{{else if (eq frontend.[0] "nuxt")}}
 * NUXT_PUBLIC_POSTHOG_KEY - PostHog project API key
 * NUXT_PUBLIC_POSTHOG_HOST - PostHog API host (default: https://us.i.posthog.com)
{{else}}
 * VITE_POSTHOG_KEY - PostHog project API key
 * VITE_POSTHOG_HOST - PostHog API host (default: https://us.i.posthog.com)
{{/if}}
 *
 * Getting started:
 * 1. Create an account at https://posthog.com
 * 2. Create a new project
 * 3. Copy the Project API key to your .env file
 * 4. Choose your region (US or EU) and set the host accordingly
 * 5. Wrap your app with <PostHogProvider>
 *
 * Example usage:
 * \`\`\`tsx
 * // In your app entry point
 * import { PostHogProvider } from "./lib/posthog";
 *
 * function App() {
 *   const user = useAuth();
 *   return (
 *     <PostHogProvider user=\\{{ id: user?.id, email: user?.email }}>
 *       <Router />
 *     </PostHogProvider>
 *   );
 * }
 *
 * // In any component
 * import { useFeatureFlag, useCapture } from "./lib/posthog";
 *
 * function MyComponent() {
 *   const showBanner = useFeatureFlag("show-banner");
 *   const capture = useCapture();
 *
 *   if (!showBanner) return null;
 *   return (
 *     <Banner onClick={() => capture("banner_clicked")} />
 *   );
 * }
 * \`\`\`
 */
`],
  ["email/postmark/server/base/src/lib/email.ts.hbs", `import * as postmark from "postmark";

// Initialize Postmark client with Server API Token
const client = new postmark.ServerClient(process.env.POSTMARK_SERVER_TOKEN || "");

export interface SendEmailOptions {
  to: string | string[];
  subject: string;
  html?: string;
  text?: string;
  from?: string;
  replyTo?: string;
  tag?: string;
  attachments?: Array<{
    name: string;
    content: string; // Base64 encoded content
    contentType: string;
    contentId?: string;
  }>;
}

/**
 * Send an email using Postmark
 * @see https://postmarkapp.com/developer/user-guide/send-email-with-api
 */
export async function sendEmail(options: SendEmailOptions) {
  const { to, subject, html, text, from, replyTo, tag, attachments } = options;

  const fromAddress = from || process.env.POSTMARK_FROM_EMAIL || "noreply@example.com";
  const toAddresses = Array.isArray(to) ? to.join(", ") : to;

  try {
    const response = await client.sendEmail({
      From: fromAddress,
      To: toAddresses,
      Subject: subject,
      HtmlBody: html,
      TextBody: text,
      ReplyTo: replyTo,
      Tag: tag,
      Attachments: attachments?.map((a) => ({
        Name: a.name,
        Content: a.content,
        ContentType: a.contentType,
        ContentID: a.contentId,
      })),
    });

    console.log("Email sent:", response.MessageID);
    return { success: true, messageId: response.MessageID };
  } catch (error) {
    console.error("Email sending error:", error);
    throw error;
  }
}

/**
 * Send an email using a Postmark template
 * @see https://postmarkapp.com/developer/user-guide/send-email-with-templates
 */
export async function sendTemplateEmail(options: {
  to: string | string[];
  templateId: number;
  templateModel: Record<string, unknown>;
  from?: string;
  tag?: string;
}) {
  const { to, templateId, templateModel, from, tag } = options;

  const fromAddress = from || process.env.POSTMARK_FROM_EMAIL || "noreply@example.com";
  const toAddresses = Array.isArray(to) ? to.join(", ") : to;

  try {
    const response = await client.sendEmailWithTemplate({
      From: fromAddress,
      To: toAddresses,
      TemplateId: templateId,
      TemplateModel: templateModel,
      Tag: tag,
    });

    console.log("Template email sent:", response.MessageID);
    return { success: true, messageId: response.MessageID };
  } catch (error) {
    console.error("Template email sending error:", error);
    throw error;
  }
}

/**
 * Send batch emails (up to 500 per batch)
 * @see https://postmarkapp.com/developer/user-guide/send-email-with-api#batch-emails
 */
export async function sendBatchEmails(
  emails: Array<{
    to: string;
    subject: string;
    html?: string;
    text?: string;
    from?: string;
    tag?: string;
  }>
) {
  const fromAddress = process.env.POSTMARK_FROM_EMAIL || "noreply@example.com";

  const messages = emails.map((email) => ({
    From: email.from || fromAddress,
    To: email.to,
    Subject: email.subject,
    HtmlBody: email.html,
    TextBody: email.text,
    Tag: email.tag,
  }));

  try {
    const responses = await client.sendEmailBatch(messages);
    console.log(\`Batch of \${responses.length} emails sent\`);
    return {
      success: true,
      results: responses.map((r) => ({
        messageId: r.MessageID,
        errorCode: r.ErrorCode,
        message: r.Message,
      })),
    };
  } catch (error) {
    console.error("Batch email sending error:", error);
    throw error;
  }
}

/**
 * Get the Postmark client instance for advanced usage
 */
export function getPostmarkClient() {
  return client;
}

export { client };
`],
  ["email/sendgrid/server/base/src/lib/email.ts.hbs", `import sgMail from "@sendgrid/mail";

// Initialize SendGrid with API key
sgMail.setApiKey(process.env.SENDGRID_API_KEY || "");

export interface SendEmailOptions {
  to: string | string[];
  subject: string;
  html?: string;
  text?: string;
  from?: string;
  replyTo?: string;
  attachments?: Array<{
    filename: string;
    content: string; // Base64 encoded content
    type: string;
    disposition?: "attachment" | "inline";
    contentId?: string;
  }>;
  categories?: string[];
  sendAt?: number; // Unix timestamp for scheduled sending
}

/**
 * Send an email using SendGrid
 * @see https://docs.sendgrid.com/api-reference/mail-send/mail-send
 */
export async function sendEmail(options: SendEmailOptions) {
  const { to, subject, html, text, from, replyTo, attachments, categories, sendAt } = options;

  const fromAddress = from || process.env.SENDGRID_FROM_EMAIL || "noreply@example.com";
  const toAddresses = Array.isArray(to) ? to : [to];

  try {
    const msg: sgMail.MailDataRequired = {
      to: toAddresses,
      from: fromAddress,
      subject,
      html: html || undefined,
      text: text || undefined,
      replyTo: replyTo || undefined,
      attachments: attachments?.map((a) => ({
        filename: a.filename,
        content: a.content,
        type: a.type,
        disposition: a.disposition || "attachment",
        contentId: a.contentId,
      })),
      categories,
      sendAt,
    };

    const response = await sgMail.send(msg);
    console.log("Email sent:", response[0].statusCode);
    return { success: true, statusCode: response[0].statusCode };
  } catch (error) {
    console.error("Email sending error:", error);
    throw error;
  }
}

/**
 * Send multiple emails in a batch (up to 1000 per batch)
 * @see https://docs.sendgrid.com/api-reference/mail-send/mail-send
 */
export async function sendBatchEmails(
  emails: Array<{
    to: string | string[];
    subject: string;
    html?: string;
    text?: string;
    from?: string;
    categories?: string[];
  }>
) {
  const fromAddress = process.env.SENDGRID_FROM_EMAIL || "noreply@example.com";

  const messages: sgMail.MailDataRequired[] = emails.map((email) => ({
    to: Array.isArray(email.to) ? email.to : [email.to],
    from: email.from || fromAddress,
    subject: email.subject,
    html: email.html || undefined,
    text: email.text || undefined,
    categories: email.categories,
  }));

  try {
    const responses = await sgMail.send(messages);
    console.log(\`Batch of \${emails.length} emails sent\`);
    return {
      success: true,
      results: responses.map((r) => ({
        statusCode: r[0].statusCode,
      })),
    };
  } catch (error) {
    console.error("Batch email sending error:", error);
    throw error;
  }
}

/**
 * Send personalized emails to multiple recipients using dynamic templates
 * @see https://docs.sendgrid.com/api-reference/mail-send/mail-send#dynamic-templates
 */
export async function sendTemplateEmail(options: {
  to: string | string[];
  templateId: string;
  dynamicTemplateData: Record<string, unknown>;
  from?: string;
  categories?: string[];
}) {
  const { to, templateId, dynamicTemplateData, from, categories } = options;

  const fromAddress = from || process.env.SENDGRID_FROM_EMAIL || "noreply@example.com";
  const toAddresses = Array.isArray(to) ? to : [to];

  try {
    const msg: sgMail.MailDataRequired = {
      to: toAddresses,
      from: fromAddress,
      templateId,
      dynamicTemplateData,
      categories,
    };

    const response = await sgMail.send(msg);
    console.log("Template email sent:", response[0].statusCode);
    return { success: true, statusCode: response[0].statusCode };
  } catch (error) {
    console.error("Template email sending error:", error);
    throw error;
  }
}

/**
 * Get the SendGrid mail client for advanced usage
 */
export function getSendGridClient() {
  return sgMail;
}

export { sgMail };
`],
  ["auth/better-auth/native/bare/app/(drawer)/index.tsx.hbs", `import { View, Text, ScrollView, TouchableOpacity, StyleSheet } from "react-native";
import { Container } from "@/components/container";
import { useColorScheme } from "@/lib/use-color-scheme";
import { NAV_THEME } from "@/lib/constants";
import { authClient } from "@/lib/auth-client";
import { SignIn } from "@/components/sign-in";
import { SignUp } from "@/components/sign-up";
{{#if (eq api "orpc")}}
import { useQuery } from "@tanstack/react-query";
import { queryClient, orpc } from "@/utils/orpc";
{{/if}}
{{#if (eq api "trpc")}}
import { useQuery } from "@tanstack/react-query";
import { queryClient, trpc } from "@/utils/trpc";
{{/if}}

export default function Home() {
const { colorScheme } = useColorScheme();
const theme = colorScheme === "dark" ? NAV_THEME.dark : NAV_THEME.light;
{{#if (eq api "orpc")}}
const healthCheck = useQuery(orpc.healthCheck.queryOptions());
const privateData = useQuery(orpc.privateData.queryOptions());
const isConnected = healthCheck?.data === "OK";
const isLoading = healthCheck?.isLoading;
{{/if}}
{{#if (eq api "trpc")}}
const healthCheck = useQuery(trpc.healthCheck.queryOptions());
const privateData = useQuery(trpc.privateData.queryOptions());
const isConnected = healthCheck?.data === "OK";
const isLoading = healthCheck?.isLoading;
{{/if}}
const { data: session } = authClient.useSession();

return (
<Container>
  <ScrollView style={styles.scrollView}>
    <View style={styles.content}>
      <Text style={[styles.title, { color: theme.text }]}>
        BETTER T STACK
      </Text>

      {session?.user ? (
      <View style={[styles.userCard, { backgroundColor: theme.card, borderColor: theme.border }]}>
        <View style={styles.userHeader}>
          <Text style={[styles.userText, { color: theme.text }]}>
            Welcome, <Text style={styles.userName}>{session.user.name}</Text>
          </Text>
        </View>
        <Text style={[styles.userEmail, { color: theme.text, opacity: 0.7 }]}>
          {session.user.email}
        </Text>
        <TouchableOpacity style={[styles.signOutButton, { backgroundColor: theme.notification }]} onPress={()=> {
          authClient.signOut();
          {{#if (eq api "orpc")}}
          queryClient.invalidateQueries();
          {{/if}}
          {{#if (eq api "trpc")}}
          queryClient.invalidateQueries();
          {{/if}}
          }}
          >
          <Text style={styles.signOutText}>Sign Out</Text>
        </TouchableOpacity>
      </View>
      ) : null}

      {{#unless (eq api "none")}}
      <View style={[styles.statusCard, { backgroundColor: theme.card, borderColor: theme.border }]}>
        <Text style={[styles.cardTitle, { color: theme.text }]}>
          System Status
        </Text>
        <View style={styles.statusRow}>
          <View style={[styles.statusIndicator, { backgroundColor: isConnected ? "#10b981" : "#ef4444" }]} />
          <View style={styles.statusContent}>
            <Text style={[styles.statusTitle, { color: theme.text }]}>
              {{#if (eq api "orpc")}}ORPC{{else}}TRPC{{/if}} Backend
            </Text>
            <Text style={[styles.statusText, { color: theme.text, opacity: 0.7 }]}>
              {isLoading
              ? "Checking connection..."
              : isConnected
              ? "Connected to API"
              : "API Disconnected"}
            </Text>
          </View>
        </View>
      </View>

      <View style={[styles.privateDataCard, { backgroundColor: theme.card, borderColor: theme.border }]}>
        <Text style={[styles.cardTitle, { color: theme.text }]}>
          Private Data
        </Text>
        {privateData && (
        <Text style={[styles.privateDataText, { color: theme.text, opacity: 0.7 }]}>
          {privateData.data?.message}
        </Text>
        )}
      </View>
      {{/unless}}

      {!session?.user && (
      <>
        <SignIn />
        <SignUp />
      </>
      )}
    </View>
  </ScrollView>
</Container>
);
}

const styles = StyleSheet.create({
scrollView: {
flex: 1,
},
content: {
padding: 16,
},
title: {
fontSize: 24,
fontWeight: "bold",
marginBottom: 16,
},
userCard: {
marginBottom: 16,
padding: 16,
borderWidth: 1,
},
userHeader: {
marginBottom: 8,
},
userText: {
fontSize: 16,
},
userName: {
fontWeight: "bold",
},
userEmail: {
fontSize: 14,
marginBottom: 12,
},
signOutButton: {
padding: 12,
},
signOutText: {
color: "#ffffff",
},
statusCard: {
marginBottom: 16,
padding: 16,
borderWidth: 1,
},
cardTitle: {
fontSize: 16,
fontWeight: "bold",
marginBottom: 12,
},
statusRow: {
flexDirection: "row",
alignItems: "center",
gap: 8,
},
statusIndicator: {
height: 8,
width: 8,
},
statusContent: {
flex: 1,
},
statusTitle: {
fontSize: 14,
fontWeight: "bold",
},
statusText: {
fontSize: 12,
},
privateDataCard: {
marginBottom: 16,
padding: 16,
borderWidth: 1,
},
privateDataText: {
fontSize: 14,
},
});`],
  ["email/plunk/server/base/src/lib/email.ts.hbs", `import Plunk from "@plunk/node";

// Initialize Plunk client with secret API key
const plunk = new Plunk(process.env.PLUNK_API_KEY || "");

export interface SendEmailOptions {
  to: string;
  subject: string;
  body: string;
  from?: string;
  name?: string;
  reply?: string;
  headers?: Record<string, string>;
  subscribed?: boolean;
}

/**
 * Send an email using Plunk
 * @see https://docs.useplunk.com/api-reference/emails/send
 */
export async function sendEmail(options: SendEmailOptions) {
  const { to, subject, body, name, reply, headers, subscribed } = options;

  try {
    const success = await plunk.emails.send({
      to,
      subject,
      body,
      name,
      reply,
      headers,
      subscribed,
    });

    if (success) {
      console.log("Email sent successfully to:", to);
      return { success: true };
    }

    return { success: false, error: "Failed to send email" };
  } catch (error) {
    console.error("Email sending error:", error);
    throw error;
  }
}

export interface TrackEventOptions {
  event: string;
  email: string;
  data?: Record<string, string | number | boolean>;
}

/**
 * Track an event for a contact in Plunk
 * Events can trigger automated email sequences (automations)
 * @see https://docs.useplunk.com/api-reference/events/track
 */
export async function trackEvent(options: TrackEventOptions) {
  const { event, email, data } = options;

  try {
    const success = await plunk.events.track({
      event,
      email,
      data,
    });

    if (success) {
      console.log(\`Event "\${event}" tracked for:\`, email);
      return { success: true };
    }

    return { success: false, error: "Failed to track event" };
  } catch (error) {
    console.error("Event tracking error:", error);
    throw error;
  }
}

/**
 * Get the Plunk client instance for advanced usage
 * Useful for accessing contacts API or other advanced features
 */
export function getPlunkClient() {
  return plunk;
}

export { plunk };
`],
  ["feature-flags/growthbook/server/base/src/lib/growthbook.ts.hbs", `import { GrowthBook } from "@growthbook/growthbook";

// GrowthBook configuration from environment variables
const apiHost = process.env.GROWTHBOOK_API_HOST || "https://cdn.growthbook.io";
const clientKey = process.env.GROWTHBOOK_CLIENT_KEY;

/**
 * Create a new GrowthBook instance for server-side feature flag evaluation
 *
 * @example
 * const gb = await createGrowthBook({ id: "user-123" });
 * if (gb.isOn("new-feature")) {
 *   // Show new feature
 * }
 * gb.destroy(); // Clean up when done
 */
export async function createGrowthBook(attributes?: Record<string, unknown>): Promise<GrowthBook> {
  const gb = new GrowthBook({
    apiHost,
    clientKey: clientKey || "",
    attributes: {
      ...attributes,
    },
    // Enable streaming for real-time feature flag updates
    backgroundSync: true,
  });

  if (!clientKey) {
    console.warn("[GrowthBook] Client key not configured, feature flags will use default values");
    return gb;
  }

  // Load feature definitions
  await gb.init({ timeout: 2000 });

  return gb;
}

/**
 * Check if a feature is enabled
 *
 * @example
 * const gb = await createGrowthBook({ id: "user-123" });
 * const isEnabled = isFeatureEnabled(gb, "dark-mode");
 */
export function isFeatureEnabled(gb: GrowthBook, featureKey: string): boolean {
  return gb.isOn(featureKey);
}

/**
 * Get a feature value with type safety
 *
 * @example
 * const gb = await createGrowthBook({ id: "user-123" });
 * const buttonColor = getFeatureValue(gb, "button-color", "blue");
 */
export function getFeatureValue<T>(gb: GrowthBook, featureKey: string, defaultValue: T): T {
  return gb.getFeatureValue(featureKey, defaultValue);
}

/**
 * Run an experiment and get the variation
 *
 * @example
 * const gb = await createGrowthBook({ id: "user-123" });
 * const result = runExperiment(gb, {
 *   key: "pricing-test",
 *   variations: ["control", "variant-a", "variant-b"]
 * });
 * console.log(result.value); // "control", "variant-a", or "variant-b"
 */
export function runExperiment<T>(
  gb: GrowthBook,
  experiment: {
    key: string;
    variations: T[];
  },
) {
  return gb.run(experiment);
}

/**
 * Track an event for analytics
 *
 * @example
 * const gb = await createGrowthBook({ id: "user-123" });
 * trackEvent(gb, "purchase", { value: 99.99 });
 */
export function trackEvent(
  gb: GrowthBook,
  eventName: string,
  properties?: Record<string, unknown>,
) {
  gb.track(eventName, properties);
}

// Re-export GrowthBook for advanced usage
export { GrowthBook };

/**
 * Environment Variables:
 *
 * GROWTHBOOK_API_HOST - GrowthBook API host (default: https://cdn.growthbook.io)
 * GROWTHBOOK_CLIENT_KEY - SDK Connection client key from GrowthBook dashboard
 *
 * Getting started:
 * 1. Create an account at https://app.growthbook.io
 * 2. Create a new SDK Connection (choose "Backend" type)
 * 3. Copy the Client Key to GROWTHBOOK_CLIENT_KEY env var
 * 4. Create features in the Features tab
 *
 * Usage in route handlers:
 * \`\`\`typescript
 * import { createGrowthBook } from "./lib/growthbook";
 *
 * app.get("/api/data", async (c) => {
 *   const userId = c.get("userId");
 *   const gb = await createGrowthBook({ id: userId });
 *
 *   const data = gb.isOn("new-data-format")
 *     ? await getNewData()
 *     : await getLegacyData();
 *
 *   gb.destroy();
 *   return c.json(data);
 * });
 * \`\`\`
 */
`],
  ["email/mailgun/server/base/src/lib/email.ts.hbs", `import Mailgun from "mailgun.js";
import FormData from "form-data";

// Initialize Mailgun client
const mailgun = new Mailgun(FormData);
const mg = mailgun.client({
  username: "api",
  key: process.env.MAILGUN_API_KEY || "",
});

const DOMAIN = process.env.MAILGUN_DOMAIN || "";

export interface SendEmailOptions {
  to: string | string[];
  subject: string;
  html?: string;
  text?: string;
  from?: string;
  replyTo?: string;
  cc?: string | string[];
  bcc?: string | string[];
  attachments?: Array<{
    filename: string;
    data: Buffer | string;
    contentType?: string;
  }>;
  tags?: string[];
  trackingClicks?: boolean;
  trackingOpens?: boolean;
}

/**
 * Send an email using Mailgun
 * @see https://documentation.mailgun.com/en/latest/api-sending-messages.html
 */
export async function sendEmail(options: SendEmailOptions) {
  const {
    to,
    subject,
    html,
    text,
    from,
    replyTo,
    cc,
    bcc,
    attachments,
    tags,
    trackingClicks,
    trackingOpens,
  } = options;

  const fromAddress = from || process.env.MAILGUN_FROM_EMAIL || "noreply@example.com";
  const toAddresses = Array.isArray(to) ? to.join(",") : to;

  try {
    const messageData: Record<string, unknown> = {
      from: fromAddress,
      to: toAddresses,
      subject,
    };

    if (html) messageData.html = html;
    if (text) messageData.text = text;
    if (replyTo) messageData["h:Reply-To"] = replyTo;
    if (cc) messageData.cc = Array.isArray(cc) ? cc.join(",") : cc;
    if (bcc) messageData.bcc = Array.isArray(bcc) ? bcc.join(",") : bcc;
    if (tags) messageData["o:tag"] = tags;
    if (trackingClicks !== undefined) messageData["o:tracking-clicks"] = trackingClicks ? "yes" : "no";
    if (trackingOpens !== undefined) messageData["o:tracking-opens"] = trackingOpens ? "yes" : "no";

    if (attachments && attachments.length > 0) {
      messageData.attachment = attachments.map((att) => ({
        filename: att.filename,
        data: att.data,
        contentType: att.contentType,
      }));
    }

    const response = await mg.messages.create(DOMAIN, messageData);
    console.log("Email sent:", response.id);
    return { success: true, messageId: response.id };
  } catch (error) {
    console.error("Email sending error:", error);
    throw error;
  }
}

/**
 * Send multiple emails in a batch using Mailgun's recipient variables
 * @see https://documentation.mailgun.com/en/latest/user_manual.html#batch-sending
 */
export async function sendBatchEmails(
  emails: Array<{
    to: string;
    subject: string;
    html?: string;
    text?: string;
    variables?: Record<string, string>;
  }>,
  commonOptions?: {
    from?: string;
    tags?: string[];
  }
) {
  const fromAddress =
    commonOptions?.from || process.env.MAILGUN_FROM_EMAIL || "noreply@example.com";

  // Mailgun batch sending uses recipient variables
  const recipients = emails.map((e) => e.to);
  const recipientVariables: Record<string, Record<string, string>> = {};

  for (const email of emails) {
    if (email.variables) {
      recipientVariables[email.to] = email.variables;
    }
  }

  try {
    // For batch emails, we use the first email as template
    const firstEmail = emails[0];
    if (!firstEmail) throw new Error("No emails provided");

    const messageData: Record<string, unknown> = {
      from: fromAddress,
      to: recipients,
      subject: firstEmail.subject,
      "recipient-variables": JSON.stringify(recipientVariables),
    };

    if (firstEmail.html) messageData.html = firstEmail.html;
    if (firstEmail.text) messageData.text = firstEmail.text;
    if (commonOptions?.tags) messageData["o:tag"] = commonOptions.tags;

    const response = await mg.messages.create(DOMAIN, messageData);
    console.log(\`Batch of \${emails.length} emails queued:\`, response.id);
    return { success: true, messageId: response.id };
  } catch (error) {
    console.error("Batch email sending error:", error);
    throw error;
  }
}

/**
 * Send an email using a Mailgun template
 * @see https://documentation.mailgun.com/en/latest/api-sending-messages.html#sending-via-api
 */
export async function sendTemplateEmail(options: {
  to: string | string[];
  template: string;
  variables: Record<string, string>;
  subject?: string;
  from?: string;
  tags?: string[];
}) {
  const { to, template, variables, subject, from, tags } = options;

  const fromAddress = from || process.env.MAILGUN_FROM_EMAIL || "noreply@example.com";
  const toAddresses = Array.isArray(to) ? to.join(",") : to;

  try {
    const messageData: Record<string, unknown> = {
      from: fromAddress,
      to: toAddresses,
      template,
      "h:X-Mailgun-Variables": JSON.stringify(variables),
    };

    if (subject) messageData.subject = subject;
    if (tags) messageData["o:tag"] = tags;

    const response = await mg.messages.create(DOMAIN, messageData);
    console.log("Template email sent:", response.id);
    return { success: true, messageId: response.id };
  } catch (error) {
    console.error("Template email sending error:", error);
    throw error;
  }
}

/**
 * Validate an email address using Mailgun's email validation API
 * Note: This requires the email validation feature to be enabled on your account
 * @see https://documentation.mailgun.com/en/latest/api-email-validation.html
 */
export async function validateEmail(email: string) {
  try {
    const result = await mg.validate.get(email);
    return {
      valid: result.is_valid,
      didYouMean: result.did_you_mean,
      isDisposable: result.is_disposable_address,
      isRoleAddress: result.is_role_address,
    };
  } catch (error) {
    console.error("Email validation error:", error);
    throw error;
  }
}

/**
 * Get the Mailgun client for advanced usage
 */
export function getMailgunClient() {
  return mg;
}

export { mg as mailgun };
`],
  ["auth/better-auth/native/uniwind/app/(drawer)/index.tsx.hbs", `import { Text, View, Pressable } from "react-native";
import { Container } from "@/components/container";
import { authClient } from "@/lib/auth-client";
import { Ionicons } from "@expo/vector-icons";
import { Card, Chip, useThemeColor } from "heroui-native";
import { SignIn } from "@/components/sign-in";
import { SignUp } from "@/components/sign-up";
{{#if (eq api "orpc")}}
import { useQuery } from "@tanstack/react-query";
import { queryClient, orpc } from "@/utils/orpc";
{{/if}}
{{#if (eq api "trpc")}}
import { useQuery } from "@tanstack/react-query";
import { queryClient, trpc } from "@/utils/trpc";
{{/if}}

export default function Home() {
{{#if (eq api "orpc")}}
const healthCheck = useQuery(orpc.healthCheck.queryOptions());
const privateData = useQuery(orpc.privateData.queryOptions());
const isConnected = healthCheck?.data === "OK";
const isLoading = healthCheck?.isLoading;
{{/if}}
{{#if (eq api "trpc")}}
const healthCheck = useQuery(trpc.healthCheck.queryOptions());
const privateData = useQuery(trpc.privateData.queryOptions());
const isConnected = healthCheck?.data === "OK";
const isLoading = healthCheck?.isLoading;
{{/if}}
const { data: session } = authClient.useSession();

const mutedColor = useThemeColor("muted");
const successColor = useThemeColor("success");
const dangerColor = useThemeColor("danger");
const foregroundColor = useThemeColor("foreground");

return (
<Container className="p-6">
  <View className="py-4 mb-6">
    <Text className="text-4xl font-bold text-foreground mb-2">
      BETTER T STACK
    </Text>
  </View>

  {session?.user ? (
  <Card variant="secondary" className="mb-6 p-4">
    <Text className="text-foreground text-base mb-2">
      Welcome, <Text className="font-medium">{session.user.name}</Text>
    </Text>
    <Text className="text-muted text-sm mb-4">
      {session.user.email}
    </Text>
    <Pressable className="bg-danger py-3 px-4 rounded-lg self-start active:opacity-70" onPress={()=> {
      authClient.signOut();
      {{#if (eq api "orpc")}}
      queryClient.invalidateQueries();
      {{/if}}
      {{#if (eq api "trpc")}}
      queryClient.invalidateQueries();
      {{/if}}
      }}
      >
      <Text className="text-foreground font-medium">Sign Out</Text>
    </Pressable>
  </Card>
  ) : null}

  {{#unless (eq api "none")}}
  <Card variant="secondary" className="p-6">
    <View className="flex-row items-center justify-between mb-4">
      <Card.Title>System Status</Card.Title>
      <Chip variant="secondary" color={isConnected ? "success" : "danger" } size="sm">
        <Chip.Label>{isConnected ? "LIVE" : "OFFLINE"}</Chip.Label>
      </Chip>
    </View>

    <Card className="p-4">
      <View className="flex-row items-center">
        <View className={\`w-3 h-3 rounded-full mr-3 \${isConnected ? "bg-success" : "bg-muted" }\`} />
        <View className="flex-1">
          <Text className="text-foreground font-medium mb-1">
            {{#if (eq api "orpc")}}ORPC{{else}}TRPC{{/if}} Backend
          </Text>
          <Card.Description>
            {isLoading
            ? "Checking connection..."
            : isConnected
            ? "Connected to API"
            : "API Disconnected"}
          </Card.Description>
        </View>
        {isLoading && (
        <Ionicons name="hourglass-outline" size={20} color={mutedColor} />
        )}
        {!isLoading && isConnected && (
        <Ionicons name="checkmark-circle" size={20} color={successColor} />
        )}
        {!isLoading && !isConnected && (
        <Ionicons name="close-circle" size={20} color={dangerColor} />
        )}
      </View>
    </Card>
  </Card>

  <Card variant="secondary" className="mt-6 p-4">
    <Card.Title className="mb-3">Private Data</Card.Title>
    {privateData && (
    <Card.Description>
      {privateData.data?.message}
    </Card.Description>
    )}
  </Card>
  {{/unless}}

  {!session?.user && (
  <>
    <SignIn />
    <SignUp />
  </>
  )}
</Container>
);
}`],
  ["job-queue/trigger-dev/server/base/src/trigger/tasks.ts.hbs", `import { task, logger, schedules, AbortTaskRunError } from "@trigger.dev/sdk/v3";

/**
 * Example email sending task
 * Trigger from your backend with: await sendEmailTask.trigger({ to, subject, body })
 * @see https://trigger.dev/docs
 */
export const sendEmailTask = task({
  id: "send-email",
  // Retry configuration
  retry: {
    maxAttempts: 3,
    minTimeoutInMs: 1000,
    maxTimeoutInMs: 10000,
    factor: 2,
  },
  run: async (payload: {
    to: string;
    subject: string;
    body: string;
    templateId?: string;
  }) => {
    const { to, subject, body, templateId } = payload;

    logger.info("Processing email task", { to, subject });

    // TODO: Implement your email sending logic here
    // Example with a hypothetical email service:
    // await emailService.send({ to, subject, body, templateId });

    // Simulate email sending
    await new Promise((resolve) => setTimeout(resolve, 1000));

    logger.info("Email sent successfully", { to });

    return {
      sent: true,
      to,
      timestamp: new Date().toISOString(),
    };
  },
});

/**
 * Example notification task
 * Supports different notification types: push, in-app, sms
 */
export const sendNotificationTask = task({
  id: "send-notification",
  retry: {
    maxAttempts: 3,
    minTimeoutInMs: 500,
    maxTimeoutInMs: 5000,
    factor: 2,
  },
  run: async (payload: {
    userId: string;
    type: "push" | "in-app" | "sms";
    title: string;
    message: string;
    data?: Record<string, unknown>;
  }) => {
    const { userId, type, title, message, data } = payload;

    logger.info("Processing notification", { userId, type, title });

    // TODO: Implement your notification logic here
    // switch (type) {
    //   case "push":
    //     await pushService.send(userId, { title, message, data });
    //     break;
    //   case "in-app":
    //     await inAppNotificationService.create(userId, { title, message, data });
    //     break;
    //   case "sms":
    //     await smsService.send(userId, message);
    //     break;
    // }

    // Simulate notification processing
    await new Promise((resolve) => setTimeout(resolve, 500));

    logger.info("Notification sent", { userId, type });

    return {
      sent: true,
      type,
      userId,
      timestamp: new Date().toISOString(),
    };
  },
});

/**
 * Example data processing task with error handling
 * Demonstrates AbortTaskRunError for permanent failures
 */
export const processDataTask = task({
  id: "process-data",
  // Machine resources (uncomment for larger workloads)
  // machine: { preset: "medium-1x" }, // 1 vCPU, 2 GB RAM
  maxDuration: 300, // 5 minutes timeout
  retry: {
    maxAttempts: 2,
  },
  run: async (payload: {
    dataId: string;
    operation: "transform" | "aggregate" | "export";
  }) => {
    const { dataId, operation } = payload;

    logger.info("Processing data", { dataId, operation });

    // Example of handling permanent errors
    if (!dataId) {
      // This is a known permanent error, don't retry
      throw new AbortTaskRunError("Data ID is required");
    }

    // TODO: Implement your data processing logic here
    // const data = await database.getData(dataId);
    // switch (operation) {
    //   case "transform":
    //     return await transformData(data);
    //   case "aggregate":
    //     return await aggregateData(data);
    //   case "export":
    //     return await exportData(data);
    // }

    // Simulate data processing
    await new Promise((resolve) => setTimeout(resolve, 2000));

    logger.info("Data processing complete", { dataId, operation });

    return {
      processed: true,
      dataId,
      operation,
      timestamp: new Date().toISOString(),
    };
  },
});

/**
 * Example scheduled task (cron job)
 * Runs every hour - customize the cron pattern as needed
 * @see https://trigger.dev/docs/tasks/scheduled
 */
export const hourlyCleanupTask = schedules.task({
  id: "hourly-cleanup",
  // Every hour at minute 0
  cron: "0 * * * *",
  run: async (payload) => {
    logger.info("Running scheduled cleanup", {
      scheduledTime: payload.timestamp,
      timezone: payload.timezone,
    });

    // TODO: Implement your cleanup logic here
    // await database.deleteExpiredSessions();
    // await cache.clearStale();

    // Simulate cleanup
    await new Promise((resolve) => setTimeout(resolve, 1000));

    logger.info("Scheduled cleanup complete", {
      nextRun: payload.upcoming[0],
    });

    return {
      cleaned: true,
      timestamp: new Date().toISOString(),
    };
  },
});

/**
 * Example daily report task with timezone
 * Runs at 9 AM in the specified timezone
 */
export const dailyReportTask = schedules.task({
  id: "daily-report",
  cron: {
    // 9 AM every day
    pattern: "0 9 * * *",
    // Change to your preferred timezone
    // See: https://cloud.trigger.dev/timezones
    timezone: "UTC",
  },
  run: async (payload) => {
    logger.info("Generating daily report", {
      scheduledTime: payload.timestamp,
      timezone: payload.timezone,
    });

    // TODO: Implement your report generation logic here
    // const report = await generateReport();
    // await sendReportEmail(report);

    // Simulate report generation
    await new Promise((resolve) => setTimeout(resolve, 3000));

    logger.info("Daily report sent", {
      nextRun: payload.upcoming[0],
    });

    return {
      reportGenerated: true,
      timestamp: new Date().toISOString(),
    };
  },
});
`],
  ["job-queue/trigger-dev/server/base/src/lib/trigger.ts.hbs", `import { tasks, configure } from "@trigger.dev/sdk/v3";
import type {
  sendEmailTask,
  sendNotificationTask,
  processDataTask,
} from "../trigger/tasks";

/**
 * Configure Trigger.dev SDK
 * This is called automatically when importing this module
 * @see https://trigger.dev/docs
 */
configure({
  secretKey: process.env.TRIGGER_SECRET_KEY,
});

/**
 * Type-safe task triggering utilities
 * Use these functions to trigger background tasks from your backend
 */

// Type definitions for task payloads
export interface EmailPayload {
  to: string;
  subject: string;
  body: string;
  templateId?: string;
}

export interface NotificationPayload {
  userId: string;
  type: "push" | "in-app" | "sms";
  title: string;
  message: string;
  data?: Record<string, unknown>;
}

export interface DataProcessingPayload {
  dataId: string;
  operation: "transform" | "aggregate" | "export";
}

/**
 * Trigger an email task
 * @example
 * const handle = await triggerEmail({
 *   to: "user@example.com",
 *   subject: "Welcome!",
 *   body: "Thanks for signing up."
 * });
 */
export async function triggerEmail(
  payload: EmailPayload,
  options?: { delay?: string | number }
) {
  return tasks.trigger<typeof sendEmailTask>("send-email", payload, options);
}

/**
 * Trigger a notification task
 * @example
 * const handle = await triggerNotification({
 *   userId: "user_123",
 *   type: "push",
 *   title: "New message",
 *   message: "You have a new message!"
 * });
 */
export async function triggerNotification(
  payload: NotificationPayload,
  options?: { delay?: string | number }
) {
  return tasks.trigger<typeof sendNotificationTask>(
    "send-notification",
    payload,
    options
  );
}

/**
 * Trigger a data processing task
 * @example
 * const handle = await triggerDataProcessing({
 *   dataId: "data_456",
 *   operation: "transform"
 * });
 */
export async function triggerDataProcessing(
  payload: DataProcessingPayload,
  options?: { delay?: string | number }
) {
  return tasks.trigger<typeof processDataTask>(
    "process-data",
    payload,
    options
  );
}

/**
 * Trigger multiple emails in batch
 * @example
 * const handles = await triggerEmailBatch([
 *   { to: "user1@example.com", subject: "Hello", body: "Hi!" },
 *   { to: "user2@example.com", subject: "Hello", body: "Hi!" }
 * ]);
 */
export async function triggerEmailBatch(payloads: EmailPayload[]) {
  return tasks.batchTrigger<typeof sendEmailTask>(
    "send-email",
    payloads.map((payload) => ({ payload }))
  );
}

/**
 * Get the status of a task run
 * @example
 * const run = await getTaskRun("run_123");
 * console.log(run.status); // "COMPLETED" | "FAILED" | "RUNNING" etc.
 */
export { tasks };
`],
  ["email/aws-ses/server/base/src/lib/email.ts.hbs", `import { SESClient, SendEmailCommand, SendRawEmailCommand } from "@aws-sdk/client-ses";

// Initialize AWS SES client
const sesClient = new SESClient({
  region: process.env.AWS_REGION || "us-east-1",
  credentials: {
    accessKeyId: process.env.AWS_ACCESS_KEY_ID || "",
    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY || "",
  },
});

export interface SendEmailOptions {
  to: string | string[];
  subject: string;
  html?: string;
  text?: string;
  from?: string;
  replyTo?: string | string[];
  cc?: string | string[];
  bcc?: string | string[];
}

/**
 * Send an email using AWS SES
 * @see https://docs.aws.amazon.com/ses/latest/APIReference/API_SendEmail.html
 */
export async function sendEmail(options: SendEmailOptions) {
  const { to, subject, html, text, from, replyTo, cc, bcc } = options;

  const fromAddress = from || process.env.AWS_SES_FROM_EMAIL || "noreply@example.com";
  const toAddresses = Array.isArray(to) ? to : [to];
  const replyToAddresses = replyTo ? (Array.isArray(replyTo) ? replyTo : [replyTo]) : undefined;
  const ccAddresses = cc ? (Array.isArray(cc) ? cc : [cc]) : undefined;
  const bccAddresses = bcc ? (Array.isArray(bcc) ? bcc : [bcc]) : undefined;

  const command = new SendEmailCommand({
    Source: fromAddress,
    Destination: {
      ToAddresses: toAddresses,
      CcAddresses: ccAddresses,
      BccAddresses: bccAddresses,
    },
    Message: {
      Subject: {
        Data: subject,
        Charset: "UTF-8",
      },
      Body: {
        ...(html && {
          Html: {
            Data: html,
            Charset: "UTF-8",
          },
        }),
        ...(text && {
          Text: {
            Data: text,
            Charset: "UTF-8",
          },
        }),
      },
    },
    ReplyToAddresses: replyToAddresses,
  });

  try {
    const response = await sesClient.send(command);
    console.log("Email sent:", response.MessageId);
    return { success: true, messageId: response.MessageId };
  } catch (error) {
    console.error("Email sending error:", error);
    throw error;
  }
}

export interface SendRawEmailOptions {
  to: string | string[];
  subject: string;
  html?: string;
  text?: string;
  from?: string;
  replyTo?: string;
  attachments?: Array<{
    filename: string;
    content: string | Buffer;
    contentType: string;
  }>;
}

/**
 * Send a raw email with attachments using AWS SES
 * @see https://docs.aws.amazon.com/ses/latest/APIReference/API_SendRawEmail.html
 */
export async function sendRawEmail(options: SendRawEmailOptions) {
  const { to, subject, html, text, from, replyTo, attachments } = options;

  const fromAddress = from || process.env.AWS_SES_FROM_EMAIL || "noreply@example.com";
  const toAddresses = Array.isArray(to) ? to : [to];

  // Build MIME message
  const boundary = \`----=_Part_\${Date.now().toString(36)}\`;
  const mixedBoundary = \`----=_Mixed_\${Date.now().toString(36)}\`;

  let rawMessage = "";
  rawMessage += \`From: \${fromAddress}\\r\\n\`;
  rawMessage += \`To: \${toAddresses.join(", ")}\\r\\n\`;
  rawMessage += \`Subject: \${subject}\\r\\n\`;
  if (replyTo) {
    rawMessage += \`Reply-To: \${replyTo}\\r\\n\`;
  }
  rawMessage += "MIME-Version: 1.0\\r\\n";

  if (attachments && attachments.length > 0) {
    rawMessage += \`Content-Type: multipart/mixed; boundary="\${mixedBoundary}"\\r\\n\\r\\n\`;
    rawMessage += \`--\${mixedBoundary}\\r\\n\`;
    rawMessage += \`Content-Type: multipart/alternative; boundary="\${boundary}"\\r\\n\\r\\n\`;
  } else {
    rawMessage += \`Content-Type: multipart/alternative; boundary="\${boundary}"\\r\\n\\r\\n\`;
  }

  // Text part
  if (text) {
    rawMessage += \`--\${boundary}\\r\\n\`;
    rawMessage += "Content-Type: text/plain; charset=UTF-8\\r\\n";
    rawMessage += "Content-Transfer-Encoding: 7bit\\r\\n\\r\\n";
    rawMessage += \`\${text}\\r\\n\`;
  }

  // HTML part
  if (html) {
    rawMessage += \`--\${boundary}\\r\\n\`;
    rawMessage += "Content-Type: text/html; charset=UTF-8\\r\\n";
    rawMessage += "Content-Transfer-Encoding: 7bit\\r\\n\\r\\n";
    rawMessage += \`\${html}\\r\\n\`;
  }

  rawMessage += \`--\${boundary}--\\r\\n\`;

  // Attachments
  if (attachments && attachments.length > 0) {
    for (const attachment of attachments) {
      rawMessage += \`--\${mixedBoundary}\\r\\n\`;
      rawMessage += \`Content-Type: \${attachment.contentType}; name="\${attachment.filename}"\\r\\n\`;
      rawMessage += "Content-Transfer-Encoding: base64\\r\\n";
      rawMessage += \`Content-Disposition: attachment; filename="\${attachment.filename}"\\r\\n\\r\\n\`;

      const content =
        typeof attachment.content === "string"
          ? attachment.content
          : attachment.content.toString("base64");

      rawMessage += \`\${content}\\r\\n\`;
    }
    rawMessage += \`--\${mixedBoundary}--\\r\\n\`;
  }

  const command = new SendRawEmailCommand({
    RawMessage: {
      Data: Buffer.from(rawMessage),
    },
  });

  try {
    const response = await sesClient.send(command);
    console.log("Raw email sent:", response.MessageId);
    return { success: true, messageId: response.MessageId };
  } catch (error) {
    console.error("Raw email sending error:", error);
    throw error;
  }
}

/**
 * Send multiple emails (note: SES has rate limits, consider using bulk sending for large volumes)
 */
export async function sendBatchEmails(
  emails: Array<{
    to: string | string[];
    subject: string;
    html?: string;
    text?: string;
    from?: string;
  }>
) {
  const results = await Promise.allSettled(
    emails.map((email) => sendEmail(email))
  );

  const successful = results.filter((r) => r.status === "fulfilled").length;
  const failed = results.filter((r) => r.status === "rejected").length;

  console.log(\`Batch emails: \${successful} sent, \${failed} failed\`);

  return {
    success: failed === 0,
    total: emails.length,
    successful,
    failed,
    results: results.map((r, i) => ({
      email: emails[i]?.to,
      status: r.status,
      ...(r.status === "fulfilled" ? { messageId: r.value.messageId } : { error: r.reason }),
    })),
  };
}

/**
 * Get the SES client for advanced usage
 */
export function getSESClient() {
  return sesClient;
}

export { sesClient, SESClient, SendEmailCommand, SendRawEmailCommand };
`],
  ["feature-flags/posthog/server/base/src/lib/posthog.ts.hbs", `import { PostHog } from "posthog-node";

// PostHog configuration from environment variables
const posthogKey = process.env.POSTHOG_API_KEY || "";
const posthogHost = process.env.POSTHOG_HOST || "https://us.i.posthog.com";

// Create a singleton PostHog client
let posthogClient: PostHog | null = null;

/**
 * Get the PostHog client instance
 * Creates a singleton client for efficient resource usage
 */
export function getPostHog(): PostHog {
  if (!posthogClient) {
    if (!posthogKey) {
      console.warn("[PostHog] API key not configured, feature flags and analytics disabled");
    }
    posthogClient = new PostHog(posthogKey || "placeholder", {
      host: posthogHost,
      // Flush events in batches for better performance
      flushAt: 20,
      // Flush events every 10 seconds
      flushInterval: 10000,
    });
  }
  return posthogClient;
}

/**
 * Check if a feature flag is enabled for a user
 *
 * @example
 * const isEnabled = await isFeatureEnabled("new-feature", "user-123");
 * if (isEnabled) {
 *   // Show new feature
 * }
 */
export async function isFeatureEnabled(
  flagKey: string,
  distinctId: string,
  groups?: Record<string, string>,
): Promise<boolean> {
  if (!posthogKey) return false;

  const client = getPostHog();
  return (
    (await client.isFeatureEnabled(flagKey, distinctId, {
      groups,
    })) ?? false
  );
}

/**
 * Get a feature flag value (for multivariate flags)
 *
 * @example
 * const variant = await getFeatureFlagValue("button-color", "user-123", "blue");
 * console.log(variant); // "red", "blue", or "green"
 */
export async function getFeatureFlagValue<T extends string | boolean>(
  flagKey: string,
  distinctId: string,
  defaultValue: T,
  groups?: Record<string, string>,
): Promise<T> {
  if (!posthogKey) return defaultValue;

  const client = getPostHog();
  const value = await client.getFeatureFlag(flagKey, distinctId, {
    groups,
  });
  return (value as T) ?? defaultValue;
}

/**
 * Get feature flag payload (JSON data attached to a flag)
 *
 * @example
 * const config = await getFeatureFlagPayload<{ maxItems: number }>(
 *   "feature-config",
 *   "user-123"
 * );
 * console.log(config?.maxItems);
 */
export async function getFeatureFlagPayload<T = unknown>(
  flagKey: string,
  distinctId: string,
  groups?: Record<string, string>,
): Promise<T | undefined> {
  if (!posthogKey) return undefined;

  const client = getPostHog();
  const payload = await client.getFeatureFlagPayload(flagKey, distinctId, {
    groups,
  });
  return payload as T | undefined;
}

/**
 * Get all feature flags for a user
 *
 * @example
 * const flags = await getAllFlags("user-123");
 * console.log(flags); // { "feature-a": true, "feature-b": "variant-1" }
 */
export async function getAllFlags(
  distinctId: string,
  groups?: Record<string, string>,
): Promise<Record<string, string | boolean>> {
  if (!posthogKey) return {};

  const client = getPostHog();
  return await client.getAllFlags(distinctId, { groups });
}

/**
 * Capture an analytics event
 *
 * @example
 * captureEvent("user-123", "purchase_completed", {
 *   product_id: "prod-456",
 *   price: 99.99,
 *   currency: "USD",
 * });
 */
export function captureEvent(
  distinctId: string,
  eventName: string,
  properties?: Record<string, unknown>,
): void {
  const client = getPostHog();
  client.capture({
    distinctId,
    event: eventName,
    properties,
  });
}

/**
 * Identify a user with properties
 *
 * @example
 * identifyUser("user-123", {
 *   email: "user@example.com",
 *   name: "John Doe",
 *   plan: "premium",
 * });
 */
export function identifyUser(distinctId: string, properties?: Record<string, unknown>): void {
  const client = getPostHog();
  client.identify({
    distinctId,
    properties,
  });
}

/**
 * Create an alias for a user (link anonymous to identified user)
 *
 * @example
 * // When user signs up, link their anonymous ID to their new user ID
 * aliasUser("new-user-123", "anon-456");
 */
export function aliasUser(distinctId: string, alias: string): void {
  const client = getPostHog();
  client.alias({
    distinctId,
    alias,
  });
}

/**
 * Set group properties for group analytics
 *
 * @example
 * setGroup("user-123", "company", "acme-corp", {
 *   name: "Acme Corporation",
 *   industry: "Technology",
 *   employees: 500,
 * });
 */
export function setGroup(
  distinctId: string,
  groupType: string,
  groupKey: string,
  properties?: Record<string, unknown>,
): void {
  const client = getPostHog();
  client.groupIdentify({
    groupType,
    groupKey,
    properties,
  });
  // Also associate the user with this group
  client.capture({
    distinctId,
    event: "$groupidentify",
    properties: {
      $group_type: groupType,
      $group_key: groupKey,
    },
  });
}

/**
 * Flush all pending events (call before shutdown)
 *
 * @example
 * // In your shutdown handler
 * await shutdownPostHog();
 */
export async function shutdownPostHog(): Promise<void> {
  if (posthogClient) {
    await posthogClient.shutdown();
    posthogClient = null;
  }
}

// Re-export PostHog class for advanced usage
export { PostHog };

/**
 * Environment Variables:
 *
 * POSTHOG_API_KEY - PostHog project API key
 * POSTHOG_HOST - PostHog API host (default: https://us.i.posthog.com)
 *
 * Getting started:
 * 1. Create an account at https://posthog.com
 * 2. Create a new project
 * 3. Copy the Project API key to POSTHOG_API_KEY env var
 * 4. Choose your region and set POSTHOG_HOST:
 *    - US: https://us.i.posthog.com (default)
 *    - EU: https://eu.i.posthog.com
 * 5. Create feature flags in the PostHog dashboard
 *
 * Usage in route handlers:
 * \`\`\`typescript
 * import { isFeatureEnabled, captureEvent } from "./lib/posthog";
 *
 * app.get("/api/data", async (c) => {
 *   const userId = c.get("userId");
 *
 *   // Check feature flag
 *   const useNewAlgorithm = await isFeatureEnabled("new-algorithm", userId);
 *
 *   const data = useNewAlgorithm
 *     ? await getDataV2()
 *     : await getDataV1();
 *
 *   // Track event
 *   captureEvent(userId, "data_fetched", {
 *     version: useNewAlgorithm ? "v2" : "v1",
 *   });
 *
 *   return c.json(data);
 * });
 *
 * // Graceful shutdown
 * process.on("SIGTERM", async () => {
 *   await shutdownPostHog();
 *   process.exit(0);
 * });
 * \`\`\`
 */
`],
  ["feature-flags/growthbook/web/react/src/lib/growthbook.tsx.hbs", `import {
  GrowthBook,
  GrowthBookProvider as GBProvider,
  useFeatureIsOn,
  useFeatureValue,
  useGrowthBook,
} from "@growthbook/growthbook-react";
import type { PropsWithChildren } from "react";
import { useEffect, useMemo, useState } from "react";

// GrowthBook configuration from environment variables
{{#if (eq frontend.[0] "next")}}
const apiHost = process.env.NEXT_PUBLIC_GROWTHBOOK_API_HOST || "https://cdn.growthbook.io";
const clientKey = process.env.NEXT_PUBLIC_GROWTHBOOK_CLIENT_KEY || "";
{{else if (eq frontend.[0] "nuxt")}}
const apiHost = process.env.NUXT_PUBLIC_GROWTHBOOK_API_HOST || "https://cdn.growthbook.io";
const clientKey = process.env.NUXT_PUBLIC_GROWTHBOOK_CLIENT_KEY || "";
{{else}}
const apiHost = import.meta.env.VITE_GROWTHBOOK_API_HOST || "https://cdn.growthbook.io";
const clientKey = import.meta.env.VITE_GROWTHBOOK_CLIENT_KEY || "";
{{/if}}

// Create a singleton GrowthBook instance
const gb = new GrowthBook({
  apiHost,
  clientKey,
  // Enable streaming for real-time feature flag updates
  backgroundSync: true,
  // Track experiment views automatically
  enableDevMode: {{#if (eq backend "self")}}process.env.NODE_ENV{{else}}import.meta.env.MODE{{/if}} === "development",
});

interface GrowthBookProviderProps extends PropsWithChildren {
  /**
   * User attributes for targeting rules
   * @example { id: "user-123", email: "user@example.com", plan: "premium" }
   */
  attributes?: Record<string, unknown>;
}

/**
 * GrowthBook Provider component
 * Wrap your app with this provider to enable feature flags
 *
 * @example
 * function App() {
 *   const user = useAuth();
 *   return (
 *     <GrowthBookProvider attributes=\\{{ id: user?.id, plan: user?.plan }}>
 *       <YourApp />
 *     </GrowthBookProvider>
 *   );
 * }
 */
export function GrowthBookProvider({ children, attributes }: GrowthBookProviderProps) {
  const [ready, setReady] = useState(false);

  useEffect(() => {
    // Load feature definitions
    gb.init({ timeout: 2000 }).then(() => {
      setReady(true);
    });
  }, []);

  useEffect(() => {
    // Update user attributes when they change
    if (attributes) {
      gb.setAttributes(attributes);
    }
  }, [attributes]);

  if (!clientKey) {
    console.warn("[GrowthBook] Client key not configured, feature flags will use default values");
  }

  return <GBProvider growthbook={gb}>{children}</GBProvider>;
}

/**
 * Hook to check if a feature is enabled
 *
 * @example
 * function MyComponent() {
 *   const showNewFeature = useFeature("new-feature");
 *   return showNewFeature ? <NewFeature /> : <OldFeature />;
 * }
 */
export function useFeature(featureKey: string): boolean {
  return useFeatureIsOn(featureKey);
}

/**
 * Hook to get a feature value
 *
 * @example
 * function MyComponent() {
 *   const buttonColor = useFeatureConfig("button-color", "blue");
 *   return <button style=\\{{ backgroundColor: buttonColor }}>Click me</button>;
 * }
 */
export function useFeatureConfig<T>(featureKey: string, defaultValue: T): T {
  return useFeatureValue(featureKey, defaultValue);
}

/**
 * Hook to run an experiment
 *
 * @example
 * function PricingPage() {
 *   const { value: variation } = useExperiment({
 *     key: "pricing-test",
 *     variations: ["control", "variant-a", "variant-b"]
 *   });
 *
 *   return <PricingTable variation={variation} />;
 * }
 */
export function useExperiment<T>(experiment: { key: string; variations: T[] }) {
  const gb = useGrowthBook();
  return useMemo(() => {
    if (!gb) return { value: experiment.variations[0], variationId: 0 };
    return gb.run(experiment);
  }, [gb, experiment.key]);
}

/**
 * Hook to track events
 *
 * @example
 * function CheckoutButton() {
 *   const track = useTrackEvent();
 *
 *   const handleClick = () => {
 *     track("checkout_started", { items: 3, total: 99.99 });
 *   };
 *
 *   return <button onClick={handleClick}>Checkout</button>;
 * }
 */
export function useTrackEvent() {
  const gb = useGrowthBook();

  return (eventName: string, properties?: Record<string, unknown>) => {
    if (gb) {
      gb.track(eventName, properties);
    }
  };
}

// Re-export types and hooks for advanced usage
export { GrowthBook, useGrowthBook, useFeatureIsOn, useFeatureValue };

/**
 * Environment Variables:
 *
{{#if (eq frontend.[0] "next")}}
 * NEXT_PUBLIC_GROWTHBOOK_API_HOST - GrowthBook API host (default: https://cdn.growthbook.io)
 * NEXT_PUBLIC_GROWTHBOOK_CLIENT_KEY - SDK Connection client key from GrowthBook dashboard
{{else if (eq frontend.[0] "nuxt")}}
 * NUXT_PUBLIC_GROWTHBOOK_API_HOST - GrowthBook API host (default: https://cdn.growthbook.io)
 * NUXT_PUBLIC_GROWTHBOOK_CLIENT_KEY - SDK Connection client key from GrowthBook dashboard
{{else}}
 * VITE_GROWTHBOOK_API_HOST - GrowthBook API host (default: https://cdn.growthbook.io)
 * VITE_GROWTHBOOK_CLIENT_KEY - SDK Connection client key from GrowthBook dashboard
{{/if}}
 *
 * Getting started:
 * 1. Create an account at https://app.growthbook.io
 * 2. Create a new SDK Connection (choose "React" type)
 * 3. Copy the Client Key to your .env file
 * 4. Create features in the Features tab
 * 5. Wrap your app with <GrowthBookProvider>
 *
 * Example usage:
 * \`\`\`tsx
 * // In your app entry point
 * import { GrowthBookProvider } from "./lib/growthbook";
 *
 * function App() {
 *   const user = useAuth();
 *   return (
 *     <GrowthBookProvider attributes=\\{{ id: user?.id }}>
 *       <Router />
 *     </GrowthBookProvider>
 *   );
 * }
 *
 * // In any component
 * import { useFeature, useFeatureConfig } from "./lib/growthbook";
 *
 * function MyComponent() {
 *   const showBanner = useFeature("show-banner");
 *   const bannerText = useFeatureConfig("banner-text", "Welcome!");
 *
 *   if (!showBanner) return null;
 *   return <Banner text={bannerText} />;
 * }
 * \`\`\`
 */
`],
  ["caching/upstash-redis/server/base/src/lib/cache.ts.hbs", `import { Redis } from "@upstash/redis";

/**
 * Upstash Redis client for serverless caching
 * @see https://upstash.com/docs/redis/overall/getstarted
 */
export const redis = new Redis({
  url: process.env.UPSTASH_REDIS_REST_URL!,
  token: process.env.UPSTASH_REDIS_REST_TOKEN!,
});

/**
 * Cache utilities for common caching patterns
 */

/**
 * Get a cached value by key
 */
export async function cacheGet<T>(key: string): Promise<T | null> {
  return redis.get<T>(key);
}

/**
 * Set a cached value with optional TTL (in seconds)
 */
export async function cacheSet<T>(
  key: string,
  value: T,
  options?: { ex?: number; px?: number; nx?: boolean; xx?: boolean }
): Promise<"OK" | null> {
  if (options?.ex) {
    return redis.set(key, value, { ex: options.ex });
  }
  if (options?.px) {
    return redis.set(key, value, { px: options.px });
  }
  if (options?.nx) {
    return redis.set(key, value, { nx: true });
  }
  if (options?.xx) {
    return redis.set(key, value, { xx: true });
  }
  return redis.set(key, value);
}

/**
 * Delete a cached value
 */
export async function cacheDelete(key: string): Promise<number> {
  return redis.del(key);
}

/**
 * Delete multiple cached values
 */
export async function cacheDeleteMany(keys: string[]): Promise<number> {
  if (keys.length === 0) return 0;
  return redis.del(...keys);
}

/**
 * Check if a key exists in cache
 */
export async function cacheExists(key: string): Promise<boolean> {
  const result = await redis.exists(key);
  return result === 1;
}

/**
 * Set expiration time on a key (in seconds)
 */
export async function cacheExpire(key: string, seconds: number): Promise<boolean> {
  const result = await redis.expire(key, seconds);
  return result === 1;
}

/**
 * Get remaining TTL of a key (in seconds)
 * Returns -1 if key has no expiration, -2 if key doesn't exist
 */
export async function cacheTTL(key: string): Promise<number> {
  return redis.ttl(key);
}

/**
 * Increment a numeric value
 */
export async function cacheIncr(key: string): Promise<number> {
  return redis.incr(key);
}

/**
 * Increment a numeric value by amount
 */
export async function cacheIncrBy(key: string, amount: number): Promise<number> {
  return redis.incrby(key, amount);
}

/**
 * Decrement a numeric value
 */
export async function cacheDecr(key: string): Promise<number> {
  return redis.decr(key);
}

/**
 * Get or set pattern - retrieves from cache or executes function and caches result
 */
export async function cacheGetOrSet<T>(
  key: string,
  fn: () => Promise<T>,
  ttlSeconds?: number
): Promise<T> {
  const cached = await cacheGet<T>(key);
  if (cached !== null) {
    return cached;
  }

  const value = await fn();
  await cacheSet(key, value, ttlSeconds ? { ex: ttlSeconds } : undefined);
  return value;
}

/**
 * Hash operations - useful for storing objects
 */
export const cacheHash = {
  async get<T>(key: string, field: string): Promise<T | null> {
    return redis.hget<T>(key, field);
  },

  async getAll<T extends Record<string, unknown>>(key: string): Promise<T | null> {
    return redis.hgetall<T>(key);
  },

  async set(key: string, field: string, value: unknown): Promise<number> {
    return redis.hset(key, { [field]: value });
  },

  async setMultiple(key: string, values: Record<string, unknown>): Promise<number> {
    return redis.hset(key, values);
  },

  async delete(key: string, ...fields: string[]): Promise<number> {
    return redis.hdel(key, ...fields);
  },

  async exists(key: string, field: string): Promise<boolean> {
    const result = await redis.hexists(key, field);
    return result === 1;
  },
};

/**
 * List operations - useful for queues, recent items, etc.
 */
export const cacheList = {
  async push(key: string, ...values: unknown[]): Promise<number> {
    return redis.rpush(key, ...values);
  },

  async unshift(key: string, ...values: unknown[]): Promise<number> {
    return redis.lpush(key, ...values);
  },

  async pop<T>(key: string): Promise<T | null> {
    return redis.rpop<T>(key);
  },

  async shift<T>(key: string): Promise<T | null> {
    return redis.lpop<T>(key);
  },

  async range<T>(key: string, start: number, stop: number): Promise<T[]> {
    return redis.lrange<T>(key, start, stop);
  },

  async length(key: string): Promise<number> {
    return redis.llen(key);
  },

  async trim(key: string, start: number, stop: number): Promise<"OK"> {
    return redis.ltrim(key, start, stop);
  },
};

/**
 * Set operations - useful for unique collections, tags, etc.
 */
export const cacheSet_ = {
  async add(key: string, ...members: unknown[]): Promise<number> {
    return redis.sadd(key, ...members);
  },

  async remove(key: string, ...members: unknown[]): Promise<number> {
    return redis.srem(key, ...members);
  },

  async members<T>(key: string): Promise<T[]> {
    return redis.smembers<T>(key);
  },

  async isMember(key: string, member: unknown): Promise<boolean> {
    const result = await redis.sismember(key, member);
    return result === 1;
  },

  async size(key: string): Promise<number> {
    return redis.scard(key);
  },
};

/**
 * JSON operations - for complex data structures
 * Note: Requires Upstash Redis with JSON module enabled
 */
export const cacheJson = {
  async get<T>(key: string, path = "$"): Promise<T | null> {
    const result = await redis.json.get<T>(key, path);
    return result;
  },

  async set(key: string, path: string, value: unknown): Promise<"OK" | null> {
    return redis.json.set(key, path, value);
  },

  async delete(key: string, path = "$"): Promise<number> {
    return redis.json.del(key, path);
  },
};
`],
  ["job-queue/inngest/server/base/src/inngest/client.ts.hbs", `import { Inngest } from "inngest";

/**
 * Inngest client configuration
 * @see https://www.inngest.com/docs
 */
export const inngest = new Inngest({
  id: "{{projectName}}",
  // Event key is optional for local development
  // Required in production - get it at https://app.inngest.com
  eventKey: process.env.INNGEST_EVENT_KEY,
});
`],
  ["job-queue/inngest/server/base/src/inngest/functions.ts.hbs", `import { inngest } from "./client";

/**
 * Example email sending function
 * Triggered by: inngest.send({ name: "app/email.send", data: { to, subject, body } })
 * @see https://www.inngest.com/docs/functions
 */
export const sendEmail = inngest.createFunction(
  {
    id: "send-email",
    // Retry configuration
    retries: 3,
  },
  { event: "app/email.send" },
  async ({ event, step }) => {
    const { to, subject, body, templateId } = event.data;

    // Use steps for reliable execution with automatic retries
    const result = await step.run("send-email", async () => {
      // TODO: Implement your email sending logic here
      // Example with a hypothetical email service:
      // await emailService.send({ to, subject, body, templateId });

      // Simulate email sending
      await new Promise((resolve) => setTimeout(resolve, 1000));

      return {
        sent: true,
        to,
        timestamp: new Date().toISOString(),
      };
    });

    return result;
  }
);

/**
 * Example notification function
 * Supports different notification types: push, in-app, sms
 */
export const sendNotification = inngest.createFunction(
  {
    id: "send-notification",
    retries: 3,
  },
  { event: "app/notification.send" },
  async ({ event, step }) => {
    const { userId, type, title, message, data } = event.data;

    const result = await step.run("send-notification", async () => {
      // TODO: Implement your notification logic here
      // switch (type) {
      //   case "push":
      //     await pushService.send(userId, { title, message, data });
      //     break;
      //   case "in-app":
      //     await inAppNotificationService.create(userId, { title, message, data });
      //     break;
      //   case "sms":
      //     await smsService.send(userId, message);
      //     break;
      // }

      // Simulate notification processing
      await new Promise((resolve) => setTimeout(resolve, 500));

      return {
        sent: true,
        type,
        userId,
        timestamp: new Date().toISOString(),
      };
    });

    return result;
  }
);

/**
 * Example data processing function with multiple steps
 * Demonstrates step-based workflows for complex operations
 */
export const processData = inngest.createFunction(
  {
    id: "process-data",
    retries: 2,
    // Cancel if another run for the same dataId starts
    cancelOn: [
      {
        event: "app/data.cancel",
        match: "data.dataId",
      },
    ],
  },
  { event: "app/data.process" },
  async ({ event, step }) => {
    const { dataId, operation } = event.data;

    // Step 1: Validate input
    await step.run("validate", async () => {
      if (!dataId) {
        throw new Error("Data ID is required");
      }
    });

    // Step 2: Process data based on operation
    const result = await step.run("process", async () => {
      // TODO: Implement your data processing logic here
      // const data = await database.getData(dataId);
      // switch (operation) {
      //   case "transform":
      //     return await transformData(data);
      //   case "aggregate":
      //     return await aggregateData(data);
      //   case "export":
      //     return await exportData(data);
      // }

      // Simulate data processing
      await new Promise((resolve) => setTimeout(resolve, 2000));

      return {
        processed: true,
        dataId,
        operation,
      };
    });

    // Step 3: Send completion notification
    await step.sendEvent("send-completion-notification", {
      name: "app/notification.send",
      data: {
        userId: "system",
        type: "in-app" as const,
        title: "Processing Complete",
        message: \`Data \${dataId} has been \${operation}ed successfully\`,
      },
    });

    return {
      ...result,
      timestamp: new Date().toISOString(),
    };
  }
);

/**
 * Example scheduled function (cron job)
 * Runs every hour - customize the cron pattern as needed
 * @see https://www.inngest.com/docs/guides/scheduled-functions
 */
export const hourlyCleanup = inngest.createFunction(
  { id: "hourly-cleanup" },
  { cron: "0 * * * *" }, // Every hour at minute 0
  async ({ step }) => {
    const result = await step.run("cleanup", async () => {
      // TODO: Implement your cleanup logic here
      // await database.deleteExpiredSessions();
      // await cache.clearStale();

      // Simulate cleanup
      await new Promise((resolve) => setTimeout(resolve, 1000));

      return {
        cleaned: true,
        timestamp: new Date().toISOString(),
      };
    });

    return result;
  }
);

/**
 * Example daily report function with timezone
 * Runs at 9 AM UTC - change timezone as needed
 */
export const dailyReport = inngest.createFunction(
  { id: "daily-report" },
  { cron: "TZ=UTC 0 9 * * *" }, // 9 AM UTC every day
  async ({ step }) => {
    // Step 1: Generate report data
    const reportData = await step.run("generate-report", async () => {
      // TODO: Implement your report generation logic here
      // const stats = await analytics.getDailyStats();
      // return generateReportData(stats);

      // Simulate report generation
      await new Promise((resolve) => setTimeout(resolve, 2000));

      return {
        generatedAt: new Date().toISOString(),
        metrics: {
          users: 100,
          events: 500,
        },
      };
    });

    // Step 2: Send report via email
    await step.sendEvent("send-report-email", {
      name: "app/email.send",
      data: {
        to: "admin@example.com",
        subject: "Daily Report",
        body: \`Daily metrics: \${JSON.stringify(reportData.metrics)}\`,
      },
    });

    return {
      reportGenerated: true,
      timestamp: new Date().toISOString(),
    };
  }
);

/**
 * Example delayed function
 * Demonstrates using step.sleep for delayed execution
 */
export const welcomeSequence = inngest.createFunction(
  { id: "welcome-sequence" },
  { event: "app/user.signup" },
  async ({ event, step }) => {
    const { userId, email, name } = event.data;

    // Send immediate welcome email
    await step.sendEvent("send-welcome", {
      name: "app/email.send",
      data: {
        to: email,
        subject: "Welcome to {{projectName}}!",
        body: \`Hi \${name}, welcome aboard!\`,
      },
    });

    // Wait 1 day before sending tips email
    await step.sleep("wait-1-day", "1d");

    await step.sendEvent("send-tips", {
      name: "app/email.send",
      data: {
        to: email,
        subject: "Getting Started Tips",
        body: \`Hi \${name}, here are some tips to get the most out of {{projectName}}...\`,
      },
    });

    // Wait 3 more days before sending feature highlight
    await step.sleep("wait-3-days", "3d");

    await step.sendEvent("send-features", {
      name: "app/email.send",
      data: {
        to: email,
        subject: "Discover More Features",
        body: \`Hi \${name}, have you tried these features yet?\`,
      },
    });

    return {
      completed: true,
      userId,
      timestamp: new Date().toISOString(),
    };
  }
);

// Export all functions for the serve handler
export const functions = [
  sendEmail,
  sendNotification,
  processData,
  hourlyCleanup,
  dailyReport,
  welcomeSequence,
];
`],
  ["job-queue/inngest/server/base/src/lib/inngest.ts.hbs", `/**
 * Inngest utility functions for triggering events from your backend
 * @see https://www.inngest.com/docs
 */
import { inngest } from "../inngest/client";

// Type definitions for event payloads
export interface EmailPayload {
  to: string;
  subject: string;
  body: string;
  templateId?: string;
}

export interface NotificationPayload {
  userId: string;
  type: "push" | "in-app" | "sms";
  title: string;
  message: string;
  data?: Record<string, unknown>;
}

export interface DataProcessingPayload {
  dataId: string;
  operation: "transform" | "aggregate" | "export";
}

export interface UserSignupPayload {
  userId: string;
  email: string;
  name: string;
}

/**
 * Trigger an email event
 * @example
 * await triggerEmail({
 *   to: "user@example.com",
 *   subject: "Welcome!",
 *   body: "Thanks for signing up."
 * });
 */
export async function triggerEmail(payload: EmailPayload) {
  return inngest.send({
    name: "app/email.send",
    data: payload,
  });
}

/**
 * Trigger a notification event
 * @example
 * await triggerNotification({
 *   userId: "user_123",
 *   type: "push",
 *   title: "New message",
 *   message: "You have a new message!"
 * });
 */
export async function triggerNotification(payload: NotificationPayload) {
  return inngest.send({
    name: "app/notification.send",
    data: payload,
  });
}

/**
 * Trigger a data processing event
 * @example
 * await triggerDataProcessing({
 *   dataId: "data_456",
 *   operation: "transform"
 * });
 */
export async function triggerDataProcessing(payload: DataProcessingPayload) {
  return inngest.send({
    name: "app/data.process",
    data: payload,
  });
}

/**
 * Cancel a running data processing job
 * @example
 * await cancelDataProcessing("data_456");
 */
export async function cancelDataProcessing(dataId: string) {
  return inngest.send({
    name: "app/data.cancel",
    data: { dataId },
  });
}

/**
 * Trigger user signup welcome sequence
 * @example
 * await triggerWelcomeSequence({
 *   userId: "user_123",
 *   email: "user@example.com",
 *   name: "John"
 * });
 */
export async function triggerWelcomeSequence(payload: UserSignupPayload) {
  return inngest.send({
    name: "app/user.signup",
    data: payload,
  });
}

/**
 * Trigger multiple events in a batch
 * @example
 * await triggerEmailBatch([
 *   { to: "user1@example.com", subject: "Hello", body: "Hi!" },
 *   { to: "user2@example.com", subject: "Hello", body: "Hi!" }
 * ]);
 */
export async function triggerEmailBatch(payloads: EmailPayload[]) {
  return inngest.send(
    payloads.map((data) => ({
      name: "app/email.send" as const,
      data,
    }))
  );
}

// Re-export the inngest client for advanced usage
export { inngest };
`],
  ["job-queue/temporal/server/base/src/temporal/client.ts.hbs", `import { Client, Connection } from "@temporalio/client";

/**
 * Temporal client configuration
 * @see https://docs.temporal.io/develop/typescript/core-application
 */

let client: Client | null = null;

/**
 * Get or create a Temporal client connection
 * Reuses existing connection if available
 */
export async function getTemporalClient(): Promise<Client> {
  if (client) {
    return client;
  }

  const connection = await Connection.connect({
    // Connect to Temporal server (default: localhost:7233)
    // Use TEMPORAL_ADDRESS env var for custom server address
    address: process.env.TEMPORAL_ADDRESS || "localhost:7233",
  });

  client = new Client({
    connection,
    // Namespace to use (default: "default")
    namespace: process.env.TEMPORAL_NAMESPACE || "default",
  });

  return client;
}

/**
 * Close the Temporal client connection
 * Call this during graceful shutdown
 */
export async function closeTemporalClient(): Promise<void> {
  if (client) {
    await client.connection.close();
    client = null;
  }
}
`],
  ["job-queue/temporal/server/base/src/temporal/activities.ts.hbs", `/**
 * Temporal Activities
 *
 * Activities are the building blocks of workflows - they perform the actual work.
 * Activities can make network calls, interact with databases, or perform any side effects.
 * They automatically retry on failure based on configuration.
 *
 * @see https://docs.temporal.io/develop/typescript/core-application#develop-activities
 */

// Activity context provides utilities like heartbeating for long-running activities
// import { Context } from "@temporalio/activity";

/**
 * Send an email activity
 * @param to - Recipient email address
 * @param subject - Email subject
 * @param body - Email body content
 */
export async function sendEmail(
  to: string,
  subject: string,
  body: string
): Promise<{ sent: boolean; timestamp: string }> {
  // TODO: Implement your email sending logic here
  // Example with a hypothetical email service:
  // await emailService.send({ to, subject, body });

  // Simulate email sending
  await new Promise((resolve) => setTimeout(resolve, 1000));

  console.log(\`[Activity] Sending email to \${to}: \${subject}\`);

  return {
    sent: true,
    timestamp: new Date().toISOString(),
  };
}

/**
 * Send a notification activity
 * @param userId - User ID to send notification to
 * @param type - Notification type: "push" | "in-app" | "sms"
 * @param message - Notification message
 */
export async function sendNotification(
  userId: string,
  type: "push" | "in-app" | "sms",
  message: string
): Promise<{ sent: boolean; type: string; timestamp: string }> {
  // TODO: Implement your notification logic here
  // switch (type) {
  //   case "push":
  //     await pushService.send(userId, message);
  //     break;
  //   case "in-app":
  //     await inAppNotificationService.create(userId, message);
  //     break;
  //   case "sms":
  //     await smsService.send(userId, message);
  //     break;
  // }

  // Simulate notification sending
  await new Promise((resolve) => setTimeout(resolve, 500));

  console.log(\`[Activity] Sending \${type} notification to user \${userId}: \${message}\`);

  return {
    sent: true,
    type,
    timestamp: new Date().toISOString(),
  };
}

/**
 * Process data activity
 * @param dataId - ID of the data to process
 * @param operation - Operation to perform: "transform" | "aggregate" | "export"
 */
export async function processData(
  dataId: string,
  operation: "transform" | "aggregate" | "export"
): Promise<{ processed: boolean; dataId: string; operation: string }> {
  // TODO: Implement your data processing logic here
  // const data = await database.getData(dataId);
  // switch (operation) {
  //   case "transform":
  //     return await transformData(data);
  //   case "aggregate":
  //     return await aggregateData(data);
  //   case "export":
  //     return await exportData(data);
  // }

  // For long-running activities, use heartbeating to report progress
  // const ctx = Context.current();
  // ctx.heartbeat("Processing started");

  // Simulate data processing
  await new Promise((resolve) => setTimeout(resolve, 2000));

  console.log(\`[Activity] Processing data \${dataId} with operation \${operation}\`);

  return {
    processed: true,
    dataId,
    operation,
  };
}

/**
 * Cleanup activity for scheduled jobs
 * Removes expired sessions, clears stale cache, etc.
 */
export async function performCleanup(): Promise<{ cleaned: boolean; timestamp: string }> {
  // TODO: Implement your cleanup logic here
  // await database.deleteExpiredSessions();
  // await cache.clearStale();

  // Simulate cleanup
  await new Promise((resolve) => setTimeout(resolve, 1000));

  console.log("[Activity] Performing scheduled cleanup");

  return {
    cleaned: true,
    timestamp: new Date().toISOString(),
  };
}

/**
 * Generate daily report activity
 */
export async function generateReport(): Promise<{
  generatedAt: string;
  metrics: { users: number; events: number };
}> {
  // TODO: Implement your report generation logic here
  // const stats = await analytics.getDailyStats();
  // return generateReportData(stats);

  // Simulate report generation
  await new Promise((resolve) => setTimeout(resolve, 2000));

  console.log("[Activity] Generating daily report");

  return {
    generatedAt: new Date().toISOString(),
    metrics: {
      users: 100,
      events: 500,
    },
  };
}

/**
 * Fetch user data activity
 * @param userId - User ID to fetch data for
 */
export async function fetchUserData(
  userId: string
): Promise<{ userId: string; email: string; name: string }> {
  // TODO: Implement your user data fetching logic
  // return await database.getUser(userId);

  // Simulate database fetch
  await new Promise((resolve) => setTimeout(resolve, 300));

  return {
    userId,
    email: \`user-\${userId}@example.com\`,
    name: \`User \${userId}\`,
  };
}
`],
  ["job-queue/temporal/server/base/src/temporal/worker.ts.hbs", `import { Worker, NativeConnection } from "@temporalio/worker";

import * as activities from "./activities";

/**
 * Temporal Worker Configuration
 *
 * Workers execute workflows and activities. You can run multiple workers
 * for scalability - they will automatically coordinate via the Temporal server.
 *
 * @see https://docs.temporal.io/develop/typescript/core-application#run-a-dev-worker
 */

const TASK_QUEUE = process.env.TEMPORAL_TASK_QUEUE || "{{projectName}}-task-queue";

/**
 * Create and run a Temporal worker
 */
export async function runWorker(): Promise<void> {
  // Connect to the Temporal server
  const connection = await NativeConnection.connect({
    address: process.env.TEMPORAL_ADDRESS || "localhost:7233",
  });

  try {
    // Create a worker that connects to the server and executes workflows/activities
    const worker = await Worker.create({
      connection,
      namespace: process.env.TEMPORAL_NAMESPACE || "default",
      taskQueue: TASK_QUEUE,
      // Point to compiled workflow file for bundling
      workflowsPath: require.resolve("./workflows"),
      // Register activities directly
      activities,
      // Optional: Configure worker behavior
      maxConcurrentActivityTaskExecutions: 100,
      maxConcurrentWorkflowTaskExecutions: 100,
    });

    // Start accepting tasks
    console.log(\`[Temporal Worker] Starting worker on task queue: \${TASK_QUEUE}\`);
    await worker.run();
  } finally {
    // Ensure we close the connection when shutting down
    await connection.close();
  }
}

/**
 * Run the worker when this file is executed directly
 * Usage: npx ts-node src/temporal/worker.ts
 */
if (require.main === module) {
  runWorker().catch((err) => {
    console.error("[Temporal Worker] Failed to start:", err);
    process.exit(1);
  });
}
`],
  ["job-queue/temporal/server/base/src/temporal/workflows.ts.hbs", `/**
 * Temporal Workflows
 *
 * Workflows are the core abstraction in Temporal. They orchestrate activities
 * and other workflows, and are durable - they survive process restarts.
 *
 * IMPORTANT: Workflow code must be deterministic!
 * - No direct I/O, network calls, or random number generation
 * - Use activities for any non-deterministic operations
 * - Use workflow.sleep instead of setTimeout
 *
 * @see https://docs.temporal.io/develop/typescript/core-application#develop-workflows
 */

import { proxyActivities, sleep, defineSignal, setHandler, condition } from "@temporalio/workflow";

// Import activity types for type-safe proxy
import type * as activities from "./activities";

// Create activity proxies with retry policies
const { sendEmail, sendNotification, processData, performCleanup, generateReport, fetchUserData } =
  proxyActivities<typeof activities>({
    // Default activity options
    startToCloseTimeout: "1 minute",
    retry: {
      initialInterval: "1 second",
      maximumInterval: "1 minute",
      backoffCoefficient: 2,
      maximumAttempts: 3,
    },
  });

// Define signals for workflow interaction
export const cancelSignal = defineSignal("cancel");

/**
 * Email sending workflow
 * Simple workflow that sends a single email
 */
export async function sendEmailWorkflow(
  to: string,
  subject: string,
  body: string
): Promise<{ sent: boolean; timestamp: string }> {
  return await sendEmail(to, subject, body);
}

/**
 * Notification workflow
 * Sends a notification to a user
 */
export async function sendNotificationWorkflow(
  userId: string,
  type: "push" | "in-app" | "sms",
  message: string
): Promise<{ sent: boolean; type: string; timestamp: string }> {
  return await sendNotification(userId, type, message);
}

/**
 * Data processing workflow with cancellation support
 * Demonstrates multi-step workflow with signal handling
 */
export async function processDataWorkflow(
  dataId: string,
  operation: "transform" | "aggregate" | "export"
): Promise<{ processed: boolean; dataId: string; operation: string; timestamp: string }> {
  let cancelled = false;

  // Set up cancellation signal handler
  setHandler(cancelSignal, () => {
    cancelled = true;
  });

  // Step 1: Validate input
  if (!dataId) {
    throw new Error("Data ID is required");
  }

  // Check for cancellation
  if (cancelled) {
    return {
      processed: false,
      dataId,
      operation,
      timestamp: new Date().toISOString(),
    };
  }

  // Step 2: Process data
  const result = await processData(dataId, operation);

  // Step 3: Send completion notification
  await sendNotification("system", "in-app", \`Data \${dataId} has been \${operation}ed successfully\`);

  return {
    ...result,
    timestamp: new Date().toISOString(),
  };
}

/**
 * Scheduled cleanup workflow
 * Can be started with a cron schedule
 *
 * Start with: client.schedule.create({
 *   scheduleId: "hourly-cleanup",
 *   spec: { cronExpressions: ["0 * * * *"] },
 *   action: { type: "startWorkflow", workflowType: "cleanupWorkflow", ... }
 * })
 */
export async function cleanupWorkflow(): Promise<{ cleaned: boolean; timestamp: string }> {
  return await performCleanup();
}

/**
 * Daily report workflow
 * Generates a report and sends it via email
 *
 * Start with cron schedule: "0 9 * * *" (9 AM daily)
 */
export async function dailyReportWorkflow(): Promise<{
  reportGenerated: boolean;
  timestamp: string;
}> {
  // Step 1: Generate report
  const reportData = await generateReport();

  // Step 2: Send report via email
  await sendEmail(
    "admin@example.com",
    "Daily Report",
    \`Daily metrics: \${JSON.stringify(reportData.metrics)}\`
  );

  return {
    reportGenerated: true,
    timestamp: new Date().toISOString(),
  };
}

/**
 * Welcome sequence workflow
 * Demonstrates long-running workflow with delays
 *
 * This workflow sends a series of emails over several days:
 * - Immediate: Welcome email
 * - After 1 day: Tips email
 * - After 3 more days: Feature highlight email
 */
export async function welcomeSequenceWorkflow(
  userId: string
): Promise<{ completed: boolean; userId: string; timestamp: string }> {
  // Fetch user data
  const user = await fetchUserData(userId);

  // Send immediate welcome email
  await sendEmail(user.email, "Welcome to {{projectName}}!", \`Hi \${user.name}, welcome aboard!\`);

  // Wait 1 day before sending tips email
  await sleep("1 day");

  await sendEmail(
    user.email,
    "Getting Started Tips",
    \`Hi \${user.name}, here are some tips to get the most out of {{projectName}}...\`
  );

  // Wait 3 more days before sending feature highlight
  await sleep("3 days");

  await sendEmail(
    user.email,
    "Discover More Features",
    \`Hi \${user.name}, have you tried these features yet?\`
  );

  return {
    completed: true,
    userId,
    timestamp: new Date().toISOString(),
  };
}

/**
 * Order processing workflow
 * Example of a saga pattern with compensation
 */
export async function orderProcessingWorkflow(orderId: string): Promise<{
  success: boolean;
  orderId: string;
  steps: string[];
}> {
  const completedSteps: string[] = [];

  try {
    // Step 1: Validate order
    completedSteps.push("validated");

    // Step 2: Reserve inventory (simulated with notification)
    await sendNotification("system", "in-app", \`Reserving inventory for order \${orderId}\`);
    completedSteps.push("inventory_reserved");

    // Step 3: Process payment (simulated)
    await sendNotification("system", "in-app", \`Processing payment for order \${orderId}\`);
    completedSteps.push("payment_processed");

    // Step 4: Ship order (simulated)
    await sendNotification("system", "in-app", \`Shipping order \${orderId}\`);
    completedSteps.push("shipped");

    // Step 5: Send confirmation email
    await sendEmail("customer@example.com", "Order Confirmed", \`Your order \${orderId} has shipped!\`);
    completedSteps.push("notification_sent");

    return {
      success: true,
      orderId,
      steps: completedSteps,
    };
  } catch (error) {
    // Compensation logic would go here
    // For example: release inventory, refund payment, etc.
    return {
      success: false,
      orderId,
      steps: completedSteps,
    };
  }
}

/**
 * Batch processing workflow with child workflows
 * Demonstrates parent-child workflow pattern
 */
export async function batchEmailWorkflow(
  recipients: Array<{ email: string; subject: string; body: string }>
): Promise<{ sent: number; failed: number }> {
  let sent = 0;
  let failed = 0;

  for (const recipient of recipients) {
    try {
      await sendEmail(recipient.email, recipient.subject, recipient.body);
      sent++;
    } catch {
      failed++;
    }
  }

  return { sent, failed };
}
`],
  ["frontend/redwood/api/src/directives/requireAuth/requireAuth.ts", `import type { ValidatorDirectiveFunc } from "@redwoodjs/graphql-server";

import { createValidatorDirective } from "@redwoodjs/graphql-server";
import gql from "graphql-tag";
import { requireAuth as applicationRequireAuth } from "src/lib/auth";

export const schema = gql\`
  """
  Use to check whether or not a user is authenticated and is associated
  with an optional set of roles.
  """
  directive @requireAuth(roles: [String]) on FIELD_DEFINITION
\`;

type RequireAuthValidate = ValidatorDirectiveFunc<{ roles?: string[] }>;

const validate: RequireAuthValidate = ({ directiveArgs }) => {
  const { roles } = directiveArgs;
  applicationRequireAuth({ roles });
};

const requireAuth = createValidatorDirective(schema, validate);

export default requireAuth;
`],
  ["frontend/redwood/api/src/directives/skipAuth/skipAuth.ts", `import { createValidatorDirective } from "@redwoodjs/graphql-server";
import gql from "graphql-tag";

export const schema = gql\`
  """
  Use to skip authentication checks and allow public access.
  """
  directive @skipAuth on FIELD_DEFINITION
\`;

const skipAuth = createValidatorDirective(schema, () => {
  return;
});

export default skipAuth;
`],
  ["frontend/redwood/web/src/pages/FatalErrorPage/FatalErrorPage.tsx", `// This page will be rendered when an error makes it all the way to the top of the
// application without being handled by a Javascript catch statement.
// https://redwoodjs.com/docs/app-configuration-redwood-toml#handleuncaughtexception

export default () => (
  <main>
    <style
      dangerouslySetInnerHTML={{
        __html: \`
          html, body {
            margin: 0;
          }
          html * {
            box-sizing: border-box;
          }
          main {
            display: flex;
            align-items: center;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
            text-align: center;
            background-color: #0f172a;
            color: #f8fafc;
            height: 100vh;
          }
          section {
            background-color: #1e293b;
            border-radius: 0.25rem;
            width: 32rem;
            padding: 1rem;
            margin: 0 auto;
            box-shadow: 0 1px 3px rgba(0,0,0,0.5);
          }
          h1 {
            font-size: 2rem;
            margin: 0;
            font-weight: 500;
            line-height: 1;
            color: #ef4444;
          }
          p {
            color: #94a3b8;
          }
        \`,
      }}
    />
    <section>
      <h1>
        <span>Something went wrong</span>
      </h1>
      <p>
        Sorry, something went wrong. Please try refreshing the page or contact support if the
        problem persists.
      </p>
    </section>
  </main>
);
`],
  ["frontend/redwood/web/src/pages/HomePage/HomePage.tsx.hbs", `import { Link, routes } from '@redwoodjs/router'
import { Metadata } from '@redwoodjs/web'

const HomePage = () => {
  return (
    <>
      <Metadata title="Home" description="Home page" />

      <main{{#if (eq cssFramework "tailwind")}} className="min-h-screen bg-slate-900 text-slate-100 flex flex-col items-center justify-center p-8"{{/if}}>
        <div{{#if (eq cssFramework "tailwind")}} className="max-w-4xl mx-auto text-center"{{/if}}>
          <h1{{#if (eq cssFramework "tailwind")}} className="text-5xl font-bold text-cyan-400 mb-6"{{/if}}>
            Welcome to RedwoodJS
          </h1>
          <p{{#if (eq cssFramework "tailwind")}} className="text-xl text-slate-300 mb-8"{{/if}}>
            Built with the Better T Stack
          </p>

          <div{{#if (eq cssFramework "tailwind")}} className="grid grid-cols-1 md:grid-cols-3 gap-6 mt-12"{{/if}}>
            <div{{#if (eq cssFramework "tailwind")}} className="bg-slate-800 p-6 rounded-lg border border-slate-700"{{/if}}>
              <h3{{#if (eq cssFramework "tailwind")}} className="text-lg font-semibold text-cyan-400 mb-2"{{/if}}>
                React Frontend
              </h3>
              <p{{#if (eq cssFramework "tailwind")}} className="text-slate-400 text-sm"{{/if}}>
                Modern React with file-based routing and Cells for data fetching.
              </p>
            </div>

            <div{{#if (eq cssFramework "tailwind")}} className="bg-slate-800 p-6 rounded-lg border border-slate-700"{{/if}}>
              <h3{{#if (eq cssFramework "tailwind")}} className="text-lg font-semibold text-cyan-400 mb-2"{{/if}}>
                GraphQL API
              </h3>
              <p{{#if (eq cssFramework "tailwind")}} className="text-slate-400 text-sm"{{/if}}>
                Type-safe GraphQL with auto-generated types and SDL-first schema.
              </p>
            </div>

            <div{{#if (eq cssFramework "tailwind")}} className="bg-slate-800 p-6 rounded-lg border border-slate-700"{{/if}}>
              <h3{{#if (eq cssFramework "tailwind")}} className="text-lg font-semibold text-cyan-400 mb-2"{{/if}}>
                Prisma ORM
              </h3>
              <p{{#if (eq cssFramework "tailwind")}} className="text-slate-400 text-sm"{{/if}}>
                Database access made easy with Prisma and automatic migrations.
              </p>
            </div>
          </div>

          <div{{#if (eq cssFramework "tailwind")}} className="mt-12"{{/if}}>
            <a
              href="https://redwoodjs.com/docs"
              target="_blank"
              rel="noopener noreferrer"
              {{#if (eq cssFramework "tailwind")}}className="inline-block bg-cyan-500 text-slate-900 px-6 py-3 rounded-lg font-semibold hover:bg-cyan-400 transition-colors"{{/if}}
            >
              Read the Docs
            </a>
          </div>
        </div>
      </main>
    </>
  )
}

export default HomePage
`],
  ["frontend/redwood/web/src/pages/NotFoundPage/NotFoundPage.tsx", `export default () => (
  <main>
    <style
      dangerouslySetInnerHTML={{
        __html: \`
          html, body {
            margin: 0;
          }
          html * {
            box-sizing: border-box;
          }
          main {
            display: flex;
            align-items: center;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
            text-align: center;
            background-color: #0f172a;
            color: #f8fafc;
            height: 100vh;
          }
          section {
            background-color: #1e293b;
            border-radius: 0.25rem;
            width: 32rem;
            padding: 1rem;
            margin: 0 auto;
            box-shadow: 0 1px 3px rgba(0,0,0,0.5);
          }
          h1 {
            font-size: 2rem;
            margin: 0;
            font-weight: 500;
            line-height: 1;
            color: #38bdf8;
          }
        \`,
      }}
    />
    <section>
      <h1>
        <span>404 Page Not Found</span>
      </h1>
    </section>
  </main>
);
`],
  ["frontend/redwood/api/src/services/posts/posts.ts", `import type { QueryResolvers, MutationResolvers } from "types/graphql";

import { db } from "src/lib/db";

export const posts: QueryResolvers["posts"] = () => {
  return db.post.findMany();
};

export const post: QueryResolvers["post"] = ({ id }) => {
  return db.post.findUnique({
    where: { id },
  });
};

export const createPost: MutationResolvers["createPost"] = ({ input }) => {
  return db.post.create({
    data: input,
  });
};

export const updatePost: MutationResolvers["updatePost"] = ({ id, input }) => {
  return db.post.update({
    data: input,
    where: { id },
  });
};

export const deletePost: MutationResolvers["deletePost"] = ({ id }) => {
  return db.post.delete({
    where: { id },
  });
};
`],
  ["job-queue/bullmq/server/base/src/lib/queue.ts.hbs", `import { Queue, Worker, type Job, type ConnectionOptions } from "bullmq";
import IORedis from "ioredis";

// Redis connection configuration
// For production, use environment variables to configure the connection
const redisConnection: ConnectionOptions = {
  host: process.env.REDIS_HOST || "localhost",
  port: Number(process.env.REDIS_PORT) || 6379,
  password: process.env.REDIS_PASSWORD || undefined,
  maxRetriesPerRequest: null, // Required for BullMQ
};

// Create a shared Redis connection for all queues
const connection = new IORedis(redisConnection);

// Export connection for reuse
export { connection };

/**
 * Example queue for background job processing
 * @see https://docs.bullmq.io/
 */
export const emailQueue = new Queue("email", { connection });
export const notificationQueue = new Queue("notification", { connection });

// Define job data types
export interface EmailJobData {
  to: string;
  subject: string;
  body: string;
  templateId?: string;
}

export interface NotificationJobData {
  userId: string;
  type: "push" | "in-app" | "sms";
  title: string;
  message: string;
  data?: Record<string, unknown>;
}

/**
 * Add an email job to the queue
 */
export async function queueEmail(data: EmailJobData, options?: { delay?: number; priority?: number }) {
  return emailQueue.add("send-email", data, {
    delay: options?.delay,
    priority: options?.priority,
    attempts: 3,
    backoff: {
      type: "exponential",
      delay: 1000,
    },
  });
}

/**
 * Add a notification job to the queue
 */
export async function queueNotification(data: NotificationJobData, options?: { delay?: number }) {
  return notificationQueue.add("send-notification", data, {
    delay: options?.delay,
    attempts: 3,
    backoff: {
      type: "exponential",
      delay: 1000,
    },
  });
}

/**
 * Schedule a recurring job (cron-style)
 * @example scheduleRecurringJob(emailQueue, "daily-report", { type: "report" }, "0 9 * * *")
 */
export async function scheduleRecurringJob<T>(
  queue: Queue,
  name: string,
  data: T,
  pattern: string, // Cron pattern
) {
  return queue.upsertJobScheduler(
    name,
    { pattern },
    { name, data: data as object },
  );
}

/**
 * Get queue statistics
 */
export async function getQueueStats(queue: Queue) {
  const [waiting, active, completed, failed, delayed] = await Promise.all([
    queue.getWaitingCount(),
    queue.getActiveCount(),
    queue.getCompletedCount(),
    queue.getFailedCount(),
    queue.getDelayedCount(),
  ]);

  return { waiting, active, completed, failed, delayed };
}

/**
 * Gracefully close all queues and connections
 * Call this during application shutdown
 */
export async function closeQueues() {
  await emailQueue.close();
  await notificationQueue.close();
  await connection.quit();
}
`],
  ["job-queue/bullmq/server/base/src/lib/workers.ts.hbs", `import { Worker, type Job } from "bullmq";
import { connection, type EmailJobData, type NotificationJobData } from "./queue";

/**
 * Email worker - processes email sending jobs
 * @see https://docs.bullmq.io/guide/workers
 */
export const emailWorker = new Worker<EmailJobData>(
  "email",
  async (job: Job<EmailJobData>) => {
    const { to, subject, body, templateId } = job.data;

    console.log(\`Processing email job \${job.id}: sending to \${to}\`);

    // TODO: Implement your email sending logic here
    // Example with a hypothetical email service:
    // await emailService.send({ to, subject, body, templateId });

    // Simulate email sending
    await new Promise((resolve) => setTimeout(resolve, 1000));

    console.log(\`Email job \${job.id} completed: sent to \${to}\`);

    return { sent: true, to, timestamp: new Date().toISOString() };
  },
  {
    connection,
    concurrency: 5, // Process up to 5 jobs in parallel
    limiter: {
      max: 100, // Max 100 jobs
      duration: 60000, // Per minute (rate limiting)
    },
  },
);

/**
 * Notification worker - processes notification jobs
 */
export const notificationWorker = new Worker<NotificationJobData>(
  "notification",
  async (job: Job<NotificationJobData>) => {
    const { userId, type, title, message, data } = job.data;

    console.log(\`Processing notification job \${job.id}: \${type} to user \${userId}\`);

    // TODO: Implement your notification logic here
    // Example:
    // switch (type) {
    //   case "push":
    //     await pushService.send(userId, { title, message, data });
    //     break;
    //   case "in-app":
    //     await inAppNotificationService.create(userId, { title, message, data });
    //     break;
    //   case "sms":
    //     await smsService.send(userId, message);
    //     break;
    // }

    // Simulate notification processing
    await new Promise((resolve) => setTimeout(resolve, 500));

    console.log(\`Notification job \${job.id} completed\`);

    return { sent: true, type, userId, timestamp: new Date().toISOString() };
  },
  {
    connection,
    concurrency: 10,
  },
);

// Event handlers for monitoring
emailWorker.on("completed", (job) => {
  console.log(\`Email job \${job.id} has completed\`);
});

emailWorker.on("failed", (job, err) => {
  console.error(\`Email job \${job?.id} has failed with error: \${err.message}\`);
});

notificationWorker.on("completed", (job) => {
  console.log(\`Notification job \${job.id} has completed\`);
});

notificationWorker.on("failed", (job, err) => {
  console.error(\`Notification job \${job?.id} has failed with error: \${err.message}\`);
});

/**
 * Gracefully close all workers
 * Call this during application shutdown
 */
export async function closeWorkers() {
  await emailWorker.close();
  await notificationWorker.close();
}

/**
 * Start all workers
 * Workers start automatically when created, but this function can be used
 * to ensure they're running or to restart after being paused
 */
export function startWorkers() {
  // Workers are already running by default
  // This function is here for explicit control if needed
  console.log("BullMQ workers started");
  console.log("- Email worker: processing 'email' queue");
  console.log("- Notification worker: processing 'notification' queue");
}
`],
  ["frontend/angular/src/app/pages/home/home.component.ts.hbs", `import { Component } from '@angular/core';

@Component({
  selector: 'app-home',
  standalone: true,
  template: \`
    {{#if (eq cssFramework "tailwind")}}
    <div class="container mx-auto max-w-3xl px-4 py-2">
      <pre class="overflow-x-auto font-mono text-sm whitespace-pre">{{ titleText }}</pre>
      <div class="grid gap-6 mt-6">
        <section class="rounded-lg border border-gray-200 dark:border-gray-800 p-4">
          <h2 class="mb-2 font-medium">Welcome to Angular</h2>
          <p class="text-sm text-gray-600 dark:text-gray-400">
            Angular is a platform and framework for building single-page client applications
            using HTML and TypeScript. It implements core and optional functionality as a
            set of TypeScript libraries that you import into your applications.
          </p>
        </section>
        <section class="rounded-lg border border-gray-200 dark:border-gray-800 p-4">
          <h2 class="mb-2 font-medium">Key Features</h2>
          <ul class="list-disc list-inside text-sm text-gray-600 dark:text-gray-400 space-y-1">
            <li>Standalone components - No NgModule required</li>
            <li>Signals - Fine-grained reactivity</li>
            <li>Built-in routing and forms</li>
            <li>Dependency injection</li>
          </ul>
        </section>
      </div>
    </div>
    {{else}}
    <div [style.maxWidth]="'48rem'" [style.margin]="'0 auto'" [style.padding]="'0.5rem 1rem'">
      <pre [style.overflow]="'auto'" [style.fontFamily]="'monospace'" [style.fontSize]="'0.875rem'" [style.whiteSpace]="'pre'">{{ titleText }}</pre>
      <div [style.display]="'grid'" [style.gap]="'1.5rem'" [style.marginTop]="'1.5rem'">
        <section [style.borderRadius]="'0.5rem'" [style.border]="'1px solid var(--border-color)'" [style.padding]="'1rem'">
          <h2 [style.marginBottom]="'0.5rem'" [style.fontWeight]="500">Welcome to Angular</h2>
          <p [style.fontSize]="'0.875rem'" [style.color]="'var(--muted-color)'">
            Angular is a platform and framework for building single-page client applications
            using HTML and TypeScript. It implements core and optional functionality as a
            set of TypeScript libraries that you import into your applications.
          </p>
        </section>
        <section [style.borderRadius]="'0.5rem'" [style.border]="'1px solid var(--border-color)'" [style.padding]="'1rem'">
          <h2 [style.marginBottom]="'0.5rem'" [style.fontWeight]="500">Key Features</h2>
          <ul [style.fontSize]="'0.875rem'" [style.color]="'var(--muted-color)'" [style.listStyleType]="'disc'" [style.paddingLeft]="'1.5rem'">
            <li>Standalone components - No NgModule required</li>
            <li>Signals - Fine-grained reactivity</li>
            <li>Built-in routing and forms</li>
            <li>Dependency injection</li>
          </ul>
        </section>
      </div>
    </div>
    {{/if}}
  \`,
})
export class HomeComponent {
  titleText = \`
 \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2557 \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2557\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2557\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2557\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2557\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2557
 \\u2588\\u2588\\u2554\\u2550\\u2550\\u2588\\u2588\\u2557\\u2588\\u2588\\u2554\\u2550\\u2550\\u2550\\u2550\\u255D\\u255A\\u2550\\u2550\\u2588\\u2588\\u2554\\u2550\\u2550\\u255D\\u255A\\u2550\\u2550\\u2588\\u2588\\u2554\\u2550\\u2550\\u255D\\u2588\\u2588\\u2554\\u2550\\u2550\\u2550\\u2550\\u255D\\u2588\\u2588\\u2554\\u2550\\u2550\\u2588\\u2588\\u2557
 \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2554\\u255D\\u2588\\u2588\\u2588\\u2588\\u2588\\u2557     \\u2588\\u2588\\u2551      \\u2588\\u2588\\u2551   \\u2588\\u2588\\u2588\\u2588\\u2588\\u2557  \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2554\\u255D
 \\u2588\\u2588\\u2554\\u2550\\u2550\\u2588\\u2588\\u2557\\u2588\\u2588\\u2554\\u2550\\u2550\\u255D     \\u2588\\u2588\\u2551      \\u2588\\u2588\\u2551   \\u2588\\u2588\\u2554\\u2550\\u2550\\u255D  \\u2588\\u2588\\u2554\\u2550\\u2550\\u2588\\u2588\\u2557
 \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2554\\u255D\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2557   \\u2588\\u2588\\u2551      \\u2588\\u2588\\u2551   \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2557\\u2588\\u2588\\u2551  \\u2588\\u2588\\u2557
 \\u255A\\u2550\\u2550\\u2550\\u2550\\u2550\\u255D \\u255A\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u255D   \\u255A\\u2550\\u255D      \\u255A\\u2550\\u255D   \\u255A\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u255D\\u255A\\u2550\\u255D  \\u255A\\u2550\\u255D

 \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2557    \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2557\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2557 \\u2588\\u2588\\u2588\\u2588\\u2588\\u2557  \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2557\\u2588\\u2588\\u2557  \\u2588\\u2588\\u2557
 \\u255A\\u2550\\u2550\\u2588\\u2588\\u2554\\u2550\\u2550\\u255D    \\u2588\\u2588\\u2554\\u2550\\u2550\\u2550\\u2550\\u255D\\u255A\\u2550\\u2550\\u2588\\u2588\\u2554\\u2550\\u2550\\u255D\\u2588\\u2588\\u2554\\u2550\\u2550\\u2588\\u2588\\u2557\\u2588\\u2588\\u2554\\u2550\\u2550\\u2550\\u2550\\u255D\\u2588\\u2588\\u2551 \\u2588\\u2588\\u2554\\u255D
    \\u2588\\u2588\\u2551       \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2557   \\u2588\\u2588\\u2551   \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2551\\u2588\\u2588\\u2551     \\u2588\\u2588\\u2588\\u2588\\u2588\\u2554\\u255D
    \\u2588\\u2588\\u2551       \\u255A\\u2550\\u2550\\u2550\\u2550\\u2588\\u2588\\u2551   \\u2588\\u2588\\u2551   \\u2588\\u2588\\u2554\\u2550\\u2550\\u2588\\u2588\\u2551\\u2588\\u2588\\u2551     \\u2588\\u2588\\u2554\\u2550\\u2588\\u2588\\u2557
    \\u2588\\u2588\\u2551       \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2551   \\u2588\\u2588\\u2551   \\u2588\\u2588\\u2551  \\u2588\\u2588\\u2551\\u255A\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2557\\u2588\\u2588\\u2551  \\u2588\\u2588\\u2557
    \\u255A\\u2550\\u255D       \\u255A\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u255D   \\u255A\\u2550\\u255D   \\u255A\\u2550\\u255D  \\u255A\\u2550\\u255D \\u255A\\u2550\\u2550\\u2550\\u2550\\u2550\\u255D\\u255A\\u2550\\u255D  \\u255A\\u2550\\u255D
\`;
}
`],
  ["frontend/native/unistyles/app/(drawer)/(tabs)/_layout.tsx.hbs", `import { Tabs } from "expo-router";
import { useUnistyles } from "react-native-unistyles";

import { TabBarIcon } from "@/components/tabbar-icon";

export default function TabLayout() {
  const { theme } = useUnistyles();

  return (
    <Tabs
      screenOptions=\\{{
        headerShown: false,
        tabBarActiveTintColor: theme.colors.primary,
        tabBarInactiveTintColor: theme.colors.mutedForeground,
        tabBarStyle: {
          backgroundColor: theme.colors.background,
          borderTopColor: theme.colors.border,
        },
      }}
    >
      <Tabs.Screen
        name="index"
        options=\\{{
          title: "Home",
          tabBarIcon: ({ color }) => <TabBarIcon name="home" color={color} />,
        }}
      />
      <Tabs.Screen
        name="two"
        options=\\{{
          title: "Explore",
          tabBarIcon: ({ color }) => (
            <TabBarIcon name="compass" color={color} />
          ),
        }}
      />
    </Tabs>
  );
}
`],
  ["frontend/native/unistyles/app/(drawer)/(tabs)/two.tsx.hbs", `import { Container } from "@/components/container";
import { ScrollView, Text, View } from "react-native";
import { StyleSheet } from "react-native-unistyles";

export default function TabTwo() {
  return (
    <Container>
      <ScrollView contentContainerStyle={styles.container}>
        <View style={styles.headerSection}>
          <Text style={styles.title}>Tab Two</Text>
          <Text style={styles.subtitle}>
            Discover more features and content
          </Text>
        </View>
      </ScrollView>
    </Container>
  );
}

const styles = StyleSheet.create((theme) => ({
  container: {
    padding: theme.spacing.lg,
  },
  headerSection: {
    paddingVertical: theme.spacing.xl,
  },
  title: {
    fontSize: theme.fontSize["3xl"],
    fontWeight: "bold",
    color: theme.colors.foreground,
    marginBottom: theme.spacing.sm,
  },
  subtitle: {
    fontSize: theme.fontSize.lg,
    color: theme.colors.mutedForeground,
  },
}));
`],
  ["frontend/native/unistyles/app/(drawer)/(tabs)/index.tsx.hbs", `import { Container } from "@/components/container";
import { ScrollView, Text, View } from "react-native";
import { StyleSheet } from "react-native-unistyles";

export default function Home() {
  return (
    <Container>
      <ScrollView contentContainerStyle={styles.container}>
        <View style={styles.headerSection}>
          <Text style={styles.title}>Tab One</Text>
          <Text style={styles.subtitle}>
            Explore the first section of your app
          </Text>
        </View>
      </ScrollView>
    </Container>
  );
}

const styles = StyleSheet.create((theme) => ({
  container: {
    padding: theme.spacing.lg,
  },
  headerSection: {
    paddingVertical: theme.spacing.xl,
  },
  title: {
    fontSize: theme.fontSize["3xl"],
    fontWeight: "bold",
    color: theme.colors.foreground,
    marginBottom: theme.spacing.sm,
  },
  subtitle: {
    fontSize: theme.fontSize.lg,
    color: theme.colors.mutedForeground,
  },
}));
`],
  ["frontend/native/bare/app/(drawer)/(tabs)/_layout.tsx.hbs", `import { TabBarIcon } from "@/components/tabbar-icon";
import { useColorScheme } from "@/lib/use-color-scheme";
import { Tabs } from "expo-router";
import { NAV_THEME } from "@/lib/constants";

export default function TabLayout() {
  const { isDarkColorScheme } = useColorScheme();
  const theme = isDarkColorScheme ? NAV_THEME.dark : NAV_THEME.light;

  return (
    <Tabs
      screenOptions=\\{{
        headerShown: false,
        tabBarActiveTintColor: theme.primary,
        tabBarInactiveTintColor: theme.text,
        tabBarStyle: {
          backgroundColor: theme.background,
          borderTopColor: theme.border,
        },
      }}
    >
      <Tabs.Screen
        name="index"
        options=\\{{
          title: "Home",
          tabBarIcon: ({ color }) => <TabBarIcon name="home" color={color} />,
        }}
      />
      <Tabs.Screen
        name="two"
        options=\\{{
          title: "Explore",
          tabBarIcon: ({ color }) => (
            <TabBarIcon name="compass" color={color} />
          ),
        }}
      />
    </Tabs>
  );
}

`],
  ["frontend/native/bare/app/(drawer)/(tabs)/two.tsx.hbs", `import { Container } from "@/components/container";
import { ScrollView, Text, View, StyleSheet } from "react-native";
import { useColorScheme } from "@/lib/use-color-scheme";
import { NAV_THEME } from "@/lib/constants";

export default function TabTwo() {
  const { colorScheme } = useColorScheme();
  const theme = colorScheme === "dark" ? NAV_THEME.dark : NAV_THEME.light;

  return (
    <Container>
      <ScrollView style={styles.scrollView}>
        <View style={styles.content}>
          <Text style={[styles.title, { color: theme.text }]}>
            Tab Two
          </Text>
          <Text style={[styles.subtitle, { color: theme.text, opacity: 0.7 }]}>
            Discover more features and content
          </Text>
        </View>
      </ScrollView>
    </Container>
  );
}

const styles = StyleSheet.create({
  scrollView: {
    flex: 1,
    padding: 16,
  },
  content: {
    paddingVertical: 16,
  },
  title: {
    fontSize: 24,
    fontWeight: "bold",
    marginBottom: 8,
  },
  subtitle: {
    fontSize: 16,
  },
});

`],
  ["frontend/native/bare/app/(drawer)/(tabs)/index.tsx.hbs", `import { Container } from "@/components/container";
import { ScrollView, Text, View, StyleSheet } from "react-native";
import { useColorScheme } from "@/lib/use-color-scheme";
import { NAV_THEME } from "@/lib/constants";

export default function TabOne() {
  const { colorScheme } = useColorScheme();
  const theme = colorScheme === "dark" ? NAV_THEME.dark : NAV_THEME.light;

  return (
    <Container>
      <ScrollView style={styles.scrollView}>
        <View style={styles.content}>
          <Text style={[styles.title, { color: theme.text }]}>
            Tab One
          </Text>
          <Text style={[styles.subtitle, { color: theme.text, opacity: 0.7 }]}>
            Explore the first section of your app
          </Text>
        </View>
      </ScrollView>
    </Container>
  );
}

const styles = StyleSheet.create({
  scrollView: {
    flex: 1,
    padding: 16,
  },
  content: {
    paddingVertical: 16,
  },
  title: {
    fontSize: 24,
    fontWeight: "bold",
    marginBottom: 8,
  },
  subtitle: {
    fontSize: 16,
  },
});

`],
  ["frontend/native/uniwind/app/(drawer)/(tabs)/_layout.tsx.hbs", `import { Tabs } from "expo-router";
import { Ionicons } from "@expo/vector-icons";
import { useThemeColor } from "heroui-native";

export default function TabLayout() {
	const themeColorForeground = useThemeColor("foreground");
	const themeColorBackground = useThemeColor("background");

	return (
		<Tabs
			screenOptions=\\{{
				headerShown: false,
				headerStyle: {
					backgroundColor: themeColorBackground,
				},
				headerTintColor: themeColorForeground,
				headerTitleStyle: {
					color: themeColorForeground,
					fontWeight: "600",
				},
				tabBarStyle: {
					backgroundColor: themeColorBackground,
				},
			}}
		>
			<Tabs.Screen
				name="index"
				options=\\{{
					title: "Home",
					tabBarIcon: ({ color, size }: { color: string; size: number }) => (
						<Ionicons name="home" size={size} color={color} />
					),
				}}
			/>
			<Tabs.Screen
				name="two"
				options=\\{{
					title: "Explore",
					tabBarIcon: ({ color, size }: { color: string; size: number }) => (
						<Ionicons name="compass" size={size} color={color} />
					),
				}}
			/>
		</Tabs>
	);
}
`],
  ["frontend/native/uniwind/app/(drawer)/(tabs)/two.tsx.hbs", `import { Container } from "@/components/container";
import { Text, View } from "react-native";
import { Card } from "heroui-native";

export default function TabTwo() {
	return (
		<Container className="p-6">
			<View className="flex-1 justify-center items-center">
				<Card variant="secondary" className="p-8 items-center">
					<Card.Title className="text-3xl mb-2">TabTwo</Card.Title>
				</Card>
			</View>
		</Container>
	);
}
`],
  ["frontend/native/uniwind/app/(drawer)/(tabs)/index.tsx.hbs", `import { Container } from "@/components/container";
import { Text, View } from "react-native";
import { Card } from "heroui-native";

export default function Home() {
	return (
		<Container className="p-6">
			<View className="flex-1 justify-center items-center">
				<Card variant="secondary" className="p-8 items-center">
					<Card.Title className="text-3xl mb-2">Tab One</Card.Title>
				</Card>
			</View>
		</Container>
	);
}
`],
  ["frontend/astro/integrations/svelte/src/components/Counter.svelte.hbs", `<script lang="ts">
	let count = $state(0);
</script>

<div class="flex items-center gap-4">
	<button
		onclick={() => count--}
		class="rounded-md bg-secondary px-4 py-2 text-secondary-foreground transition-colors hover:bg-secondary/80"
	>
		-
	</button>
	<span class="min-w-[3rem] text-center text-2xl font-bold">{count}</span>
	<button
		onclick={() => count++}
		class="rounded-md bg-primary px-4 py-2 text-primary-foreground transition-colors hover:bg-primary/80"
	>
		+
	</button>
</div>
`],
  ["frontend/astro/integrations/react/src/components/ModeToggle.tsx.hbs", `import { useEffect, useState } from 'react';

export default function ModeToggle() {
	const [isDark, setIsDark] = useState(true);

	useEffect(() => {
		setIsDark(document.documentElement.classList.contains('dark'));
	}, []);

	const toggleTheme = () => {
		document.documentElement.classList.toggle('dark');
		setIsDark(!isDark);
	};

	return (
		<button
			onClick={toggleTheme}
			className="rounded-md p-2 hover:bg-accent"
			aria-label="Toggle theme"
		>
			{isDark ? (
				<svg className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
					<path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />
				</svg>
			) : (
				<svg className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
					<path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" />
				</svg>
			)}
		</button>
	);
}
`],
  ["frontend/astro/integrations/react/src/components/Counter.tsx.hbs", `import { useState } from 'react';

export default function Counter() {
	const [count, setCount] = useState(0);

	return (
		<div className="flex items-center gap-4">
			<button
				onClick={() => setCount(count - 1)}
				className="rounded-md bg-secondary px-4 py-2 text-secondary-foreground transition-colors hover:bg-secondary/80"
			>
				-
			</button>
			<span className="min-w-[3rem] text-center text-2xl font-bold">{count}</span>
			<button
				onClick={() => setCount(count + 1)}
				className="rounded-md bg-primary px-4 py-2 text-primary-foreground transition-colors hover:bg-primary/80"
			>
				+
			</button>
		</div>
	);
}
`],
  ["frontend/astro/integrations/solid/src/components/Counter.tsx.hbs", `import { createSignal } from 'solid-js';

export default function Counter() {
	const [count, setCount] = createSignal(0);

	return (
		<div class="flex items-center gap-4">
			<button
				onClick={() => setCount(count() - 1)}
				class="rounded-md bg-secondary px-4 py-2 text-secondary-foreground transition-colors hover:bg-secondary/80"
			>
				-
			</button>
			<span class="min-w-[3rem] text-center text-2xl font-bold">{count()}</span>
			<button
				onClick={() => setCount(count() + 1)}
				class="rounded-md bg-primary px-4 py-2 text-primary-foreground transition-colors hover:bg-primary/80"
			>
				+
			</button>
		</div>
	);
}
`],
  ["frontend/astro/integrations/vue/src/components/Counter.vue.hbs", `<script setup lang="ts">
import { ref } from 'vue';

const count = ref(0);
</script>

<template>
	<div class="flex items-center gap-4">
		<button
			@click="count--"
			class="rounded-md bg-secondary px-4 py-2 text-secondary-foreground transition-colors hover:bg-secondary/80"
		>
			-
		</button>
		<span class="min-w-[3rem] text-center text-2xl font-bold">{{ count }}</span>
		<button
			@click="count++"
			class="rounded-md bg-primary px-4 py-2 text-primary-foreground transition-colors hover:bg-primary/80"
		>
			+
		</button>
	</div>
</template>
`],
  ["frontend/astro/integrations/react/src/lib/utils.ts.hbs", `{{#if (eq uiLibrary "shadcn-ui")}}
import { clsx, type ClassValue } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}
{{/if}}
`],
  ["api/garph/web/astro/src/utils/garph.ts.hbs", `import { createClient, type InferClient } from "@garph/gqty";
import {
  createGeneratedSchema,
  createScalarsEnumsHash,
} from "@garph/gqty/dist/utils";
import {
  g,
  queryType,
  mutationType,
{{#if (includes examples "todo")}}
  todoType,
{{/if}}
} from "@{{projectName}}/api/index";
import { env } from "@{{projectName}}/env/web";

// Generate schema and scalars for GQty client
const generatedSchema = createGeneratedSchema(g);
const scalarsEnumsHash = createScalarsEnumsHash(g);

// Create type-safe GraphQL client
export const client = createClient<{
  query: InferClient<typeof queryType>;
  mutation: InferClient<typeof mutationType>;
}>({
  generatedSchema,
  scalarsEnumsHash,
  url: \`\${env.VITE_SERVER_URL}/graphql\`,
{{#if (eq auth "better-auth")}}
  credentials: "include",
{{/if}}
});

// Export typed query and mutation functions
export const { query, mutation, resolved } = client;

// Helper for fetching data
export async function graphqlFetcher<T>(
  fn: () => T | Promise<T>
): Promise<T> {
  return resolved(fn);
}
`],
  ["api/ts-rest/fullstack/next/src/utils/ts-rest.ts.hbs", `import { QueryClient } from "@tanstack/react-query";
import { initClient, tsRestFetchApi } from "@ts-rest/core";
import { initTsrReactQuery } from "@ts-rest/react-query";
import { contract } from "@{{projectName}}/api/index";

export const queryClient = new QueryClient({
	defaultOptions: {
		queries: {
			retry: 2,
			staleTime: 1000 * 60,
		},
	},
});

const client = initClient(contract, {
	baseUrl: "/api/rest",
	baseHeaders: {},
{{#if (eq auth "better-auth")}}
	credentials: "include",
{{/if}}
	api: tsRestFetchApi,
});

export const tsr = initTsrReactQuery(contract, client);
`],
  ["api/garph/fullstack/next/src/utils/garph.ts.hbs", `import { QueryClient } from "@tanstack/react-query";
import { createClient, type InferClient } from "@garph/gqty";
import {
  createGeneratedSchema,
  createScalarsEnumsHash,
} from "@garph/gqty/dist/utils";
import {
  g,
  queryType,
  mutationType,
{{#if (includes examples "todo")}}
  todoType,
{{/if}}
} from "@{{projectName}}/api/index";

// Create QueryClient for React Query integration
export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      retry: 2,
      staleTime: 1000 * 60,
    },
  },
});

// Generate schema and scalars for GQty client
const generatedSchema = createGeneratedSchema(g);
const scalarsEnumsHash = createScalarsEnumsHash(g);

// Create type-safe GraphQL client
export const client = createClient<{
  query: InferClient<typeof queryType>;
  mutation: InferClient<typeof mutationType>;
}>({
  generatedSchema,
  scalarsEnumsHash,
  url: "/api/graphql",
{{#if (eq auth "better-auth")}}
  credentials: "include",
{{/if}}
});

// Export typed query and mutation functions
export const { query, mutation, resolved } = client;

// Helper for React Query integration
export async function graphqlFetcher<T>(
  fn: () => T | Promise<T>
): Promise<T> {
  return resolved(fn);
}
`],
  ["api/ts-rest/fullstack/astro/src/utils/ts-rest.ts.hbs", `import { QueryClient } from "@tanstack/react-query";
import { initClient, tsRestFetchApi } from "@ts-rest/core";
import { initTsrReactQuery } from "@ts-rest/react-query";
import { contract } from "@{{projectName}}/api/index";

export const queryClient = new QueryClient({
	defaultOptions: {
		queries: {
			retry: 2,
			staleTime: 1000 * 60,
		},
	},
});

const client = initClient(contract, {
	baseUrl: "/api/rest",
	baseHeaders: {},
{{#if (eq auth "better-auth")}}
	credentials: "include",
{{/if}}
	api: tsRestFetchApi,
});

export const tsr = initTsrReactQuery(contract, client);
`],
  ["api/ts-rest/fullstack/tanstack-start/src/utils/ts-rest.ts.hbs", `import { QueryClient } from "@tanstack/react-query";
import { initClient, tsRestFetchApi } from "@ts-rest/core";
import { initTsrReactQuery } from "@ts-rest/react-query";
import { contract } from "@{{projectName}}/api/index";

export const queryClient = new QueryClient({
	defaultOptions: {
		queries: {
			retry: 2,
			staleTime: 1000 * 60,
		},
	},
});

const client = initClient(contract, {
	baseUrl: "/api/rest",
	baseHeaders: {},
{{#if (eq auth "better-auth")}}
	credentials: "include",
{{/if}}
	api: tsRestFetchApi,
});

export const tsr = initTsrReactQuery(contract, client);
`],
  ["api/garph/fullstack/astro/src/utils/garph.ts.hbs", `import { QueryClient } from "@tanstack/react-query";
import { createClient, type InferClient } from "@garph/gqty";
import {
  createGeneratedSchema,
  createScalarsEnumsHash,
} from "@garph/gqty/dist/utils";
import {
  g,
  queryType,
  mutationType,
{{#if (includes examples "todo")}}
  todoType,
{{/if}}
} from "@{{projectName}}/api/index";

// Create QueryClient for React Query integration
export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      retry: 2,
      staleTime: 1000 * 60,
    },
  },
});

// Generate schema and scalars for GQty client
const generatedSchema = createGeneratedSchema(g);
const scalarsEnumsHash = createScalarsEnumsHash(g);

// Create type-safe GraphQL client
export const client = createClient<{
  query: InferClient<typeof queryType>;
  mutation: InferClient<typeof mutationType>;
}>({
  generatedSchema,
  scalarsEnumsHash,
  url: "/api/graphql",
{{#if (eq auth "better-auth")}}
  credentials: "include",
{{/if}}
});

// Export typed query and mutation functions
export const { query, mutation, resolved } = client;

// Helper for React Query integration
export async function graphqlFetcher<T>(
  fn: () => T | Promise<T>
): Promise<T> {
  return resolved(fn);
}
`],
  ["api/garph/fullstack/tanstack-start/src/utils/garph.ts.hbs", `import { QueryClient } from "@tanstack/react-query";
import { createClient, type InferClient } from "@garph/gqty";
import {
  createGeneratedSchema,
  createScalarsEnumsHash,
} from "@garph/gqty/dist/utils";
import {
  g,
  queryType,
  mutationType,
{{#if (includes examples "todo")}}
  todoType,
{{/if}}
} from "@{{projectName}}/api/index";

// Create QueryClient for React Query integration
export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      retry: 2,
      staleTime: 1000 * 60,
    },
  },
});

// Generate schema and scalars for GQty client
const generatedSchema = createGeneratedSchema(g);
const scalarsEnumsHash = createScalarsEnumsHash(g);

// Create type-safe GraphQL client
export const client = createClient<{
  query: InferClient<typeof queryType>;
  mutation: InferClient<typeof mutationType>;
}>({
  generatedSchema,
  scalarsEnumsHash,
  url: "/api/graphql",
{{#if (eq auth "better-auth")}}
  credentials: "include",
{{/if}}
});

// Export typed query and mutation functions
export const { query, mutation, resolved } = client;

// Helper for React Query integration
export async function graphqlFetcher<T>(
  fn: () => T | Promise<T>
): Promise<T> {
  return resolved(fn);
}
`],
  ["frontend/react/web-base/src/components/ui/skeleton.tsx.hbs", `import { cn } from "@/lib/utils";

function Skeleton({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      data-slot="skeleton"
      className={cn("bg-muted rounded-none animate-pulse", className)}
      {...props}
    />
  );
}

export { Skeleton };
`],
  ["frontend/react/web-base/src/components/ui/dropdown-menu.tsx.hbs", `import * as React from 'react'
import { Menu as MenuPrimitive } from '@base-ui/react/menu'

import { CheckIcon, ChevronRightIcon } from 'lucide-react'
import { cn } from '@/lib/utils'

function DropdownMenu({ ...props }: MenuPrimitive.Root.Props) {
  return <MenuPrimitive.Root data-slot="dropdown-menu" {...props} />
}

function DropdownMenuPortal({ ...props }: MenuPrimitive.Portal.Props) {
  return <MenuPrimitive.Portal data-slot="dropdown-menu-portal" {...props} />
}

function DropdownMenuTrigger({ ...props }: MenuPrimitive.Trigger.Props) {
  return <MenuPrimitive.Trigger data-slot="dropdown-menu-trigger" {...props} />
}

function DropdownMenuContent({
  align = 'start',
  alignOffset = 0,
  side = 'bottom',
  sideOffset = 4,
  className,
  ...props
}: MenuPrimitive.Popup.Props &
  Pick<
    MenuPrimitive.Positioner.Props,
    'align' | 'alignOffset' | 'side' | 'sideOffset'
  >) {
  return (
    <MenuPrimitive.Portal>
      <MenuPrimitive.Positioner
        className="isolate z-50 outline-none"
        align={align}
        alignOffset={alignOffset}
        side={side}
        sideOffset={sideOffset}
      >
        <MenuPrimitive.Popup
          data-slot="dropdown-menu-content"
          className={cn(
            'data-open:animate-in data-closed:animate-out data-closed:fade-out-0 data-open:fade-in-0 data-closed:zoom-out-95 data-open:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 ring-foreground/10 bg-popover text-popover-foreground min-w-32 rounded-none shadow-md ring-1 duration-100 z-50 max-h-(--available-height) w-(--anchor-width) origin-(--transform-origin) overflow-x-hidden overflow-y-auto outline-none data-closed:overflow-hidden',
            className,
          )}
          {...props}
        />
      </MenuPrimitive.Positioner>
    </MenuPrimitive.Portal>
  )
}

function DropdownMenuGroup({ ...props }: MenuPrimitive.Group.Props) {
  return <MenuPrimitive.Group data-slot="dropdown-menu-group" {...props} />
}

function DropdownMenuLabel({
  className,
  inset,
  ...props
}: MenuPrimitive.GroupLabel.Props & {
  inset?: boolean
}) {
  return (
    <MenuPrimitive.GroupLabel
      data-slot="dropdown-menu-label"
      data-inset={inset}
      className={cn(
        'text-muted-foreground px-2 py-2 text-xs data-[inset]:pl-8',
        className,
      )}
      {...props}
    />
  )
}

function DropdownMenuItem({
  className,
  inset,
  variant = 'default',
  ...props
}: MenuPrimitive.Item.Props & {
  inset?: boolean
  variant?: 'default' | 'destructive'
}) {
  return (
    <MenuPrimitive.Item
      data-slot="dropdown-menu-item"
      data-inset={inset}
      data-variant={variant}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:text-destructive not-data-[variant=destructive]:focus:**:text-accent-foreground gap-2 rounded-none px-2 py-2 text-xs [&_svg:not([class*='size-'])]:size-4 group/dropdown-menu-item relative flex cursor-default items-center outline-hidden select-none data-disabled:pointer-events-none data-disabled:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0",
        className,
      )}
      {...props}
    />
  )
}

function DropdownMenuSub({ ...props }: MenuPrimitive.SubmenuRoot.Props) {
  return <MenuPrimitive.SubmenuRoot data-slot="dropdown-menu-sub" {...props} />
}

function DropdownMenuSubTrigger({
  className,
  inset,
  children,
  ...props
}: MenuPrimitive.SubmenuTrigger.Props & {
  inset?: boolean
}) {
  return (
    <MenuPrimitive.SubmenuTrigger
      data-slot="dropdown-menu-sub-trigger"
      data-inset={inset}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-open:bg-accent data-open:text-accent-foreground not-data-[variant=destructive]:focus:**:text-accent-foreground gap-2 rounded-none px-2 py-2 text-xs [&_svg:not([class*='size-'])]:size-4 flex cursor-default items-center outline-hidden select-none data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0",
        className,
      )}
      {...props}
    >
      {children}
      <ChevronRightIcon className="ml-auto" />
    </MenuPrimitive.SubmenuTrigger>
  )
}

function DropdownMenuSubContent({
  align = 'start',
  alignOffset = -3,
  side = 'right',
  sideOffset = 0,
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuContent>) {
  return (
    <DropdownMenuContent
      data-slot="dropdown-menu-sub-content"
      className={cn(
        'data-open:animate-in data-closed:animate-out data-closed:fade-out-0 data-open:fade-in-0 data-closed:zoom-out-95 data-open:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 ring-foreground/10 bg-popover text-popover-foreground min-w-[96px] rounded-none shadow-lg ring-1 duration-100 w-auto',
        className,
      )}
      align={align}
      alignOffset={alignOffset}
      side={side}
      sideOffset={sideOffset}
      {...props}
    />
  )
}

function DropdownMenuCheckboxItem({
  className,
  children,
  checked,
  ...props
}: MenuPrimitive.CheckboxItem.Props) {
  return (
    <MenuPrimitive.CheckboxItem
      data-slot="dropdown-menu-checkbox-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground focus:**:text-accent-foreground gap-2 rounded-none py-2 pr-8 pl-2 text-xs [&_svg:not([class*='size-'])]:size-4 relative flex cursor-default items-center outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0",
        className,
      )}
      checked={checked}
      {...props}
    >
      <span
        className="pointer-events-none absolute right-2 flex items-center justify-center pointer-events-none"
        data-slot="dropdown-menu-checkbox-item-indicator"
      >
        <MenuPrimitive.CheckboxItemIndicator>
          <CheckIcon />
        </MenuPrimitive.CheckboxItemIndicator>
      </span>
      {children}
    </MenuPrimitive.CheckboxItem>
  )
}

function DropdownMenuRadioGroup({ ...props }: MenuPrimitive.RadioGroup.Props) {
  return (
    <MenuPrimitive.RadioGroup
      data-slot="dropdown-menu-radio-group"
      {...props}
    />
  )
}

function DropdownMenuRadioItem({
  className,
  children,
  ...props
}: MenuPrimitive.RadioItem.Props) {
  return (
    <MenuPrimitive.RadioItem
      data-slot="dropdown-menu-radio-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground focus:**:text-accent-foreground gap-2 rounded-none py-2 pr-8 pl-2 text-xs [&_svg:not([class*='size-'])]:size-4 relative flex cursor-default items-center outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0",
        className,
      )}
      {...props}
    >
      <span
        className="pointer-events-none absolute right-2 flex items-center justify-center pointer-events-none"
        data-slot="dropdown-menu-radio-item-indicator"
      >
        <MenuPrimitive.RadioItemIndicator>
          <CheckIcon />
        </MenuPrimitive.RadioItemIndicator>
      </span>
      {children}
    </MenuPrimitive.RadioItem>
  )
}

function DropdownMenuSeparator({
  className,
  ...props
}: MenuPrimitive.Separator.Props) {
  return (
    <MenuPrimitive.Separator
      data-slot="dropdown-menu-separator"
      className={cn('bg-border -mx-1 h-px', className)}
      {...props}
    />
  )
}

function DropdownMenuShortcut({
  className,
  ...props
}: React.ComponentProps<'span'>) {
  return (
    <span
      data-slot="dropdown-menu-shortcut"
      className={cn(
        'text-muted-foreground group-focus/dropdown-menu-item:text-accent-foreground ml-auto text-xs tracking-widest',
        className,
      )}
      {...props}
    />
  )
}

export {
  DropdownMenu,
  DropdownMenuPortal,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuLabel,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuSub,
  DropdownMenuSubTrigger,
  DropdownMenuSubContent,
}
`],
  ["frontend/react/web-base/src/components/ui/label.tsx.hbs", `'use client'

import * as React from 'react'

import { cn } from '@/lib/utils'

function Label({ className, ...props }: React.ComponentProps<'label'>) {
  return (
    <label
      data-slot="label"
      className={cn(
        'gap-2 text-xs leading-none group-data-[disabled=true]:opacity-50 peer-disabled:opacity-50 flex items-center select-none group-data-[disabled=true]:pointer-events-none peer-disabled:cursor-not-allowed',
        className,
      )}
      {...props}
    />
  )
}

export { Label }
`],
  ["frontend/react/web-base/src/components/ui/button.tsx.hbs", `import { Button as ButtonPrimitive } from '@base-ui/react/button'
import {  cva } from 'class-variance-authority'
import type {VariantProps} from 'class-variance-authority';

import { cn } from '@/lib/utils'

const buttonVariants = cva(
  "focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:aria-invalid:border-destructive/50 rounded-none border border-transparent bg-clip-padding text-xs font-medium focus-visible:ring-1 aria-invalid:ring-1 [&_svg:not([class*='size-'])]:size-4 inline-flex items-center justify-center whitespace-nowrap transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none shrink-0 [&_svg]:shrink-0 outline-none group/button select-none",
  {
    variants: {
      variant: {
        default: 'bg-primary text-primary-foreground [a]:hover:bg-primary/80',
        outline:
          'border-border bg-background hover:bg-muted hover:text-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50 aria-expanded:bg-muted aria-expanded:text-foreground',
        secondary:
          'bg-secondary text-secondary-foreground hover:bg-secondary/80 aria-expanded:bg-secondary aria-expanded:text-secondary-foreground',
        ghost:
          'hover:bg-muted hover:text-foreground dark:hover:bg-muted/50 aria-expanded:bg-muted aria-expanded:text-foreground',
        destructive:
          'bg-destructive/10 hover:bg-destructive/20 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/20 text-destructive focus-visible:border-destructive/40 dark:hover:bg-destructive/30',
        link: 'text-primary underline-offset-4 hover:underline',
      },
      size: {
        default:
          'h-8 gap-1.5 px-2.5 has-data-[icon=inline-end]:pr-2 has-data-[icon=inline-start]:pl-2',
        xs: "h-6 gap-1 rounded-none px-2 text-xs has-data-[icon=inline-end]:pr-1.5 has-data-[icon=inline-start]:pl-1.5 [&_svg:not([class*='size-'])]:size-3",
        sm: "h-7 gap-1 rounded-none px-2.5 has-data-[icon=inline-end]:pr-1.5 has-data-[icon=inline-start]:pl-1.5 [&_svg:not([class*='size-'])]:size-3.5",
        lg: 'h-9 gap-1.5 px-2.5 has-data-[icon=inline-end]:pr-3 has-data-[icon=inline-start]:pl-3',
        icon: 'size-8',
        'icon-xs': "size-6 rounded-none [&_svg:not([class*='size-'])]:size-3",
        'icon-sm': 'size-7 rounded-none',
        'icon-lg': 'size-9',
      },
    },
    defaultVariants: {
      variant: 'default',
      size: 'default',
    },
  },
)

function Button({
  className,
  variant = 'default',
  size = 'default',
  ...props
}: ButtonPrimitive.Props & VariantProps<typeof buttonVariants>) {
  return (
    <ButtonPrimitive
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Button, buttonVariants }
`],
  ["frontend/react/web-base/src/components/ui/checkbox.tsx.hbs", `import { Checkbox as CheckboxPrimitive } from '@base-ui/react/checkbox'

import { CheckIcon } from 'lucide-react'
import { cn } from '@/lib/utils'

function Checkbox({ className, ...props }: CheckboxPrimitive.Root.Props) {
  return (
    <CheckboxPrimitive.Root
      data-slot="checkbox"
      className={cn(
        'border-input dark:bg-input/30 data-checked:bg-primary data-checked:text-primary-foreground dark:data-checked:bg-primary data-checked:border-primary aria-invalid:aria-checked:border-primary aria-invalid:border-destructive dark:aria-invalid:border-destructive/50 focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 flex size-4 items-center justify-center rounded-none border transition-colors group-has-disabled/field:opacity-50 focus-visible:ring-1 aria-invalid:ring-1 peer relative shrink-0 outline-none after:absolute after:-inset-x-3 after:-inset-y-2 disabled:cursor-not-allowed disabled:opacity-50',
        className,
      )}
      {...props}
    >
      <CheckboxPrimitive.Indicator
        data-slot="checkbox-indicator"
        className="[&>svg]:size-3.5 grid place-content-center text-current transition-none"
      >
        <CheckIcon />
      </CheckboxPrimitive.Indicator>
    </CheckboxPrimitive.Root>
  )
}

export { Checkbox }
`],
  ["frontend/react/web-base/src/components/ui/input.tsx.hbs", `import * as React from 'react'
import { Input as InputPrimitive } from '@base-ui/react/input'

import { cn } from '@/lib/utils'

function Input({ className, type, ...props }: React.ComponentProps<'input'>) {
  return (
    <InputPrimitive
      type={type}
      data-slot="input"
      className={cn(
        'dark:bg-input/30 border-input focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:aria-invalid:border-destructive/50 disabled:bg-input/50 dark:disabled:bg-input/80 h-8 rounded-none border bg-transparent px-2.5 py-1 text-xs transition-colors file:h-6 file:text-xs file:font-medium focus-visible:ring-1 aria-invalid:ring-1 md:text-xs file:text-foreground placeholder:text-muted-foreground w-full min-w-0 outline-none file:inline-flex file:border-0 file:bg-transparent disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50',
        className,
      )}
      {...props}
    />
  )
}

export { Input }
`],
  ["frontend/react/web-base/src/components/ui/sonner.tsx.hbs", `import { useTheme } from 'next-themes'
import { Toaster as Sonner  } from 'sonner'
import {
  CircleCheckIcon,
  InfoIcon,
  Loader2Icon,
  OctagonXIcon,
  TriangleAlertIcon,
} from 'lucide-react'
import type {ToasterProps} from 'sonner';

const Toaster = ({ ...props }: ToasterProps) => {
  const { theme = 'system' } = useTheme()

  return (
    <Sonner
      theme={theme as ToasterProps['theme']}
      className="toaster group"
      icons=\\{{
        success: <CircleCheckIcon className="size-4" />,
        info: <InfoIcon className="size-4" />,
        warning: <TriangleAlertIcon className="size-4" />,
        error: <OctagonXIcon className="size-4" />,
        loading: <Loader2Icon className="size-4 animate-spin" />,
      }}
      style={
        {
          '--normal-bg': 'var(--popover)',
          '--normal-text': 'var(--popover-foreground)',
          '--normal-border': 'var(--border)',
          '--border-radius': 'var(--radius)',
        } as React.CSSProperties
      }
      toastOptions=\\{{
        classNames: {
          toast: 'cn-toast',
        },
      }}
      {...props}
    />
  )
}

export { Toaster }
`],
  ["frontend/react/web-base/src/components/ui/card.tsx.hbs", `import * as React from 'react'

import { cn } from '@/lib/utils'

function Card({
  className,
  size = 'default',
  ...props
}: React.ComponentProps<'div'> & { size?: 'default' | 'sm' }) {
  return (
    <div
      data-slot="card"
      data-size={size}
      className={cn(
        'ring-foreground/10 bg-card text-card-foreground gap-4 overflow-hidden rounded-none py-4 text-xs/relaxed ring-1 has-data-[slot=card-footer]:pb-0 has-[>img:first-child]:pt-0 data-[size=sm]:gap-2 data-[size=sm]:py-3 data-[size=sm]:has-data-[slot=card-footer]:pb-0 *:[img:first-child]:rounded-none *:[img:last-child]:rounded-none group/card flex flex-col',
        className,
      )}
      {...props}
    />
  )
}

function CardHeader({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="card-header"
      className={cn(
        'gap-1 rounded-none px-4 group-data-[size=sm]/card:px-3 [.border-b]:pb-4 group-data-[size=sm]/card:[.border-b]:pb-3 group/card-header @container/card-header grid auto-rows-min items-start has-data-[slot=card-action]:grid-cols-[1fr_auto] has-data-[slot=card-description]:grid-rows-[auto_auto]',
        className,
      )}
      {...props}
    />
  )
}

function CardTitle({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="card-title"
      className={cn(
        'text-sm font-medium group-data-[size=sm]/card:text-sm',
        className,
      )}
      {...props}
    />
  )
}

function CardDescription({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="card-description"
      className={cn('text-muted-foreground text-xs/relaxed', className)}
      {...props}
    />
  )
}

function CardAction({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="card-action"
      className={cn(
        'col-start-2 row-span-2 row-start-1 self-start justify-self-end',
        className,
      )}
      {...props}
    />
  )
}

function CardContent({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="card-content"
      className={cn('px-4 group-data-[size=sm]/card:px-3', className)}
      {...props}
    />
  )
}

function CardFooter({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="card-footer"
      className={cn(
        'rounded-none border-t p-4 group-data-[size=sm]/card:p-3 flex items-center',
        className,
      )}
      {...props}
    />
  )
}

export {
  Card,
  CardHeader,
  CardFooter,
  CardTitle,
  CardAction,
  CardDescription,
  CardContent,
}
`],
  ["cms/sanity/web/next/src/sanity/env.ts.hbs", `export const projectId = process.env.NEXT_PUBLIC_SANITY_PROJECT_ID!;
export const dataset = process.env.NEXT_PUBLIC_SANITY_DATASET!;
export const apiVersion =
  process.env.NEXT_PUBLIC_SANITY_API_VERSION || "2024-07-11";

// Used for server-side fetching
export const token = process.env.SANITY_API_READ_TOKEN;
`],
  ["logging/winston/server/base/src/lib/logger.ts.hbs", `import winston from "winston";

// Log levels: error, warn, info, http, verbose, debug, silly
const logLevel = process.env.LOG_LEVEL || "info";
const isDevelopment = process.env.NODE_ENV !== "production";

// Custom format for development with colors
const devFormat = winston.format.combine(
  winston.format.colorize(),
  winston.format.timestamp({ format: "YYYY-MM-DD HH:mm:ss" }),
  winston.format.printf(({ timestamp, level, message, ...meta }) => {
    const metaStr = Object.keys(meta).length ? \` \${JSON.stringify(meta)}\` : "";
    return \`\${timestamp} [\${level}]: \${message}\${metaStr}\`;
  }),
);

// JSON format for production
const prodFormat = winston.format.combine(
  winston.format.timestamp(),
  winston.format.errors({ stack: true }),
  winston.format.json(),
);

// Create logger instance
const logger = winston.createLogger({
  level: logLevel,
  format: isDevelopment ? devFormat : prodFormat,
  defaultMeta: { env: process.env.NODE_ENV || "development" },
  transports: [
    new winston.transports.Console({
      stderrLevels: ["error"],
    }),
  ],
});

/**
 * Create a child logger with additional context
 * Useful for adding request IDs, user IDs, or other contextual information
 *
 * @example
 * const requestLogger = createChildLogger({ requestId: 'abc123', userId: 'user456' });
 * requestLogger.info('Processing request');
 */
export function createChildLogger(bindings: Record<string, unknown>): winston.Logger {
  return logger.child(bindings);
}

/**
 * Log levels explained (npm log levels):
 * - error (0): Error messages for failures that don't stop the application
 * - warn (1): Warning messages for potentially problematic situations
 * - info (2): General information about application flow
 * - http (3): HTTP request logging
 * - verbose (4): More detailed than info
 * - debug (5): Detailed information useful during development
 * - silly (6): Most detailed logging
 *
 * @example
 * logger.info('Server started');
 * logger.info('Server started on port', { port: 3000 });
 * logger.error('Failed to process request', { err: error });
 * logger.debug('User action logged', { userId, action });
 */
export { logger };

export default logger;
`],
  ["api/orpc/web/astro/src/utils/orpc.ts.hbs", `import { createORPCClient } from '@orpc/client';
import { RPCLink } from '@orpc/client/fetch';
import type { appRouter } from '@{{projectName}}/api/routers/index';

const link = new RPCLink({
{{#if (eq backend "self")}}
	url: '/api/rpc',
{{else}}
	url: import.meta.env.PUBLIC_SERVER_URL
		? \`\${import.meta.env.PUBLIC_SERVER_URL}/rpc\`
		: 'http://localhost:3001/rpc',
{{/if}}
	headers: () => ({}),
});

export const client = createORPCClient<typeof appRouter>(link);
`],
  ["api/orpc/web/svelte/src/lib/orpc.ts.hbs", `import { PUBLIC_SERVER_URL } from "$env/static/public";
import { createORPCClient } from "@orpc/client";
import { RPCLink } from "@orpc/client/fetch";
import { createTanstackQueryUtils } from "@orpc/tanstack-query";
import { QueryCache, QueryClient } from "@tanstack/svelte-query";
import type { AppRouterClient } from "@{{projectName}}/api/routers/index";

export const queryClient = new QueryClient({
	queryCache: new QueryCache({
		onError: (error) => {
			console.error(\`Error: \${error.message}\`);
		},
	}),
});

export const link = new RPCLink({
	url: \`\${PUBLIC_SERVER_URL}/rpc\`,
	{{#if (eq auth "better-auth")}}
	fetch(url, options) {
		return fetch(url, {
			...options,
			credentials: "include",
		});
	},
	{{/if}}
});

export const client: AppRouterClient = createORPCClient(link);

export const orpc = createTanstackQueryUtils(client);
`],
  ["cms/strapi/web/next/src/strapi/env.ts.hbs", `// Strapi environment configuration
export const strapiUrl = process.env.NEXT_PUBLIC_STRAPI_URL || "http://localhost:1337";
export const strapiApiUrl = \`\${strapiUrl}/api\`;

// API token for server-side authenticated requests
export const strapiApiToken = process.env.STRAPI_API_TOKEN;
`],
  ["cms/strapi/web/next/src/strapi/index.ts.hbs", `// Strapi client and utilities
export { strapiClient, strapiServerClient, strapiFetch, strapiFetchSingle } from "./lib/client";
export { buildCollectionQuery, stringifyQuery, populateConfigs, filterBuilders } from "./lib/queries";
export { getStrapiMediaUrl, getStrapiMediaFormat, getStrapiMediaDimensions, getStrapiSrcSet } from "./lib/media";
export { strapiUrl, strapiApiUrl, strapiApiToken } from "./env";

// Types
export type {
  StrapiPagination,
  StrapiCollectionResponse,
  StrapiSingleResponse,
  StrapiBaseDocument,
  StrapiMedia,
  StrapiMediaFormat,
  StrapiSEO,
  Article,
  Author,
  Category,
  Page,
  Homepage,
} from "./lib/types";
`],
  ["logging/pino/server/base/src/lib/logger.ts.hbs", `import pino from "pino";
import type { Logger, LoggerOptions } from "pino";

// Log levels: trace, debug, info, warn, error, fatal
const logLevel = (process.env.LOG_LEVEL || "info") as pino.LevelWithSilent;
const isDevelopment = process.env.NODE_ENV !== "production";

// Create logger options
const loggerOptions: LoggerOptions = {
  level: logLevel,
  // Add timestamp formatting
  timestamp: pino.stdTimeFunctions.isoTime,
  // Base context for all logs
  base: {
    env: process.env.NODE_ENV || "development",
  },
};

// Use pino-pretty in development for readable logs
// In production, use raw JSON for better performance and log aggregation
let logger: Logger;

if (isDevelopment && process.env.PINO_PRETTY !== "false") {
  logger = pino({
    ...loggerOptions,
    transport: {
      target: "pino-pretty",
      options: {
        colorize: true,
        translateTime: "SYS:standard",
        ignore: "pid,hostname",
        singleLine: false,
      },
    },
  });
} else {
  logger = pino(loggerOptions);
}

/**
 * Create a child logger with additional context
 * Useful for adding request IDs, user IDs, or other contextual information
 *
 * @example
 * const requestLogger = createChildLogger({ requestId: 'abc123', userId: 'user456' });
 * requestLogger.info('Processing request');
 */
export function createChildLogger(bindings: Record<string, unknown>): Logger {
  return logger.child(bindings);
}

/**
 * Log levels explained:
 * - trace: Most detailed logging, typically disabled in production
 * - debug: Detailed information useful during development
 * - info: General information about application flow
 * - warn: Warning messages for potentially problematic situations
 * - error: Error messages for failures that don't stop the application
 * - fatal: Critical errors that may cause the application to terminate
 *
 * @example
 * logger.info('Server started');
 * logger.info({ port: 3000 }, 'Server started on port');
 * logger.error({ err: error }, 'Failed to process request');
 * logger.debug({ userId, action }, 'User action logged');
 */
export { logger };

export default logger;
`],
  ["api/orpc/web/solid/src/utils/orpc.ts.hbs", `import { createORPCClient } from "@orpc/client";
import { RPCLink } from "@orpc/client/fetch";
import { createTanstackQueryUtils } from "@orpc/tanstack-query";
import { QueryCache, QueryClient } from "@tanstack/solid-query";
import type { AppRouterClient } from "@{{projectName}}/api/routers/index";
import { env } from "@{{projectName}}/env/web";

export const queryClient = new QueryClient({
	queryCache: new QueryCache({
		onError: (error) => {
			console.error(\`Error: \${error.message}\`);
		},
	}),
});

export const link = new RPCLink({
	url: \`\${env.VITE_SERVER_URL}/rpc\`,
{{#if (eq auth "better-auth")}}
	fetch(url, options) {
		return fetch(url, {
			...options,
			credentials: "include",
		});
	},
{{/if}}
});

export const client: AppRouterClient = createORPCClient(link);

export const orpc = createTanstackQueryUtils(client);
`],
  ["api/orpc/web/nuxt/app/plugins/orpc.ts.hbs", `import { defineNuxtPlugin } from '#app'
import type { AppRouterClient } from "@{{projectName}}/api/routers/index";
import { createORPCClient } from '@orpc/client'
import { RPCLink } from '@orpc/client/fetch'
import { createTanstackQueryUtils } from "@orpc/tanstack-query";

export default defineNuxtPlugin(() => {
  const config = useRuntimeConfig();
  const rpcUrl = \`\${config.public.serverUrl}/rpc\`;

  const rpcLink = new RPCLink({
    url: rpcUrl,
    {{#if (eq auth "better-auth")}}
    fetch(url, options) {
        return fetch(url, {
        ...options,
        credentials: "include",
        });
    },
    {{/if}}
  })


  const client: AppRouterClient = createORPCClient(rpcLink)
  const orpcUtils = createTanstackQueryUtils(client)

  return {
    provide: {
      orpc: orpcUtils
    }
  }
})
`],
  ["api/orpc/web/nuxt/app/plugins/vue-query.ts.hbs", `import type {
  DehydratedState,
  VueQueryPluginOptions,
} from '@tanstack/vue-query'
import {
  dehydrate,
  hydrate,
  QueryCache,
  QueryClient,
  VueQueryPlugin,
} from '@tanstack/vue-query'

export default defineNuxtPlugin((nuxt) => {
  const vueQueryState = useState<DehydratedState | null>('vue-query')

  const toast = useToast()

  const queryClient = new QueryClient({
    queryCache: new QueryCache({
      onError: (error) => {
        console.log(error)
        toast.add({
          title: 'Error',
          description: error?.message || 'An unexpected error occurred.',
        })
      },
    }),
  })
  const options: VueQueryPluginOptions = { queryClient }

  nuxt.vueApp.use(VueQueryPlugin, options)

  if (import.meta.server) {
    nuxt.hooks.hook('app:rendered', () => {
      vueQueryState.value = dehydrate(queryClient)
    })
  }

  if (import.meta.client) {
    nuxt.hooks.hook('app:created', () => {
      hydrate(queryClient, vueQueryState.value)
    })
  }
})
`],
  ["backend/server/nitro/routes/api/auth/[...path].ts.hbs", `{{#if (eq auth "better-auth")}}
import { auth } from "@{{projectName}}/auth";
import { toNodeHandler } from "better-auth/node";

const authHandler = toNodeHandler(auth);

export default defineEventHandler(async (event) => {
	const { req, res } = event.node;
	await authHandler(req, res);
});
{{else}}
// Auth placeholder - Better Auth not configured
export default defineEventHandler(() => {
	return { error: "Auth not configured" };
});
{{/if}}
`],
  ["search/typesense/server/base/src/lib/search.ts.hbs", `import Typesense from "typesense";
import type { SearchParams, SearchResponse, CollectionCreateSchema } from "typesense/lib/Typesense/Documents";
import type { CollectionSchema } from "typesense/lib/Typesense/Collection";

/**
 * Typesense client for fast, typo-tolerant search
 * @see https://typesense.org/docs/
 */
export const searchClient = new Typesense.Client({
  nodes: [
    {
      host: process.env.TYPESENSE_HOST!,
      port: Number(process.env.TYPESENSE_PORT || 8108),
      protocol: process.env.TYPESENSE_PROTOCOL || "http",
    },
  ],
  apiKey: process.env.TYPESENSE_API_KEY!,
  connectionTimeoutSeconds: 5,
  numRetries: 3,
  retryIntervalSeconds: 0.1,
});

/**
 * Search utilities for common search patterns
 */

/**
 * Search documents in a collection
 */
export async function search<T extends Record<string, unknown>>(
  collectionName: string,
  query: string,
  queryBy: string,
  options?: Omit<SearchParams, "q" | "query_by">
): Promise<SearchResponse<T>> {
  return searchClient.collections<T>(collectionName).documents().search({
    q: query,
    query_by: queryBy,
    ...options,
  });
}

/**
 * Add or update documents in a collection (upsert)
 */
export async function addDocuments<T extends Record<string, unknown>>(
  collectionName: string,
  documents: T[],
  options?: { action?: "create" | "update" | "upsert" | "emplace" }
): Promise<{ success: number; failed: number }> {
  const results = await searchClient
    .collections<T>(collectionName)
    .documents()
    .import(documents, { action: options?.action || "upsert" });

  let success = 0;
  let failed = 0;

  for (const result of results) {
    if (result.success) {
      success++;
    } else {
      failed++;
    }
  }

  return { success, failed };
}

/**
 * Update a single document by ID
 */
export async function updateDocument<T extends Record<string, unknown>>(
  collectionName: string,
  documentId: string,
  document: Partial<T>
): Promise<T> {
  return searchClient
    .collections<T>(collectionName)
    .documents(documentId)
    .update(document) as Promise<T>;
}

/**
 * Delete a document by ID
 */
export async function deleteDocument(
  collectionName: string,
  documentId: string
): Promise<{ id: string }> {
  const result = await searchClient
    .collections(collectionName)
    .documents(documentId)
    .delete();
  return { id: result.id };
}

/**
 * Delete multiple documents by filter
 */
export async function deleteDocuments(
  collectionName: string,
  filterBy: string
): Promise<{ numDeleted: number }> {
  const result = await searchClient
    .collections(collectionName)
    .documents()
    .delete({ filter_by: filterBy });
  return { numDeleted: result.num_deleted };
}

/**
 * Delete all documents in a collection
 */
export async function deleteAllDocuments(collectionName: string): Promise<{ numDeleted: number }> {
  const result = await searchClient
    .collections(collectionName)
    .documents()
    .delete({ truncate: true });
  return { numDeleted: result.num_deleted };
}

/**
 * Get a single document by ID
 */
export async function getDocument<T extends Record<string, unknown>>(
  collectionName: string,
  documentId: string
): Promise<T | null> {
  try {
    return await searchClient
      .collections<T>(collectionName)
      .documents(documentId)
      .retrieve();
  } catch {
    return null;
  }
}

/**
 * Export all documents from a collection
 */
export async function exportDocuments<T extends Record<string, unknown>>(
  collectionName: string
): Promise<T[]> {
  const exported = await searchClient
    .collections<T>(collectionName)
    .documents()
    .export();

  return exported
    .split("\\n")
    .filter(Boolean)
    .map((line) => JSON.parse(line) as T);
}

/**
 * Create a collection if it doesn't exist
 */
export async function createCollection(
  schema: CollectionCreateSchema
): Promise<CollectionSchema> {
  return searchClient.collections().create(schema);
}

/**
 * Delete a collection
 */
export async function deleteCollection(collectionName: string): Promise<CollectionSchema> {
  return searchClient.collections(collectionName).delete();
}

/**
 * Get all collections
 */
export async function getCollections(): Promise<{ name: string; numDocuments: number }[]> {
  const collections = await searchClient.collections().retrieve();
  return collections.map((collection) => ({
    name: collection.name,
    numDocuments: collection.num_documents,
  }));
}

/**
 * Get collection info
 */
export async function getCollection(collectionName: string): Promise<CollectionSchema | null> {
  try {
    return await searchClient.collections(collectionName).retrieve();
  } catch {
    return null;
  }
}

/**
 * Update collection schema (add/drop fields)
 */
export async function updateCollectionSchema(
  collectionName: string,
  updates: { fields: Array<{ name: string; drop?: boolean; type?: string; facet?: boolean; optional?: boolean }> }
): Promise<CollectionSchema> {
  return searchClient.collections(collectionName).update(updates);
}

/**
 * Create or update a collection alias
 */
export async function upsertAlias(
  aliasName: string,
  collectionName: string
): Promise<{ name: string; collection_name: string }> {
  return searchClient.aliases().upsert(aliasName, { collection_name: collectionName });
}

/**
 * Delete a collection alias
 */
export async function deleteAlias(aliasName: string): Promise<{ name: string }> {
  return searchClient.aliases(aliasName).delete();
}

/**
 * Get all aliases
 */
export async function getAliases(): Promise<{ name: string; collectionName: string }[]> {
  const { aliases } = await searchClient.aliases().retrieve();
  return aliases.map((alias) => ({
    name: alias.name,
    collectionName: alias.collection_name,
  }));
}

/**
 * Multi-search across multiple collections
 */
export async function multiSearch<T extends Record<string, unknown>>(
  searches: Array<{
    collection: string;
    q: string;
    query_by: string;
    filter_by?: string;
    sort_by?: string;
    per_page?: number;
  }>
): Promise<{ results: SearchResponse<T>[] }> {
  return searchClient.multiSearch.perform({ searches });
}

/**
 * Health check for Typesense
 */
export async function healthCheck(): Promise<{ status: "available" | "unavailable" }> {
  try {
    await searchClient.health.retrieve();
    return { status: "available" };
  } catch {
    return { status: "unavailable" };
  }
}
`],
  ["search/meilisearch/server/base/src/lib/search.ts.hbs", `import { MeiliSearch, type SearchParams, type SearchResponse, type Index } from "meilisearch";

/**
 * Meilisearch client for lightning-fast search
 * @see https://www.meilisearch.com/docs
 */
export const searchClient = new MeiliSearch({
  host: process.env.MEILISEARCH_HOST!,
  apiKey: process.env.MEILISEARCH_API_KEY,
});

/**
 * Search utilities for common search patterns
 */

/**
 * Get or create an index
 */
export async function getIndex<T extends Record<string, unknown>>(indexName: string): Promise<Index<T>> {
  return searchClient.index<T>(indexName);
}

/**
 * Search documents in an index
 */
export async function search<T extends Record<string, unknown>>(
  indexName: string,
  query: string,
  options?: SearchParams
): Promise<SearchResponse<T>> {
  const index = searchClient.index<T>(indexName);
  return index.search(query, options);
}

/**
 * Add or update documents in an index
 */
export async function addDocuments<T extends Record<string, unknown>>(
  indexName: string,
  documents: T[],
  options?: { primaryKey?: string }
): Promise<{ taskUid: number }> {
  const index = searchClient.index<T>(indexName);
  const task = await index.addDocuments(documents, options);
  return { taskUid: task.taskUid };
}

/**
 * Update documents in an index (partial update)
 */
export async function updateDocuments<T extends Record<string, unknown>>(
  indexName: string,
  documents: Partial<T>[],
  options?: { primaryKey?: string }
): Promise<{ taskUid: number }> {
  const index = searchClient.index<T>(indexName);
  const task = await index.updateDocuments(documents, options);
  return { taskUid: task.taskUid };
}

/**
 * Delete a document by ID
 */
export async function deleteDocument(
  indexName: string,
  documentId: string | number
): Promise<{ taskUid: number }> {
  const index = searchClient.index(indexName);
  const task = await index.deleteDocument(documentId);
  return { taskUid: task.taskUid };
}

/**
 * Delete multiple documents by IDs
 */
export async function deleteDocuments(
  indexName: string,
  documentIds: (string | number)[]
): Promise<{ taskUid: number }> {
  const index = searchClient.index(indexName);
  const task = await index.deleteDocuments(documentIds);
  return { taskUid: task.taskUid };
}

/**
 * Delete all documents in an index
 */
export async function deleteAllDocuments(indexName: string): Promise<{ taskUid: number }> {
  const index = searchClient.index(indexName);
  const task = await index.deleteAllDocuments();
  return { taskUid: task.taskUid };
}

/**
 * Get a single document by ID
 */
export async function getDocument<T extends Record<string, unknown>>(
  indexName: string,
  documentId: string | number
): Promise<T | null> {
  try {
    const index = searchClient.index<T>(indexName);
    return await index.getDocument(documentId);
  } catch {
    return null;
  }
}

/**
 * Get all documents from an index with pagination
 */
export async function getDocuments<T extends Record<string, unknown>>(
  indexName: string,
  options?: { offset?: number; limit?: number; fields?: string[] }
): Promise<{ results: T[]; offset: number; limit: number; total: number }> {
  const index = searchClient.index<T>(indexName);
  return index.getDocuments(options);
}

/**
 * Create an index if it doesn't exist
 */
export async function createIndex(
  indexName: string,
  options?: { primaryKey?: string }
): Promise<{ taskUid: number }> {
  const task = await searchClient.createIndex(indexName, options);
  return { taskUid: task.taskUid };
}

/**
 * Delete an index
 */
export async function deleteIndex(indexName: string): Promise<{ taskUid: number }> {
  const task = await searchClient.deleteIndex(indexName);
  return { taskUid: task.taskUid };
}

/**
 * Get all indexes
 */
export async function getIndexes(): Promise<{ uid: string; primaryKey: string | null }[]> {
  const { results } = await searchClient.getIndexes();
  return results.map((index) => ({
    uid: index.uid,
    primaryKey: index.primaryKey,
  }));
}

/**
 * Configure searchable attributes for an index
 */
export async function updateSearchableAttributes(
  indexName: string,
  attributes: string[]
): Promise<{ taskUid: number }> {
  const index = searchClient.index(indexName);
  const task = await index.updateSearchableAttributes(attributes);
  return { taskUid: task.taskUid };
}

/**
 * Configure filterable attributes for an index
 */
export async function updateFilterableAttributes(
  indexName: string,
  attributes: string[]
): Promise<{ taskUid: number }> {
  const index = searchClient.index(indexName);
  const task = await index.updateFilterableAttributes(attributes);
  return { taskUid: task.taskUid };
}

/**
 * Configure sortable attributes for an index
 */
export async function updateSortableAttributes(
  indexName: string,
  attributes: string[]
): Promise<{ taskUid: number }> {
  const index = searchClient.index(indexName);
  const task = await index.updateSortableAttributes(attributes);
  return { taskUid: task.taskUid };
}

/**
 * Wait for a task to complete
 */
export async function waitForTask(taskUid: number): Promise<void> {
  await searchClient.waitForTask(taskUid);
}

/**
 * Get the status of a task
 */
export async function getTaskStatus(taskUid: number): Promise<{
  status: "enqueued" | "processing" | "succeeded" | "failed" | "canceled";
  error?: { message: string; code: string };
}> {
  const task = await searchClient.getTask(taskUid);
  return {
    status: task.status,
    error: task.error ? { message: task.error.message, code: task.error.code } : undefined,
  };
}

/**
 * Health check for Meilisearch
 */
export async function healthCheck(): Promise<{ status: "available" | "unavailable" }> {
  try {
    await searchClient.health();
    return { status: "available" };
  } catch {
    return { status: "unavailable" };
  }
}
`],
  ["payments/polar/web/react/tanstack-start/src/routes/success.tsx.hbs", `import { createFileRoute, useSearch } from "@tanstack/react-router";

export const Route = createFileRoute("/success")({
	component: SuccessPage,
	validateSearch: (search) => ({
		checkout_id: search.checkout_id as string,
	}),
});

function SuccessPage() {
	const { checkout_id } = useSearch({ from: "/success" });

	return (
		<div className="container mx-auto px-4 py-8">
			<h1>Payment Successful!</h1>
			{checkout_id && <p>Checkout ID: {checkout_id}</p>}
		</div>
	);
}
`],
  ["payments/polar/web/react/tanstack-start/src/functions/get-payment.ts.hbs", `import { authClient } from "@/lib/auth-client";
import { authMiddleware } from "@/middleware/auth";
import { createServerFn } from "@tanstack/react-start";
import { getRequestHeaders } from "@tanstack/react-start/server";

export const getPayment = createServerFn({ method: "GET" })
    .middleware([authMiddleware])
    .handler(async () => {
        const { data: customerState } = await authClient.customer.state({
            fetchOptions: {
                headers: getRequestHeaders()
            }
        });
        return customerState;
    });
`],
  ["payments/lemon-squeezy/web/svelte/src/routes/success/+page.svelte.hbs", `<script lang="ts">
	import { page } from "$app/stores";

	$: checkoutId = $page.url.searchParams.get("checkout_id");
</script>

<div class="container mx-auto px-4 py-8">
	<h1 class="text-2xl font-bold mb-4">Payment Successful!</h1>
	<p class="text-gray-600 mb-4">
		Thank you for your purchase. Your payment has been processed successfully.
	</p>
	{#if checkoutId}
		<p class="text-sm text-gray-500">Checkout ID: {checkoutId}</p>
	{/if}
</div>
`],
  ["addons/pwa/apps/web/next/src/app/manifest.ts.hbs", `import type { MetadataRoute } from "next";

export default function manifest(): MetadataRoute.Manifest {
	return {
		name: "{{projectName}}",
		short_name: "{{projectName}}",
		description:
			"my pwa app",
		start_url: "/new",
		display: "standalone",
		background_color: "#ffffff",
		theme_color: "#000000",
		icons: [
			{
				src: "/favicon/web-app-manifest-192x192.png",
				sizes: "192x192",
				type: "image/png",
			},
			{
				src: "/favicon/web-app-manifest-512x512.png",
				sizes: "512x512",
				type: "image/png",
			},
		],
	};
}
`],
  ["addons/pwa/apps/web/next/public/favicon/apple-touch-icon.png", `[Binary file]`],
  ["addons/pwa/apps/web/next/public/favicon/web-app-manifest-192x192.png", `[Binary file]`],
  ["addons/pwa/apps/web/next/public/favicon/favicon-96x96.png", `[Binary file]`],
  ["addons/pwa/apps/web/next/public/favicon/web-app-manifest-512x512.png", `[Binary file]`],
  ["addons/pwa/apps/web/next/public/favicon/site.webmanifest.hbs", `{
	"name": "{{projectName}}",
	"short_name": "{{projectName}}",
	"icons": [
		{
			"src": "/web-app-manifest-192x192.png",
			"sizes": "192x192",
			"type": "image/png",
			"purpose": "maskable"
		},
		{
			"src": "/web-app-manifest-512x512.png",
			"sizes": "512x512",
			"type": "image/png",
			"purpose": "maskable"
		}
	],
	"theme_color": "#ffffff",
	"background_color": "#ffffff",
	"display": "standalone"
}
`],
  ["addons/pwa/apps/web/next/public/favicon/favicon.svg", `<svg xmlns="http://www.w3.org/2000/svg" version="1.1" xmlns:xlink="http://www.w3.org/1999/xlink" width="92" height="92"><svg width="92" height="92" viewBox="0 0 92 92" fill="none" xmlns="http://www.w3.org/2000/svg">
  <rect x="8" y="8" width="76" height="76" rx="12" fill="#F5EEFF" stroke="#B79AFF" stroke-width="3"></rect>
  <text x="46" y="56" text-anchor="middle" font-family="monospace" font-size="40" fill="#8F5BFF">$<tspan dx="0" dy="0">_</tspan></text>
</svg><style>@media (prefers-color-scheme: light) { :root { filter: none; } }
@media (prefers-color-scheme: dark) { :root { filter: none; } }
</style></svg>`],
  ["payments/lemon-squeezy/web/react/tanstack-router/src/routes/success.tsx.hbs", `import { createFileRoute } from "@tanstack/react-router";

export const Route = createFileRoute("/success")({
	component: SuccessPage,
});

function SuccessPage() {
	const { checkout_id } = Route.useSearch();

	return (
		<div className="container mx-auto px-4 py-8">
			<h1 className="text-2xl font-bold mb-4">Payment Successful!</h1>
			<p className="text-gray-600 mb-4">
				Thank you for your purchase. Your payment has been processed successfully.
			</p>
			{checkout_id && (
				<p className="text-sm text-gray-500">Checkout ID: {checkout_id}</p>
			)}
		</div>
	);
}
`],
  ["payments/lemon-squeezy/web/react/react-router/src/routes/success.tsx.hbs", `import { useSearchParams } from "react-router";

export default function SuccessPage() {
	const [searchParams] = useSearchParams();
	const checkoutId = searchParams.get("checkout_id");

	return (
		<div className="container mx-auto px-4 py-8">
			<h1 className="text-2xl font-bold mb-4">Payment Successful!</h1>
			<p className="text-gray-600 mb-4">
				Thank you for your purchase. Your payment has been processed successfully.
			</p>
			{checkoutId && (
				<p className="text-sm text-gray-500">Checkout ID: {checkoutId}</p>
			)}
		</div>
	);
}
`],
  ["payments/polar/web/react/tanstack-router/src/routes/success.tsx.hbs", `import { createFileRoute, useSearch } from "@tanstack/react-router";

export const Route = createFileRoute("/success")({
	component: SuccessPage,
	validateSearch: (search) => ({
		checkout_id: search.checkout_id as string,
	}),
});

function SuccessPage() {
	const { checkout_id } = useSearch({ from: "/success" });

	return (
		<div className="container mx-auto px-4 py-8">
			<h1>Payment Successful!</h1>
			{checkout_id && <p>Checkout ID: {checkout_id}</p>}
		</div>
	);
}
`],
  ["payments/stripe/web/svelte/src/routes/success/+page.svelte.hbs", `<script lang="ts">
	import { page } from '$app/state';

	const session_id = $derived(page.url.searchParams.get('session_id'));
</script>

<div class="container mx-auto px-4 py-8">
	<h1 class="text-2xl font-bold mb-4">Payment Successful!</h1>
	<p class="text-gray-600 mb-4">
		Thank you for your purchase. Your payment has been processed successfully.
	</p>
	{#if session_id}
		<p class="text-sm text-gray-500">Session ID: {session_id}</p>
	{/if}
</div>
`],
  ["payments/stripe/web/react/react-router/src/routes/success.tsx.hbs", `import { useSearchParams } from "react-router";

export default function SuccessPage() {
	const [searchParams] = useSearchParams();
	const session_id = searchParams.get("session_id");

	return (
		<div className="container mx-auto px-4 py-8">
			<h1 className="text-2xl font-bold mb-4">Payment Successful!</h1>
			<p className="text-gray-600 mb-4">
				Thank you for your purchase. Your payment has been processed successfully.
			</p>
			{session_id && (
				<p className="text-sm text-gray-500">Session ID: {session_id}</p>
			)}
		</div>
	);
}
`],
  ["payments/polar/web/svelte/src/routes/success/+page.svelte.hbs", `<script lang="ts">
	import { page } from '$app/state';
	
	const checkout_id = $derived(page.url.searchParams.get('checkout_id'));
</script>

<div class="container mx-auto px-4 py-8">
	<h1>Payment Successful!</h1>
	{#if checkout_id}
		<p>Checkout ID: {checkout_id}</p>
	{/if}
</div>
`],
  ["payments/stripe/web/react/tanstack-router/src/routes/success.tsx.hbs", `import { createFileRoute, useSearch } from "@tanstack/react-router";

export const Route = createFileRoute("/success")({
	component: SuccessPage,
	validateSearch: (search) => ({
		session_id: search.session_id as string,
	}),
});

function SuccessPage() {
	const { session_id } = useSearch({ from: "/success" });

	return (
		<div className="container mx-auto px-4 py-8">
			<h1 className="text-2xl font-bold mb-4">Payment Successful!</h1>
			<p className="text-gray-600 mb-4">
				Thank you for your purchase. Your payment has been processed successfully.
			</p>
			{session_id && (
				<p className="text-sm text-gray-500">Session ID: {session_id}</p>
			)}
		</div>
	);
}
`],
  ["payments/lemon-squeezy/web/react/tanstack-start/src/routes/success.tsx.hbs", `import { createFileRoute } from "@tanstack/react-router";

export const Route = createFileRoute("/success")({
	component: SuccessPage,
});

function SuccessPage() {
	const { checkout_id } = Route.useSearch();

	return (
		<div className="container mx-auto px-4 py-8">
			<h1 className="text-2xl font-bold mb-4">Payment Successful!</h1>
			<p className="text-gray-600 mb-4">
				Thank you for your purchase. Your payment has been processed successfully.
			</p>
			{checkout_id && (
				<p className="text-sm text-gray-500">Checkout ID: {checkout_id}</p>
			)}
		</div>
	);
}
`],
  ["payments/polar/web/react/react-router/src/routes/success.tsx.hbs", `import { useSearchParams } from "react-router";

export default function SuccessPage() {
    const [searchParams] = useSearchParams();
    const checkout_id = searchParams.get("checkout_id");

    return (
        <div className="container mx-auto px-4 py-8">
            <h1>Payment Successful!</h1>
            {checkout_id && <p>Checkout ID: {checkout_id}</p>}
        </div>
    );
}
`],
  ["payments/stripe/web/react/tanstack-start/src/routes/success.tsx.hbs", `import { createFileRoute, useSearch } from "@tanstack/react-router";

export const Route = createFileRoute("/success")({
	component: SuccessPage,
	validateSearch: (search) => ({
		session_id: search.session_id as string,
	}),
});

function SuccessPage() {
	const { session_id } = useSearch({ from: "/success" });

	return (
		<div className="container mx-auto px-4 py-8">
			<h1 className="text-2xl font-bold mb-4">Payment Successful!</h1>
			<p className="text-gray-600 mb-4">
				Thank you for your purchase. Your payment has been processed successfully.
			</p>
			{session_id && (
				<p className="text-sm text-gray-500">Session ID: {session_id}</p>
			)}
		</div>
	);
}
`],
  ["payments/paddle/web/react/tanstack-router/src/routes/success.tsx.hbs", `import { createFileRoute } from "@tanstack/react-router";

export const Route = createFileRoute("/success")({
	component: SuccessPage,
});

function SuccessPage() {
	const { transaction_id } = Route.useSearch<{ transaction_id?: string }>();

	return (
		<div className="container mx-auto px-4 py-8">
			<h1 className="text-2xl font-bold mb-4">Payment Successful!</h1>
			<p className="text-gray-600 mb-4">
				Thank you for your purchase. Your payment has been processed successfully.
			</p>
			{transaction_id && (
				<p className="text-sm text-gray-500">Transaction ID: {transaction_id}</p>
			)}
		</div>
	);
}
`],
  ["payments/paddle/web/react/tanstack-start/src/routes/success.tsx.hbs", `import { createFileRoute } from "@tanstack/react-router";

export const Route = createFileRoute("/success")({
	component: SuccessPage,
});

function SuccessPage() {
	const { transaction_id } = Route.useSearch<{ transaction_id?: string }>();

	return (
		<div className="container mx-auto px-4 py-8">
			<h1 className="text-2xl font-bold mb-4">Payment Successful!</h1>
			<p className="text-gray-600 mb-4">
				Thank you for your purchase. Your payment has been processed successfully.
			</p>
			{transaction_id && (
				<p className="text-sm text-gray-500">Transaction ID: {transaction_id}</p>
			)}
		</div>
	);
}
`],
  ["examples/ai/web/react/tanstack-start/src/routes/ai.tsx.hbs", `{{#if (eq backend "convex")}}
import { api } from "@{{projectName}}/backend/convex/_generated/api";
import {
  useUIMessages,
  useSmoothText,
  type UIMessage,
} from "@convex-dev/agent/react";
import { createFileRoute } from "@tanstack/react-router";
import { useMutation } from "convex/react";
import { Send, Loader2 } from "lucide-react";
import { useRef, useEffect, useState } from "react";
import { Streamdown } from "streamdown";

import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";

export const Route = createFileRoute("/ai")({
  component: RouteComponent,
});

function MessageContent({
  text,
  isStreaming,
}: {
  text: string;
  isStreaming: boolean;
}) {
  const [visibleText] = useSmoothText(text, {
    startStreaming: isStreaming,
  });
  return <Streamdown>{visibleText}</Streamdown>;
}

function RouteComponent() {
  const [input, setInput] = useState("");
  const [threadId, setThreadId] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const messagesEndRef = useRef<HTMLDivElement>(null);

  const createThread = useMutation(api.chat.createNewThread);
  const sendMessage = useMutation(api.chat.sendMessage);

  const { results: messages } = useUIMessages(
    api.chat.listMessages,
    threadId ? { threadId } : "skip",
    { initialNumItems: 50, stream: true },
  );

  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  }, [messages]);

  const hasStreamingMessage = messages?.some(
    (m: UIMessage) => m.status === "streaming",
  );

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    const text = input.trim();
    if (!text || isLoading) return;

    setIsLoading(true);
    setInput("");

    try {
      let currentThreadId = threadId;
      if (!currentThreadId) {
        currentThreadId = await createThread();
        setThreadId(currentThreadId);
      }

      await sendMessage({ threadId: currentThreadId, prompt: text });
    } catch (error) {
      console.error("Failed to send message:", error);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="grid grid-rows-[1fr_auto] overflow-hidden w-full mx-auto p-4">
      <div className="overflow-y-auto space-y-4 pb-4">
        {!messages || messages.length === 0 ? (
          <div className="text-center text-muted-foreground mt-8">
            Ask me anything to get started!
          </div>
        ) : (
          messages.map((message: UIMessage) => (
            <div
              key={message.key}
              className={\`p-3 rounded-lg \${
                message.role === "user"
                  ? "bg-primary/10 ml-8"
                  : "bg-secondary/20 mr-8"
              }\`}
            >
              <p className="text-sm font-semibold mb-1">
                {message.role === "user" ? "You" : "AI Assistant"}
              </p>
              <MessageContent
                text={message.text ?? ""}
                isStreaming={message.status === "streaming"}
              />
            </div>
          ))
        )}
        {isLoading && !hasStreamingMessage && (
          <div className="p-3 rounded-lg bg-secondary/20 mr-8">
            <p className="text-sm font-semibold mb-1">AI Assistant</p>
            <div className="flex items-center gap-2 text-muted-foreground">
              <Loader2 className="h-4 w-4 animate-spin" />
              <span>Thinking...</span>
            </div>
          </div>
        )}
        <div ref={messagesEndRef} />
      </div>

      <form
        onSubmit={handleSubmit}
        className="w-full flex items-center space-x-2 pt-2 border-t"
      >
        <Input
          name="prompt"
          value={input}
          onChange={(e) => setInput(e.target.value)}
          placeholder="Type your message..."
          className="flex-1"
          autoComplete="off"
          autoFocus
          disabled={isLoading}
        />
        <Button type="submit" size="icon" disabled={isLoading || !input.trim()}>
          {isLoading ? (
            <Loader2 className="h-4 w-4 animate-spin" />
          ) : (
            <Send size={18} />
          )}
        </Button>
      </form>
    </div>
  );
}
{{else if (eq ai "modelfusion")}}
import { createFileRoute } from "@tanstack/react-router";
import { Send, Loader2 } from "lucide-react";
import { useRef, useEffect, useState, useCallback } from "react";
import { Streamdown } from "streamdown";
{{#unless (eq backend "self")}}
import { env } from "@{{projectName}}/env/web";
{{/unless}}

import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";

type Message = {
  id: string;
  role: "user" | "assistant";
  content: string;
};

export const Route = createFileRoute("/ai")({
  component: RouteComponent,
});

function RouteComponent() {
  const [input, setInput] = useState("");
  const [messages, setMessages] = useState<Message[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [streamingContent, setStreamingContent] = useState("");
  const messagesEndRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  }, [messages, streamingContent]);

  const sendMessage = useCallback(async (text: string) => {
    const userMessage: Message = {
      id: Date.now().toString(),
      role: "user",
      content: text,
    };

    setMessages((prev) => [...prev, userMessage]);
    setIsLoading(true);
    setStreamingContent("");

    try {
      const response = await fetch({{#if (eq backend "self")}}"/api/ai"{{else}}\`\${env.VITE_SERVER_URL}/ai\`{{/if}}, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          messages: [...messages, userMessage].map((m) => ({
            role: m.role,
            content: m.content,
          })),
        }),
      });

      if (!response.ok) throw new Error("Failed to send message");

      const reader = response.body?.getReader();
      const decoder = new TextDecoder();
      let fullContent = "";

      if (reader) {
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          const chunk = decoder.decode(value, { stream: true });
          const lines = chunk.split("\\n");

          for (const line of lines) {
            if (line.startsWith("data: ")) {
              const data = line.slice(6);
              if (data === "[DONE]") continue;
              try {
                const parsed = JSON.parse(data);
                if (parsed.content) {
                  fullContent += parsed.content;
                  setStreamingContent(fullContent);
                }
              } catch {
                // Ignore parsing errors for incomplete chunks
              }
            }
          }
        }
      }

      const assistantMessage: Message = {
        id: (Date.now() + 1).toString(),
        role: "assistant",
        content: fullContent,
      };
      setMessages((prev) => [...prev, assistantMessage]);
      setStreamingContent("");
    } catch (error) {
      console.error("Failed to send message:", error);
    } finally {
      setIsLoading(false);
    }
  }, [messages]);

  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    const text = input.trim();
    if (!text || isLoading) return;
    setInput("");
    sendMessage(text);
  };

  return (
    <div className="grid grid-rows-[1fr_auto] overflow-hidden w-full mx-auto p-4">
      <div className="overflow-y-auto space-y-4 pb-4">
        {messages.length === 0 && !streamingContent ? (
          <div className="text-center text-muted-foreground mt-8">
            Ask me anything to get started!
          </div>
        ) : (
          <>
            {messages.map((message) => (
              <div
                key={message.id}
                className={\`p-3 rounded-lg \${
                  message.role === "user"
                    ? "bg-primary/10 ml-8"
                    : "bg-secondary/20 mr-8"
                }\`}
              >
                <p className="text-sm font-semibold mb-1">
                  {message.role === "user" ? "You" : "AI Assistant"}
                </p>
                <Streamdown>{message.content}</Streamdown>
              </div>
            ))}
            {streamingContent && (
              <div className="p-3 rounded-lg bg-secondary/20 mr-8">
                <p className="text-sm font-semibold mb-1">AI Assistant</p>
                <Streamdown isAnimating>{streamingContent}</Streamdown>
              </div>
            )}
          </>
        )}
        {isLoading && !streamingContent && (
          <div className="p-3 rounded-lg bg-secondary/20 mr-8">
            <p className="text-sm font-semibold mb-1">AI Assistant</p>
            <div className="flex items-center gap-2 text-muted-foreground">
              <Loader2 className="h-4 w-4 animate-spin" />
              <span>Thinking...</span>
            </div>
          </div>
        )}
        <div ref={messagesEndRef} />
      </div>

      <form
        onSubmit={handleSubmit}
        className="w-full flex items-center space-x-2 pt-2 border-t"
      >
        <Input
          name="prompt"
          value={input}
          onChange={(e) => setInput(e.target.value)}
          placeholder="Type your message..."
          className="flex-1"
          autoComplete="off"
          autoFocus
          disabled={isLoading}
        />
        <Button type="submit" size="icon" disabled={isLoading || !input.trim()}>
          {isLoading ? (
            <Loader2 className="h-4 w-4 animate-spin" />
          ) : (
            <Send size={18} />
          )}
        </Button>
      </form>
    </div>
  );
}
{{else if (eq ai "langgraph")}}
import { createFileRoute } from "@tanstack/react-router";
import { Send, Loader2 } from "lucide-react";
import { useRef, useEffect, useState, useCallback } from "react";
import { Streamdown } from "streamdown";
{{#unless (eq backend "self")}}
import { env } from "@{{projectName}}/env/web";
{{/unless}}

import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";

type Message = {
  id: string;
  role: "user" | "assistant";
  content: string;
};

export const Route = createFileRoute("/ai")({
  component: RouteComponent,
});

function RouteComponent() {
  const [input, setInput] = useState("");
  const [messages, setMessages] = useState<Message[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [streamingContent, setStreamingContent] = useState("");
  const messagesEndRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  }, [messages, streamingContent]);

  const sendMessage = useCallback(async (text: string) => {
    const userMessage: Message = {
      id: Date.now().toString(),
      role: "user",
      content: text,
    };

    setMessages((prev) => [...prev, userMessage]);
    setIsLoading(true);
    setStreamingContent("");

    try {
      const response = await fetch({{#if (eq backend "self")}}"/api/ai"{{else}}\`\${env.VITE_SERVER_URL}/ai\`{{/if}}, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          messages: [...messages, userMessage].map((m) => ({
            role: m.role,
            content: m.content,
          })),
        }),
      });

      if (!response.ok) throw new Error("Failed to send message");

      const reader = response.body?.getReader();
      const decoder = new TextDecoder();
      let fullContent = "";

      if (reader) {
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          const chunk = decoder.decode(value, { stream: true });
          const lines = chunk.split("\\n");

          for (const line of lines) {
            if (line.startsWith("data: ")) {
              const data = line.slice(6);
              if (data === "[DONE]") continue;
              try {
                const parsed = JSON.parse(data);
                if (parsed.content) {
                  fullContent += parsed.content;
                  setStreamingContent(fullContent);
                }
              } catch {
                // Ignore parsing errors for incomplete chunks
              }
            }
          }
        }
      }

      const assistantMessage: Message = {
        id: (Date.now() + 1).toString(),
        role: "assistant",
        content: fullContent,
      };
      setMessages((prev) => [...prev, assistantMessage]);
      setStreamingContent("");
    } catch (error) {
      console.error("Failed to send message:", error);
    } finally {
      setIsLoading(false);
    }
  }, [messages]);

  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    const text = input.trim();
    if (!text || isLoading) return;
    setInput("");
    sendMessage(text);
  };

  return (
    <div className="grid grid-rows-[1fr_auto] overflow-hidden w-full mx-auto p-4">
      <div className="overflow-y-auto space-y-4 pb-4">
        {messages.length === 0 && !streamingContent ? (
          <div className="text-center text-muted-foreground mt-8">
            Ask me anything to get started!
          </div>
        ) : (
          <>
            {messages.map((message) => (
              <div
                key={message.id}
                className={\`p-3 rounded-lg \${
                  message.role === "user"
                    ? "bg-primary/10 ml-8"
                    : "bg-secondary/20 mr-8"
                }\`}
              >
                <p className="text-sm font-semibold mb-1">
                  {message.role === "user" ? "You" : "AI Assistant"}
                </p>
                <Streamdown>{message.content}</Streamdown>
              </div>
            ))}
            {streamingContent && (
              <div className="p-3 rounded-lg bg-secondary/20 mr-8">
                <p className="text-sm font-semibold mb-1">AI Assistant</p>
                <Streamdown isAnimating>{streamingContent}</Streamdown>
              </div>
            )}
          </>
        )}
        {isLoading && !streamingContent && (
          <div className="p-3 rounded-lg bg-secondary/20 mr-8">
            <p className="text-sm font-semibold mb-1">AI Assistant</p>
            <div className="flex items-center gap-2 text-muted-foreground">
              <Loader2 className="h-4 w-4 animate-spin" />
              <span>Thinking...</span>
            </div>
          </div>
        )}
        <div ref={messagesEndRef} />
      </div>

      <form
        onSubmit={handleSubmit}
        className="w-full flex items-center space-x-2 pt-2 border-t"
      >
        <Input
          name="prompt"
          value={input}
          onChange={(e) => setInput(e.target.value)}
          placeholder="Type your message..."
          className="flex-1"
          autoComplete="off"
          autoFocus
          disabled={isLoading}
        />
        <Button type="submit" size="icon" disabled={isLoading || !input.trim()}>
          {isLoading ? (
            <Loader2 className="h-4 w-4 animate-spin" />
          ) : (
            <Send size={18} />
          )}
        </Button>
      </form>
    </div>
  );
}
{{else}}
import { createFileRoute } from "@tanstack/react-router";
import { useChat } from "@ai-sdk/react";
import { DefaultChatTransport } from "ai";
import { Send } from "lucide-react";
import { useRef, useEffect, useState } from "react";
import { Streamdown } from "streamdown";
{{#unless (eq backend "self")}}
import { env } from "@{{projectName}}/env/web";
{{/unless}}

import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";

export const Route = createFileRoute("/ai")({
  component: RouteComponent,
});

function RouteComponent() {
  const [input, setInput] = useState("");
  const { messages, sendMessage, status } = useChat({
    transport: new DefaultChatTransport({
      api: {{#if (eq backend "self")}}"/api/ai"{{else}}\`\${env.VITE_SERVER_URL}/ai\`{{/if}},
    }),
  });

  const messagesEndRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  }, [messages]);

  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    const text = input.trim();
    if (!text) return;
    sendMessage({ text });
    setInput("");
  };

  return (
    <div className="grid grid-rows-[1fr_auto] overflow-hidden w-full mx-auto p-4">
      <div className="overflow-y-auto space-y-4 pb-4">
        {messages.length === 0 ? (
          <div className="text-center text-muted-foreground mt-8">
            Ask me anything to get started!
          </div>
        ) : (
          messages.map((message) => (
            <div
              key={message.id}
              className={\`p-3 rounded-lg \${
                message.role === "user"
                  ? "bg-primary/10 ml-8"
                  : "bg-secondary/20 mr-8"
              }\`}
            >
              <p className="text-sm font-semibold mb-1">
                {message.role === "user" ? "You" : "AI Assistant"}
              </p>
              {message.parts?.map((part, index) => {
                if (part.type === "text") {
                  return (
                    <Streamdown
                      key={index}
                      isAnimating={status === "streaming" && message.role === "assistant"}
                    >
                      {part.text}
                    </Streamdown>
                  );
                }
                return null;
              })}
            </div>
          ))
        )}
        <div ref={messagesEndRef} />
      </div>

      <form
        onSubmit={handleSubmit}
        className="w-full flex items-center space-x-2 pt-2 border-t"
      >
        <Input
          name="prompt"
          value={input}
          onChange={(e) => setInput(e.target.value)}
          placeholder="Type your message..."
          className="flex-1"
          autoComplete="off"
          autoFocus
        />
        <Button type="submit" size="icon">
          <Send size={18} />
        </Button>
      </form>
    </div>
  );
}
{{/if}}
`],
  ["payments/paddle/web/react/react-router/src/routes/success.tsx.hbs", `import { useSearchParams } from "react-router";

export default function SuccessPage() {
	const [searchParams] = useSearchParams();
	const transactionId = searchParams.get("transaction_id");

	return (
		<div className="container mx-auto px-4 py-8">
			<h1 className="text-2xl font-bold mb-4">Payment Successful!</h1>
			<p className="text-gray-600 mb-4">
				Thank you for your purchase. Your payment has been processed successfully.
			</p>
			{transactionId && (
				<p className="text-sm text-gray-500">Transaction ID: {transactionId}</p>
			)}
		</div>
	);
}
`],
  ["auth/stack-auth/web/react/next/src/lib/auth-client.ts.hbs", `"use client";

import { useUser, useStackApp } from "@stackframe/stack";

export { useUser, useStackApp };

export function useAuthClient() {
  const user = useUser();
  const app = useStackApp();

  return {
    user,
    isAuthenticated: !!user,
    isLoading: false,
    signOut: () => user?.signOut(),
    redirectToSignIn: () => app.redirectToSignIn(),
    redirectToSignUp: () => app.redirectToSignUp(),
  };
}
`],
  ["auth/stack-auth/web/react/next/src/components/user-menu.tsx.hbs", `"use client";

import { UserButton } from "@stackframe/stack";

export default function UserMenu() {
  return <UserButton />;
}
`],
  ["auth/stack-auth/web/react/next/src/components/sign-in-form.tsx.hbs", `"use client";

import { SignIn } from "@stackframe/stack";

export default function SignInForm({
  onSwitchToSignUp,
}: {
  onSwitchToSignUp: () => void;
}) {
  return (
    <div className="mx-auto w-full mt-10 max-w-md p-6">
      <SignIn
        fullPage={false}
        automaticRedirect={true}
        extraInfo={
          <button
            type="button"
            onClick={onSwitchToSignUp}
            className="text-indigo-600 hover:text-indigo-800 text-sm mt-4"
          >
            Need an account? Sign Up
          </button>
        }
      />
    </div>
  );
}
`],
  ["auth/stack-auth/web/react/next/src/components/providers.tsx.hbs", `"use client";

import { StackProvider, StackTheme } from "@stackframe/stack";
import { stackServerApp } from "@/stack/server";
import type { ReactNode } from "react";

export function AuthProvider({ children }: { children: ReactNode }) {
  return (
    <StackProvider app={stackServerApp}>
      <StackTheme>
        {children}
      </StackTheme>
    </StackProvider>
  );
}
`],
  ["auth/stack-auth/web/react/next/src/components/sign-up-form.tsx.hbs", `"use client";

import { SignUp } from "@stackframe/stack";

export default function SignUpForm({
  onSwitchToSignIn,
}: {
  onSwitchToSignIn: () => void;
}) {
  return (
    <div className="mx-auto w-full mt-10 max-w-md p-6">
      <SignUp
        fullPage={false}
        automaticRedirect={true}
        extraInfo={
          <button
            type="button"
            onClick={onSwitchToSignIn}
            className="text-indigo-600 hover:text-indigo-800 text-sm mt-4"
          >
            Already have an account? Sign In
          </button>
        }
      />
    </div>
  );
}
`],
  ["auth/nextauth/web/react/next/src/lib/auth-client.ts.hbs", `"use client";

import { signIn, signOut, useSession } from "next-auth/react";

export { signIn, signOut, useSession };

export function useAuthClient() {
  const { data: session, status } = useSession();

  return {
    session,
    user: session?.user ?? null,
    isAuthenticated: status === "authenticated",
    isLoading: status === "loading",
    signIn,
    signOut,
  };
}
`],
  ["auth/nextauth/web/react/next/src/components/user-menu.tsx.hbs", `"use client";

import { useAuthClient } from "@/lib/auth-client";
import { Button } from "./ui/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "./ui/dropdown-menu";

export default function UserMenu() {
  const { user, signOut } = useAuthClient();

  if (!user) {
    return null;
  }

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="outline" className="flex items-center gap-2">
          {user.image ? (
            <img
              src={user.image}
              alt={user.name || "User"}
              className="h-6 w-6 rounded-full"
            />
          ) : (
            <div className="h-6 w-6 rounded-full bg-primary text-primary-foreground flex items-center justify-center text-sm font-medium">
              {user.name?.charAt(0) || user.email?.charAt(0) || "U"}
            </div>
          )}
          <span className="hidden sm:inline">{user.name || user.email}</span>
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end" className="w-56">
        <DropdownMenuLabel>
          <div className="flex flex-col space-y-1">
            <p className="text-sm font-medium">{user.name}</p>
            <p className="text-xs text-muted-foreground">{user.email}</p>
          </div>
        </DropdownMenuLabel>
        <DropdownMenuSeparator />
        <DropdownMenuItem asChild>
          <a href="/dashboard">Dashboard</a>
        </DropdownMenuItem>
        <DropdownMenuSeparator />
        <DropdownMenuItem
          onClick={() => signOut({ callbackUrl: "/" })}
          className="text-red-600 focus:text-red-600"
        >
          Sign Out
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}
`],
  ["auth/nextauth/web/react/next/src/components/sign-in-form.tsx.hbs", `"use client";

import { useForm } from "@tanstack/react-form";
import { signIn } from "next-auth/react";
import { useRouter } from "next/navigation";
import { toast } from "sonner";
import z from "zod";
import Loader from "./loader";
import { Button } from "./ui/button";
import { Input } from "./ui/input";
import { Label } from "./ui/label";
import { useAuthClient } from "@/lib/auth-client";

export default function SignInForm({
  onSwitchToSignUp,
}: {
  onSwitchToSignUp: () => void;
}) {
  const router = useRouter();
  const { isLoading } = useAuthClient();

  const form = useForm({
    defaultValues: {
      email: "",
      password: "",
    },
    onSubmit: async ({ value }) => {
      const result = await signIn("credentials", {
        email: value.email,
        password: value.password,
        redirect: false,
      });

      if (result?.error) {
        toast.error("Invalid credentials");
      } else {
        router.push("/dashboard");
        toast.success("Sign in successful");
      }
    },
    validators: {
      onSubmit: z.object({
        email: z.email("Invalid email address"),
        password: z.string().min(8, "Password must be at least 8 characters"),
      }),
    },
  });

  if (isLoading) {
    return <Loader />;
  }

  return (
    <div className="mx-auto w-full mt-10 max-w-md p-6">
      <h1 className="mb-6 text-center text-3xl font-bold">Welcome Back</h1>

      <form
        onSubmit={(e) => {
          e.preventDefault();
          e.stopPropagation();
          form.handleSubmit();
        }}
        className="space-y-4"
      >
        <div>
          <form.Field name="email">
            {(field) => (
              <div className="space-y-2">
                <Label htmlFor={field.name}>Email</Label>
                <Input
                  id={field.name}
                  name={field.name}
                  type="email"
                  value={field.state.value}
                  onBlur={field.handleBlur}
                  onChange={(e) => field.handleChange(e.target.value)}
                />
                {field.state.meta.errors.map((error) => (
                  <p key={error?.message} className="text-red-500">
                    {error?.message}
                  </p>
                ))}
              </div>
            )}
          </form.Field>
        </div>

        <div>
          <form.Field name="password">
            {(field) => (
              <div className="space-y-2">
                <Label htmlFor={field.name}>Password</Label>
                <Input
                  id={field.name}
                  name={field.name}
                  type="password"
                  value={field.state.value}
                  onBlur={field.handleBlur}
                  onChange={(e) => field.handleChange(e.target.value)}
                />
                {field.state.meta.errors.map((error) => (
                  <p key={error?.message} className="text-red-500">
                    {error?.message}
                  </p>
                ))}
              </div>
            )}
          </form.Field>
        </div>

        <form.Subscribe>
          {(state) => (
            <Button
              type="submit"
              className="w-full"
              disabled={!state.canSubmit || state.isSubmitting}
            >
              {state.isSubmitting ? "Signing in..." : "Sign In"}
            </Button>
          )}
        </form.Subscribe>
      </form>

      <div className="mt-4 space-y-2">
        <div className="relative">
          <div className="absolute inset-0 flex items-center">
            <span className="w-full border-t" />
          </div>
          <div className="relative flex justify-center text-xs uppercase">
            <span className="bg-background px-2 text-muted-foreground">
              Or continue with
            </span>
          </div>
        </div>

        <div className="grid grid-cols-2 gap-2">
          <Button
            variant="outline"
            onClick={() => signIn("github", { callbackUrl: "/dashboard" })}
          >
            GitHub
          </Button>
          <Button
            variant="outline"
            onClick={() => signIn("google", { callbackUrl: "/dashboard" })}
          >
            Google
          </Button>
        </div>
      </div>

      <div className="mt-4 text-center">
        <Button
          variant="link"
          onClick={onSwitchToSignUp}
          className="text-indigo-600 hover:text-indigo-800"
        >
          Need an account? Sign Up
        </Button>
      </div>
    </div>
  );
}
`],
  ["auth/nextauth/web/react/next/src/components/providers.tsx.hbs", `"use client";

import { SessionProvider } from "next-auth/react";
import type { ReactNode } from "react";

export function AuthProvider({ children }: { children: ReactNode }) {
  return <SessionProvider>{children}</SessionProvider>;
}
`],
  ["auth/nextauth/web/react/next/src/components/sign-up-form.tsx.hbs", `"use client";

import { useForm } from "@tanstack/react-form";
import { toast } from "sonner";
import z from "zod";
import Loader from "./loader";
import { Button } from "./ui/button";
import { Input } from "./ui/input";
import { Label } from "./ui/label";
import { useAuthClient } from "@/lib/auth-client";

export default function SignUpForm({
  onSwitchToSignIn,
}: {
  onSwitchToSignIn: () => void;
}) {
  const { isLoading } = useAuthClient();

  const form = useForm({
    defaultValues: {
      name: "",
      email: "",
      password: "",
      confirmPassword: "",
    },
    onSubmit: async ({ value }) => {
      // Implement your sign-up logic here
      // This could call an API route to create a user in your database
      try {
        const response = await fetch("/api/auth/register", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            name: value.name,
            email: value.email,
            password: value.password,
          }),
        });

        if (!response.ok) {
          const error = await response.json();
          toast.error(error.message || "Registration failed");
          return;
        }

        toast.success("Account created! Please sign in.");
        onSwitchToSignIn();
      } catch {
        toast.error("Registration failed");
      }
    },
    validators: {
      onSubmit: z
        .object({
          name: z.string().min(2, "Name must be at least 2 characters"),
          email: z.email("Invalid email address"),
          password: z.string().min(8, "Password must be at least 8 characters"),
          confirmPassword: z.string(),
        })
        .refine((data) => data.password === data.confirmPassword, {
          message: "Passwords don't match",
          path: ["confirmPassword"],
        }),
    },
  });

  if (isLoading) {
    return <Loader />;
  }

  return (
    <div className="mx-auto w-full mt-10 max-w-md p-6">
      <h1 className="mb-6 text-center text-3xl font-bold">Create Account</h1>

      <form
        onSubmit={(e) => {
          e.preventDefault();
          e.stopPropagation();
          form.handleSubmit();
        }}
        className="space-y-4"
      >
        <div>
          <form.Field name="name">
            {(field) => (
              <div className="space-y-2">
                <Label htmlFor={field.name}>Name</Label>
                <Input
                  id={field.name}
                  name={field.name}
                  type="text"
                  value={field.state.value}
                  onBlur={field.handleBlur}
                  onChange={(e) => field.handleChange(e.target.value)}
                />
                {field.state.meta.errors.map((error) => (
                  <p key={error?.message} className="text-red-500">
                    {error?.message}
                  </p>
                ))}
              </div>
            )}
          </form.Field>
        </div>

        <div>
          <form.Field name="email">
            {(field) => (
              <div className="space-y-2">
                <Label htmlFor={field.name}>Email</Label>
                <Input
                  id={field.name}
                  name={field.name}
                  type="email"
                  value={field.state.value}
                  onBlur={field.handleBlur}
                  onChange={(e) => field.handleChange(e.target.value)}
                />
                {field.state.meta.errors.map((error) => (
                  <p key={error?.message} className="text-red-500">
                    {error?.message}
                  </p>
                ))}
              </div>
            )}
          </form.Field>
        </div>

        <div>
          <form.Field name="password">
            {(field) => (
              <div className="space-y-2">
                <Label htmlFor={field.name}>Password</Label>
                <Input
                  id={field.name}
                  name={field.name}
                  type="password"
                  value={field.state.value}
                  onBlur={field.handleBlur}
                  onChange={(e) => field.handleChange(e.target.value)}
                />
                {field.state.meta.errors.map((error) => (
                  <p key={error?.message} className="text-red-500">
                    {error?.message}
                  </p>
                ))}
              </div>
            )}
          </form.Field>
        </div>

        <div>
          <form.Field name="confirmPassword">
            {(field) => (
              <div className="space-y-2">
                <Label htmlFor={field.name}>Confirm Password</Label>
                <Input
                  id={field.name}
                  name={field.name}
                  type="password"
                  value={field.state.value}
                  onBlur={field.handleBlur}
                  onChange={(e) => field.handleChange(e.target.value)}
                />
                {field.state.meta.errors.map((error) => (
                  <p key={error?.message} className="text-red-500">
                    {error?.message}
                  </p>
                ))}
              </div>
            )}
          </form.Field>
        </div>

        <form.Subscribe>
          {(state) => (
            <Button
              type="submit"
              className="w-full"
              disabled={!state.canSubmit || state.isSubmitting}
            >
              {state.isSubmitting ? "Creating account..." : "Sign Up"}
            </Button>
          )}
        </form.Subscribe>
      </form>

      <div className="mt-4 text-center">
        <Button
          variant="link"
          onClick={onSwitchToSignIn}
          className="text-indigo-600 hover:text-indigo-800"
        >
          Already have an account? Sign In
        </Button>
      </div>
    </div>
  );
}
`],
  ["examples/ai/web/react/react-router/src/routes/ai.tsx.hbs", `{{#if (eq backend "convex")}}
import { api } from "@{{projectName}}/backend/convex/_generated/api";
import {
  useUIMessages,
  useSmoothText,
  type UIMessage,
} from "@convex-dev/agent/react";
import { useMutation } from "convex/react";
import { Send, Loader2 } from "lucide-react";
import React, { useRef, useEffect, useState } from "react";
import { Streamdown } from "streamdown";

import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";

function MessageContent({
  text,
  isStreaming,
}: {
  text: string;
  isStreaming: boolean;
}) {
  const [visibleText] = useSmoothText(text, {
    startStreaming: isStreaming,
  });
  return <Streamdown>{visibleText}</Streamdown>;
}

const AI: React.FC = () => {
  const [input, setInput] = useState("");
  const [threadId, setThreadId] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const messagesEndRef = useRef<HTMLDivElement>(null);

  const createThread = useMutation(api.chat.createNewThread);
  const sendMessage = useMutation(api.chat.sendMessage);

  const { results: messages } = useUIMessages(
    api.chat.listMessages,
    threadId ? { threadId } : "skip",
    { initialNumItems: 50, stream: true },
  );

  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  }, [messages]);

  const hasStreamingMessage = messages?.some(
    (m: UIMessage) => m.status === "streaming",
  );

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    const text = input.trim();
    if (!text || isLoading) return;

    setIsLoading(true);
    setInput("");

    try {
      let currentThreadId = threadId;
      if (!currentThreadId) {
        currentThreadId = await createThread();
        setThreadId(currentThreadId);
      }

      await sendMessage({ threadId: currentThreadId, prompt: text });
    } catch (error) {
      console.error("Failed to send message:", error);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="grid grid-rows-[1fr_auto] overflow-hidden w-full mx-auto p-4">
      <div className="overflow-y-auto space-y-4 pb-4">
        {!messages || messages.length === 0 ? (
          <div className="text-center text-muted-foreground mt-8">
            Ask me anything to get started!
          </div>
        ) : (
          messages.map((message: UIMessage) => (
            <div
              key={message.key}
              className={\`p-3 rounded-lg \${
                message.role === "user"
                  ? "bg-primary/10 ml-8"
                  : "bg-secondary/20 mr-8"
              }\`}
            >
              <p className="text-sm font-semibold mb-1">
                {message.role === "user" ? "You" : "AI Assistant"}
              </p>
              <MessageContent
                text={message.text ?? ""}
                isStreaming={message.status === "streaming"}
              />
            </div>
          ))
        )}
        {isLoading && !hasStreamingMessage && (
          <div className="p-3 rounded-lg bg-secondary/20 mr-8">
            <p className="text-sm font-semibold mb-1">AI Assistant</p>
            <div className="flex items-center gap-2 text-muted-foreground">
              <Loader2 className="h-4 w-4 animate-spin" />
              <span>Thinking...</span>
            </div>
          </div>
        )}
        <div ref={messagesEndRef} />
      </div>

      <form
        onSubmit={handleSubmit}
        className="w-full flex items-center space-x-2 pt-2 border-t"
      >
        <Input
          name="prompt"
          value={input}
          onChange={(e) => setInput(e.target.value)}
          placeholder="Type your message..."
          className="flex-1"
          autoComplete="off"
          autoFocus
          disabled={isLoading}
        />
        <Button type="submit" size="icon" disabled={isLoading || !input.trim()}>
          {isLoading ? (
            <Loader2 className="h-4 w-4 animate-spin" />
          ) : (
            <Send size={18} />
          )}
        </Button>
      </form>
    </div>
  );
};

export default AI;
{{else if (eq ai "modelfusion")}}
import React, { useRef, useEffect, useState, useCallback } from "react";
import { Send, Loader2 } from "lucide-react";
import { Streamdown } from "streamdown";
import { env } from "@{{projectName}}/env/web";

import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";

type Message = {
  id: string;
  role: "user" | "assistant";
  content: string;
};

const AI: React.FC = () => {
  const [input, setInput] = useState("");
  const [messages, setMessages] = useState<Message[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [streamingContent, setStreamingContent] = useState("");
  const messagesEndRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  }, [messages, streamingContent]);

  const sendMessage = useCallback(async (text: string) => {
    const userMessage: Message = {
      id: Date.now().toString(),
      role: "user",
      content: text,
    };

    setMessages((prev) => [...prev, userMessage]);
    setIsLoading(true);
    setStreamingContent("");

    try {
      const response = await fetch(\`\${env.VITE_SERVER_URL}/ai\`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          messages: [...messages, userMessage].map((m) => ({
            role: m.role,
            content: m.content,
          })),
        }),
      });

      if (!response.ok) throw new Error("Failed to send message");

      const reader = response.body?.getReader();
      const decoder = new TextDecoder();
      let fullContent = "";

      if (reader) {
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          const chunk = decoder.decode(value, { stream: true });
          const lines = chunk.split("\\n");

          for (const line of lines) {
            if (line.startsWith("data: ")) {
              const data = line.slice(6);
              if (data === "[DONE]") continue;
              try {
                const parsed = JSON.parse(data);
                if (parsed.content) {
                  fullContent += parsed.content;
                  setStreamingContent(fullContent);
                }
              } catch {
                // Ignore parsing errors for incomplete chunks
              }
            }
          }
        }
      }

      const assistantMessage: Message = {
        id: (Date.now() + 1).toString(),
        role: "assistant",
        content: fullContent,
      };
      setMessages((prev) => [...prev, assistantMessage]);
      setStreamingContent("");
    } catch (error) {
      console.error("Failed to send message:", error);
    } finally {
      setIsLoading(false);
    }
  }, [messages]);

  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    const text = input.trim();
    if (!text || isLoading) return;
    setInput("");
    sendMessage(text);
  };

  return (
    <div className="grid grid-rows-[1fr_auto] overflow-hidden w-full mx-auto p-4">
      <div className="overflow-y-auto space-y-4 pb-4">
        {messages.length === 0 && !streamingContent ? (
          <div className="text-center text-muted-foreground mt-8">
            Ask me anything to get started!
          </div>
        ) : (
          <>
            {messages.map((message) => (
              <div
                key={message.id}
                className={\`p-3 rounded-lg \${
                  message.role === "user"
                    ? "bg-primary/10 ml-8"
                    : "bg-secondary/20 mr-8"
                }\`}
              >
                <p className="text-sm font-semibold mb-1">
                  {message.role === "user" ? "You" : "AI Assistant"}
                </p>
                <Streamdown>{message.content}</Streamdown>
              </div>
            ))}
            {streamingContent && (
              <div className="p-3 rounded-lg bg-secondary/20 mr-8">
                <p className="text-sm font-semibold mb-1">AI Assistant</p>
                <Streamdown isAnimating>{streamingContent}</Streamdown>
              </div>
            )}
          </>
        )}
        {isLoading && !streamingContent && (
          <div className="p-3 rounded-lg bg-secondary/20 mr-8">
            <p className="text-sm font-semibold mb-1">AI Assistant</p>
            <div className="flex items-center gap-2 text-muted-foreground">
              <Loader2 className="h-4 w-4 animate-spin" />
              <span>Thinking...</span>
            </div>
          </div>
        )}
        <div ref={messagesEndRef} />
      </div>

      <form
        onSubmit={handleSubmit}
        className="w-full flex items-center space-x-2 pt-2 border-t"
      >
        <Input
          name="prompt"
          value={input}
          onChange={(e) => setInput(e.target.value)}
          placeholder="Type your message..."
          className="flex-1"
          autoComplete="off"
          autoFocus
          disabled={isLoading}
        />
        <Button type="submit" size="icon" disabled={isLoading || !input.trim()}>
          {isLoading ? (
            <Loader2 className="h-4 w-4 animate-spin" />
          ) : (
            <Send size={18} />
          )}
        </Button>
      </form>
    </div>
  );
};

export default AI;
{{else if (eq ai "langgraph")}}
import React, { useRef, useEffect, useState, useCallback } from "react";
import { Send, Loader2 } from "lucide-react";
import { Streamdown } from "streamdown";
import { env } from "@{{projectName}}/env/web";

import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";

type Message = {
  id: string;
  role: "user" | "assistant";
  content: string;
};

const AI: React.FC = () => {
  const [input, setInput] = useState("");
  const [messages, setMessages] = useState<Message[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [streamingContent, setStreamingContent] = useState("");
  const messagesEndRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  }, [messages, streamingContent]);

  const sendMessage = useCallback(async (text: string) => {
    const userMessage: Message = {
      id: Date.now().toString(),
      role: "user",
      content: text,
    };

    setMessages((prev) => [...prev, userMessage]);
    setIsLoading(true);
    setStreamingContent("");

    try {
      const response = await fetch(\`\${env.VITE_SERVER_URL}/ai\`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          messages: [...messages, userMessage].map((m) => ({
            role: m.role,
            content: m.content,
          })),
        }),
      });

      if (!response.ok) throw new Error("Failed to send message");

      const reader = response.body?.getReader();
      const decoder = new TextDecoder();
      let fullContent = "";

      if (reader) {
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          const chunk = decoder.decode(value, { stream: true });
          const lines = chunk.split("\\n");

          for (const line of lines) {
            if (line.startsWith("data: ")) {
              const data = line.slice(6);
              if (data === "[DONE]") continue;
              try {
                const parsed = JSON.parse(data);
                if (parsed.content) {
                  fullContent += parsed.content;
                  setStreamingContent(fullContent);
                }
              } catch {
                // Ignore parsing errors for incomplete chunks
              }
            }
          }
        }
      }

      const assistantMessage: Message = {
        id: (Date.now() + 1).toString(),
        role: "assistant",
        content: fullContent,
      };
      setMessages((prev) => [...prev, assistantMessage]);
      setStreamingContent("");
    } catch (error) {
      console.error("Failed to send message:", error);
    } finally {
      setIsLoading(false);
    }
  }, [messages]);

  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    const text = input.trim();
    if (!text || isLoading) return;
    setInput("");
    sendMessage(text);
  };

  return (
    <div className="grid grid-rows-[1fr_auto] overflow-hidden w-full mx-auto p-4">
      <div className="overflow-y-auto space-y-4 pb-4">
        {messages.length === 0 && !streamingContent ? (
          <div className="text-center text-muted-foreground mt-8">
            Ask me anything to get started!
          </div>
        ) : (
          <>
            {messages.map((message) => (
              <div
                key={message.id}
                className={\`p-3 rounded-lg \${
                  message.role === "user"
                    ? "bg-primary/10 ml-8"
                    : "bg-secondary/20 mr-8"
                }\`}
              >
                <p className="text-sm font-semibold mb-1">
                  {message.role === "user" ? "You" : "AI Assistant"}
                </p>
                <Streamdown>{message.content}</Streamdown>
              </div>
            ))}
            {streamingContent && (
              <div className="p-3 rounded-lg bg-secondary/20 mr-8">
                <p className="text-sm font-semibold mb-1">AI Assistant</p>
                <Streamdown isAnimating>{streamingContent}</Streamdown>
              </div>
            )}
          </>
        )}
        {isLoading && !streamingContent && (
          <div className="p-3 rounded-lg bg-secondary/20 mr-8">
            <p className="text-sm font-semibold mb-1">AI Assistant</p>
            <div className="flex items-center gap-2 text-muted-foreground">
              <Loader2 className="h-4 w-4 animate-spin" />
              <span>Thinking...</span>
            </div>
          </div>
        )}
        <div ref={messagesEndRef} />
      </div>

      <form
        onSubmit={handleSubmit}
        className="w-full flex items-center space-x-2 pt-2 border-t"
      >
        <Input
          name="prompt"
          value={input}
          onChange={(e) => setInput(e.target.value)}
          placeholder="Type your message..."
          className="flex-1"
          autoComplete="off"
          autoFocus
          disabled={isLoading}
        />
        <Button type="submit" size="icon" disabled={isLoading || !input.trim()}>
          {isLoading ? (
            <Loader2 className="h-4 w-4 animate-spin" />
          ) : (
            <Send size={18} />
          )}
        </Button>
      </form>
    </div>
  );
};

export default AI;
{{else}}
import React, { useRef, useEffect, useState } from "react";
import { useChat } from "@ai-sdk/react";
import { DefaultChatTransport } from "ai";
import { Send } from "lucide-react";
import { Streamdown } from "streamdown";
import { env } from "@{{projectName}}/env/web";

import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";

const AI: React.FC = () => {
  const [input, setInput] = useState("");
  const { messages, sendMessage, status } = useChat({
    transport: new DefaultChatTransport({
      api: \`\${env.VITE_SERVER_URL}/ai\`,
    }),
  });

  const messagesEndRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  }, [messages]);

  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    const text = input.trim();
    if (!text) return;
    sendMessage({ text });
    setInput("");
  };

  return (
    <div className="grid grid-rows-[1fr_auto] overflow-hidden w-full mx-auto p-4">
      <div className="overflow-y-auto space-y-4 pb-4">
        {messages.length === 0 ? (
          <div className="text-center text-muted-foreground mt-8">
            Ask me anything to get started!
          </div>
        ) : (
          messages.map((message) => (
            <div
              key={message.id}
              className={\`p-3 rounded-lg \${
                message.role === "user"
                  ? "bg-primary/10 ml-8"
                  : "bg-secondary/20 mr-8"
              }\`}
            >
              <p className="text-sm font-semibold mb-1">
                {message.role === "user" ? "You" : "AI Assistant"}
              </p>
              {message.parts?.map((part, index) => {
                if (part.type === "text") {
                  return (
                    <Streamdown
                      key={index}
                      isAnimating={status === "streaming" && message.role === "assistant"}
                    >
                      {part.text}
                    </Streamdown>
                  );
                }
                return null;
              })}
            </div>
          ))
        )}
        <div ref={messagesEndRef} />
      </div>

      <form
        onSubmit={handleSubmit}
        className="w-full flex items-center space-x-2 pt-2 border-t"
      >
        <Input
          name="prompt"
          value={input}
          onChange={(e) => setInput(e.target.value)}
          placeholder="Type your message..."
          className="flex-1"
          autoComplete="off"
          autoFocus
        />
        <Button type="submit" size="icon">
          <Send size={18} />
        </Button>
      </form>
    </div>
  );
};

export default AI;
{{/if}}
`],
  ["examples/todo/web/svelte/src/routes/todos/+page.svelte.hbs", `{{#if (eq backend "convex")}}
<script lang="ts">
	import { useQuery, useConvexClient } from 'convex-svelte';
	import { api } from '@{{projectName}}/backend/convex/_generated/api';
	import type { Id } from '@{{projectName}}/backend/convex/_generated/dataModel';

	let newTodoText = $state('');
	let isAdding = $state(false);
	let addError = $state<Error | null>(null);
	let togglingId = $state<Id<'todos'> | null>(null);
	let toggleError = $state<Error | null>(null);
	let deletingId = $state<Id<'todos'> | null>(null);
	let deleteError = $state<Error | null>(null);

	const client = useConvexClient();

	const todosQuery = useQuery(api.todos.getAll, {});

	async function handleAddTodo(event: SubmitEvent) {
		event.preventDefault();
		const text = newTodoText.trim();
		if (!text || isAdding) return;

		isAdding = true;
		addError = null;
		try {
			await client.mutation(api.todos.create, { text });
			newTodoText = '';
		} catch (err) {
			console.error('Failed to add todo:', err);
			addError = err instanceof Error ? err : new Error(String(err));
		} finally {
			isAdding = false;
		}
	}

	async function handleToggleTodo(id: Id<'todos'>, completed: boolean) {
		if (togglingId === id || deletingId === id) return;

		togglingId = id;
		toggleError = null;
		try {
			await client.mutation(api.todos.toggle, { id, completed: !completed });
		} catch (err) {
			console.error('Failed to toggle todo:', err);
			toggleError = err instanceof Error ? err : new Error(String(err));
		} finally {
			if (togglingId === id) {
				togglingId = null;
			}
		}
	}

	async function handleDeleteTodo(id: Id<'todos'>) {
		if (togglingId === id || deletingId === id) return;

		deletingId = id;
		deleteError = null;
		try {
			await client.mutation(api.todos.deleteTodo, { id });
		} catch (err) {
			console.error('Failed to delete todo:', err);
			deleteError = err instanceof Error ? err : new Error(String(err));
		} finally {
			if (deletingId === id) {
				deletingId = null;
			}
		}
	}

	const canAdd = $derived(!isAdding && newTodoText.trim().length > 0);
	const isLoadingTodos = $derived(todosQuery.isLoading);
	const todos = $derived(todosQuery.data ?? []);
	const hasTodos = $derived(todos.length > 0);

</script>

<div class="p-4">
	<h1 class="text-xl mb-4">Todos (Convex)</h1>

	<form onsubmit={handleAddTodo} class="flex gap-2 mb-4">
		<input
			type="text"
			bind:value={newTodoText}
			placeholder="New task..."
			disabled={isAdding}
			class="p-1 flex-grow"
		/>
		<button
			type="submit"
			disabled={!canAdd}
			class="bg-blue-500 text-white px-3 py-1 rounded disabled:opacity-50"
		>
			{#if isAdding}Adding...{:else}Add{/if}
		</button>
	</form>

	{#if isLoadingTodos}
		<p>Loading...</p>
	{:else if !hasTodos}
		<p>No todos yet.</p>
	{:else}
		<ul class="space-y-1">
			{#each todos as todo (todo._id)}
				{@const isTogglingThis = togglingId === todo._id}
				{@const isDeletingThis = deletingId === todo._id}
				{@const isDisabled = isTogglingThis || isDeletingThis}
				<li
					class="flex items-center justify-between p-2"
					class:opacity-50={isDisabled}
				>
					<div class="flex items-center gap-2">
						<input
							type="checkbox"
							id={\`todo-\${todo._id}\`}
							checked={todo.completed}
							onchange={() => handleToggleTodo(todo._id, todo.completed)}
							disabled={isDisabled}
						/>
						<label
							for={\`todo-\${todo._id}\`}
							class:line-through={todo.completed}
						>
							{todo.text}
						</label>
					</div>
					<button
						type="button"
						onclick={() => handleDeleteTodo(todo._id)}
						disabled={isDisabled}
						aria-label="Delete todo"
						class="text-red-500 px-1 disabled:opacity-50"
					>
						{#if isDeletingThis}Deleting...{:else}X{/if}
					</button>
				</li>
			{/each}
		</ul>
	{/if}

	{#if todosQuery.error}
		<p class="mt-4 text-red-500">
			Error loading: {todosQuery.error?.message ?? 'Unknown error'}
		</p>
	{/if}
	{#if addError}
		<p class="mt-4 text-red-500">
			Error adding: {addError.message ?? 'Unknown error'}
		</p>
	{/if}
	{#if toggleError}
		<p class="mt-4 text-red-500">
			Error updating: {toggleError.message ?? 'Unknown error'}
		</p>
	{/if}
	{#if deleteError}
		<p class="mt-4 text-red-500">
			Error deleting: {deleteError.message ?? 'Unknown error'}
		</p>
	{/if}
</div>
{{else}}
<script lang="ts">
	{{#if (eq api "orpc")}}
	import { orpc } from '$lib/orpc';
	{{/if}}
	import { createQuery, createMutation } from '@tanstack/svelte-query';

	let newTodoText = $state('');

	{{#if (eq api "orpc")}}
	const todosQuery = createQuery(orpc.todo.getAll.queryOptions());

	const addMutation = createMutation(
		orpc.todo.create.mutationOptions({
			onSuccess: () => {
				$todosQuery.refetch();
				newTodoText = '';
			},
			onError: (error) => {
				console.error('Failed to create todo:', error?.message ?? error);
			},
		})
	);

	const toggleMutation = createMutation(
		orpc.todo.toggle.mutationOptions({
			onSuccess: () => {
				$todosQuery.refetch();
			},
			onError: (error) => {
				console.error('Failed to toggle todo:', error?.message ?? error);
			},
		})
	);

	const deleteMutation = createMutation(
		orpc.todo.delete.mutationOptions({
			onSuccess: () => {
				$todosQuery.refetch();
			},
			onError: (error) => {
				console.error('Failed to delete todo:', error?.message ?? error);
			},
		})
	);
	{{/if}}

	function handleAddTodo(event: SubmitEvent) {
		event.preventDefault();
		const text = newTodoText.trim();
		if (text) {
			$addMutation.mutate({ text });
		}
	}

	function handleToggleTodo(id: number, completed: boolean) {
		$toggleMutation.mutate({ id, completed: !completed });
	}

	function handleDeleteTodo(id: number) {
		$deleteMutation.mutate({ id });
	}

	const isAdding = $derived($addMutation.isPending);
	const canAdd = $derived(!isAdding && newTodoText.trim().length > 0);
	const isLoadingTodos = $derived($todosQuery.isLoading);
	const todos = $derived($todosQuery.data ?? []);
	const hasTodos = $derived(todos.length > 0);

</script>

<div class="p-4">
	<h1 class="text-xl mb-4">Todos{{#if (eq api "orpc")}} (oRPC){{/if}}</h1>

	<form onsubmit={handleAddTodo} class="flex gap-2 mb-4">
		<input
			type="text"
			bind:value={newTodoText}
			placeholder="New task..."
			disabled={isAdding}
			class=" p-1 flex-grow"
		/>
		<button
			type="submit"
			disabled={!canAdd}
			class="bg-blue-500 text-white px-3 py-1 rounded disabled:opacity-50"
		>
			{#if isAdding}Adding...{:else}Add{/if}
		</button>
	</form>

	{#if isLoadingTodos}
		<p>Loading...</p>
	{:else if !hasTodos}
		<p>No todos yet.</p>
	{:else}
		<ul class="space-y-1">
			{#each todos as todo (todo.id)}
				{@const isToggling = $toggleMutation.isPending && $toggleMutation.variables?.id === todo.id}
				{@const isDeleting = $deleteMutation.isPending && $deleteMutation.variables?.id === todo.id}
				{@const isDisabled = isToggling || isDeleting}
				<li
					class="flex items-center justify-between p-2 "
					class:opacity-50={isDisabled}
				>
					<div class="flex items-center gap-2">
						<input
							type="checkbox"
							id={\`todo-\${todo.id}\`}
							checked={todo.completed}
							onchange={() => handleToggleTodo(todo.id, todo.completed)}
							disabled={isDisabled}
						/>
						<label
							for={\`todo-\${todo.id}\`}
							class:line-through={todo.completed}
						>
							{todo.text}
						</label>
					</div>
					<button
						type="button"
						onclick={() => handleDeleteTodo(todo.id)}
						disabled={isDisabled}
						aria-label="Delete todo"
						class="text-red-500 px-1 disabled:opacity-50"
					>
						{#if isDeleting}Deleting...{:else}X{/if}
					</button>
				</li>
			{/each}
		</ul>
	{/if}

	{#if $todosQuery.isError}
		<p class="mt-4 text-red-500">
			Error loading: {$todosQuery.error?.message ?? 'Unknown error'}
		</p>
	{/if}
	{#if $addMutation.isError}
		<p class="mt-4 text-red-500">
			Error adding: {$addMutation.error?.message ?? 'Unknown error'}
		</p>
	{/if}
	{#if $toggleMutation.isError}
		<p class="mt-4 text-red-500">
			Error updating: {$toggleMutation.error?.message ?? 'Unknown error'}
		</p>
	{/if}
	{#if $deleteMutation.isError}
		<p class="mt-4 text-red-500">
			Error deleting: {$deleteMutation.error?.message ?? 'Unknown error'}
		</p>
	{/if}
</div>
{{/if}}
`],
  ["payments/paddle/web/svelte/src/routes/success/+page.svelte.hbs", `<script lang="ts">
	import { page } from "$app/stores";

	$: transactionId = $page.url.searchParams.get("transaction_id");
</script>

<div class="container mx-auto px-4 py-8">
	<h1 class="text-2xl font-bold mb-4">Payment Successful!</h1>
	<p class="text-gray-600 mb-4">
		Thank you for your purchase. Your payment has been processed successfully.
	</p>
	{#if transactionId}
		<p class="text-sm text-gray-500">Transaction ID: {transactionId}</p>
	{/if}
</div>
`],
  ["auth/supabase-auth/web/react/next/src/components/user-menu.tsx.hbs", `"use client";

import { useAuthClient } from "@/lib/auth-client";
import { useRouter } from "next/navigation";

export default function UserMenu() {
  const { user, signOut, isLoading } = useAuthClient();
  const router = useRouter();

  const handleSignOut = async () => {
    await signOut();
    router.push("/login");
    router.refresh();
  };

  if (isLoading) {
    return (
      <div className="h-8 w-8 rounded-full bg-gray-200 animate-pulse" />
    );
  }

  if (!user) {
    return (
      <button
        onClick={() => router.push("/login")}
        className="px-4 py-2 text-sm font-medium text-white bg-indigo-600 rounded-md hover:bg-indigo-700"
      >
        Sign In
      </button>
    );
  }

  return (
    <div className="flex items-center gap-4">
      <span className="text-sm text-gray-700">
        {user.email}
      </span>
      <button
        onClick={handleSignOut}
        className="px-4 py-2 text-sm font-medium text-gray-700 bg-gray-100 rounded-md hover:bg-gray-200"
      >
        Sign Out
      </button>
    </div>
  );
}
`],
  ["auth/supabase-auth/web/react/next/src/components/sign-in-form.tsx.hbs", `"use client";

import { useState } from "react";
import { useAuthClient } from "@/lib/auth-client";
import { useRouter } from "next/navigation";

export default function SignInForm({
  onSwitchToSignUp,
}: {
  onSwitchToSignUp: () => void;
}) {
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [error, setError] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const { signInWithEmail, signInWithOAuth } = useAuthClient();
  const router = useRouter();

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsLoading(true);
    setError(null);

    const { error } = await signInWithEmail(email, password);

    if (error) {
      setError(error.message);
      setIsLoading(false);
    } else {
      router.push("/dashboard");
      router.refresh();
    }
  };

  const handleOAuthSignIn = async (provider: "google" | "github") => {
    setIsLoading(true);
    setError(null);
    const { error } = await signInWithOAuth(provider);
    if (error) {
      setError(error.message);
      setIsLoading(false);
    }
  };

  return (
    <div className="mx-auto w-full mt-10 max-w-md p-6">
      <h2 className="text-2xl font-bold text-center mb-6">Sign In</h2>

      <form onSubmit={handleSubmit} className="space-y-4">
        <div>
          <label htmlFor="email" className="block text-sm font-medium text-gray-700">
            Email
          </label>
          <input
            id="email"
            type="email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
            required
            className="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
          />
        </div>

        <div>
          <label htmlFor="password" className="block text-sm font-medium text-gray-700">
            Password
          </label>
          <input
            id="password"
            type="password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            required
            className="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
          />
        </div>

        {error && (
          <div className="text-red-600 text-sm">{error}</div>
        )}

        <button
          type="submit"
          disabled={isLoading}
          className="w-full py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 disabled:opacity-50"
        >
          {isLoading ? "Signing in..." : "Sign In"}
        </button>
      </form>

      <div className="mt-4">
        <div className="relative">
          <div className="absolute inset-0 flex items-center">
            <div className="w-full border-t border-gray-300" />
          </div>
          <div className="relative flex justify-center text-sm">
            <span className="px-2 bg-white text-gray-500">Or continue with</span>
          </div>
        </div>

        <div className="mt-4 grid grid-cols-2 gap-3">
          <button
            onClick={() => handleOAuthSignIn("github")}
            disabled={isLoading}
            className="w-full py-2 px-4 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-50 disabled:opacity-50"
          >
            GitHub
          </button>
          <button
            onClick={() => handleOAuthSignIn("google")}
            disabled={isLoading}
            className="w-full py-2 px-4 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-50 disabled:opacity-50"
          >
            Google
          </button>
        </div>
      </div>

      <button
        type="button"
        onClick={onSwitchToSignUp}
        className="mt-4 w-full text-indigo-600 hover:text-indigo-800 text-sm"
      >
        Need an account? Sign Up
      </button>
    </div>
  );
}
`],
  ["auth/supabase-auth/web/react/next/src/components/sign-up-form.tsx.hbs", `"use client";

import { useState } from "react";
import { useAuthClient } from "@/lib/auth-client";
import { useRouter } from "next/navigation";

export default function SignUpForm({
  onSwitchToSignIn,
}: {
  onSwitchToSignIn: () => void;
}) {
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [confirmPassword, setConfirmPassword] = useState("");
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const { signUpWithEmail, signInWithOAuth } = useAuthClient();
  const router = useRouter();

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsLoading(true);
    setError(null);

    if (password !== confirmPassword) {
      setError("Passwords do not match");
      setIsLoading(false);
      return;
    }

    const { error } = await signUpWithEmail(email, password);

    if (error) {
      setError(error.message);
      setIsLoading(false);
    } else {
      setSuccess(true);
      setIsLoading(false);
    }
  };

  const handleOAuthSignIn = async (provider: "google" | "github") => {
    setIsLoading(true);
    setError(null);
    const { error } = await signInWithOAuth(provider);
    if (error) {
      setError(error.message);
      setIsLoading(false);
    }
  };

  if (success) {
    return (
      <div className="mx-auto w-full mt-10 max-w-md p-6 text-center">
        <h2 className="text-2xl font-bold mb-4">Check your email</h2>
        <p className="text-gray-600 mb-4">
          We've sent you a confirmation link. Please check your email to complete your registration.
        </p>
        <button
          onClick={onSwitchToSignIn}
          className="text-indigo-600 hover:text-indigo-800"
        >
          Back to Sign In
        </button>
      </div>
    );
  }

  return (
    <div className="mx-auto w-full mt-10 max-w-md p-6">
      <h2 className="text-2xl font-bold text-center mb-6">Sign Up</h2>

      <form onSubmit={handleSubmit} className="space-y-4">
        <div>
          <label htmlFor="email" className="block text-sm font-medium text-gray-700">
            Email
          </label>
          <input
            id="email"
            type="email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
            required
            className="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
          />
        </div>

        <div>
          <label htmlFor="password" className="block text-sm font-medium text-gray-700">
            Password
          </label>
          <input
            id="password"
            type="password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            required
            minLength={6}
            className="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
          />
        </div>

        <div>
          <label htmlFor="confirmPassword" className="block text-sm font-medium text-gray-700">
            Confirm Password
          </label>
          <input
            id="confirmPassword"
            type="password"
            value={confirmPassword}
            onChange={(e) => setConfirmPassword(e.target.value)}
            required
            minLength={6}
            className="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
          />
        </div>

        {error && (
          <div className="text-red-600 text-sm">{error}</div>
        )}

        <button
          type="submit"
          disabled={isLoading}
          className="w-full py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 disabled:opacity-50"
        >
          {isLoading ? "Creating account..." : "Sign Up"}
        </button>
      </form>

      <div className="mt-4">
        <div className="relative">
          <div className="absolute inset-0 flex items-center">
            <div className="w-full border-t border-gray-300" />
          </div>
          <div className="relative flex justify-center text-sm">
            <span className="px-2 bg-white text-gray-500">Or continue with</span>
          </div>
        </div>

        <div className="mt-4 grid grid-cols-2 gap-3">
          <button
            onClick={() => handleOAuthSignIn("github")}
            disabled={isLoading}
            className="w-full py-2 px-4 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-50 disabled:opacity-50"
          >
            GitHub
          </button>
          <button
            onClick={() => handleOAuthSignIn("google")}
            disabled={isLoading}
            className="w-full py-2 px-4 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-50 disabled:opacity-50"
          >
            Google
          </button>
        </div>
      </div>

      <button
        type="button"
        onClick={onSwitchToSignIn}
        className="mt-4 w-full text-indigo-600 hover:text-indigo-800 text-sm"
      >
        Already have an account? Sign In
      </button>
    </div>
  );
}
`],
  ["auth/supabase-auth/web/react/next/src/lib/auth-client.ts.hbs", `"use client";

import { createClient } from "@/lib/supabase/client";
import { useEffect, useState } from "react";
import type { User } from "@supabase/supabase-js";

export function useUser() {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    const supabase = createClient();

    // Get initial user
    supabase.auth.getUser().then(({ data: { user } }) => {
      setUser(user);
      setIsLoading(false);
    });

    // Listen for auth changes
    const {
      data: { subscription },
    } = supabase.auth.onAuthStateChange((_event, session) => {
      setUser(session?.user ?? null);
    });

    return () => subscription.unsubscribe();
  }, []);

  return { user, isLoading };
}

export function useAuthClient() {
  const { user, isLoading } = useUser();
  const supabase = createClient();

  return {
    user,
    isAuthenticated: !!user,
    isLoading,
    signOut: async () => {
      await supabase.auth.signOut();
    },
    signInWithEmail: async (email: string, password: string) => {
      return supabase.auth.signInWithPassword({ email, password });
    },
    signUpWithEmail: async (email: string, password: string) => {
      return supabase.auth.signUp({ email, password });
    },
    signInWithOAuth: async (provider: "google" | "github") => {
      return supabase.auth.signInWithOAuth({
        provider,
        options: {
          redirectTo: \`\${window.location.origin}/auth/callback\`,
        },
      });
    },
  };
}
`],
  ["examples/todo/web/react/tanstack-start/src/routes/todos.tsx.hbs", `import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Checkbox } from "@/components/ui/checkbox";
import { Input } from "@/components/ui/input";
import { createFileRoute } from "@tanstack/react-router";
{{#if (eq backend "convex")}}
import { Trash2 } from "lucide-react";
{{else}}
import { Loader2, Trash2 } from "lucide-react";
{{/if}}
import { useState } from "react";

{{#if (eq backend "convex")}}
import { useSuspenseQuery } from "@tanstack/react-query";
import { convexQuery } from "@convex-dev/react-query";
import { useMutation } from "convex/react";
import { api } from "@{{projectName}}/backend/convex/_generated/api";
import type { Id } from "@{{projectName}}/backend/convex/_generated/dataModel";
{{else}}
{{#if (eq api "trpc")}}
import { useTRPC } from "@/utils/trpc";
{{/if}}
{{#if (eq api "orpc")}}
import { orpc } from "@/utils/orpc";
{{/if}}
import { useMutation, useQuery } from "@tanstack/react-query";
{{/if}}

export const Route = createFileRoute("/todos")({
  component: TodosRoute,
});

function TodosRoute() {
  const [newTodoText, setNewTodoText] = useState("");

  {{#if (eq backend "convex")}}
  const todosQuery = useSuspenseQuery(convexQuery(api.todos.getAll, {}));
  const todos = todosQuery.data;

  const createTodo = useMutation(api.todos.create);
  const toggleTodo = useMutation(api.todos.toggle);
  const removeTodo = useMutation(api.todos.deleteTodo);

  const handleAddTodo = async (e: React.FormEvent) => {
    e.preventDefault();
    const text = newTodoText.trim();
    if (text) {
      setNewTodoText("");
      try {
        await createTodo({ text });
      } catch (error) {
        console.error("Failed to add todo:", error);
        setNewTodoText(text);
      }
    }
  };

  const handleToggleTodo = async (id: Id<"todos">, completed: boolean) => {
    try {
      await toggleTodo({ id, completed: !completed });
    } catch (error) {
      console.error("Failed to toggle todo:", error);
    }
  };

  const handleDeleteTodo = async (id: Id<"todos">) => {
    try {
      await removeTodo({ id });
    } catch (error) {
      console.error("Failed to delete todo:", error);
    }
  };
  {{else}}
    {{#if (eq api "trpc")}}
  const trpc = useTRPC();
    {{/if}}
    {{#if (eq api "orpc")}}
    {{/if}}

    {{#if (eq api "trpc")}}
  const todos = useQuery(trpc.todo.getAll.queryOptions());
  const createMutation = useMutation(
    trpc.todo.create.mutationOptions({
      onSuccess: () => {
        todos.refetch();
        setNewTodoText("");
      },
    }),
  );
  const toggleMutation = useMutation(
    trpc.todo.toggle.mutationOptions({
      onSuccess: () => { todos.refetch() },
    }),
  );
  const deleteMutation = useMutation(
    trpc.todo.delete.mutationOptions({
      onSuccess: () => { todos.refetch() },
    }),
  );
    {{/if}}
    {{#if (eq api "orpc")}}
  const todos = useQuery(orpc.todo.getAll.queryOptions());
  const createMutation = useMutation(
    orpc.todo.create.mutationOptions({
      onSuccess: () => {
        todos.refetch();
        setNewTodoText("");
      },
    }),
  );
  const toggleMutation = useMutation(
    orpc.todo.toggle.mutationOptions({
      onSuccess: () => { todos.refetch() },
    }),
  );
  const deleteMutation = useMutation(
    orpc.todo.delete.mutationOptions({
      onSuccess: () => { todos.refetch() },
    }),
  );
    {{/if}}

  const handleAddTodo = (e: React.FormEvent) => {
    e.preventDefault();
    if (newTodoText.trim()) {
      createMutation.mutate({ text: newTodoText });
    }
  };

  const handleToggleTodo = (id: number, completed: boolean) => {
    toggleMutation.mutate({ id, completed: !completed });
  };

  const handleDeleteTodo = (id: number) => {
    deleteMutation.mutate({ id });
  };
  {{/if}}

  return (
    <div className="mx-auto w-full max-w-md py-10">
      <Card>
        <CardHeader>
          <CardTitle>Todo List{{#if (eq backend "convex")}} (Convex){{/if}}</CardTitle>
          <CardDescription>Manage your tasks efficiently</CardDescription>
        </CardHeader>
        <CardContent>
          <form
            onSubmit={handleAddTodo}
            className="mb-6 flex items-center space-x-2"
          >
            <Input
              value={newTodoText}
              onChange={(e) => setNewTodoText(e.target.value)}
              placeholder="Add a new task..."
              {{#unless (eq backend "convex")}}
              disabled={createMutation.isPending}
              {{/unless}}
            />
            <Button
              type="submit"
              {{#unless (eq backend "convex")}}
              disabled={createMutation.isPending || !newTodoText.trim()}
              {{else}}
              disabled={!newTodoText.trim()}
              {{/unless}}
            >
              {{#unless (eq backend "convex")}}
              {createMutation.isPending ? (
                <Loader2 className="h-4 w-4 animate-spin" />
              ) : (
                "Add"
              )}
              {{else}}
              Add
              {{/unless}}
            </Button>
          </form>

          {{#if (eq backend "convex")}}
          {todos?.length === 0 ? (
            <p className="py-4 text-center">No todos yet. Add one above!</p>
          ) : (
            <ul className="space-y-2">
              {todos?.map((todo) => (
                <li
                  key={todo._id}
                  className="flex items-center justify-between rounded-md border p-2"
                >
                  <div className="flex items-center space-x-2">
                    <Checkbox
                      checked={todo.completed}
                      onCheckedChange={() =>
                        handleToggleTodo(todo._id, todo.completed)
                      }
                      id={\`todo-\${todo._id}\`}
                    />
                    <label
                      htmlFor={\`todo-\${todo._id}\`}
                      className={\`\${
                        todo.completed
                          ? "text-muted-foreground line-through"
                          : ""
                      }\`}
                    >
                      {todo.text}
                    </label>
                  </div>
                  <Button
                    variant="ghost"
                    size="icon"
                    onClick={() => handleDeleteTodo(todo._id)}
                    aria-label="Delete todo"
                  >
                    <Trash2 className="h-4 w-4" />
                  </Button>
                </li>
              ))}
            </ul>
          )}
          {{else}}
          {todos.isLoading ? (
            <div className="flex justify-center py-4">
              <Loader2 className="h-6 w-6 animate-spin" />
            </div>
          ) : todos.data?.length === 0 ? (
            <p className="py-4 text-center">No todos yet. Add one above!</p>
          ) : (
            <ul className="space-y-2">
              {todos.data?.map((todo) => (
                <li
                  key={todo.id}
                  className="flex items-center justify-between rounded-md border p-2"
                >
                  <div className="flex items-center space-x-2">
                    <Checkbox
                      checked={todo.completed}
                      onCheckedChange={() =>
                        handleToggleTodo(todo.id, todo.completed)
                      }
                      id={\`todo-\${todo.id}\`}
                    />
                    <label
                      htmlFor={\`todo-\${todo.id}\`}
                      className={\`\${todo.completed ? "line-through" : ""}\`}
                    >
                      {todo.text}
                    </label>
                  </div>
                  <Button
                    variant="ghost"
                    size="icon"
                    onClick={() => handleDeleteTodo(todo.id)}
                    aria-label="Delete todo"
                  >
                    <Trash2 className="h-4 w-4" />
                  </Button>
                </li>
              ))}
            </ul>
          )}
          {{/if}}
        </CardContent>
      </Card>
    </div>
  );
}
`],
  ["auth/clerk/convex/web/react/tanstack-start/src/start.ts.hbs", `import { clerkMiddleware } from '@clerk/tanstack-react-start/server'
import { createStart } from '@tanstack/react-start'

export const startInstance = createStart(() => {
	return {
		requestMiddleware: [clerkMiddleware()],
	}
})`],
  ["examples/ai/web/react/tanstack-router/src/routes/ai.tsx.hbs", `{{#if (eq backend "convex")}}
import { api } from "@{{projectName}}/backend/convex/_generated/api";
import {
  useUIMessages,
  useSmoothText,
  type UIMessage,
} from "@convex-dev/agent/react";
import { createFileRoute } from "@tanstack/react-router";
import { useMutation } from "convex/react";
import { Send, Loader2 } from "lucide-react";
import { useRef, useEffect, useState } from "react";
import { Streamdown } from "streamdown";

import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";

export const Route = createFileRoute("/ai")({
  component: RouteComponent,
});

function MessageContent({
  text,
  isStreaming,
}: {
  text: string;
  isStreaming: boolean;
}) {
  const [visibleText] = useSmoothText(text, {
    startStreaming: isStreaming,
  });
  return <Streamdown>{visibleText}</Streamdown>;
}

function RouteComponent() {
  const [input, setInput] = useState("");
  const [threadId, setThreadId] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const messagesEndRef = useRef<HTMLDivElement>(null);

  const createThread = useMutation(api.chat.createNewThread);
  const sendMessage = useMutation(api.chat.sendMessage);

  const { results: messages } = useUIMessages(
    api.chat.listMessages,
    threadId ? { threadId } : "skip",
    { initialNumItems: 50, stream: true },
  );

  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  }, [messages]);

  const hasStreamingMessage = messages?.some(
    (m: UIMessage) => m.status === "streaming",
  );

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    const text = input.trim();
    if (!text || isLoading) return;

    setIsLoading(true);
    setInput("");

    try {
      let currentThreadId = threadId;
      if (!currentThreadId) {
        currentThreadId = await createThread();
        setThreadId(currentThreadId);
      }

      await sendMessage({ threadId: currentThreadId, prompt: text });
    } catch (error) {
      console.error("Failed to send message:", error);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="grid grid-rows-[1fr_auto] overflow-hidden w-full mx-auto p-4">
      <div className="overflow-y-auto space-y-4 pb-4">
        {!messages || messages.length === 0 ? (
          <div className="text-center text-muted-foreground mt-8">
            Ask me anything to get started!
          </div>
        ) : (
          messages.map((message: UIMessage) => (
            <div
              key={message.key}
              className={\`p-3 rounded-lg \${
                message.role === "user"
                  ? "bg-primary/10 ml-8"
                  : "bg-secondary/20 mr-8"
              }\`}
            >
              <p className="text-sm font-semibold mb-1">
                {message.role === "user" ? "You" : "AI Assistant"}
              </p>
              <MessageContent
                text={message.text ?? ""}
                isStreaming={message.status === "streaming"}
              />
            </div>
          ))
        )}
        {isLoading && !hasStreamingMessage && (
          <div className="p-3 rounded-lg bg-secondary/20 mr-8">
            <p className="text-sm font-semibold mb-1">AI Assistant</p>
            <div className="flex items-center gap-2 text-muted-foreground">
              <Loader2 className="h-4 w-4 animate-spin" />
              <span>Thinking...</span>
            </div>
          </div>
        )}
        <div ref={messagesEndRef} />
      </div>

      <form
        onSubmit={handleSubmit}
        className="w-full flex items-center space-x-2 pt-2 border-t"
      >
        <Input
          name="prompt"
          value={input}
          onChange={(e) => setInput(e.target.value)}
          placeholder="Type your message..."
          className="flex-1"
          autoComplete="off"
          autoFocus
          disabled={isLoading}
        />
        <Button type="submit" size="icon" disabled={isLoading || !input.trim()}>
          {isLoading ? (
            <Loader2 className="h-4 w-4 animate-spin" />
          ) : (
            <Send size={18} />
          )}
        </Button>
      </form>
    </div>
  );
}
{{else if (eq ai "modelfusion")}}
import { createFileRoute } from "@tanstack/react-router";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Send, Loader2 } from "lucide-react";
import { useRef, useEffect, useState, useCallback } from "react";
import { Streamdown } from "streamdown";
{{#unless (eq backend "self")}}
import { env } from "@{{projectName}}/env/web";
{{/unless}}

type Message = {
  id: string;
  role: "user" | "assistant";
  content: string;
};

export const Route = createFileRoute("/ai")({
  component: RouteComponent,
});

function RouteComponent() {
  const [input, setInput] = useState("");
  const [messages, setMessages] = useState<Message[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [streamingContent, setStreamingContent] = useState("");
  const messagesEndRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  }, [messages, streamingContent]);

  const sendMessage = useCallback(async (text: string) => {
    const userMessage: Message = {
      id: Date.now().toString(),
      role: "user",
      content: text,
    };

    setMessages((prev) => [...prev, userMessage]);
    setIsLoading(true);
    setStreamingContent("");

    try {
      const response = await fetch({{#if (eq backend "self")}}"/api/ai"{{else}}\`\${env.VITE_SERVER_URL}/ai\`{{/if}}, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          messages: [...messages, userMessage].map((m) => ({
            role: m.role,
            content: m.content,
          })),
        }),
      });

      if (!response.ok) throw new Error("Failed to send message");

      const reader = response.body?.getReader();
      const decoder = new TextDecoder();
      let fullContent = "";

      if (reader) {
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          const chunk = decoder.decode(value, { stream: true });
          const lines = chunk.split("\\n");

          for (const line of lines) {
            if (line.startsWith("data: ")) {
              const data = line.slice(6);
              if (data === "[DONE]") continue;
              try {
                const parsed = JSON.parse(data);
                if (parsed.content) {
                  fullContent += parsed.content;
                  setStreamingContent(fullContent);
                }
              } catch {
                // Ignore parsing errors for incomplete chunks
              }
            }
          }
        }
      }

      const assistantMessage: Message = {
        id: (Date.now() + 1).toString(),
        role: "assistant",
        content: fullContent,
      };
      setMessages((prev) => [...prev, assistantMessage]);
      setStreamingContent("");
    } catch (error) {
      console.error("Failed to send message:", error);
    } finally {
      setIsLoading(false);
    }
  }, [messages]);

  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    const text = input.trim();
    if (!text || isLoading) return;
    setInput("");
    sendMessage(text);
  };

  return (
    <div className="grid grid-rows-[1fr_auto] overflow-hidden w-full mx-auto p-4">
      <div className="overflow-y-auto space-y-4 pb-4">
        {messages.length === 0 && !streamingContent ? (
          <div className="text-center text-muted-foreground mt-8">
            Ask me anything to get started!
          </div>
        ) : (
          <>
            {messages.map((message) => (
              <div
                key={message.id}
                className={\`p-3 rounded-lg \${
                  message.role === "user"
                    ? "bg-primary/10 ml-8"
                    : "bg-secondary/20 mr-8"
                }\`}
              >
                <p className="text-sm font-semibold mb-1">
                  {message.role === "user" ? "You" : "AI Assistant"}
                </p>
                <Streamdown>{message.content}</Streamdown>
              </div>
            ))}
            {streamingContent && (
              <div className="p-3 rounded-lg bg-secondary/20 mr-8">
                <p className="text-sm font-semibold mb-1">AI Assistant</p>
                <Streamdown isAnimating>{streamingContent}</Streamdown>
              </div>
            )}
          </>
        )}
        {isLoading && !streamingContent && (
          <div className="p-3 rounded-lg bg-secondary/20 mr-8">
            <p className="text-sm font-semibold mb-1">AI Assistant</p>
            <div className="flex items-center gap-2 text-muted-foreground">
              <Loader2 className="h-4 w-4 animate-spin" />
              <span>Thinking...</span>
            </div>
          </div>
        )}
        <div ref={messagesEndRef} />
      </div>

      <form
        onSubmit={handleSubmit}
        className="w-full flex items-center space-x-2 pt-2 border-t"
      >
        <Input
          name="prompt"
          value={input}
          onChange={(e) => setInput(e.target.value)}
          placeholder="Type your message..."
          className="flex-1"
          autoComplete="off"
          autoFocus
          disabled={isLoading}
        />
        <Button type="submit" size="icon" disabled={isLoading || !input.trim()}>
          {isLoading ? (
            <Loader2 className="h-4 w-4 animate-spin" />
          ) : (
            <Send size={18} />
          )}
        </Button>
      </form>
    </div>
  );
}
{{else if (eq ai "langgraph")}}
import { createFileRoute } from "@tanstack/react-router";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Send, Loader2 } from "lucide-react";
import { useRef, useEffect, useState, useCallback } from "react";
import { Streamdown } from "streamdown";
{{#unless (eq backend "self")}}
import { env } from "@{{projectName}}/env/web";
{{/unless}}

type Message = {
  id: string;
  role: "user" | "assistant";
  content: string;
};

export const Route = createFileRoute("/ai")({
  component: RouteComponent,
});

function RouteComponent() {
  const [input, setInput] = useState("");
  const [messages, setMessages] = useState<Message[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [streamingContent, setStreamingContent] = useState("");
  const messagesEndRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  }, [messages, streamingContent]);

  const sendMessage = useCallback(async (text: string) => {
    const userMessage: Message = {
      id: Date.now().toString(),
      role: "user",
      content: text,
    };

    setMessages((prev) => [...prev, userMessage]);
    setIsLoading(true);
    setStreamingContent("");

    try {
      const response = await fetch({{#if (eq backend "self")}}"/api/ai"{{else}}\`\${env.VITE_SERVER_URL}/ai\`{{/if}}, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          messages: [...messages, userMessage].map((m) => ({
            role: m.role,
            content: m.content,
          })),
        }),
      });

      if (!response.ok) throw new Error("Failed to send message");

      const reader = response.body?.getReader();
      const decoder = new TextDecoder();
      let fullContent = "";

      if (reader) {
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          const chunk = decoder.decode(value, { stream: true });
          const lines = chunk.split("\\n");

          for (const line of lines) {
            if (line.startsWith("data: ")) {
              const data = line.slice(6);
              if (data === "[DONE]") continue;
              try {
                const parsed = JSON.parse(data);
                if (parsed.content) {
                  fullContent += parsed.content;
                  setStreamingContent(fullContent);
                }
              } catch {
                // Ignore parsing errors for incomplete chunks
              }
            }
          }
        }
      }

      const assistantMessage: Message = {
        id: (Date.now() + 1).toString(),
        role: "assistant",
        content: fullContent,
      };
      setMessages((prev) => [...prev, assistantMessage]);
      setStreamingContent("");
    } catch (error) {
      console.error("Failed to send message:", error);
    } finally {
      setIsLoading(false);
    }
  }, [messages]);

  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    const text = input.trim();
    if (!text || isLoading) return;
    setInput("");
    sendMessage(text);
  };

  return (
    <div className="grid grid-rows-[1fr_auto] overflow-hidden w-full mx-auto p-4">
      <div className="overflow-y-auto space-y-4 pb-4">
        {messages.length === 0 && !streamingContent ? (
          <div className="text-center text-muted-foreground mt-8">
            Ask me anything to get started!
          </div>
        ) : (
          <>
            {messages.map((message) => (
              <div
                key={message.id}
                className={\`p-3 rounded-lg \${
                  message.role === "user"
                    ? "bg-primary/10 ml-8"
                    : "bg-secondary/20 mr-8"
                }\`}
              >
                <p className="text-sm font-semibold mb-1">
                  {message.role === "user" ? "You" : "AI Assistant"}
                </p>
                <Streamdown>{message.content}</Streamdown>
              </div>
            ))}
            {streamingContent && (
              <div className="p-3 rounded-lg bg-secondary/20 mr-8">
                <p className="text-sm font-semibold mb-1">AI Assistant</p>
                <Streamdown isAnimating>{streamingContent}</Streamdown>
              </div>
            )}
          </>
        )}
        {isLoading && !streamingContent && (
          <div className="p-3 rounded-lg bg-secondary/20 mr-8">
            <p className="text-sm font-semibold mb-1">AI Assistant</p>
            <div className="flex items-center gap-2 text-muted-foreground">
              <Loader2 className="h-4 w-4 animate-spin" />
              <span>Thinking...</span>
            </div>
          </div>
        )}
        <div ref={messagesEndRef} />
      </div>

      <form
        onSubmit={handleSubmit}
        className="w-full flex items-center space-x-2 pt-2 border-t"
      >
        <Input
          name="prompt"
          value={input}
          onChange={(e) => setInput(e.target.value)}
          placeholder="Type your message..."
          className="flex-1"
          autoComplete="off"
          autoFocus
          disabled={isLoading}
        />
        <Button type="submit" size="icon" disabled={isLoading || !input.trim()}>
          {isLoading ? (
            <Loader2 className="h-4 w-4 animate-spin" />
          ) : (
            <Send size={18} />
          )}
        </Button>
      </form>
    </div>
  );
}
{{else}}
import { createFileRoute } from "@tanstack/react-router";
import { useChat } from "@ai-sdk/react";
import { DefaultChatTransport } from "ai";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Send } from "lucide-react";
import { useRef, useEffect, useState } from "react";
import { Streamdown } from "streamdown";
{{#unless (eq backend "self")}}
import { env } from "@{{projectName}}/env/web";
{{/unless}}

export const Route = createFileRoute("/ai")({
  component: RouteComponent,
});

function RouteComponent() {
  const [input, setInput] = useState("");
  const { messages, sendMessage, status } = useChat({
    transport: new DefaultChatTransport({
      api: {{#if (eq backend "self")}}"/api/ai"{{else}}\`\${env.VITE_SERVER_URL}/ai\`{{/if}},
    }),
  });

  const messagesEndRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  }, [messages]);

  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    const text = input.trim();
    if (!text) return;
    sendMessage({ text });
    setInput("");
  };

  return (
    <div className="grid grid-rows-[1fr_auto] overflow-hidden w-full mx-auto p-4">
      <div className="overflow-y-auto space-y-4 pb-4">
        {messages.length === 0 ? (
          <div className="text-center text-muted-foreground mt-8">
            Ask me anything to get started!
          </div>
        ) : (
          messages.map((message) => (
            <div
              key={message.id}
              className={\`p-3 rounded-lg \${
                message.role === "user"
                  ? "bg-primary/10 ml-8"
                  : "bg-secondary/20 mr-8"
              }\`}
            >
              <p className="text-sm font-semibold mb-1">
                {message.role === "user" ? "You" : "AI Assistant"}
              </p>
              {message.parts?.map((part, index) => {
                if (part.type === "text") {
                  return (
                    <Streamdown
                      key={index}
                      isAnimating={status === "streaming" && message.role === "assistant"}
                    >
                      {part.text}
                    </Streamdown>
                  );
                }
                return null;
              })}
            </div>
          ))
        )}
        <div ref={messagesEndRef} />
      </div>

      <form
        onSubmit={handleSubmit}
        className="w-full flex items-center space-x-2 pt-2 border-t"
      >
        <Input
          name="prompt"
          value={input}
          onChange={(e) => setInput(e.target.value)}
          placeholder="Type your message..."
          className="flex-1"
          autoComplete="off"
          autoFocus
        />
        <Button type="submit" size="icon">
          <Send size={18} />
        </Button>
      </form>
    </div>
  );
}
{{/if}}
`],
  ["auth/clerk/convex/web/react/next/src/middleware.ts.hbs", `import { clerkMiddleware } from "@clerk/nextjs/server";

export default clerkMiddleware();

export const config = {
	matcher: [
		// Skip Next.js internals and all static files, unless found in search params
		"/((?!_next|[^?]*\\\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)",
		// Always run for API routes
		"/(api|trpc)(.*)",
	],
};
`],
  ["examples/todo/web/react/tanstack-router/src/routes/todos.tsx.hbs", `import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Checkbox } from "@/components/ui/checkbox";
import { Input } from "@/components/ui/input";
import { createFileRoute } from "@tanstack/react-router";
import { Loader2, Trash2 } from "lucide-react";
import { useState } from "react";

{{#if (eq backend "convex")}}
import { useMutation, useQuery } from "convex/react";
import { api } from "@{{projectName}}/backend/convex/_generated/api";
import type { Id } from "@{{projectName}}/backend/convex/_generated/dataModel";
{{else}}
  {{#if (eq api "orpc")}}
  import { orpc } from "@/utils/orpc";
  {{/if}}
  {{#if (eq api "trpc")}}
  import { trpc } from "@/utils/trpc";
  {{/if}}
import { useMutation, useQuery } from "@tanstack/react-query";
{{/if}}

export const Route = createFileRoute("/todos")({
  component: TodosRoute,
});

function TodosRoute() {
  const [newTodoText, setNewTodoText] = useState("");

  {{#if (eq backend "convex")}}
  const todos = useQuery(api.todos.getAll);
  const createTodo = useMutation(api.todos.create);
  const toggleTodo = useMutation(api.todos.toggle);
  const deleteTodo = useMutation(api.todos.deleteTodo);

  const handleAddTodo = async (e: React.FormEvent) => {
    e.preventDefault();
    const text = newTodoText.trim();
    if (!text) return;
    await createTodo({ text });
    setNewTodoText("");
  };

  const handleToggleTodo = (id: Id<"todos">, currentCompleted: boolean) => {
    toggleTodo({ id, completed: !currentCompleted });
  };

  const handleDeleteTodo = (id: Id<"todos">) => {
    deleteTodo({ id });
  };
  {{else}}
    {{#if (eq api "orpc")}}
    const todos = useQuery(orpc.todo.getAll.queryOptions());
    const createMutation = useMutation(
      orpc.todo.create.mutationOptions({
        onSuccess: () => {
          todos.refetch();
          setNewTodoText("");
        },
      }),
    );
    const toggleMutation = useMutation(
      orpc.todo.toggle.mutationOptions({
        onSuccess: () => { todos.refetch() },
      }),
    );
    const deleteMutation = useMutation(
      orpc.todo.delete.mutationOptions({
        onSuccess: () => { todos.refetch() },
      }),
    );
    {{/if}}
    {{#if (eq api "trpc")}}
    const todos = useQuery(trpc.todo.getAll.queryOptions());
    const createMutation = useMutation(
      trpc.todo.create.mutationOptions({
        onSuccess: () => {
          todos.refetch();
          setNewTodoText("");
        },
      }),
    );
    const toggleMutation = useMutation(
      trpc.todo.toggle.mutationOptions({
        onSuccess: () => { todos.refetch() },
      }),
    );
    const deleteMutation = useMutation(
      trpc.todo.delete.mutationOptions({
        onSuccess: () => { todos.refetch() },
      }),
    );
    {{/if}}

  const handleAddTodo = (e: React.FormEvent) => {
    e.preventDefault();
    if (newTodoText.trim()) {
      createMutation.mutate({ text: newTodoText });
    }
  };

  const handleToggleTodo = (id: number, completed: boolean) => {
    toggleMutation.mutate({ id, completed: !completed });
  };

  const handleDeleteTodo = (id: number) => {
    deleteMutation.mutate({ id });
  };
  {{/if}}

  return (
    <div className="mx-auto w-full max-w-md py-10">
      <Card>
        <CardHeader>
          <CardTitle>Todo List</CardTitle>
          <CardDescription>Manage your tasks efficiently</CardDescription>
        </CardHeader>
        <CardContent>
          <form
            onSubmit={handleAddTodo}
            className="mb-6 flex items-center space-x-2"
          >
            <Input
              value={newTodoText}
              onChange={(e) => setNewTodoText(e.target.value)}
              placeholder="Add a new task..."
              {{#if (eq backend "convex")}}
              {{else}}
              disabled={createMutation.isPending}
              {{/if}}
            />
            <Button
              type="submit"
              {{#if (eq backend "convex")}}
              disabled={!newTodoText.trim()}
              {{else}}
              disabled={createMutation.isPending || !newTodoText.trim()}
              {{/if}}
            >
              {{#if (eq backend "convex")}}
              Add
              {{else}}
                {createMutation.isPending ? (
                  <Loader2 className="h-4 w-4 animate-spin" />
                ) : (
                  "Add"
                )}
              {{/if}}
            </Button>
          </form>

          {{#if (eq backend "convex")}}
            {todos === undefined ? (
              <div className="flex justify-center py-4">
                <Loader2 className="h-6 w-6 animate-spin" />
              </div>
            ) : todos.length === 0 ? (
              <p className="py-4 text-center">No todos yet. Add one above!</p>
            ) : (
              <ul className="space-y-2">
                {todos.map((todo) => (
                  <li
                    key={todo._id}
                    className="flex items-center justify-between rounded-md border p-2"
                  >
                    <div className="flex items-center space-x-2">
                      <Checkbox
                        checked={todo.completed}
                        onCheckedChange={() =>
                          handleToggleTodo(todo._id, todo.completed)
                        }
                        id={\`todo-\${todo._id}\`}
                      />
                      <label
                        htmlFor={\`todo-\${todo._id}\`}
                        className={\`\${todo.completed ? "line-through text-muted-foreground" : ""}\`}
                      >
                        {todo.text}
                      </label>
                    </div>
                    <Button
                      variant="ghost"
                      size="icon"
                      onClick={() => handleDeleteTodo(todo._id)}
                      aria-label="Delete todo"
                    >
                      <Trash2 className="h-4 w-4" />
                    </Button>
                  </li>
                ))}
              </ul>
            )}
          {{else}}
            {todos.isLoading ? (
              <div className="flex justify-center py-4">
                <Loader2 className="h-6 w-6 animate-spin" />
              </div>
            ) : todos.data?.length === 0 ? (
              <p className="py-4 text-center">
                No todos yet. Add one above!
              </p>
            ) : (
              <ul className="space-y-2">
                {todos.data?.map((todo) => (
                  <li
                    key={todo.id}
                    className="flex items-center justify-between rounded-md border p-2"
                  >
                    <div className="flex items-center space-x-2">
                      <Checkbox
                        checked={todo.completed}
                        onCheckedChange={() =>
                          handleToggleTodo(todo.id, todo.completed)
                        }
                        id={\`todo-\${todo.id}\`}
                      />
                      <label
                        htmlFor={\`todo-\${todo.id}\`}
                        className={\`\${todo.completed ? "line-through" : ""}\`}
                      >
                        {todo.text}
                      </label>
                    </div>
                    <Button
                      variant="ghost"
                      size="icon"
                      onClick={() => handleDeleteTodo(todo.id)}
                      aria-label="Delete todo"
                    >
                      <Trash2 className="h-4 w-4" />
                    </Button>
                  </li>
                ))}
              </ul>
            )}
          {{/if}}
        </CardContent>
      </Card>
    </div>
  );
}
`],
  ["examples/todo/server/prisma/base/src/routers/todo.ts.hbs", `{{#if (eq api "orpc")}}
import z from "zod";
import prisma from "@{{projectName}}/db";
import { publicProcedure } from "../index";

export const todoRouter = {
  getAll: publicProcedure.handler(async () => {
    return await prisma.todo.findMany({
      orderBy: {
        id: "asc",
      },
    });
  }),

  create: publicProcedure
    .input(z.object({ text: z.string().min(1) }))
    .handler(async ({ input }) => {
      return await prisma.todo.create({
        data: {
          text: input.text,
        },
      });
    }),

  toggle: publicProcedure
    {{#if (eq database "mongodb")}}
    .input(z.object({ id: z.string(), completed: z.boolean() }))
    {{else}}
    .input(z.object({ id: z.number(), completed: z.boolean() }))
    {{/if}}
    .handler(async ({ input }) => {
      return await prisma.todo.update({
        where: { id: input.id },
        data: { completed: input.completed },
      });
    }),

  delete: publicProcedure
    {{#if (eq database "mongodb")}}
    .input(z.object({ id: z.string() }))
    {{else}}
    .input(z.object({ id: z.number() }))
    {{/if}}
    .handler(async ({ input }) => {
      return await prisma.todo.delete({
        where: { id: input.id },
      });
    }),
};
{{/if}}

{{#if (eq api "trpc")}}
import { TRPCError } from "@trpc/server";
import z from "zod";
import prisma from "@{{projectName}}/db";
import { publicProcedure, router } from "../index";

export const todoRouter = router({
  getAll: publicProcedure.query(async () => {
    return await prisma.todo.findMany({
      orderBy: {
        id: "asc"
      }
    });
  }),

  create: publicProcedure
    .input(z.object({ text: z.string().min(1) }))
    .mutation(async ({ input }) => {
      return await prisma.todo.create({
        data: {
          text: input.text,
        },
      });
    }),

  toggle: publicProcedure
    {{#if (eq database "mongodb")}}
    .input(z.object({ id: z.string(), completed: z.boolean() }))
    {{else}}
    .input(z.object({ id: z.number(), completed: z.boolean() }))
    {{/if}}
    .mutation(async ({ input }) => {
      try {
        return await prisma.todo.update({
          where: { id: input.id },
          data: { completed: input.completed },
        });
      } catch (error) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "Todo not found",
        });
      }
    }),

  delete: publicProcedure
    {{#if (eq database "mongodb")}}
    .input(z.object({ id: z.string() }))
    {{else}}
    .input(z.object({ id: z.number() }))
    {{/if}}
    .mutation(async ({ input }) => {
      try {
        return await prisma.todo.delete({
          where: { id: input.id },
        });
      } catch (error) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "Todo not found",
        });
      }
    }),
});
{{/if}}
`],
  ["auth/better-auth/web/react/tanstack-start/src/routes/login.tsx.hbs", `import SignInForm from "@/components/sign-in-form";
import SignUpForm from "@/components/sign-up-form";
import { createFileRoute } from "@tanstack/react-router";
import { useState } from "react";

export const Route = createFileRoute("/login")({
  component: RouteComponent,
});

function RouteComponent() {
  const [showSignIn, setShowSignIn] = useState(false);

  return showSignIn ? (
    <SignInForm onSwitchToSignUp={() => setShowSignIn(false)} />
  ) : (
    <SignUpForm onSwitchToSignIn={() => setShowSignIn(true)} />
  );
}
`],
  ["auth/better-auth/web/react/tanstack-start/src/routes/dashboard.tsx.hbs", `import { getUser } from "@/functions/get-user";
{{#if (eq payments "polar") }}
import { Button } from "@/components/ui/button";
import { authClient } from "@/lib/auth-client";
import { getPayment } from "@/functions/get-payment";
{{/if}}
{{#if (eq api "trpc") }}
import { useTRPC } from "@/utils/trpc";
import { useQuery } from "@tanstack/react-query";
{{/if}}
{{#if (eq api "orpc") }}
import { orpc } from "@/utils/orpc";
import { useQuery } from "@tanstack/react-query";
{{/if}}
import { createFileRoute, redirect } from "@tanstack/react-router";

export const Route = createFileRoute("/dashboard")({
  component: RouteComponent,
  beforeLoad: async () => {
    const session = await getUser();
    {{#if (eq payments "polar") }}
    const customerState = await getPayment();
    return { session, customerState };
    {{else}}
    return { session };
    {{/if}}
  },
  loader: async ({ context }) => {
    if (!context.session) {
      throw redirect({
        to: "/login",
      });
    }
  },
});

function RouteComponent() {
  const { session{{#if (eq payments "polar") }}, customerState{{/if}} } = Route.useRouteContext();

  {{#if (eq api "trpc") }}
  const trpc = useTRPC();
  const privateData = useQuery(trpc.privateData.queryOptions());
  {{/if}}
  {{#if (eq api "orpc") }}
  const privateData = useQuery(orpc.privateData.queryOptions());
  {{/if}}

  {{#if (eq payments "polar") }}
  const hasProSubscription = (customerState?.activeSubscriptions?.length ?? 0) > 0;
  // For debugging: console.log("Active subscriptions:", customerState?.activeSubscriptions);
  {{/if}}

  return (
    <div>
      <h1>Dashboard</h1>
      <p>Welcome {session?.user.name}</p>
      {{#if (eq api "trpc") }}
      <p>API: {privateData.data?.message}</p>
      {{else if (eq api "orpc") }}
      <p>API: {privateData.data?.message}</p>
      {{/if}}
      {{#if (eq payments "polar") }}
      <p>Plan: {hasProSubscription ? "Pro" : "Free"}</p>
      {hasProSubscription ? (
        <Button
          onClick={async function handlePortal() {
            await authClient.customer.portal();
          }}
        >
          Manage Subscription
        </Button>
      ) : (
        <Button
          onClick={async function handleUpgrade() {
            await authClient.checkout({ slug: "pro" });
          }}
        >
          Upgrade to Pro
        </Button>
      )}
      {{/if}}
    </div>
  );
}`],
  ["auth/auth0/web/react/next/src/lib/auth-client.ts.hbs", `"use client";

import { useUser as useAuth0User, UserProvider } from "@auth0/nextjs-auth0/client";

export function AuthProvider({ children }: { children: React.ReactNode }) {
  return <UserProvider>{children}</UserProvider>;
}

export function useUser() {
  const { user, isLoading, error } = useAuth0User();

  return {
    user: user
      ? {
          id: user.sub || "",
          email: user.email || "",
          name: user.name || "",
          image: user.picture || "",
        }
      : null,
    isLoading,
    error,
  };
}

export function useAuthClient() {
  const { user, isLoading, error } = useAuth0User();

  return {
    user: user
      ? {
          id: user.sub || "",
          email: user.email || "",
          name: user.name || "",
          image: user.picture || "",
        }
      : null,
    isAuthenticated: !!user,
    isLoading,
    error,
    signOut: () => {
      window.location.href = "/api/auth/logout";
    },
    signIn: () => {
      window.location.href = "/api/auth/login";
    },
  };
}
`],
  ["auth/auth0/web/react/next/src/components/user-menu.tsx.hbs", `"use client";

import { useAuthClient } from "@/lib/auth-client";
import Link from "next/link";

export default function UserMenu() {
  const { user, isAuthenticated, isLoading, signOut, signIn } = useAuthClient();

  if (isLoading) {
    return (
      <div className="h-8 w-8 rounded-full bg-gray-200 animate-pulse" />
    );
  }

  if (!isAuthenticated) {
    return (
      <button
        onClick={signIn}
        className="px-4 py-2 text-sm font-medium text-white bg-indigo-600 rounded-md hover:bg-indigo-700"
      >
        Sign In
      </button>
    );
  }

  return (
    <div className="relative group">
      <button className="flex items-center space-x-2">
        {user?.image ? (
          <img
            src={user.image}
            alt={user.name || "User avatar"}
            className="h-8 w-8 rounded-full"
          />
        ) : (
          <div className="h-8 w-8 rounded-full bg-indigo-600 flex items-center justify-center text-white text-sm font-medium">
            {user?.name?.charAt(0) || user?.email?.charAt(0) || "U"}
          </div>
        )}
        <span className="text-sm font-medium text-gray-700">
          {user?.name || user?.email}
        </span>
      </button>

      <div className="absolute right-0 mt-2 w-48 py-1 bg-white rounded-md shadow-lg opacity-0 invisible group-hover:opacity-100 group-hover:visible transition-all duration-200 z-50">
        <Link
          href="/dashboard"
          className="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100"
        >
          Dashboard
        </Link>
        <button
          onClick={signOut}
          className="w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100"
        >
          Sign Out
        </button>
      </div>
    </div>
  );
}
`],
  ["auth/auth0/web/react/next/src/components/sign-in-form.tsx.hbs", `"use client";

import { useAuthClient } from "@/lib/auth-client";

export default function SignInForm() {
  const { signIn, isLoading } = useAuthClient();

  return (
    <div className="mx-auto w-full mt-10 max-w-md p-6">
      <h2 className="text-2xl font-bold text-center mb-6">Sign In</h2>

      <p className="text-center text-gray-600 mb-6">
        Click the button below to sign in with Auth0.
      </p>

      <button
        onClick={signIn}
        disabled={isLoading}
        className="w-full py-3 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 disabled:opacity-50"
      >
        {isLoading ? "Loading..." : "Sign In with Auth0"}
      </button>

      <p className="mt-4 text-center text-sm text-gray-500">
        You'll be redirected to Auth0 to complete the sign-in process.
      </p>
    </div>
  );
}
`],
  ["examples/todo/server/drizzle/postgres/src/schema/todo.ts", `import { pgTable, text, boolean, serial } from "drizzle-orm/pg-core";

export const todo = pgTable("todo", {
  id: serial("id").primaryKey(),
  text: text("text").notNull(),
  completed: boolean("completed").default(false).notNull(),
});
`],
  ["examples/todo/server/drizzle/base/src/routers/todo.ts.hbs", `{{#if (eq api "orpc")}}
import { eq } from "drizzle-orm";
import z from "zod";
import { db } from "@{{projectName}}/db";
import { todo } from "@{{projectName}}/db/schema/todo";
import { publicProcedure } from "../index";

export const todoRouter = {
  getAll: publicProcedure.handler(async () => {
    return await db.select().from(todo);
  }),

  create: publicProcedure
    .input(z.object({ text: z.string().min(1) }))
    .handler(async ({ input }) => {
      return await db
        .insert(todo)
        .values({
          text: input.text,
        });
    }),

  toggle: publicProcedure
    .input(z.object({ id: z.number(), completed: z.boolean() }))
    .handler(async ({ input }) => {
      return await db
        .update(todo)
        .set({ completed: input.completed })
        .where(eq(todo.id, input.id));
    }),

  delete: publicProcedure
    .input(z.object({ id: z.number() }))
    .handler(async ({ input }) => {
      return await db.delete(todo).where(eq(todo.id, input.id));
    }),
};
{{/if}}

{{#if (eq api "trpc")}}
import z from "zod";
import { router, publicProcedure } from "../index";
import { todo } from "@{{projectName}}/db/schema/todo";
import { eq } from "drizzle-orm";
import { db } from "@{{projectName}}/db";

export const todoRouter = router({
  getAll: publicProcedure.query(async () => {
    return await db.select().from(todo);
  }),

  create: publicProcedure
    .input(z.object({ text: z.string().min(1) }))
    .mutation(async ({ input }) => {
      return await db.insert(todo).values({
        text: input.text,
      });
    }),

  toggle: publicProcedure
    .input(z.object({ id: z.number(), completed: z.boolean() }))
    .mutation(async ({ input }) => {
      return await db
        .update(todo)
        .set({ completed: input.completed })
        .where(eq(todo.id, input.id));
    }),

  delete: publicProcedure
    .input(z.object({ id: z.number() }))
    .mutation(async ({ input }) => {
      return await db.delete(todo).where(eq(todo.id, input.id));
    }),
});
{{/if}}
`],
  ["examples/todo/server/mongoose/base/src/routers/todo.ts.hbs", `{{#if (eq api "orpc")}}
import z from "zod";
import { publicProcedure } from "../index";
import { Todo } from "@{{projectName}}/db/models/todo.model";

export const todoRouter = {
    getAll: publicProcedure.handler(async () => {
        return await Todo.find().lean();
    }),

    create: publicProcedure
        .input(z.object({ text: z.string().min(1) }))
        .handler(async ({ input }) => {
            const newTodo = await Todo.create({ text: input.text });
            return newTodo.toObject();
    }),

    toggle: publicProcedure
        .input(z.object({ id: z.string(), completed: z.boolean() }))
        .handler(async ({ input }) => {
            await Todo.updateOne({ id: input.id }, { completed: input.completed });
            return { success: true };
    }),

    delete: publicProcedure
        .input(z.object({ id: z.string() }))
        .handler(async ({ input }) => {
            await Todo.deleteOne({ id: input.id });
            return { success: true };
    }),
};

{{/if}}

{{#if (eq api "trpc")}}
import z from "zod";
import { router, publicProcedure } from "../index";
import { Todo } from "@{{projectName}}/db/models/todo.model";

export const todoRouter = router({
    getAll: publicProcedure.query(async () => {
        return await Todo.find().lean();
    }),

    create: publicProcedure
        .input(z.object({ text: z.string().min(1) }))
        .mutation(async ({ input }) => {
            const newTodo = await Todo.create({ text: input.text });
        return newTodo.toObject();
    }),

    toggle: publicProcedure
        .input(z.object({ id: z.string(), completed: z.boolean() }))
        .mutation(async ({ input }) => {
            await Todo.updateOne({ id: input.id }, { completed: input.completed });
            return { success: true };
    }),

    delete: publicProcedure
        .input(z.object({ id: z.string() }))
        .mutation(async ({ input }) => {
            await Todo.deleteOne({ id: input.id });
            return { success: true };
    }),
});
{{/if}}
`],
  ["examples/todo/server/drizzle/mysql/src/schema/todo.ts", `import { mysqlTable, varchar, int, boolean } from "drizzle-orm/mysql-core";

export const todo = mysqlTable("todo", {
  id: int("id").primaryKey().autoincrement(),
  text: varchar("text", { length: 255 }).notNull(),
  completed: boolean("completed").default(false).notNull(),
});
`],
  ["auth/supabase-auth/fullstack/next/src/lib/supabase/client.ts.hbs", `import { createBrowserClient } from "@supabase/ssr";

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );
}
`],
  ["auth/supabase-auth/fullstack/next/src/lib/supabase/server.ts.hbs", `import { createServerClient } from "@supabase/ssr";
import { cookies } from "next/headers";

export async function createClient() {
  const cookieStore = await cookies();

  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return cookieStore.getAll();
        },
        setAll(cookiesToSet) {
          try {
            cookiesToSet.forEach(({ name, value, options }) =>
              cookieStore.set(name, value, options)
            );
          } catch {
            // The \`setAll\` method was called from a Server Component.
            // This can be ignored if you have middleware refreshing
            // user sessions.
          }
        },
      },
    }
  );
}
`],
  ["auth/supabase-auth/fullstack/next/src/lib/supabase/middleware.ts.hbs", `import { createServerClient } from "@supabase/ssr";
import { NextResponse, type NextRequest } from "next/server";

export async function updateSession(request: NextRequest) {
  let supabaseResponse = NextResponse.next({
    request,
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return request.cookies.getAll();
        },
        setAll(cookiesToSet) {
          cookiesToSet.forEach(({ name, value }) =>
            request.cookies.set(name, value)
          );
          supabaseResponse = NextResponse.next({
            request,
          });
          cookiesToSet.forEach(({ name, value, options }) =>
            supabaseResponse.cookies.set(name, value, options)
          );
        },
      },
    }
  );

  // IMPORTANT: Avoid writing any logic between createServerClient and
  // supabase.auth.getUser(). A simple mistake could make it very hard to debug
  // issues with users being randomly logged out.
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (
    !user &&
    !request.nextUrl.pathname.startsWith("/login") &&
    !request.nextUrl.pathname.startsWith("/auth")
  ) {
    // no user, potentially respond by redirecting the user to the login page
    const url = request.nextUrl.clone();
    url.pathname = "/login";
    return NextResponse.redirect(url);
  }

  // IMPORTANT: You *must* return the supabaseResponse object as it is. If you're
  // creating a new response object with NextResponse.next() make sure to:
  // 1. Pass the request in it, like so:
  //    const myNewResponse = NextResponse.next({ request })
  // 2. Copy over the cookies, like so:
  //    myNewResponse.cookies.setAll(supabaseResponse.cookies.getAll())
  // 3. Change the myNewResponse object to fit your needs, but avoid changing
  //    the cookies!
  // 4. Finally:
  //    return myNewResponse
  // If this is not done, you may be causing the browser and server to go out
  // of sync and terminate the user's session prematurely!

  return supabaseResponse;
}
`],
  ["examples/ai/web/svelte/src/routes/ai/+page.svelte.hbs", `<script lang="ts">
	import { PUBLIC_SERVER_URL } from "$env/static/public";
	import { Chat } from "@ai-sdk/svelte";
	import { DefaultChatTransport } from "ai";

	let input = $state("");
	const chat = new Chat({
		transport: new DefaultChatTransport({
			api: \`\${PUBLIC_SERVER_URL}/ai\`,
		}),
	});

	let messagesEndElement: HTMLDivElement | null = $state(null);

	$effect(() => {
		if (chat.messages.length > 0) {
			setTimeout(() => {
				messagesEndElement?.scrollIntoView({ behavior: "smooth" });
			}, 0);
		}
	});

	function handleSubmit(e: Event) {
		e.preventDefault();
		const text = input.trim();
		if (!text) return;
		chat.sendMessage({ text });
		input = "";
	}
</script>

<div
	class="mx-auto grid h-full w-full max-w-2xl grid-rows-[1fr_auto] overflow-hidden p-4"
>
	<div class="mb-4 space-y-4 overflow-y-auto pb-4">
		{#if chat.messages.length === 0}
			<div class="mt-8 text-center text-neutral-500">
				Ask me anything to get started!
			</div>
		{/if}

		{#each chat.messages as message (message.id)}
			<div
				class="p-3 rounded-lg w-fit max-w-[85%] text-sm md:text-base"
				class:ml-auto={message.role === "user"}
				class:bg-primary={message.role === "user"}
				class:bg-secondary={message.role === "assistant"}
			>
				<p
					class="mb-1 text-sm font-semibold"
					class:text-indigo-600={message.role === "user"}
					class:text-neutral-400={message.role === "assistant"}
				>
					{message.role === "user" ? "You" : "AI Assistant"}
				</p>
				<div class="whitespace-pre-wrap break-words">
					{#each message.parts as part, partIndex (partIndex)}
						{#if part.type === "text"}
							{part.text}
						{/if}
					{/each}
				</div>
			</div>
		{/each}
		<div bind:this={messagesEndElement}></div>
	</div>

	<form
		onsubmit={handleSubmit}
		class="w-full flex items-center space-x-2 pt-2 border-t"
	>
		<input
			name="prompt"
			bind:value={input}
			placeholder="Type your message..."
			class="flex-1 rounded border border-neutral-600 bg-neutral-800 px-3 py-2 text-neutral-100 placeholder-neutral-500 focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500 disabled:opacity-50"
			autocomplete="off"
			onkeydown={(e) => {
				if (e.key === "Enter" && !e.shiftKey) {
					e.preventDefault();
					handleSubmit(e);
				}
			}}
		/>
		<button
			type="submit"
			disabled={!input.trim()}
			class="inline-flex h-10 w-10 items-center justify-center rounded bg-indigo-600 text-white hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 focus:ring-offset-neutral-900 disabled:cursor-not-allowed disabled:opacity-50"
			aria-label="Send message"
		>
			<svg
				xmlns="http://www.w3.org/2000/svg"
				width="18"
				height="18"
				viewBox="0 0 24 24"
				fill="none"
				stroke="currentColor"
				stroke-width="2"
				stroke-linecap="round"
				stroke-linejoin="round"
			>
				<path d="m22 2-7 20-4-9-9-4Z" />
				<path d="M22 2 11 13" />
			</svg>
		</button>
	</form>
</div>
`],
  ["examples/todo/server/prisma/mongodb/prisma/schema/todo.prisma.hbs", `model Todo {
  id        String  @id @default(auto()) @map("_id") @db.ObjectId
  text      String
  completed Boolean @default(false)

  @@map("todo")
}
`],
  ["examples/todo/server/mongoose/mongodb/src/models/todo.model.ts.hbs", `import mongoose from 'mongoose';

const { Schema, model } = mongoose;

const todoSchema = new Schema({
  id: {
    type: mongoose.Schema.Types.ObjectId,
    auto: true,
  },
  text: {
    type: String,
    required: true,
  },
  completed: {
    type: Boolean,
    default: false,
  },
}, {
  collection: 'todo'
});

const Todo = model('Todo', todoSchema);

export { Todo };
`],
  ["examples/todo/server/prisma/mysql/prisma/schema/todo.prisma.hbs", `model Todo {
  id        Int     @id @default(autoincrement())
  text      String
  completed Boolean @default(false)

  @@map("todo")
}
`],
  ["auth/better-auth/web/react/tanstack-start/src/middleware/auth.ts.hbs", `{{#if (eq backend "self")}}
import { auth } from "@{{projectName}}/auth";
import { createMiddleware } from "@tanstack/react-start";


export const authMiddleware = createMiddleware().server(async ({ next, request }) => {
    const session = await auth.api.getSession({
        headers: request.headers,
    })
    return next({
        context: { session }
    })
})
{{else}}
import { authClient } from "@/lib/auth-client";
import { createMiddleware } from "@tanstack/react-start";

export const authMiddleware = createMiddleware().server(
	async ({ next, request }) => {
		const session = await authClient.getSession({
			fetchOptions: {
				headers: request.headers,
				throw: true
			}
		})
		return next({
			context: { session },
		});
	},
);
{{/if}}
`],
  ["examples/todo/server/drizzle/sqlite/src/schema/todo.ts", `import { integer, sqliteTable, text } from "drizzle-orm/sqlite-core";

export const todo = sqliteTable("todo", {
  id: integer("id").primaryKey({ autoIncrement: true }),
  text: text("text").notNull(),
  completed: integer("completed", { mode: "boolean" }).default(false).notNull(),
});
`],
  ["examples/todo/server/prisma/sqlite/prisma/schema/todo.prisma.hbs", `model Todo {
  id        Int     @id @default(autoincrement())
  text      String
  completed Boolean @default(false)

  @@map("todo")
}
`],
  ["auth/better-auth/web/react/tanstack-start/src/functions/get-user.ts.hbs", `import { authMiddleware } from "@/middleware/auth";
import { createServerFn } from "@tanstack/react-start";

export const getUser = createServerFn({ method: "GET" }).middleware([authMiddleware]).handler(async ({ context }) => {
    return context.session
})`],
  ["auth/better-auth/web/react/tanstack-start/src/components/user-menu.tsx.hbs", `import { Link, useNavigate } from "@tanstack/react-router";

import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { authClient } from "@/lib/auth-client";

import { Button } from "./ui/button";
import { Skeleton } from "./ui/skeleton";

export default function UserMenu() {
  const navigate = useNavigate();
  const { data: session, isPending } = authClient.useSession();

  if (isPending) {
    return <Skeleton className="h-9 w-24" />;
  }

  if (!session) {
    return (
      <Link to="/login">
        <Button variant="outline">Sign In</Button>
      </Link>
    );
  }

  return (
    <DropdownMenu>
      <DropdownMenuTrigger render={<Button variant="outline" />}>
        {session.user.name}
      </DropdownMenuTrigger>
      <DropdownMenuContent className="bg-card">
        <DropdownMenuGroup>
          <DropdownMenuLabel>My Account</DropdownMenuLabel>
          <DropdownMenuSeparator />
          <DropdownMenuItem>{session.user.email}</DropdownMenuItem>
          <DropdownMenuItem
            variant="destructive"
            onClick={() => {
              authClient.signOut({
                fetchOptions: {
                  onSuccess: () => {
                    navigate({
                      to: "/",
                    });
                  },
                },
              });
            }}
          >
            Sign Out
          </DropdownMenuItem>
        </DropdownMenuGroup>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}
`],
  ["auth/better-auth/web/react/tanstack-start/src/components/sign-in-form.tsx.hbs", `import { authClient } from "@/lib/auth-client";
import { useForm } from "@tanstack/react-form";
import { useNavigate } from "@tanstack/react-router";
import { toast } from "sonner";
import z from "zod";
import Loader from "./loader";
import { Button } from "./ui/button";
import { Input } from "./ui/input";
import { Label } from "./ui/label";

export default function SignInForm({ onSwitchToSignUp }: { onSwitchToSignUp: () => void }) {
  const navigate = useNavigate({
    from: "/",
  });
  const { isPending } = authClient.useSession();

  const form = useForm({
    defaultValues: {
      email: "",
      password: "",
    },
    onSubmit: async ({ value }) => {
      await authClient.signIn.email(
        {
          email: value.email,
          password: value.password,
        },
        {
          onSuccess: () => {
            navigate({
              to: "/dashboard",
            });
            toast.success("Sign in successful");
          },
          onError: (error) => {
            toast.error(error.error.message || error.error.statusText);
          },
        },
      );
    },
    validators: {
      onSubmit: z.object({
        email: z.email("Invalid email address"),
        password: z.string().min(8, "Password must be at least 8 characters"),
      }),
    },
  });

  if (isPending) {
    return <Loader />;
  }

  return (
    <div className="mx-auto w-full mt-10 max-w-md p-6">
      <h1 className="mb-6 text-center text-3xl font-bold">Welcome Back</h1>

      <form
        onSubmit={(e) => {
          e.preventDefault();
          e.stopPropagation();
          form.handleSubmit();
        }}
        className="space-y-4"
      >
        <div>
          <form.Field name="email">
            {(field) => (
              <div className="space-y-2">
                <Label htmlFor={field.name}>Email</Label>
                <Input
                  id={field.name}
                  name={field.name}
                  type="email"
                  value={field.state.value}
                  onBlur={field.handleBlur}
                  onChange={(e) => field.handleChange(e.target.value)}
                />
                {field.state.meta.errors.map((error) => (
                  <p key={error?.message} className="text-red-500">
                    {error?.message}
                  </p>
                ))}
              </div>
            )}
          </form.Field>
        </div>

        <div>
          <form.Field name="password">
            {(field) => (
              <div className="space-y-2">
                <Label htmlFor={field.name}>Password</Label>
                <Input
                  id={field.name}
                  name={field.name}
                  type="password"
                  value={field.state.value}
                  onBlur={field.handleBlur}
                  onChange={(e) => field.handleChange(e.target.value)}
                />
                {field.state.meta.errors.map((error) => (
                  <p key={error?.message} className="text-red-500">
                    {error?.message}
                  </p>
                ))}
              </div>
            )}
          </form.Field>
        </div>

        <form.Subscribe>
          {(state) => (
            <Button
              type="submit"
              className="w-full"
              disabled={!state.canSubmit || state.isSubmitting}
            >
              {state.isSubmitting ? "Submitting..." : "Sign In"}
            </Button>
          )}
        </form.Subscribe>
      </form>

      <div className="mt-4 text-center">
        <Button
          variant="link"
          onClick={onSwitchToSignUp}
          className="text-indigo-600 hover:text-indigo-800"
        >
          Need an account? Sign Up
        </Button>
      </div>
    </div>
  );
}
`],
  ["auth/better-auth/web/react/tanstack-start/src/components/sign-up-form.tsx.hbs", `import { authClient } from "@/lib/auth-client";
import { useForm } from "@tanstack/react-form";
import { useNavigate } from "@tanstack/react-router";
import { toast } from "sonner";
import z from "zod";
import Loader from "./loader";
import { Button } from "./ui/button";
import { Input } from "./ui/input";
import { Label } from "./ui/label";

export default function SignUpForm({ onSwitchToSignIn }: { onSwitchToSignIn: () => void }) {
  const navigate = useNavigate({
    from: "/",
  });
  const { isPending } = authClient.useSession();

  const form = useForm({
    defaultValues: {
      email: "",
      password: "",
      name: "",
    },
    onSubmit: async ({ value }) => {
      await authClient.signUp.email(
        {
          email: value.email,
          password: value.password,
          name: value.name,
        },
        {
          onSuccess: () => {
            navigate({
              to: "/dashboard",
            });
            toast.success("Sign up successful");
          },
          onError: (error) => {
            toast.error(error.error.message || error.error.statusText);
          },
        },
      );
    },
    validators: {
      onSubmit: z.object({
        name: z.string().min(2, "Name must be at least 2 characters"),
        email: z.email("Invalid email address"),
        password: z.string().min(8, "Password must be at least 8 characters"),
      }),
    },
  });

  if (isPending) {
    return <Loader />;
  }

  return (
    <div className="mx-auto w-full mt-10 max-w-md p-6">
      <h1 className="mb-6 text-center text-3xl font-bold">Create Account</h1>

      <form
        onSubmit={(e) => {
          e.preventDefault();
          e.stopPropagation();
          form.handleSubmit();
        }}
        className="space-y-4"
      >
        <div>
          <form.Field name="name">
            {(field) => (
              <div className="space-y-2">
                <Label htmlFor={field.name}>Name</Label>
                <Input
                  id={field.name}
                  name={field.name}
                  value={field.state.value}
                  onBlur={field.handleBlur}
                  onChange={(e) => field.handleChange(e.target.value)}
                />
                {field.state.meta.errors.map((error) => (
                  <p key={error?.message} className="text-red-500">
                    {error?.message}
                  </p>
                ))}
              </div>
            )}
          </form.Field>
        </div>

        <div>
          <form.Field name="email">
            {(field) => (
              <div className="space-y-2">
                <Label htmlFor={field.name}>Email</Label>
                <Input
                  id={field.name}
                  name={field.name}
                  type="email"
                  value={field.state.value}
                  onBlur={field.handleBlur}
                  onChange={(e) => field.handleChange(e.target.value)}
                />
                {field.state.meta.errors.map((error) => (
                  <p key={error?.message} className="text-red-500">
                    {error?.message}
                  </p>
                ))}
              </div>
            )}
          </form.Field>
        </div>

        <div>
          <form.Field name="password">
            {(field) => (
              <div className="space-y-2">
                <Label htmlFor={field.name}>Password</Label>
                <Input
                  id={field.name}
                  name={field.name}
                  type="password"
                  value={field.state.value}
                  onBlur={field.handleBlur}
                  onChange={(e) => field.handleChange(e.target.value)}
                />
                {field.state.meta.errors.map((error) => (
                  <p key={error?.message} className="text-red-500">
                    {error?.message}
                  </p>
                ))}
              </div>
            )}
          </form.Field>
        </div>

        <form.Subscribe>
          {(state) => (
            <Button
              type="submit"
              className="w-full"
              disabled={!state.canSubmit || state.isSubmitting}
            >
              {state.isSubmitting ? "Submitting..." : "Sign Up"}
            </Button>
          )}
        </form.Subscribe>
      </form>

      <div className="mt-4 text-center">
        <Button
          variant="link"
          onClick={onSwitchToSignIn}
          className="text-indigo-600 hover:text-indigo-800"
        >
          Already have an account? Sign In
        </Button>
      </div>
    </div>
  );
}
`],
  ["examples/todo/web/react/react-router/src/routes/todos.tsx.hbs", `import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Checkbox } from "@/components/ui/checkbox";
import { Input } from "@/components/ui/input";
import { Loader2, Trash2 } from "lucide-react";
import { useState } from "react";

{{#if (eq backend "convex")}}
import { useMutation, useQuery } from "convex/react";
import { api } from "@{{projectName}}/backend/convex/_generated/api";
import type { Id } from "@{{projectName}}/backend/convex/_generated/dataModel";
{{else}}
  {{#if (eq api "orpc")}}
  import { orpc } from "@/utils/orpc";
  {{/if}}
  {{#if (eq api "trpc")}}
  import { trpc } from "@/utils/trpc";
  {{/if}}
import { useMutation, useQuery } from "@tanstack/react-query";
{{/if}}

export default function Todos() {
  const [newTodoText, setNewTodoText] = useState("");

  {{#if (eq backend "convex")}}
  const todos = useQuery(api.todos.getAll);
  const createTodo = useMutation(api.todos.create);
  const toggleTodo = useMutation(api.todos.toggle);
  const deleteTodo = useMutation(api.todos.deleteTodo);

  const handleAddTodo = async (e: React.FormEvent) => {
    e.preventDefault();
    const text = newTodoText.trim();
    if (!text) return;
    await createTodo({ text });
    setNewTodoText("");
  };

  const handleToggleTodo = (id: Id<"todos">, currentCompleted: boolean) => {
    toggleTodo({ id, completed: !currentCompleted });
  };

  const handleDeleteTodo = (id: Id<"todos">) => {
    deleteTodo({ id });
  };
  {{else}}
    {{#if (eq api "orpc")}}
    const todos = useQuery(orpc.todo.getAll.queryOptions());
    const createMutation = useMutation(
      orpc.todo.create.mutationOptions({
        onSuccess: () => {
          todos.refetch();
          setNewTodoText("");
        },
      })
    );
    const toggleMutation = useMutation(
      orpc.todo.toggle.mutationOptions({
        onSuccess: () => { todos.refetch() },
      })
    );
    const deleteMutation = useMutation(
      orpc.todo.delete.mutationOptions({
        onSuccess: () => { todos.refetch() },
      })
    );
    {{/if}}
    {{#if (eq api "trpc")}}
    const todos = useQuery(trpc.todo.getAll.queryOptions());
    const createMutation = useMutation(
      trpc.todo.create.mutationOptions({
        onSuccess: () => {
          todos.refetch();
          setNewTodoText("");
        },
      })
    );
    const toggleMutation = useMutation(
      trpc.todo.toggle.mutationOptions({
        onSuccess: () => { todos.refetch() },
      })
    );
    const deleteMutation = useMutation(
      trpc.todo.delete.mutationOptions({
        onSuccess: () => { todos.refetch() },
      })
    );
    {{/if}}

  const handleAddTodo = (e: React.FormEvent) => {
    e.preventDefault();
    if (newTodoText.trim()) {
      createMutation.mutate({ text: newTodoText });
    }
  };

  const handleToggleTodo = (id: number, completed: boolean) => {
    toggleMutation.mutate({ id, completed: !completed });
  };

  const handleDeleteTodo = (id: number) => {
    deleteMutation.mutate({ id });
  };
  {{/if}}

  return (
    <div className="w-full mx-auto max-w-md py-10">
      <Card>
        <CardHeader>
          <CardTitle>Todo List</CardTitle>
          <CardDescription>Manage your tasks efficiently</CardDescription>
        </CardHeader>
        <CardContent>
          <form
            onSubmit={handleAddTodo}
            className="mb-6 flex items-center space-x-2"
          >
            <Input
              value={newTodoText}
              onChange={(e) => setNewTodoText(e.target.value)}
              placeholder="Add a new task..."
              {{#if (eq backend "convex")}}
              {{else}}
              disabled={createMutation.isPending}
              {{/if}}
            />
            <Button
              type="submit"
              {{#if (eq backend "convex")}}
              disabled={!newTodoText.trim()}
              {{else}}
              disabled={createMutation.isPending || !newTodoText.trim()}
              {{/if}}
            >
              {{#if (eq backend "convex")}}
              Add
              {{else}}
                {createMutation.isPending ? (
                  <Loader2 className="h-4 w-4 animate-spin" />
                ) : (
                  "Add"
                )}
              {{/if}}
            </Button>
          </form>

          {{#if (eq backend "convex")}}
            {todos === undefined ? (
              <div className="flex justify-center py-4">
                <Loader2 className="h-6 w-6 animate-spin" />
              </div>
            ) : todos.length === 0 ? (
              <p className="py-4 text-center">No todos yet. Add one above!</p>
            ) : (
              <ul className="space-y-2">
                {todos.map((todo) => (
                  <li
                    key={todo._id}
                    className="flex items-center justify-between rounded-md border p-2"
                  >
                    <div className="flex items-center space-x-2">
                      <Checkbox
                        checked={todo.completed}
                        onCheckedChange={() =>
                          handleToggleTodo(todo._id, todo.completed)
                        }
                        id={\`todo-\${todo._id}\`}
                      />
                      <label
                        htmlFor={\`todo-\${todo._id}\`}
                        className={\`\${todo.completed ? "line-through text-muted-foreground" : ""}\`}
                      >
                        {todo.text}
                      </label>
                    </div>
                    <Button
                      variant="ghost"
                      size="icon"
                      onClick={() => handleDeleteTodo(todo._id)}
                      aria-label="Delete todo"
                    >
                      <Trash2 className="h-4 w-4" />
                    </Button>
                  </li>
                ))}
              </ul>
            )}
          {{else}}
            {todos.isLoading ? (
              <div className="flex justify-center py-4">
                <Loader2 className="h-6 w-6 animate-spin" />
              </div>
            ) : todos.data?.length === 0 ? (
              <p className="py-4 text-center">
                No todos yet. Add one above!
              </p>
            ) : (
              <ul className="space-y-2">
                {todos.data?.map((todo) => (
                  <li
                    key={todo.id}
                    className="flex items-center justify-between rounded-md border p-2"
                  >
                    <div className="flex items-center space-x-2">
                      <Checkbox
                        checked={todo.completed}
                        onCheckedChange={() =>
                          handleToggleTodo(todo.id, todo.completed)
                        }
                        id={\`todo-\${todo.id}\`}
                      />
                      <label
                        htmlFor={\`todo-\${todo.id}\`}
                        className={\`\${todo.completed ? "line-through" : ""}\`}
                      >
                        {todo.text}
                      </label>
                    </div>
                    <Button
                      variant="ghost"
                      size="icon"
                      onClick={() => handleDeleteTodo(todo.id)}
                      aria-label="Delete todo"
                    >
                      <Trash2 className="h-4 w-4" />
                    </Button>
                  </li>
                ))}
              </ul>
            )}
          {{/if}}
        </CardContent>
      </Card>
    </div>
  );
}
`],
  ["auth/better-auth/web/svelte/src/routes/login/+page.svelte.hbs", `<script lang="ts">
	import SignInForm from '../../components/SignInForm.svelte';
	import SignUpForm from '../../components/SignUpForm.svelte';

	let showSignIn = $state(true);
</script>

{#if showSignIn}
	<SignInForm switchToSignUp={() => showSignIn = false} />
{:else}
	<SignUpForm switchToSignIn={() => showSignIn = true} />
{/if}
`],
  ["auth/better-auth/web/svelte/src/routes/dashboard/+page.svelte.hbs", `<script lang="ts">
	import { goto } from '$app/navigation';
	import { authClient } from '$lib/auth-client';
	{{#if (eq api "orpc")}}
	import { orpc } from '$lib/orpc';
	import { createQuery } from '@tanstack/svelte-query';
	{{/if}}
	{{#if (eq payments "polar")}}
	let customerState = $state<{ activeSubscriptions?: unknown[] } | null>(null);
	{{/if}}

	const sessionQuery = authClient.useSession();

	{{#if (eq api "orpc")}}
	const privateDataQuery = createQuery(orpc.privateData.queryOptions());
	{{/if}}

	$effect(() => {
		if (!$sessionQuery.isPending && !$sessionQuery.data) {
			goto('/login');
		}
	});

	{{#if (eq payments "polar")}}
	$effect(() => {
		if ($sessionQuery.data) {
			authClient.customer.state().then(({ data }) => {
				customerState = data;
			});
		}
	});
	{{/if}}
</script>

{#if $sessionQuery.isPending}
	<div>Loading...</div>
{:else if !$sessionQuery.data}
	<div>Redirecting to login...</div>
{:else}
	<div>
		<h1>Dashboard</h1>
		<p>Welcome {$sessionQuery.data.user.name}</p>
		{{#if (eq api "orpc")}}
		<p>API: {$privateDataQuery.data?.message}</p>
		{{/if}}
		{{#if (eq payments "polar")}}
		<p>Plan: {customerState?.activeSubscriptions?.length > 0 ? "Pro" : "Free"}</p>
		{#if customerState?.activeSubscriptions?.length > 0}
			<button onclick={async () => await authClient.customer.portal()}>
				Manage Subscription
			</button>
		{:else}
			<button onclick={async () => await authClient.checkout({ slug: "pro" })}>
				Upgrade to Pro
			</button>
		{/if}
		{{/if}}
	</div>
{/if}
`],
  ["auth/better-auth/web/react/react-router/src/routes/login.tsx.hbs", `import SignInForm from "@/components/sign-in-form";
import SignUpForm from "@/components/sign-up-form";
import { useState } from "react";

export default function Login() {
  const [showSignIn, setShowSignIn] = useState(false);

  return showSignIn ? (
    <SignInForm onSwitchToSignUp={() => setShowSignIn(false)} />
  ) : (
    <SignUpForm onSwitchToSignIn={() => setShowSignIn(true)} />
  );
}
`],
  ["auth/better-auth/web/react/react-router/src/routes/dashboard.tsx.hbs", `{{#if (eq payments "polar")}}
import { Button } from "@/components/ui/button";
{{/if}}
import { authClient } from "@/lib/auth-client";
{{#if (eq api "orpc")}}
import { orpc } from "@/utils/orpc";
{{/if}}
{{#if (eq api "trpc")}}
import { trpc } from "@/utils/trpc";
{{/if}}
{{#if ( or (eq api "orpc") (eq api "trpc"))}}
import { useQuery } from "@tanstack/react-query";
{{/if}}
import { useEffect, useState } from "react";
import { useNavigate } from "react-router";

export default function Dashboard() {
  const { data: session, isPending } = authClient.useSession();
  const navigate = useNavigate();
  {{#if (eq payments "polar")}}
  const [customerState, setCustomerState] = useState<any>(null);
  {{/if}}

  {{#if (eq api "orpc")}}
  const privateData = useQuery(orpc.privateData.queryOptions());
  {{/if}}
  {{#if (eq api "trpc")}}
  const privateData = useQuery(trpc.privateData.queryOptions());
  {{/if}}

  useEffect(() => {
    if (!session && !isPending) {
      navigate("/login");
    }
  }, [session, isPending, navigate]);

  {{#if (eq payments "polar")}}
  useEffect(() => {
    async function fetchCustomerState() {
      if (session) {
        const { data } = await authClient.customer.state();
        setCustomerState(data);
      }
    }

    fetchCustomerState();
  }, [session]);
  {{/if}}

  if (isPending) {
    return <div>Loading...</div>;
  }

  {{#if (eq payments "polar")}}
  const hasProSubscription = customerState?.activeSubscriptions?.length! > 0;
  console.log("Active subscriptions:", customerState?.activeSubscriptions);
  {{/if}}

  return (
    <div>
      <h1>Dashboard</h1>
      <p>Welcome {session?.user.name}</p>
      {{#if ( or (eq api "orpc") (eq api "trpc"))}}
      <p>API: {privateData.data?.message}</p>
      {{/if}}
      {{#if (eq payments "polar")}}
      <p>Plan: {hasProSubscription ? "Pro" : "Free"}</p>
      {hasProSubscription ? (
        <Button onClick={async () => await authClient.customer.portal()}>
          Manage Subscription
        </Button>
      ) : (
        <Button onClick={async () => await authClient.checkout({ slug: "pro" })}>
          Upgrade to Pro
        </Button>
      )}
      {{/if}}
    </div>
  );
}
`],
  ["auth/better-auth/web/react/react-router/src/components/user-menu.tsx.hbs", `import { Link, useNavigate } from "react-router";

import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { authClient } from "@/lib/auth-client";

import { Button } from "./ui/button";
import { Skeleton } from "./ui/skeleton";

export default function UserMenu() {
  const navigate = useNavigate();
  const { data: session, isPending } = authClient.useSession();

  if (isPending) {
    return <Skeleton className="h-9 w-24" />;
  }

  if (!session) {
    return (
      <Link to="/login">
        <Button variant="outline">Sign In</Button>
      </Link>
    );
  }

  return (
    <DropdownMenu>
      <DropdownMenuTrigger render={<Button variant="outline" />}>
        {session.user.name}
      </DropdownMenuTrigger>
      <DropdownMenuContent className="bg-card">
        <DropdownMenuGroup>
          <DropdownMenuLabel>My Account</DropdownMenuLabel>
          <DropdownMenuSeparator />
          <DropdownMenuItem>{session.user.email}</DropdownMenuItem>
          <DropdownMenuItem
            variant="destructive"
            onClick={() => {
              authClient.signOut({
                fetchOptions: {
                  onSuccess: () => {
                    navigate("/");
                  },
                },
              });
            }}
          >
            Sign Out
          </DropdownMenuItem>
        </DropdownMenuGroup>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}
`],
  ["auth/better-auth/web/react/react-router/src/components/sign-in-form.tsx.hbs", `import { authClient } from "@/lib/auth-client";
import { useForm } from "@tanstack/react-form";
import { useNavigate } from "react-router";
import { toast } from "sonner";
import z from "zod";
import Loader from "./loader";
import { Button } from "./ui/button";
import { Input } from "./ui/input";
import { Label } from "./ui/label";

export default function SignInForm({
  onSwitchToSignUp,
}: {
  onSwitchToSignUp: () => void;
}) {
  const navigate = useNavigate();
  const { isPending } = authClient.useSession();

  const form = useForm({
    defaultValues: {
      email: "",
      password: "",
    },
    onSubmit: async ({ value }) => {
      await authClient.signIn.email(
        {
          email: value.email,
          password: value.password,
        },
        {
          onSuccess: () => {
            navigate("/dashboard");
            toast.success("Sign in successful");
          },
          onError: (error) => {
            toast.error(error.error.message || error.error.statusText);
          },
        }
      );
    },
    validators: {
      onSubmit: z.object({
        email: z.email("Invalid email address"),
        password: z.string().min(8, "Password must be at least 8 characters"),
      }),
    },
  });

  if (isPending) {
    return <Loader />;
  }

  return (
    <div className="mx-auto w-full mt-10 max-w-md p-6">
      <h1 className="mb-6 text-center text-3xl font-bold">Welcome Back</h1>

      <form
        onSubmit={(e) => {
          e.preventDefault();
          e.stopPropagation();
          form.handleSubmit();
        }}
        className="space-y-4"
      >
        <div>
          <form.Field name="email">
            {(field) => (
              <div className="space-y-2">
                <Label htmlFor={field.name}>Email</Label>
                <Input
                  id={field.name}
                  name={field.name}
                  type="email"
                  value={field.state.value}
                  onBlur={field.handleBlur}
                  onChange={(e) => field.handleChange(e.target.value)}
                />
                {field.state.meta.errors.map((error) => (
                  <p key={error?.message} className="text-red-500">
                    {error?.message}
                  </p>
                ))}
              </div>
            )}
          </form.Field>
        </div>

        <div>
          <form.Field name="password">
            {(field) => (
              <div className="space-y-2">
                <Label htmlFor={field.name}>Password</Label>
                <Input
                  id={field.name}
                  name={field.name}
                  type="password"
                  value={field.state.value}
                  onBlur={field.handleBlur}
                  onChange={(e) => field.handleChange(e.target.value)}
                />
                {field.state.meta.errors.map((error) => (
                  <p key={error?.message} className="text-red-500">
                    {error?.message}
                  </p>
                ))}
              </div>
            )}
          </form.Field>
        </div>

        <form.Subscribe>
          {(state) => (
            <Button
              type="submit"
              className="w-full"
              disabled={!state.canSubmit || state.isSubmitting}
            >
              {state.isSubmitting ? "Submitting..." : "Sign In"}
            </Button>
          )}
        </form.Subscribe>
      </form>

      <div className="mt-4 text-center">
        <Button
          variant="link"
          onClick={onSwitchToSignUp}
          className="text-indigo-600 hover:text-indigo-800"
        >
          Need an account? Sign Up
        </Button>
      </div>
    </div>
  );
}
`],
  ["auth/better-auth/web/react/react-router/src/components/sign-up-form.tsx.hbs", `import { authClient } from "@/lib/auth-client";
import { useForm } from "@tanstack/react-form";
import { useNavigate } from "react-router";
import { toast } from "sonner";
import z from "zod";
import Loader from "./loader";
import { Button } from "./ui/button";
import { Input } from "./ui/input";
import { Label } from "./ui/label";

export default function SignUpForm({
  onSwitchToSignIn,
}: {
  onSwitchToSignIn: () => void;
}) {
  const navigate = useNavigate();
  const { isPending } = authClient.useSession();

  const form = useForm({
    defaultValues: {
      email: "",
      password: "",
      name: "",
    },
    onSubmit: async ({ value }) => {
      await authClient.signUp.email(
        {
          email: value.email,
          password: value.password,
          name: value.name,
        },
        {
          onSuccess: () => {
            navigate("/dashboard");
            toast.success("Sign up successful");
          },
          onError: (error) => {
            toast.error(error.error.message || error.error.statusText);
          },
        }
      );
    },
    validators: {
      onSubmit: z.object({
        name: z.string().min(2, "Name must be at least 2 characters"),
        email: z.email("Invalid email address"),
        password: z.string().min(8, "Password must be at least 8 characters"),
      }),
    },
  });

  if (isPending) {
    return <Loader />;
  }

  return (
    <div className="mx-auto w-full mt-10 max-w-md p-6">
      <h1 className="mb-6 text-center text-3xl font-bold">Create Account</h1>

      <form
        onSubmit={(e) => {
          e.preventDefault();
          e.stopPropagation();
          form.handleSubmit();
        }}
        className="space-y-4"
      >
        <div>
          <form.Field name="name">
            {(field) => (
              <div className="space-y-2">
                <Label htmlFor={field.name}>Name</Label>
                <Input
                  id={field.name}
                  name={field.name}
                  value={field.state.value}
                  onBlur={field.handleBlur}
                  onChange={(e) => field.handleChange(e.target.value)}
                />
                {field.state.meta.errors.map((error) => (
                  <p key={error?.message} className="text-red-500">
                    {error?.message}
                  </p>
                ))}
              </div>
            )}
          </form.Field>
        </div>

        <div>
          <form.Field name="email">
            {(field) => (
              <div className="space-y-2">
                <Label htmlFor={field.name}>Email</Label>
                <Input
                  id={field.name}
                  name={field.name}
                  type="email"
                  value={field.state.value}
                  onBlur={field.handleBlur}
                  onChange={(e) => field.handleChange(e.target.value)}
                />
                {field.state.meta.errors.map((error) => (
                  <p key={error?.message} className="text-red-500">
                    {error?.message}
                  </p>
                ))}
              </div>
            )}
          </form.Field>
        </div>

        <div>
          <form.Field name="password">
            {(field) => (
              <div className="space-y-2">
                <Label htmlFor={field.name}>Password</Label>
                <Input
                  id={field.name}
                  name={field.name}
                  type="password"
                  value={field.state.value}
                  onBlur={field.handleBlur}
                  onChange={(e) => field.handleChange(e.target.value)}
                />
                {field.state.meta.errors.map((error) => (
                  <p key={error?.message} className="text-red-500">
                    {error?.message}
                  </p>
                ))}
              </div>
            )}
          </form.Field>
        </div>

        <form.Subscribe>
          {(state) => (
            <Button
              type="submit"
              className="w-full"
              disabled={!state.canSubmit || state.isSubmitting}
            >
              {state.isSubmitting ? "Submitting..." : "Sign Up"}
            </Button>
          )}
        </form.Subscribe>
      </form>

      <div className="mt-4 text-center">
        <Button
          variant="link"
          onClick={onSwitchToSignIn}
          className="text-indigo-600 hover:text-indigo-800"
        >
          Already have an account? Sign In
        </Button>
      </div>
    </div>
  );
}
`],
  ["auth/clerk/convex/native/base/app/(auth)/sign-up.tsx.hbs", `import * as React from "react";
import { Text, TextInput, TouchableOpacity, View } from "react-native";
import { useSignUp } from "@clerk/clerk-expo";
import { Link, useRouter } from "expo-router";

export default function SignUpScreen() {
  const { isLoaded, signUp, setActive } = useSignUp();
  const router = useRouter();

  const [emailAddress, setEmailAddress] = React.useState("");
  const [password, setPassword] = React.useState("");
  const [pendingVerification, setPendingVerification] = React.useState(false);
  const [code, setCode] = React.useState("");

  // Handle submission of sign-up form
  const onSignUpPress = async () => {
    if (!isLoaded) return;

    console.log(emailAddress, password);

    // Start sign-up process using email and password provided
    try {
      await signUp.create({
        emailAddress,
        password,
      });

      // Send user an email with verification code
      await signUp.prepareEmailAddressVerification({ strategy: "email_code" });

      // Set 'pendingVerification' to true to display second form
      // and capture OTP code
      setPendingVerification(true);
    } catch (err) {
      // See https://clerk.com/docs/custom-flows/error-handling
      // for more info on error handling
      console.error(JSON.stringify(err, null, 2));
    }
  };

  // Handle submission of verification form
  const onVerifyPress = async () => {
    if (!isLoaded) return;

    try {
      // Use the code the user provided to attempt verification
      const signUpAttempt = await signUp.attemptEmailAddressVerification({
        code,
      });

      // If verification was completed, set the session to active
      // and redirect the user
      if (signUpAttempt.status === "complete") {
        await setActive({ session: signUpAttempt.createdSessionId });
        router.replace("/");
      } else {
        // If the status is not complete, check why. User may need to
        // complete further steps.
        console.error(JSON.stringify(signUpAttempt, null, 2));
      }
    } catch (err) {
      // See https://clerk.com/docs/custom-flows/error-handling
      // for more info on error handling
      console.error(JSON.stringify(err, null, 2));
    }
  };

  if (pendingVerification) {
    return (
      <>
        <Text>Verify your email</Text>
        <TextInput
          value={code}
          placeholder="Enter your verification code"
          onChangeText={(code) => setCode(code)}
        />
        <TouchableOpacity onPress={onVerifyPress}>
          <Text>Verify</Text>
        </TouchableOpacity>
      </>
    );
  }

  return (
    <View>
      <Text>Sign up</Text>
      <TextInput
        autoCapitalize="none"
        value={emailAddress}
        placeholder="Enter email"
        onChangeText={(email) => setEmailAddress(email)}
      />
      <TextInput
        value={password}
        placeholder="Enter password"
        secureTextEntry={true}
        onChangeText={(password) => setPassword(password)}
      />
      <TouchableOpacity onPress={onSignUpPress}>
        <Text>Continue</Text>
      </TouchableOpacity>
      <View style=\\{{ display: "flex", flexDirection: "row", gap: 3 }}>
        <Text>Already have an account?</Text>
        <Link href="/sign-in">
          <Text>Sign in</Text>
        </Link>
      </View>
    </View>
  );
}
`],
  ["auth/clerk/convex/native/base/app/(auth)/sign-in.tsx.hbs", `import { useSignIn } from "@clerk/clerk-expo";
import { Link, useRouter } from "expo-router";
import { Text, TextInput, TouchableOpacity, View } from "react-native";
import React from "react";

export default function Page() {
  const { signIn, setActive, isLoaded } = useSignIn();
  const router = useRouter();

  const [emailAddress, setEmailAddress] = React.useState("");
  const [password, setPassword] = React.useState("");

  // Handle the submission of the sign-in form
  const onSignInPress = async () => {
    if (!isLoaded) return;

    // Start the sign-in process using the email and password provided
    try {
      const signInAttempt = await signIn.create({
        identifier: emailAddress,
        password,
      });

      // If sign-in process is complete, set the created session as active
      // and redirect the user
      if (signInAttempt.status === "complete") {
        await setActive({ session: signInAttempt.createdSessionId });
        router.replace("/");
      } else {
        // If the status isn't complete, check why. User might need to
        // complete further steps.
        console.error(JSON.stringify(signInAttempt, null, 2));
      }
    } catch (err) {
      // See https://clerk.com/docs/custom-flows/error-handling
      // for more info on error handling
      console.error(JSON.stringify(err, null, 2));
    }
  };

  return (
    <View>
      <Text>Sign in</Text>
      <TextInput
        autoCapitalize="none"
        value={emailAddress}
        placeholder="Enter email"
        onChangeText={(emailAddress) => setEmailAddress(emailAddress)}
      />
      <TextInput
        value={password}
        placeholder="Enter password"
        secureTextEntry={true}
        onChangeText={(password) => setPassword(password)}
      />
      <TouchableOpacity onPress={onSignInPress}>
        <Text>Continue</Text>
      </TouchableOpacity>
      <View style=\\{{ display: "flex", flexDirection: "row", gap: 3 }}>
        <Text>Don't have an account?</Text>
        <Link href="/sign-up">
          <Text>Sign up</Text>
        </Link>
      </View>
    </View>
  );
}
`],
  ["auth/clerk/convex/native/base/app/(auth)/_layout.tsx.hbs", `import { Redirect, Stack } from "expo-router";
import { useAuth } from "@clerk/clerk-expo";

export default function AuthRoutesLayout() {
  const { isSignedIn } = useAuth();

  if (isSignedIn) {
    return <Redirect href={"/"} />;
  }

  return <Stack />;
}
`],
  ["auth/better-auth/web/react/next/src/components/user-menu.tsx.hbs", `import Link from "next/link";
import { useRouter } from "next/navigation";

import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { authClient } from "@/lib/auth-client";

import { Button } from "./ui/button";
import { Skeleton } from "./ui/skeleton";

export default function UserMenu() {
  const router = useRouter();
  const { data: session, isPending } = authClient.useSession();

  if (isPending) {
    return <Skeleton className="h-9 w-24" />;
  }

  if (!session) {
    return (
      <Link href="/login">
        <Button variant="outline">Sign In</Button>
      </Link>
    );
  }

  return (
    <DropdownMenu>
      <DropdownMenuTrigger render={<Button variant="outline" />}>
        {session.user.name}
      </DropdownMenuTrigger>
      <DropdownMenuContent className="bg-card">
        <DropdownMenuGroup>
          <DropdownMenuLabel>My Account</DropdownMenuLabel>
          <DropdownMenuSeparator />
          <DropdownMenuItem>{session.user.email}</DropdownMenuItem>
          <DropdownMenuItem
            variant="destructive"
            onClick={() => {
              authClient.signOut({
                fetchOptions: {
                  onSuccess: () => {
                    router.push("/");
                  },
                },
              });
            }}
          >
            Sign Out
          </DropdownMenuItem>
        </DropdownMenuGroup>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}
`],
  ["auth/better-auth/web/react/next/src/components/sign-in-form.tsx.hbs", `import { authClient } from "@/lib/auth-client";
import { useForm } from "@tanstack/react-form";
import { toast } from "sonner";
import z from "zod";
import Loader from "./loader";
import { Button } from "./ui/button";
import { Input } from "./ui/input";
import { Label } from "./ui/label";
import { useRouter } from "next/navigation";

export default function SignInForm({
  onSwitchToSignUp,
}: {
  onSwitchToSignUp: () => void;
}) {
  const router = useRouter()
  const { isPending } = authClient.useSession();

  const form = useForm({
    defaultValues: {
      email: "",
      password: "",
    },
    onSubmit: async ({ value }) => {
      await authClient.signIn.email(
        {
          email: value.email,
          password: value.password,
        },
        {
          onSuccess: () => {
            router.push("/dashboard")
            toast.success("Sign in successful");
          },
          onError: (error) => {
            toast.error(error.error.message || error.error.statusText);
          },
        },
      );
    },
    validators: {
      onSubmit: z.object({
        email: z.email("Invalid email address"),
        password: z.string().min(8, "Password must be at least 8 characters"),
      }),
    },
  });

  if (isPending) {
    return <Loader />;
  }

  return (
    <div className="mx-auto w-full mt-10 max-w-md p-6">
      <h1 className="mb-6 text-center text-3xl font-bold">Welcome Back</h1>

      <form
        onSubmit={(e) => {
          e.preventDefault();
          e.stopPropagation();
          form.handleSubmit();
        }}
        className="space-y-4"
      >
        <div>
          <form.Field name="email">
            {(field) => (
              <div className="space-y-2">
                <Label htmlFor={field.name}>Email</Label>
                <Input
                  id={field.name}
                  name={field.name}
                  type="email"
                  value={field.state.value}
                  onBlur={field.handleBlur}
                  onChange={(e) => field.handleChange(e.target.value)}
                />
                {field.state.meta.errors.map((error) => (
                  <p key={error?.message} className="text-red-500">
                    {error?.message}
                  </p>
                ))}
              </div>
            )}
          </form.Field>
        </div>

        <div>
          <form.Field name="password">
            {(field) => (
              <div className="space-y-2">
                <Label htmlFor={field.name}>Password</Label>
                <Input
                  id={field.name}
                  name={field.name}
                  type="password"
                  value={field.state.value}
                  onBlur={field.handleBlur}
                  onChange={(e) => field.handleChange(e.target.value)}
                />
                {field.state.meta.errors.map((error) => (
                  <p key={error?.message} className="text-red-500">
                    {error?.message}
                  </p>
                ))}
              </div>
            )}
          </form.Field>
        </div>

        <form.Subscribe>
          {(state) => (
            <Button
              type="submit"
              className="w-full"
              disabled={!state.canSubmit || state.isSubmitting}
            >
              {state.isSubmitting ? "Submitting..." : "Sign In"}
            </Button>
          )}
        </form.Subscribe>
      </form>

      <div className="mt-4 text-center">
        <Button
          variant="link"
          onClick={onSwitchToSignUp}
          className="text-indigo-600 hover:text-indigo-800"
        >
          Need an account? Sign Up
        </Button>
      </div>
    </div>
  );
}
`],
  ["auth/better-auth/web/react/next/src/components/sign-up-form.tsx.hbs", `import { authClient } from "@/lib/auth-client";
import { useForm } from "@tanstack/react-form";
import { toast } from "sonner";
import z from "zod";
import Loader from "./loader";
import { Button } from "./ui/button";
import { Input } from "./ui/input";
import { Label } from "./ui/label";
import { useRouter } from "next/navigation";

export default function SignUpForm({
  onSwitchToSignIn,
}: {
  onSwitchToSignIn: () => void;
}) {
  const router = useRouter();
  const { isPending } = authClient.useSession();

  const form = useForm({
    defaultValues: {
      email: "",
      password: "",
      name: "",
    },
    onSubmit: async ({ value }) => {
      await authClient.signUp.email(
        {
          email: value.email,
          password: value.password,
          name: value.name,
        },
        {
          onSuccess: () => {
            router.push("/dashboard");
            toast.success("Sign up successful");
          },
          onError: (error) => {
            toast.error(error.error.message || error.error.statusText);
          },
        },
      );
    },
    validators: {
      onSubmit: z.object({
        name: z.string().min(2, "Name must be at least 2 characters"),
        email: z.email("Invalid email address"),
        password: z.string().min(8, "Password must be at least 8 characters"),
      }),
    },
  });

  if (isPending) {
    return <Loader />;
  }

  return (
    <div className="mx-auto w-full mt-10 max-w-md p-6">
      <h1 className="mb-6 text-center text-3xl font-bold">Create Account</h1>

      <form
        onSubmit={(e) => {
          e.preventDefault();
          e.stopPropagation();
          form.handleSubmit();
        }}
        className="space-y-4"
      >
        <div>
          <form.Field name="name">
            {(field) => (
              <div className="space-y-2">
                <Label htmlFor={field.name}>Name</Label>
                <Input
                  id={field.name}
                  name={field.name}
                  value={field.state.value}
                  onBlur={field.handleBlur}
                  onChange={(e) => field.handleChange(e.target.value)}
                />
                {field.state.meta.errors.map((error) => (
                  <p key={error?.message} className="text-red-500">
                    {error?.message}
                  </p>
                ))}
              </div>
            )}
          </form.Field>
        </div>

        <div>
          <form.Field name="email">
            {(field) => (
              <div className="space-y-2">
                <Label htmlFor={field.name}>Email</Label>
                <Input
                  id={field.name}
                  name={field.name}
                  type="email"
                  value={field.state.value}
                  onBlur={field.handleBlur}
                  onChange={(e) => field.handleChange(e.target.value)}
                />
                {field.state.meta.errors.map((error) => (
                  <p key={error?.message} className="text-red-500">
                    {error?.message}
                  </p>
                ))}
              </div>
            )}
          </form.Field>
        </div>

        <div>
          <form.Field name="password">
            {(field) => (
              <div className="space-y-2">
                <Label htmlFor={field.name}>Password</Label>
                <Input
                  id={field.name}
                  name={field.name}
                  type="password"
                  value={field.state.value}
                  onBlur={field.handleBlur}
                  onChange={(e) => field.handleChange(e.target.value)}
                />
                {field.state.meta.errors.map((error) => (
                  <p key={error?.message} className="text-red-500">
                    {error?.message}
                  </p>
                ))}
              </div>
            )}
          </form.Field>
        </div>

        <form.Subscribe>
          {(state) => (
            <Button
              type="submit"
              className="w-full"
              disabled={!state.canSubmit || state.isSubmitting}
            >
              {state.isSubmitting ? "Submitting..." : "Sign Up"}
            </Button>
          )}
        </form.Subscribe>
      </form>

      <div className="mt-4 text-center">
        <Button
          variant="link"
          onClick={onSwitchToSignIn}
          className="text-indigo-600 hover:text-indigo-800"
        >
          Already have an account? Sign In
        </Button>
      </div>
    </div>
  );
}
`],
  ["auth/better-auth/web/react/tanstack-router/src/routes/login.tsx.hbs", `import SignInForm from "@/components/sign-in-form";
import SignUpForm from "@/components/sign-up-form";
import { createFileRoute } from "@tanstack/react-router";
import { useState } from "react";

export const Route = createFileRoute("/login")({
  component: RouteComponent,
});

function RouteComponent() {
  const [showSignIn, setShowSignIn] = useState(false);

  return showSignIn ? (
    <SignInForm onSwitchToSignUp={() => setShowSignIn(false)} />
  ) : (
    <SignUpForm onSwitchToSignIn={() => setShowSignIn(true)} />
  );
}
`],
  ["auth/better-auth/web/react/tanstack-router/src/routes/dashboard.tsx.hbs", `{{#if (eq payments "polar")}}
import { Button } from "@/components/ui/button";
{{/if}}
import { authClient } from "@/lib/auth-client";
{{#if (eq api "orpc")}}
import { orpc } from "@/utils/orpc";
{{/if}}
{{#if (eq api "trpc")}}
import { trpc } from "@/utils/trpc";
{{/if}}
{{#if ( or (eq api "orpc") (eq api "trpc"))}}
import { useQuery } from "@tanstack/react-query";
{{/if}}
import { createFileRoute, redirect } from "@tanstack/react-router";

export const Route = createFileRoute("/dashboard")({
	component: RouteComponent,
	beforeLoad: async () => {
		const session = await authClient.getSession();
		if (!session.data) {
			redirect({
				to: "/login",
				throw: true
			});
		}
		{{#if (eq payments "polar")}}
		const {data: customerState} = await authClient.customer.state()
		return { session, customerState };
		{{else}}
		return { session };
		{{/if}}
	}
});

function RouteComponent() {
	const { session{{#if (eq payments "polar")}}, customerState{{/if}} } = Route.useRouteContext();

	{{#if (eq api "orpc")}}
	const privateData = useQuery(orpc.privateData.queryOptions());
	{{/if}}
	{{#if (eq api "trpc")}}
	const privateData = useQuery(trpc.privateData.queryOptions());
	{{/if}}

	{{#if (eq payments "polar")}}
	const hasProSubscription = customerState?.activeSubscriptions?.length! > 0
    console.log("Active subscriptions:", customerState?.activeSubscriptions)
	{{/if}}

	return (
		<div>
			<h1>Dashboard</h1>
			<p>Welcome {session.data?.user.name}</p>
			{{#if ( or (eq api "orpc") (eq api "trpc"))}}
			<p>API: {privateData.data?.message}</p>
			{{/if}}
			{{#if (eq payments "polar")}}
			<p>Plan: {hasProSubscription ? "Pro" : "Free"}</p>
			{hasProSubscription ? (
				<Button onClick={async () => await authClient.customer.portal()}>
					Manage Subscription
				</Button>
			) : (
				<Button onClick={async () => await authClient.checkout({ slug: "pro" })}>
					Upgrade to Pro
				</Button>
			)}
			{{/if}}
		</div>
	);
}
`],
  ["auth/better-auth/web/react/tanstack-router/src/components/user-menu.tsx.hbs", `import { Link, useNavigate } from "@tanstack/react-router";

import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { authClient } from "@/lib/auth-client";

import { Button } from "./ui/button";
import { Skeleton } from "./ui/skeleton";

export default function UserMenu() {
  const navigate = useNavigate();
  const { data: session, isPending } = authClient.useSession();

  if (isPending) {
    return <Skeleton className="h-9 w-24" />;
  }

  if (!session) {
    return (
      <Link to="/login">
        <Button variant="outline">Sign In</Button>
      </Link>
    );
  }

  return (
    <DropdownMenu>
      <DropdownMenuTrigger render={<Button variant="outline" />}>
        {session.user.name}
      </DropdownMenuTrigger>
      <DropdownMenuContent className="bg-card">
        <DropdownMenuGroup>
          <DropdownMenuLabel>My Account</DropdownMenuLabel>
          <DropdownMenuSeparator />
          <DropdownMenuItem>{session.user.email}</DropdownMenuItem>
          <DropdownMenuItem
            variant="destructive"
            onClick={() => {
              authClient.signOut({
                fetchOptions: {
                  onSuccess: () => {
                    navigate({
                      to: "/",
                    });
                  },
                },
              });
            }}
          >
            Sign Out
          </DropdownMenuItem>
        </DropdownMenuGroup>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}
`],
  ["auth/better-auth/web/react/tanstack-router/src/components/sign-in-form.tsx.hbs", `import { authClient } from "@/lib/auth-client";
import { useForm } from "@tanstack/react-form";
import { useNavigate } from "@tanstack/react-router";
import { toast } from "sonner";
import z from "zod";
import Loader from "./loader";
import { Button } from "./ui/button";
import { Input } from "./ui/input";
import { Label } from "./ui/label";

export default function SignInForm({ onSwitchToSignUp }: { onSwitchToSignUp: () => void }) {
  const navigate = useNavigate({
    from: "/",
  });
  const { isPending } = authClient.useSession();

  const form = useForm({
    defaultValues: {
      email: "",
      password: "",
    },
    onSubmit: async ({ value }) => {
      await authClient.signIn.email(
        {
          email: value.email,
          password: value.password,
        },
        {
          onSuccess: () => {
            navigate({
              to: "/dashboard",
            });
            toast.success("Sign in successful");
          },
          onError: (error) => {
            toast.error(error.error.message || error.error.statusText);
          },
        },
      );
    },
    validators: {
      onSubmit: z.object({
        email: z.email("Invalid email address"),
        password: z.string().min(8, "Password must be at least 8 characters"),
      }),
    },
  });

  if (isPending) {
    return <Loader />;
  }

  return (
    <div className="mx-auto w-full mt-10 max-w-md p-6">
      <h1 className="mb-6 text-center text-3xl font-bold">Welcome Back</h1>

      <form
        onSubmit={(e) => {
          e.preventDefault();
          e.stopPropagation();
          form.handleSubmit();
        }}
        className="space-y-4"
      >
        <div>
          <form.Field name="email">
            {(field) => (
              <div className="space-y-2">
                <Label htmlFor={field.name}>Email</Label>
                <Input
                  id={field.name}
                  name={field.name}
                  type="email"
                  value={field.state.value}
                  onBlur={field.handleBlur}
                  onChange={(e) => field.handleChange(e.target.value)}
                />
                {field.state.meta.errors.map((error) => (
                  <p key={error?.message} className="text-red-500">
                    {error?.message}
                  </p>
                ))}
              </div>
            )}
          </form.Field>
        </div>

        <div>
          <form.Field name="password">
            {(field) => (
              <div className="space-y-2">
                <Label htmlFor={field.name}>Password</Label>
                <Input
                  id={field.name}
                  name={field.name}
                  type="password"
                  value={field.state.value}
                  onBlur={field.handleBlur}
                  onChange={(e) => field.handleChange(e.target.value)}
                />
                {field.state.meta.errors.map((error) => (
                  <p key={error?.message} className="text-red-500">
                    {error?.message}
                  </p>
                ))}
              </div>
            )}
          </form.Field>
        </div>

        <form.Subscribe>
          {(state) => (
            <Button
              type="submit"
              className="w-full"
              disabled={!state.canSubmit || state.isSubmitting}
            >
              {state.isSubmitting ? "Submitting..." : "Sign In"}
            </Button>
          )}
        </form.Subscribe>
      </form>

      <div className="mt-4 text-center">
        <Button
          variant="link"
          onClick={onSwitchToSignUp}
          className="text-indigo-600 hover:text-indigo-800"
        >
          Need an account? Sign Up
        </Button>
      </div>
    </div>
  );
}
`],
  ["auth/better-auth/web/react/tanstack-router/src/components/sign-up-form.tsx.hbs", `import { authClient } from "@/lib/auth-client";
import { useForm } from "@tanstack/react-form";
import { useNavigate } from "@tanstack/react-router";
import { toast } from "sonner";
import z from "zod";
import Loader from "./loader";
import { Button } from "./ui/button";
import { Input } from "./ui/input";
import { Label } from "./ui/label";

export default function SignUpForm({ onSwitchToSignIn }: { onSwitchToSignIn: () => void }) {
  const navigate = useNavigate({
    from: "/",
  });
  const { isPending } = authClient.useSession();

  const form = useForm({
    defaultValues: {
      email: "",
      password: "",
      name: "",
    },
    onSubmit: async ({ value }) => {
      await authClient.signUp.email(
        {
          email: value.email,
          password: value.password,
          name: value.name,
        },
        {
          onSuccess: () => {
            navigate({
              to: "/dashboard",
            });
            toast.success("Sign up successful");
          },
          onError: (error) => {
            toast.error(error.error.message || error.error.statusText);
          },
        },
      );
    },
    validators: {
      onSubmit: z.object({
        name: z.string().min(2, "Name must be at least 2 characters"),
        email: z.email("Invalid email address"),
        password: z.string().min(8, "Password must be at least 8 characters"),
      }),
    },
  });

  if (isPending) {
    return <Loader />;
  }

  return (
    <div className="mx-auto w-full mt-10 max-w-md p-6">
      <h1 className="mb-6 text-center text-3xl font-bold">Create Account</h1>

      <form
        onSubmit={(e) => {
          e.preventDefault();
          e.stopPropagation();
          form.handleSubmit();
        }}
        className="space-y-4"
      >
        <div>
          <form.Field name="name">
            {(field) => (
              <div className="space-y-2">
                <Label htmlFor={field.name}>Name</Label>
                <Input
                  id={field.name}
                  name={field.name}
                  value={field.state.value}
                  onBlur={field.handleBlur}
                  onChange={(e) => field.handleChange(e.target.value)}
                />
                {field.state.meta.errors.map((error) => (
                  <p key={error?.message} className="text-red-500">
                    {error?.message}
                  </p>
                ))}
              </div>
            )}
          </form.Field>
        </div>

        <div>
          <form.Field name="email">
            {(field) => (
              <div className="space-y-2">
                <Label htmlFor={field.name}>Email</Label>
                <Input
                  id={field.name}
                  name={field.name}
                  type="email"
                  value={field.state.value}
                  onBlur={field.handleBlur}
                  onChange={(e) => field.handleChange(e.target.value)}
                />
                {field.state.meta.errors.map((error) => (
                  <p key={error?.message} className="text-red-500">
                    {error?.message}
                  </p>
                ))}
              </div>
            )}
          </form.Field>
        </div>

        <div>
          <form.Field name="password">
            {(field) => (
              <div className="space-y-2">
                <Label htmlFor={field.name}>Password</Label>
                <Input
                  id={field.name}
                  name={field.name}
                  type="password"
                  value={field.state.value}
                  onBlur={field.handleBlur}
                  onChange={(e) => field.handleChange(e.target.value)}
                />
                {field.state.meta.errors.map((error) => (
                  <p key={error?.message} className="text-red-500">
                    {error?.message}
                  </p>
                ))}
              </div>
            )}
          </form.Field>
        </div>

        <form.Subscribe>
          {(state) => (
            <Button
              type="submit"
              className="w-full"
              disabled={!state.canSubmit || state.isSubmitting}
            >
              {state.isSubmitting ? "Submitting..." : "Sign Up"}
            </Button>
          )}
        </form.Subscribe>
      </form>

      <div className="mt-4 text-center">
        <Button
          variant="link"
          onClick={onSwitchToSignIn}
          className="text-indigo-600 hover:text-indigo-800"
        >
          Already have an account? Sign In
        </Button>
      </div>
    </div>
  );
}
`],
  ["auth/better-auth/web/react/base/src/lib/auth-client.ts.hbs", `import { createAuthClient } from "better-auth/react";
{{#if (eq payments "polar")}}
import { polarClient } from "@polar-sh/better-auth";
{{/if}}
{{#unless (eq backend "self")}}
import { env } from "@{{projectName}}/env/web";
{{/unless}}

export const authClient = createAuthClient({
{{#unless (eq backend "self")}}
	baseURL: env.{{#if (includes frontend "next")}}NEXT_PUBLIC_SERVER_URL{{else}}VITE_SERVER_URL{{/if}},
{{/unless}}
{{#if (eq payments "polar")}}
	plugins: [polarClient()]
{{/if}}
});
`],
  ["examples/todo/server/prisma/postgres/prisma/schema/todo.prisma.hbs", `model Todo {
  id        Int     @id @default(autoincrement())
  text      String
  completed Boolean @default(false)

  @@map("todo")
}
`],
  ["api/garph/web/react/base/src/utils/garph.ts.hbs", `import { QueryClient } from "@tanstack/react-query";
import { createClient, type InferClient } from "@garph/gqty";
import {
  createGeneratedSchema,
  createScalarsEnumsHash,
} from "@garph/gqty/dist/utils";
import {
  g,
  queryType,
  mutationType,
{{#if (includes examples "todo")}}
  todoType,
{{/if}}
} from "@{{projectName}}/api/index";
import { env } from "@{{projectName}}/env/web";

// Create QueryClient for React Query integration
export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      retry: 2,
      staleTime: 1000 * 60,
    },
  },
});

// Generate schema and scalars for GQty client
const generatedSchema = createGeneratedSchema(g);
const scalarsEnumsHash = createScalarsEnumsHash(g);

// Create type-safe GraphQL client
export const client = createClient<{
  query: InferClient<typeof queryType>;
  mutation: InferClient<typeof mutationType>;
}>({
  generatedSchema,
  scalarsEnumsHash,
  url: \`\${env.VITE_SERVER_URL}/graphql\`,
{{#if (eq auth "better-auth")}}
  credentials: "include",
{{/if}}
});

// Export typed query and mutation functions
export const { query, mutation, resolved } = client;

// Helper for React Query integration
export async function graphqlFetcher<T>(
  fn: () => T | Promise<T>
): Promise<T> {
  return resolved(fn);
}
`],
  ["api/garph/fullstack/astro/src/pages/api/graphql.ts.hbs", `import type { APIRoute } from "astro";
import { createYoga } from "graphql-yoga";
import { createSchema } from "@{{projectName}}/api/routers";
import { createContext } from "@{{projectName}}/api/context";
{{#if (eq auth "better-auth")}}
import { auth } from "@/lib/auth";
{{/if}}

const yoga = createYoga({
  graphqlEndpoint: "/api/graphql",
  fetchAPI: { Response },
  context: async ({ request }) => {
{{#if (eq auth "better-auth")}}
    const session = await auth.api.getSession({
      headers: request.headers,
    });
    // Create a minimal API context for Astro
    const astroContext = { request } as any;
    return createContext(astroContext, session);
{{else}}
    // Create a minimal API context for Astro
    const astroContext = { request } as any;
    return createContext(astroContext);
{{/if}}
  },
  schema: async ({ request }) => {
{{#if (eq auth "better-auth")}}
    const session = await auth.api.getSession({
      headers: request.headers,
    });
    const astroContext = { request } as any;
    const ctx = createContext(astroContext, session);
{{else}}
    const astroContext = { request } as any;
    const ctx = createContext(astroContext);
{{/if}}
    return createSchema(ctx);
  },
});

export const GET: APIRoute = async ({ request }) => {
  return yoga.handleRequest(request, {});
};

export const POST: APIRoute = async ({ request }) => {
  return yoga.handleRequest(request, {});
};
`],
  ["api/ts-rest/web/react/base/src/utils/ts-rest.ts.hbs", `import { QueryClient } from "@tanstack/react-query";
import { initClient, tsRestFetchApi } from "@ts-rest/core";
import { initTsrReactQuery } from "@ts-rest/react-query";
import { contract } from "@{{projectName}}/api/index";
import { env } from "@{{projectName}}/env/web";

export const queryClient = new QueryClient({
	defaultOptions: {
		queries: {
			retry: 2,
			staleTime: 1000 * 60,
		},
	},
});

const client = initClient(contract, {
	baseUrl: \`\${env.VITE_SERVER_URL}/rest\`,
	baseHeaders: {},
{{#if (eq auth "better-auth")}}
	credentials: "include",
{{/if}}
	api: tsRestFetchApi,
});

export const tsr = initTsrReactQuery(contract, client);
`],
  ["api/garph/fullstack/tanstack-start/src/routes/api/graphql.ts.hbs", `import { createAPIFileRoute } from "@tanstack/react-start/api";
import { createYoga } from "graphql-yoga";
import { createSchema } from "@{{projectName}}/api/routers";
import { createContext } from "@{{projectName}}/api/context";
{{#if (eq auth "better-auth")}}
import { auth } from "@/lib/auth";
{{/if}}

const yoga = createYoga({
  graphqlEndpoint: "/api/graphql",
  fetchAPI: { Response },
  context: async ({ request }) => {
{{#if (eq auth "better-auth")}}
    const session = await auth.api.getSession({
      headers: request.headers,
    });
    return createContext(request, session);
{{else}}
    return createContext(request);
{{/if}}
  },
  schema: async ({ request }) => {
{{#if (eq auth "better-auth")}}
    const session = await auth.api.getSession({
      headers: request.headers,
    });
    const ctx = createContext(request, session);
{{else}}
    const ctx = createContext(request);
{{/if}}
    return createSchema(ctx);
  },
});

export const APIRoute = createAPIFileRoute("/api/graphql")({
  GET: async ({ request }) => yoga.handleRequest(request, {}),
  POST: async ({ request }) => yoga.handleRequest(request, {}),
});
`],
  ["api/trpc/web/react/base/src/utils/trpc.ts.hbs", `{{#if (includes frontend 'next')}}
import { QueryCache, QueryClient } from '@tanstack/react-query';
import { createTRPCClient, httpBatchLink } from '@trpc/client';
import { createTRPCOptionsProxy } from '@trpc/tanstack-react-query';
import type { AppRouter } from "@{{projectName}}/api/routers/index";
import { toast } from 'sonner';
{{#unless (eq backend "self")}}
import { env } from "@{{projectName}}/env/web";
{{/unless}}

export const queryClient = new QueryClient({
	queryCache: new QueryCache({
		onError: (error, query) => {
			toast.error(error.message, {
				action: {
					label: "retry",
					onClick: query.invalidate,
				},
			});
		},
	}),
});

const trpcClient = createTRPCClient<AppRouter>({
	links: [
		httpBatchLink({
{{#if (eq backend "self")}}
			url: "/api/trpc",
{{else}}
			url: \`\${env.NEXT_PUBLIC_SERVER_URL}/trpc\`,
{{/if}}
{{#if (eq auth "better-auth")}}
			fetch(url, options) {
				return fetch(url, {
					...options,
					credentials: "include",
				});
			},
{{/if}}
		}),
	],
})

export const trpc = createTRPCOptionsProxy<AppRouter>({
	client: trpcClient,
	queryClient,
});

{{else if (includes frontend 'tanstack-start')}}
import { createTRPCContext } from "@trpc/tanstack-react-query";
import type { AppRouter } from "@{{projectName}}/api/routers/index";

export const { TRPCProvider, useTRPC, useTRPCClient } =
	createTRPCContext<AppRouter>();

{{else}}
import type { AppRouter } from "@{{projectName}}/api/routers/index";
import { QueryCache, QueryClient } from "@tanstack/react-query";
import { createTRPCClient, httpBatchLink } from "@trpc/client";
import { createTRPCOptionsProxy } from "@trpc/tanstack-react-query";
import { toast } from "sonner";
import { env } from "@{{projectName}}/env/web";

export const queryClient = new QueryClient({
	queryCache: new QueryCache({
		onError: (error, query) => {
			toast.error(error.message, {
				action: {
					label: "retry",
					onClick: query.invalidate,
				},
			});
		},
	}),
});

export const trpcClient = createTRPCClient<AppRouter>({
	links: [
		httpBatchLink({
			url: \`\${env.VITE_SERVER_URL}/trpc\`,
{{#if (eq auth "better-auth")}}
			fetch(url, options) {
				return fetch(url, {
					...options,
					credentials: "include",
				});
			},
{{/if}}
		}),
	],
});

export const trpc = createTRPCOptionsProxy<AppRouter>({
	client: trpcClient,
	queryClient,
});
{{/if}}
`],
  ["cms/sanity/web/next/src/sanity/lib/client.ts.hbs", `import { createClient, type QueryParams } from "next-sanity";

import { apiVersion, dataset, projectId, token } from "../env";

export const client = createClient({
  projectId,
  dataset,
  apiVersion,
  useCdn: true, // Set to false for ISR/SSG or tag-based revalidation
});

// Server-side client with token for authenticated requests
export const serverClient = token
  ? client.withConfig({
      token,
      useCdn: false,
    })
  : client;

// Helper function for fetching data with revalidation options
export async function sanityFetch<T>({
  query,
  params = {},
  revalidate = 60,
  tags = [],
}: {
  query: string;
  params?: QueryParams;
  revalidate?: number | false;
  tags?: string[];
}): Promise<T> {
  return client.fetch<T>(query, params, {
    next: {
      revalidate: tags.length ? false : revalidate,
      tags,
    },
  });
}
`],
  ["cms/sanity/web/next/src/sanity/lib/image.ts.hbs", `import createImageUrlBuilder from "@sanity/image-url";
import type { SanityImageSource } from "@sanity/image-url/lib/types/types";

import { dataset, projectId } from "../env";

const imageBuilder = createImageUrlBuilder({
  projectId,
  dataset,
});

export function urlFor(source: SanityImageSource) {
  return imageBuilder.image(source);
}
`],
  ["cms/sanity/web/next/src/sanity/lib/queries.ts.hbs", `import { defineQuery } from "next-sanity";

// Get all posts
export const POSTS_QUERY = defineQuery(\`
  *[_type == "post" && defined(slug.current)] | order(publishedAt desc) {
    _id,
    title,
    slug,
    excerpt,
    publishedAt,
    mainImage,
    "author": author->{ name, image }
  }
\`);

// Get a single post by slug
export const POST_QUERY = defineQuery(\`
  *[_type == "post" && slug.current == $slug][0] {
    _id,
    title,
    slug,
    excerpt,
    body,
    publishedAt,
    mainImage,
    "author": author->{ name, image, bio }
  }
\`);

// Get all pages
export const PAGES_QUERY = defineQuery(\`
  *[_type == "page" && defined(slug.current)] | order(title asc) {
    _id,
    title,
    slug
  }
\`);

// Get a single page by slug
export const PAGE_QUERY = defineQuery(\`
  *[_type == "page" && slug.current == $slug][0] {
    _id,
    title,
    slug,
    content
  }
\`);

// Get all authors
export const AUTHORS_QUERY = defineQuery(\`
  *[_type == "author"] | order(name asc) {
    _id,
    name,
    slug,
    image,
    bio
  }
\`);
`],
  ["cms/sanity/web/next/src/sanity/schemas/post.ts.hbs", `import { defineField, defineType } from "sanity";

export const post = defineType({
  name: "post",
  title: "Post",
  type: "document",
  fields: [
    defineField({
      name: "title",
      title: "Title",
      type: "string",
      validation: (rule) => rule.required(),
    }),
    defineField({
      name: "slug",
      title: "Slug",
      type: "slug",
      options: {
        source: "title",
        maxLength: 96,
      },
      validation: (rule) => rule.required(),
    }),
    defineField({
      name: "author",
      title: "Author",
      type: "reference",
      to: { type: "author" },
    }),
    defineField({
      name: "mainImage",
      title: "Main image",
      type: "image",
      options: {
        hotspot: true,
      },
    }),
    defineField({
      name: "publishedAt",
      title: "Published at",
      type: "datetime",
    }),
    defineField({
      name: "excerpt",
      title: "Excerpt",
      type: "text",
      rows: 3,
    }),
    defineField({
      name: "body",
      title: "Body",
      type: "blockContent",
    }),
  ],
  preview: {
    select: {
      title: "title",
      author: "author.name",
      media: "mainImage",
    },
    prepare(selection) {
      const { author } = selection;
      return { ...selection, subtitle: author && \`by \${author}\` };
    },
  },
});
`],
  ["cms/sanity/web/next/src/sanity/schemas/author.ts.hbs", `import { defineField, defineType } from "sanity";

export const author = defineType({
  name: "author",
  title: "Author",
  type: "document",
  fields: [
    defineField({
      name: "name",
      title: "Name",
      type: "string",
      validation: (rule) => rule.required(),
    }),
    defineField({
      name: "slug",
      title: "Slug",
      type: "slug",
      options: {
        source: "name",
        maxLength: 96,
      },
      validation: (rule) => rule.required(),
    }),
    defineField({
      name: "image",
      title: "Image",
      type: "image",
      options: {
        hotspot: true,
      },
    }),
    defineField({
      name: "bio",
      title: "Bio",
      type: "array",
      of: [
        {
          title: "Block",
          type: "block",
          styles: [{ title: "Normal", value: "normal" }],
          lists: [],
        },
      ],
    }),
  ],
  preview: {
    select: {
      title: "name",
      media: "image",
    },
  },
});
`],
  ["cms/sanity/web/next/src/sanity/schemas/page.ts.hbs", `import { defineField, defineType } from "sanity";

export const page = defineType({
  name: "page",
  title: "Page",
  type: "document",
  fields: [
    defineField({
      name: "title",
      title: "Title",
      type: "string",
      validation: (rule) => rule.required(),
    }),
    defineField({
      name: "slug",
      title: "Slug",
      type: "slug",
      options: {
        source: "title",
        maxLength: 96,
      },
      validation: (rule) => rule.required(),
    }),
    defineField({
      name: "content",
      title: "Content",
      type: "blockContent",
    }),
    defineField({
      name: "seo",
      title: "SEO",
      type: "object",
      fields: [
        defineField({
          name: "metaTitle",
          title: "Meta Title",
          type: "string",
        }),
        defineField({
          name: "metaDescription",
          title: "Meta Description",
          type: "text",
          rows: 3,
        }),
      ],
    }),
  ],
  preview: {
    select: {
      title: "title",
      subtitle: "slug.current",
    },
  },
});
`],
  ["cms/sanity/web/next/src/sanity/schemas/index.ts.hbs", `import { author } from "./author";
import { blockContent } from "./blockContent";
import { page } from "./page";
import { post } from "./post";

export const schemaTypes = [author, blockContent, page, post];
`],
  ["cms/sanity/web/next/src/sanity/schemas/blockContent.ts.hbs", `import { defineType, defineArrayMember } from "sanity";

export const blockContent = defineType({
  title: "Block Content",
  name: "blockContent",
  type: "array",
  of: [
    defineArrayMember({
      title: "Block",
      type: "block",
      styles: [
        { title: "Normal", value: "normal" },
        { title: "H1", value: "h1" },
        { title: "H2", value: "h2" },
        { title: "H3", value: "h3" },
        { title: "H4", value: "h4" },
        { title: "Quote", value: "blockquote" },
      ],
      lists: [
        { title: "Bullet", value: "bullet" },
        { title: "Numbered", value: "number" },
      ],
      marks: {
        decorators: [
          { title: "Strong", value: "strong" },
          { title: "Emphasis", value: "em" },
          { title: "Code", value: "code" },
          { title: "Underline", value: "underline" },
          { title: "Strike", value: "strike-through" },
        ],
        annotations: [
          {
            title: "URL",
            name: "link",
            type: "object",
            fields: [
              {
                title: "URL",
                name: "href",
                type: "url",
              },
            ],
          },
        ],
      },
    }),
    defineArrayMember({
      type: "image",
      options: { hotspot: true },
    }),
  ],
});
`],
  ["cms/payload/web/next/src/payload/collections/Media.ts.hbs", `import type { CollectionConfig } from "payload";

export const Media: CollectionConfig = {
  slug: "media",
  upload: {
    staticDir: "media",
    mimeTypes: ["image/*", "video/*", "audio/*", "application/pdf"],
  },
  admin: {
    useAsTitle: "alt",
  },
  fields: [
    {
      name: "alt",
      type: "text",
      required: true,
    },
    {
      name: "caption",
      type: "textarea",
    },
  ],
};
`],
  ["cms/payload/web/next/src/payload/collections/Pages.ts.hbs", `import type { CollectionConfig } from "payload";

export const Pages: CollectionConfig = {
  slug: "pages",
  admin: {
    useAsTitle: "title",
    defaultColumns: ["title", "slug", "status", "updatedAt"],
  },
  versions: {
    drafts: true,
  },
  fields: [
    {
      name: "title",
      type: "text",
      required: true,
    },
    {
      name: "slug",
      type: "text",
      required: true,
      unique: true,
      admin: {
        position: "sidebar",
      },
    },
    {
      name: "status",
      type: "select",
      options: [
        { label: "Draft", value: "draft" },
        { label: "Published", value: "published" },
      ],
      defaultValue: "draft",
      admin: {
        position: "sidebar",
      },
    },
    {
      name: "content",
      type: "richText",
    },
    {
      name: "featuredImage",
      type: "upload",
      relationTo: "media",
    },
    {
      name: "meta",
      type: "group",
      fields: [
        {
          name: "title",
          type: "text",
          label: "Meta Title",
        },
        {
          name: "description",
          type: "textarea",
          label: "Meta Description",
        },
      ],
    },
  ],
};
`],
  ["cms/payload/web/next/src/payload/collections/Users.ts.hbs", `import type { CollectionConfig } from "payload";

export const Users: CollectionConfig = {
  slug: "users",
  auth: true,
  admin: {
    useAsTitle: "email",
  },
  fields: [
    {
      name: "name",
      type: "text",
    },
    {
      name: "role",
      type: "select",
      options: [
        { label: "Admin", value: "admin" },
        { label: "Editor", value: "editor" },
        { label: "User", value: "user" },
      ],
      defaultValue: "user",
      required: true,
    },
  ],
};
`],
  ["cms/strapi/web/next/src/strapi/lib/client.ts.hbs", `import { strapi } from "@strapi/client";
import { strapiApiUrl, strapiApiToken } from "../env";

// Public client for client-side requests (no auth)
export const strapiClient = strapi({
  baseURL: strapiApiUrl,
});

// Authenticated client for server-side requests
export const strapiServerClient = strapi({
  baseURL: strapiApiUrl,
  auth: strapiApiToken,
});

// Type-safe fetch helper with revalidation support
export async function strapiFetch<T>({
  collection,
  documentId,
  params = {},
  revalidate = 60,
  tags = [],
  useAuth = false,
}: {
  collection: string;
  documentId?: string;
  params?: Record<string, unknown>;
  revalidate?: number | false;
  tags?: string[];
  useAuth?: boolean;
}): Promise<T> {
  const client = useAuth ? strapiServerClient : strapiClient;
  const collectionManager = client.collection(collection);

  // Build fetch options for Next.js caching
  const fetchOptions = {
    next: {
      revalidate: tags.length ? false : revalidate,
      tags,
    },
  };

  if (documentId) {
    // Fetch single document
    const response = await collectionManager.findOne(documentId, {
      ...params,
      ...fetchOptions,
    });
    return response as T;
  }

  // Fetch collection
  const response = await collectionManager.find({
    ...params,
    ...fetchOptions,
  });
  return response as T;
}

// Helper for single-type content
export async function strapiFetchSingle<T>({
  resource,
  params = {},
  revalidate = 60,
  tags = [],
  useAuth = false,
}: {
  resource: string;
  params?: Record<string, unknown>;
  revalidate?: number | false;
  tags?: string[];
  useAuth?: boolean;
}): Promise<T> {
  const client = useAuth ? strapiServerClient : strapiClient;
  const singleManager = client.single(resource);

  const fetchOptions = {
    next: {
      revalidate: tags.length ? false : revalidate,
      tags,
    },
  };

  const response = await singleManager.find({
    ...params,
    ...fetchOptions,
  });
  return response as T;
}
`],
  ["cms/strapi/web/next/src/strapi/lib/media.ts.hbs", `import { strapiUrl } from "../env";
import type { StrapiMedia } from "./types";

// Get full URL for Strapi media
export function getStrapiMediaUrl(media: StrapiMedia | null | undefined): string | null {
  if (!media?.url) return null;

  // If URL is already absolute, return as-is
  if (media.url.startsWith("http://") || media.url.startsWith("https://")) {
    return media.url;
  }

  // Prepend Strapi URL for relative paths
  return \`\${strapiUrl}\${media.url}\`;
}

// Get responsive image URL based on format
export function getStrapiMediaFormat(
  media: StrapiMedia | null | undefined,
  format: "thumbnail" | "small" | "medium" | "large" = "medium"
): string | null {
  if (!media) return null;

  // Try to get the requested format, fallback to original
  const formatData = media.formats?.[format];
  if (formatData?.url) {
    if (formatData.url.startsWith("http://") || formatData.url.startsWith("https://")) {
      return formatData.url;
    }
    return \`\${strapiUrl}\${formatData.url}\`;
  }

  // Fallback to original
  return getStrapiMediaUrl(media);
}

// Get image dimensions
export function getStrapiMediaDimensions(
  media: StrapiMedia | null | undefined,
  format?: "thumbnail" | "small" | "medium" | "large"
): { width: number; height: number } | null {
  if (!media) return null;

  if (format && media.formats?.[format]) {
    const formatData = media.formats[format];
    return {
      width: formatData.width,
      height: formatData.height,
    };
  }

  if (media.width && media.height) {
    return {
      width: media.width,
      height: media.height,
    };
  }

  return null;
}

// Generate srcset for responsive images
export function getStrapiSrcSet(media: StrapiMedia | null | undefined): string | null {
  if (!media?.formats) return null;

  const srcsetParts: string[] = [];
  const formats = ["thumbnail", "small", "medium", "large"] as const;

  for (const format of formats) {
    const formatData = media.formats[format];
    if (formatData?.url && formatData.width) {
      const url =
        formatData.url.startsWith("http://") || formatData.url.startsWith("https://")
          ? formatData.url
          : \`\${strapiUrl}\${formatData.url}\`;
      srcsetParts.push(\`\${url} \${formatData.width}w\`);
    }
  }

  // Add original as largest
  if (media.url && media.width) {
    const url =
      media.url.startsWith("http://") || media.url.startsWith("https://")
        ? media.url
        : \`\${strapiUrl}\${media.url}\`;
    srcsetParts.push(\`\${url} \${media.width}w\`);
  }

  return srcsetParts.length > 0 ? srcsetParts.join(", ") : null;
}
`],
  ["cms/strapi/web/next/src/strapi/lib/queries.ts.hbs", `import qs from "qs";

// Query parameter builders for common Strapi operations

// Build query string for collection fetching with pagination
export function buildCollectionQuery({
  page = 1,
  pageSize = 25,
  sort,
  filters,
  populate,
  fields,
  locale,
  publicationState = "live",
}: {
  page?: number;
  pageSize?: number;
  sort?: string | string[];
  filters?: Record<string, unknown>;
  populate?: string | string[] | Record<string, unknown>;
  fields?: string[];
  locale?: string;
  publicationState?: "live" | "preview";
}): Record<string, unknown> {
  return {
    pagination: { page, pageSize },
    ...(sort && { sort }),
    ...(filters && { filters }),
    ...(populate && { populate }),
    ...(fields && { fields }),
    ...(locale && { locale }),
    publicationState,
  };
}

// Stringify query params for URL
export function stringifyQuery(params: Record<string, unknown>): string {
  return qs.stringify(params, {
    encodeValuesOnly: true,
    arrayFormat: "brackets",
  });
}

// Common populate configurations
export const populateConfigs = {
  // Populate all first-level relations
  all: "*",
  // Deep populate for nested content
  deep: {
    populate: "*",
  },
  // Common blog post populate
  blogPost: {
    author: {
      fields: ["name", "email"],
      populate: {
        avatar: {
          fields: ["url", "alternativeText"],
        },
      },
    },
    featuredImage: {
      fields: ["url", "alternativeText", "width", "height"],
    },
    categories: {
      fields: ["name", "slug"],
    },
    seo: {
      populate: "*",
    },
  },
  // Common page populate
  page: {
    seo: {
      populate: "*",
    },
    blocks: {
      populate: "*",
    },
  },
} as const;

// Common filter builders
export const filterBuilders = {
  // Filter by slug
  bySlug: (slug: string) => ({
    slug: { $eq: slug },
  }),
  // Filter by published status
  published: () => ({
    publishedAt: { $notNull: true },
  }),
  // Filter by category
  byCategory: (categorySlug: string) => ({
    categories: {
      slug: { $eq: categorySlug },
    },
  }),
  // Search by title
  searchTitle: (query: string) => ({
    title: { $containsi: query },
  }),
  // Date range filter
  dateRange: (start: string, end: string) => ({
    publishedAt: {
      $gte: start,
      $lte: end,
    },
  }),
} as const;
`],
  ["cms/strapi/web/next/src/strapi/lib/types.ts.hbs", `// Common Strapi response types

// Pagination metadata from Strapi
export interface StrapiPagination {
  page: number;
  pageSize: number;
  pageCount: number;
  total: number;
}

// Standard Strapi collection response
export interface StrapiCollectionResponse<T> {
  data: T[];
  meta: {
    pagination: StrapiPagination;
  };
}

// Standard Strapi single response
export interface StrapiSingleResponse<T> {
  data: T;
  meta: Record<string, unknown>;
}

// Base Strapi document attributes
export interface StrapiBaseDocument {
  documentId: string;
  createdAt: string;
  updatedAt: string;
  publishedAt: string | null;
  locale?: string;
}

// Media/file type
export interface StrapiMedia {
  id: number;
  documentId: string;
  name: string;
  alternativeText: string | null;
  caption: string | null;
  width: number | null;
  height: number | null;
  formats: {
    thumbnail?: StrapiMediaFormat;
    small?: StrapiMediaFormat;
    medium?: StrapiMediaFormat;
    large?: StrapiMediaFormat;
  } | null;
  hash: string;
  ext: string;
  mime: string;
  size: number;
  url: string;
  previewUrl: string | null;
  provider: string;
}

export interface StrapiMediaFormat {
  name: string;
  hash: string;
  ext: string;
  mime: string;
  width: number;
  height: number;
  size: number;
  url: string;
}

// SEO component type (common in Strapi projects)
export interface StrapiSEO {
  metaTitle?: string;
  metaDescription?: string;
  metaImage?: StrapiMedia;
  keywords?: string;
  canonicalURL?: string;
  metaRobots?: string;
  structuredData?: Record<string, unknown>;
}

// Example content types - customize these for your project

export interface Article extends StrapiBaseDocument {
  title: string;
  slug: string;
  content: string;
  excerpt?: string;
  featuredImage?: StrapiMedia;
  author?: Author;
  categories?: Category[];
  seo?: StrapiSEO;
}

export interface Author extends StrapiBaseDocument {
  name: string;
  email?: string;
  bio?: string;
  avatar?: StrapiMedia;
}

export interface Category extends StrapiBaseDocument {
  name: string;
  slug: string;
  description?: string;
}

export interface Page extends StrapiBaseDocument {
  title: string;
  slug: string;
  content?: string;
  seo?: StrapiSEO;
}

// Homepage single type example
export interface Homepage extends StrapiBaseDocument {
  title: string;
  description?: string;
  heroImage?: StrapiMedia;
  seo?: StrapiSEO;
}
`],
  ["api/orpc/web/react/base/src/utils/orpc.ts.hbs", `import { createORPCClient } from "@orpc/client";
import { RPCLink } from "@orpc/client/fetch";
import { createTanstackQueryUtils } from "@orpc/tanstack-query";
import { QueryCache, QueryClient } from "@tanstack/react-query";
import { toast } from "sonner";
{{#if (and (includes frontend "tanstack-start") (eq backend "self"))}}
import { createRouterClient } from "@orpc/server";
import type { RouterClient } from "@orpc/server";
import { createIsomorphicFn } from "@tanstack/react-start";
import { appRouter } from "@{{projectName}}/api/routers/index";
import { createContext } from "@{{projectName}}/api/context";
{{else if (includes frontend "tanstack-start")}}
import type { RouterClient } from "@orpc/server";
import type { AppRouter } from "@{{projectName}}/api/routers/index";
import { env } from "@{{projectName}}/env/web";
{{else}}
import type { AppRouterClient } from "@{{projectName}}/api/routers/index";
{{#unless (eq backend "self")}}
import { env } from "@{{projectName}}/env/web";
{{/unless}}
{{/if}}

export const queryClient = new QueryClient({
	queryCache: new QueryCache({
		onError: (error, query) => {
			toast.error(\`Error: \${error.message}\`, {
				action: {
					label: "retry",
					onClick: query.invalidate,
				},
			});
		},
	}),
});

{{#if (and (includes frontend "tanstack-start") (eq backend "self"))}}
const getORPCClient = createIsomorphicFn()
	.server(() =>
		createRouterClient(appRouter, {
			context: async ({ req }) => {
				return createContext({ req });
			},
		}),
	)
	.client((): RouterClient<typeof appRouter> => {
			const link = new RPCLink({
			url: \`\${window.location.origin}/api/rpc\`,
{{#if (eq auth "better-auth")}}
			fetch(url, options) {
				return fetch(url, {
					...options,
					credentials: "include",
				});
			},
{{/if}}
		});

		return createORPCClient(link);
	});

export const client: RouterClient<typeof appRouter> = getORPCClient();
{{else if (includes frontend "tanstack-start")}}
const link = new RPCLink({
	url: \`\${env.VITE_SERVER_URL}/rpc\`,
{{#if (eq auth "better-auth")}}
	fetch(url, options) {
		return fetch(url, {
			...options,
			credentials: "include",
		});
	},
{{/if}}
});

const getORPCClient = () => {
	return createORPCClient(link) as RouterClient<AppRouter>;
};

export const client: RouterClient<AppRouter> = getORPCClient();
{{else}}
export const link = new RPCLink({
{{#if (and (eq backend "self") (includes frontend "next"))}}
	url: \`\${typeof window !== "undefined" ? window.location.origin : "http://localhost:3001"}/api/rpc\`,
{{else if (includes frontend "next")}}
	url: \`\${env.NEXT_PUBLIC_SERVER_URL}/rpc\`,
{{else}}
	url: \`\${env.VITE_SERVER_URL}/rpc\`,
{{/if}}
{{#if (eq auth "better-auth")}}
	fetch(url, options) {
		return fetch(url, {
			...options,
			credentials: "include",
		});
	},
{{#if (includes frontend "next")}}
	headers: async () => {
		if (typeof window !== "undefined") {
			return {}
		}

		const { headers } = await import("next/headers")
		return Object.fromEntries(await headers())
	},
{{/if}}
{{/if}}
});

export const client: AppRouterClient = createORPCClient(link)
{{/if}}

export const orpc = createTanstackQueryUtils(client)

`],
  ["payments/polar/web/react/next/src/app/success/page.tsx.hbs", `export default async function SuccessPage({
    searchParams,
}: {
    searchParams: Promise<{ checkout_id: string }>
}) {
    const params = await searchParams;
    const checkout_id = params.checkout_id;

    return (
        <div className="px-4 py-8">
            <h1>Payment Successful!</h1>
            {checkout_id && <p>Checkout ID: {checkout_id}</p>}
        </div>
    );
}
`],
  ["payments/lemon-squeezy/web/react/next/src/app/success/page.tsx.hbs", `export default async function SuccessPage({
	searchParams,
}: {
	searchParams: Promise<{ checkout_id?: string }>
}) {
	const params = await searchParams;
	const checkoutId = params.checkout_id;

	return (
		<div className="container mx-auto px-4 py-8">
			<h1 className="text-2xl font-bold mb-4">Payment Successful!</h1>
			<p className="text-gray-600 mb-4">
				Thank you for your purchase. Your payment has been processed successfully.
			</p>
			{checkoutId && (
				<p className="text-sm text-gray-500">Checkout ID: {checkoutId}</p>
			)}
		</div>
	);
}
`],
  ["payments/stripe/web/react/next/src/app/success/page.tsx.hbs", `export default async function SuccessPage({
	searchParams,
}: {
	searchParams: Promise<{ session_id: string }>
}) {
	const params = await searchParams;
	const session_id = params.session_id;

	return (
		<div className="container mx-auto px-4 py-8">
			<h1 className="text-2xl font-bold mb-4">Payment Successful!</h1>
			<p className="text-gray-600 mb-4">
				Thank you for your purchase. Your payment has been processed successfully.
			</p>
			{session_id && (
				<p className="text-sm text-gray-500">Session ID: {session_id}</p>
			)}
		</div>
	);
}
`],
  ["payments/paddle/web/react/next/src/app/success/page.tsx.hbs", `export default async function SuccessPage({
	searchParams,
}: {
	searchParams: Promise<{ transaction_id?: string }>
}) {
	const params = await searchParams;
	const transactionId = params.transaction_id;

	return (
		<div className="container mx-auto px-4 py-8">
			<h1 className="text-2xl font-bold mb-4">Payment Successful!</h1>
			<p className="text-gray-600 mb-4">
				Thank you for your purchase. Your payment has been processed successfully.
			</p>
			{transactionId && (
				<p className="text-sm text-gray-500">Transaction ID: {transactionId}</p>
			)}
		</div>
	);
}
`],
  ["examples/ai/fullstack/tanstack-start/src/routes/api/ai/$.ts.hbs", `{{#if (eq ai "modelfusion")}}
import { createFileRoute } from "@tanstack/react-router";
import { streamText, openai } from "modelfusion";

const model = openai.ChatTextGenerator({
	model: "gpt-4o-mini",
	temperature: 0.7,
	maxGenerationTokens: 1000,
});

export const Route = createFileRoute("/api/ai/$")({
	server: {
		handlers: {
			POST: async ({ request }) => {
				try {
					const { messages } = await request.json();

					const chatMessages = messages.map((msg: { role: string; content: string }) => {
						if (msg.role === "user") {
							return openai.ChatMessage.user(msg.content);
						}
						return openai.ChatMessage.assistant(msg.content);
					});

					const textStream = await streamText({
						model,
						prompt: chatMessages,
					});

					const encoder = new TextEncoder();
					const readable = new ReadableStream({
						async start(controller) {
							try {
								for await (const delta of textStream) {
									if (delta) {
										controller.enqueue(encoder.encode(\`data: \${JSON.stringify({ content: delta })}\\n\\n\`));
									}
								}
								controller.enqueue(encoder.encode("data: [DONE]\\n\\n"));
								controller.close();
							} catch (error) {
								controller.error(error);
							}
						},
					});

					return new Response(readable, {
						headers: {
							"Content-Type": "text/event-stream",
							"Cache-Control": "no-cache",
							Connection: "keep-alive",
						},
					});
				} catch (error) {
					console.error("AI API error:", error);
					return new Response(
						JSON.stringify({ error: "Failed to process AI request" }),
						{
							status: 500,
							headers: { "Content-Type": "application/json" },
						},
					);
				}
			},
		},
	},
});
{{else if (eq ai "langgraph")}}
import { createFileRoute } from "@tanstack/react-router";
import { ChatGoogleGenerativeAI } from "@langchain/google-genai";
import { HumanMessage, AIMessage, type BaseMessage } from "@langchain/core/messages";
import { createReactAgent } from "@langchain/langgraph/prebuilt";

const model = new ChatGoogleGenerativeAI({
	model: "gemini-2.0-flash",
	temperature: 0,
});

const agent = createReactAgent({
	llm: model,
	tools: [],
});

export const Route = createFileRoute("/api/ai/$")({
	server: {
		handlers: {
			POST: async ({ request }) => {
				try {
					const { messages } = await request.json();

					const langchainMessages: BaseMessage[] = messages.map((msg: { role: string; content: string }) => {
						if (msg.role === "user") {
							return new HumanMessage(msg.content);
						}
						return new AIMessage(msg.content);
					});

					const stream = await agent.stream(
						{ messages: langchainMessages },
						{ streamMode: "messages" }
					);

					const encoder = new TextEncoder();
					const readable = new ReadableStream({
						async start(controller) {
							try {
								for await (const [message] of stream) {
									if (message.content) {
										const content = typeof message.content === "string"
											? message.content
											: JSON.stringify(message.content);
										controller.enqueue(encoder.encode(\`data: \${JSON.stringify({ content })}\\n\\n\`));
									}
								}
								controller.enqueue(encoder.encode("data: [DONE]\\n\\n"));
								controller.close();
							} catch (error) {
								controller.error(error);
							}
						},
					});

					return new Response(readable, {
						headers: {
							"Content-Type": "text/event-stream",
							"Cache-Control": "no-cache",
							Connection: "keep-alive",
						},
					});
				} catch (error) {
					console.error("AI API error:", error);
					return new Response(
						JSON.stringify({ error: "Failed to process AI request" }),
						{
							status: 500,
							headers: { "Content-Type": "application/json" },
						},
					);
				}
			},
		},
	},
});
{{else if (eq ai "google-adk")}}
import { createFileRoute } from "@tanstack/react-router";
import { LlmAgent, Runner } from "@google/adk";

const agent = new LlmAgent({
	name: "chat_agent",
	model: "gemini-2.5-flash",
	description: "A helpful AI assistant that can answer questions and help with tasks.",
	instruction: "You are a helpful AI assistant. Respond to user queries in a clear and concise manner.",
	tools: [],
});

export const Route = createFileRoute("/api/ai/$")({
	server: {
		handlers: {
			POST: async ({ request }) => {
				try {
					const { messages } = await request.json();

					const lastMessage = messages[messages.length - 1];
					const userMessage = lastMessage?.content || "";

					const runner = new Runner({ agent, appName: "chat-app" });
					const result = await runner.runAsync({ userMessage });

					let responseText = "";
					for await (const event of result) {
						if (event.content?.parts) {
							for (const part of event.content.parts) {
								if (part.text) {
									responseText += part.text;
								}
							}
						}
					}

					const encoder = new TextEncoder();
					const readable = new ReadableStream({
						start(controller) {
							controller.enqueue(encoder.encode(\`data: \${JSON.stringify({ content: responseText })}\\n\\n\`));
							controller.enqueue(encoder.encode("data: [DONE]\\n\\n"));
							controller.close();
						},
					});

					return new Response(readable, {
						headers: {
							"Content-Type": "text/event-stream",
							"Cache-Control": "no-cache",
							Connection: "keep-alive",
						},
					});
				} catch (error) {
					console.error("AI API error:", error);
					return new Response(
						JSON.stringify({ error: "Failed to process AI request" }),
						{
							status: 500,
							headers: { "Content-Type": "application/json" },
						},
					);
				}
			},
		},
	},
});
{{else}}
import { createFileRoute } from "@tanstack/react-router";
import { google } from "@ai-sdk/google";
import { streamText, type UIMessage, convertToModelMessages, wrapLanguageModel } from "ai";
import { devToolsMiddleware } from "@ai-sdk/devtools";

export const Route = createFileRoute("/api/ai/$")({
  server: {
    handlers: {
      POST: async ({ request }) => {
        try {
          const { messages }: { messages: UIMessage[] } = await request.json();

          const model = wrapLanguageModel({
            model: google("gemini-2.5-flash"),
            middleware: devToolsMiddleware(),
          });
          const result = streamText({
            model,
            messages: await convertToModelMessages(messages),
          });

          return result.toUIMessageStreamResponse();
        } catch (error) {
          console.error("AI API error:", error);
          return new Response(
            JSON.stringify({ error: "Failed to process AI request" }),
            {
              status: 500,
              headers: { "Content-Type": "application/json" },
            },
          );
        }
      },
    },
  },
});
{{/if}}
`],
  ["examples/ai/fullstack/next/src/app/api/ai/route.ts.hbs", `{{#if (eq ai "modelfusion")}}
import { streamText, openai } from "modelfusion";

export const maxDuration = 30;

const model = openai.ChatTextGenerator({
	model: "gpt-4o-mini",
	temperature: 0.7,
	maxGenerationTokens: 1000,
});

export async function POST(req: Request) {
	const { messages } = await req.json();

	const chatMessages = messages.map((msg: { role: string; content: string }) => {
		if (msg.role === "user") {
			return openai.ChatMessage.user(msg.content);
		}
		return openai.ChatMessage.assistant(msg.content);
	});

	const textStream = await streamText({
		model,
		prompt: chatMessages,
	});

	const encoder = new TextEncoder();
	const readable = new ReadableStream({
		async start(controller) {
			try {
				for await (const delta of textStream) {
					if (delta) {
						controller.enqueue(encoder.encode(\`data: \${JSON.stringify({ content: delta })}\\n\\n\`));
					}
				}
				controller.enqueue(encoder.encode("data: [DONE]\\n\\n"));
				controller.close();
			} catch (error) {
				controller.error(error);
			}
		},
	});

	return new Response(readable, {
		headers: {
			"Content-Type": "text/event-stream",
			"Cache-Control": "no-cache",
			Connection: "keep-alive",
		},
	});
}
{{else if (eq ai "langgraph")}}
import { ChatGoogleGenerativeAI } from "@langchain/google-genai";
import { HumanMessage, AIMessage, type BaseMessage } from "@langchain/core/messages";
import { createReactAgent } from "@langchain/langgraph/prebuilt";

export const maxDuration = 30;

const model = new ChatGoogleGenerativeAI({
	model: "gemini-2.0-flash",
	temperature: 0,
});

const agent = createReactAgent({
	llm: model,
	tools: [],
});

export async function POST(req: Request) {
	const { messages } = await req.json();

	const langchainMessages: BaseMessage[] = messages.map((msg: { role: string; content: string }) => {
		if (msg.role === "user") {
			return new HumanMessage(msg.content);
		}
		return new AIMessage(msg.content);
	});

	const stream = await agent.stream(
		{ messages: langchainMessages },
		{ streamMode: "messages" }
	);

	const encoder = new TextEncoder();
	const readable = new ReadableStream({
		async start(controller) {
			try {
				for await (const [message] of stream) {
					if (message.content) {
						const content = typeof message.content === "string"
							? message.content
							: JSON.stringify(message.content);
						controller.enqueue(encoder.encode(\`data: \${JSON.stringify({ content })}\\n\\n\`));
					}
				}
				controller.enqueue(encoder.encode("data: [DONE]\\n\\n"));
				controller.close();
			} catch (error) {
				controller.error(error);
			}
		},
	});

	return new Response(readable, {
		headers: {
			"Content-Type": "text/event-stream",
			"Cache-Control": "no-cache",
			Connection: "keep-alive",
		},
	});
}
{{else if (eq ai "google-adk")}}
import { LlmAgent, Runner } from "@google/adk";

export const maxDuration = 30;

const agent = new LlmAgent({
	name: "chat_agent",
	model: "gemini-2.5-flash",
	description: "A helpful AI assistant that can answer questions and help with tasks.",
	instruction: "You are a helpful AI assistant. Respond to user queries in a clear and concise manner.",
	tools: [],
});

export async function POST(req: Request) {
	const { messages } = await req.json();

	const lastMessage = messages[messages.length - 1];
	const userMessage = lastMessage?.content || "";

	const runner = new Runner({ agent, appName: "chat-app" });
	const result = await runner.runAsync({ userMessage });

	let responseText = "";
	for await (const event of result) {
		if (event.content?.parts) {
			for (const part of event.content.parts) {
				if (part.text) {
					responseText += part.text;
				}
			}
		}
	}

	const encoder = new TextEncoder();
	const readable = new ReadableStream({
		start(controller) {
			controller.enqueue(encoder.encode(\`data: \${JSON.stringify({ content: responseText })}\\n\\n\`));
			controller.enqueue(encoder.encode("data: [DONE]\\n\\n"));
			controller.close();
		},
	});

	return new Response(readable, {
		headers: {
			"Content-Type": "text/event-stream",
			"Cache-Control": "no-cache",
			Connection: "keep-alive",
		},
	});
}
{{else}}
import { google } from "@ai-sdk/google";
import { streamText, type UIMessage, convertToModelMessages, wrapLanguageModel } from "ai";
import { devToolsMiddleware } from "@ai-sdk/devtools";

export const maxDuration = 30;

export async function POST(req: Request) {
	const { messages }: { messages: UIMessage[] } = await req.json();

	const model = wrapLanguageModel({
		model: google("gemini-2.5-flash"),
		middleware: devToolsMiddleware(),
	});
	const result = streamText({
		model,
		messages: await convertToModelMessages(messages),
	});

	return result.toUIMessageStreamResponse();
}
{{/if}}
`],
  ["examples/ai/web/react/next/src/app/ai/page.tsx.hbs", `{{#if (eq backend "convex")}}
"use client";

import { api } from "@{{projectName}}/backend/convex/_generated/api";
import {
  useUIMessages,
  useSmoothText,
  type UIMessage,
} from "@convex-dev/agent/react";
import { useMutation } from "convex/react";
import { Send, Loader2 } from "lucide-react";
{{#if (eq webDeploy "cloudflare")}}
import dynamic from "next/dynamic";

const Streamdown = dynamic(
  () => import("streamdown").then((mod) => ({ default: mod.Streamdown })),
  {
    loading: () => (
      <div className="flex h-full items-center justify-center">
        <div className="text-muted-foreground">Loading response...</div>
      </div>
    ),
    ssr: false,
  }
);
{{else}}
import { Streamdown } from "streamdown";
{{/if}}
import { useEffect, useRef, useState } from "react";

import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";

function MessageContent({
  text,
  isStreaming,
}: {
  text: string;
  isStreaming: boolean;
}) {
  const [visibleText] = useSmoothText(text, {
    startStreaming: isStreaming,
  });
  return <Streamdown>{visibleText}</Streamdown>;
}

export default function AIPage() {
  const [input, setInput] = useState("");
  const [threadId, setThreadId] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const messagesEndRef = useRef<HTMLDivElement>(null);

  const createThread = useMutation(api.chat.createNewThread);
  const sendMessage = useMutation(api.chat.sendMessage);

  const { results: messages } = useUIMessages(
    api.chat.listMessages,
    threadId ? { threadId } : "skip",
    { initialNumItems: 50, stream: true },
  );

  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  }, [messages]);

  const hasStreamingMessage = messages?.some(
    (m: UIMessage) => m.status === "streaming",
  );

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    const text = input.trim();
    if (!text || isLoading) return;

    setIsLoading(true);
    setInput("");

    try {
      let currentThreadId = threadId;
      if (!currentThreadId) {
        currentThreadId = await createThread();
        setThreadId(currentThreadId);
      }

      await sendMessage({ threadId: currentThreadId, prompt: text });
    } catch (error) {
      console.error("Failed to send message:", error);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="grid grid-rows-[1fr_auto] overflow-hidden w-full mx-auto p-4">
      <div className="overflow-y-auto space-y-4 pb-4">
        {!messages || messages.length === 0 ? (
          <div className="text-center text-muted-foreground mt-8">
            Ask me anything to get started!
          </div>
        ) : (
          messages.map((message: UIMessage) => (
            <div
              key={message.key}
              className={\`p-3 rounded-lg \${
                message.role === "user"
                  ? "bg-primary/10 ml-8"
                  : "bg-secondary/20 mr-8"
              }\`}
            >
              <p className="text-sm font-semibold mb-1">
                {message.role === "user" ? "You" : "AI Assistant"}
              </p>
              <MessageContent
                text={message.text ?? ""}
                isStreaming={message.status === "streaming"}
              />
            </div>
          ))
        )}
        {isLoading && !hasStreamingMessage && (
          <div className="p-3 rounded-lg bg-secondary/20 mr-8">
            <p className="text-sm font-semibold mb-1">AI Assistant</p>
            <div className="flex items-center gap-2 text-muted-foreground">
              <Loader2 className="h-4 w-4 animate-spin" />
              <span>Thinking...</span>
            </div>
          </div>
        )}
        <div ref={messagesEndRef} />
      </div>

      <form
        onSubmit={handleSubmit}
        className="w-full flex items-center space-x-2 pt-2 border-t"
      >
        <Input
          name="prompt"
          value={input}
          onChange={(e) => setInput(e.target.value)}
          placeholder="Type your message..."
          className="flex-1"
          autoComplete="off"
          autoFocus
          disabled={isLoading}
        />
        <Button type="submit" size="icon" disabled={isLoading || !input.trim()}>
          {isLoading ? (
            <Loader2 className="h-4 w-4 animate-spin" />
          ) : (
            <Send size={18} />
          )}
        </Button>
      </form>
    </div>
  );
}
{{else if (eq ai "modelfusion")}}
"use client";

import { Send, Loader2 } from "lucide-react";
{{#if (eq webDeploy "cloudflare")}}
import dynamic from "next/dynamic";

const Streamdown = dynamic(
  () => import("streamdown").then((mod) => ({ default: mod.Streamdown })),
  {
    loading: () => (
      <div className="flex h-full items-center justify-center">
        <div className="text-muted-foreground">Loading response...</div>
      </div>
    ),
    ssr: false,
  }
);
{{else}}
import { Streamdown } from "streamdown";
{{/if}}
import { useEffect, useRef, useState, useCallback } from "react";

import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
{{#unless (eq backend "self")}}
import { env } from "@{{projectName}}/env/web";
{{/unless}}

type Message = {
  id: string;
  role: "user" | "assistant";
  content: string;
};

export default function AIPage() {
  const [input, setInput] = useState("");
  const [messages, setMessages] = useState<Message[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [streamingContent, setStreamingContent] = useState("");
  const messagesEndRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  }, [messages, streamingContent]);

  const sendMessage = useCallback(async (text: string) => {
    const userMessage: Message = {
      id: Date.now().toString(),
      role: "user",
      content: text,
    };

    setMessages((prev) => [...prev, userMessage]);
    setIsLoading(true);
    setStreamingContent("");

    try {
      const response = await fetch({{#if (eq backend "self")}}"/api/ai"{{else}}\`\${env.NEXT_PUBLIC_SERVER_URL}/ai\`{{/if}}, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          messages: [...messages, userMessage].map((m) => ({
            role: m.role,
            content: m.content,
          })),
        }),
      });

      if (!response.ok) throw new Error("Failed to send message");

      const reader = response.body?.getReader();
      const decoder = new TextDecoder();
      let fullContent = "";

      if (reader) {
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          const chunk = decoder.decode(value, { stream: true });
          const lines = chunk.split("\\n");

          for (const line of lines) {
            if (line.startsWith("data: ")) {
              const data = line.slice(6);
              if (data === "[DONE]") continue;
              try {
                const parsed = JSON.parse(data);
                if (parsed.content) {
                  fullContent += parsed.content;
                  setStreamingContent(fullContent);
                }
              } catch {
                // Ignore parsing errors for incomplete chunks
              }
            }
          }
        }
      }

      const assistantMessage: Message = {
        id: (Date.now() + 1).toString(),
        role: "assistant",
        content: fullContent,
      };
      setMessages((prev) => [...prev, assistantMessage]);
      setStreamingContent("");
    } catch (error) {
      console.error("Failed to send message:", error);
    } finally {
      setIsLoading(false);
    }
  }, [messages]);

  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    const text = input.trim();
    if (!text || isLoading) return;
    setInput("");
    sendMessage(text);
  };

  return (
    <div className="grid grid-rows-[1fr_auto] overflow-hidden w-full mx-auto p-4">
      <div className="overflow-y-auto space-y-4 pb-4">
        {messages.length === 0 && !streamingContent ? (
          <div className="text-center text-muted-foreground mt-8">
            Ask me anything to get started!
          </div>
        ) : (
          <>
            {messages.map((message) => (
              <div
                key={message.id}
                className={\`p-3 rounded-lg \${
                  message.role === "user"
                    ? "bg-primary/10 ml-8"
                    : "bg-secondary/20 mr-8"
                }\`}
              >
                <p className="text-sm font-semibold mb-1">
                  {message.role === "user" ? "You" : "AI Assistant"}
                </p>
                <Streamdown>{message.content}</Streamdown>
              </div>
            ))}
            {streamingContent && (
              <div className="p-3 rounded-lg bg-secondary/20 mr-8">
                <p className="text-sm font-semibold mb-1">AI Assistant</p>
                <Streamdown isAnimating>{streamingContent}</Streamdown>
              </div>
            )}
          </>
        )}
        {isLoading && !streamingContent && (
          <div className="p-3 rounded-lg bg-secondary/20 mr-8">
            <p className="text-sm font-semibold mb-1">AI Assistant</p>
            <div className="flex items-center gap-2 text-muted-foreground">
              <Loader2 className="h-4 w-4 animate-spin" />
              <span>Thinking...</span>
            </div>
          </div>
        )}
        <div ref={messagesEndRef} />
      </div>

      <form
        onSubmit={handleSubmit}
        className="w-full flex items-center space-x-2 pt-2 border-t"
      >
        <Input
          name="prompt"
          value={input}
          onChange={(e) => setInput(e.target.value)}
          placeholder="Type your message..."
          className="flex-1"
          autoComplete="off"
          autoFocus
          disabled={isLoading}
        />
        <Button type="submit" size="icon" disabled={isLoading || !input.trim()}>
          {isLoading ? (
            <Loader2 className="h-4 w-4 animate-spin" />
          ) : (
            <Send size={18} />
          )}
        </Button>
      </form>
    </div>
  );
}
{{else if (eq ai "langgraph")}}
"use client";

import { Send, Loader2 } from "lucide-react";
{{#if (eq webDeploy "cloudflare")}}
import dynamic from "next/dynamic";

const Streamdown = dynamic(
  () => import("streamdown").then((mod) => ({ default: mod.Streamdown })),
  {
    loading: () => (
      <div className="flex h-full items-center justify-center">
        <div className="text-muted-foreground">Loading response...</div>
      </div>
    ),
    ssr: false,
  }
);
{{else}}
import { Streamdown } from "streamdown";
{{/if}}
import { useEffect, useRef, useState, useCallback } from "react";

import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
{{#unless (eq backend "self")}}
import { env } from "@{{projectName}}/env/web";
{{/unless}}

type Message = {
  id: string;
  role: "user" | "assistant";
  content: string;
};

export default function AIPage() {
  const [input, setInput] = useState("");
  const [messages, setMessages] = useState<Message[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [streamingContent, setStreamingContent] = useState("");
  const messagesEndRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  }, [messages, streamingContent]);

  const sendMessage = useCallback(async (text: string) => {
    const userMessage: Message = {
      id: Date.now().toString(),
      role: "user",
      content: text,
    };

    setMessages((prev) => [...prev, userMessage]);
    setIsLoading(true);
    setStreamingContent("");

    try {
      const response = await fetch({{#if (eq backend "self")}}"/api/ai"{{else}}\`\${env.NEXT_PUBLIC_SERVER_URL}/ai\`{{/if}}, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          messages: [...messages, userMessage].map((m) => ({
            role: m.role,
            content: m.content,
          })),
        }),
      });

      if (!response.ok) throw new Error("Failed to send message");

      const reader = response.body?.getReader();
      const decoder = new TextDecoder();
      let fullContent = "";

      if (reader) {
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          const chunk = decoder.decode(value, { stream: true });
          const lines = chunk.split("\\n");

          for (const line of lines) {
            if (line.startsWith("data: ")) {
              const data = line.slice(6);
              if (data === "[DONE]") continue;
              try {
                const parsed = JSON.parse(data);
                if (parsed.content) {
                  fullContent += parsed.content;
                  setStreamingContent(fullContent);
                }
              } catch {
                // Ignore parsing errors for incomplete chunks
              }
            }
          }
        }
      }

      const assistantMessage: Message = {
        id: (Date.now() + 1).toString(),
        role: "assistant",
        content: fullContent,
      };
      setMessages((prev) => [...prev, assistantMessage]);
      setStreamingContent("");
    } catch (error) {
      console.error("Failed to send message:", error);
    } finally {
      setIsLoading(false);
    }
  }, [messages]);

  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    const text = input.trim();
    if (!text || isLoading) return;
    setInput("");
    sendMessage(text);
  };

  return (
    <div className="grid grid-rows-[1fr_auto] overflow-hidden w-full mx-auto p-4">
      <div className="overflow-y-auto space-y-4 pb-4">
        {messages.length === 0 && !streamingContent ? (
          <div className="text-center text-muted-foreground mt-8">
            Ask me anything to get started!
          </div>
        ) : (
          <>
            {messages.map((message) => (
              <div
                key={message.id}
                className={\`p-3 rounded-lg \${
                  message.role === "user"
                    ? "bg-primary/10 ml-8"
                    : "bg-secondary/20 mr-8"
                }\`}
              >
                <p className="text-sm font-semibold mb-1">
                  {message.role === "user" ? "You" : "AI Assistant"}
                </p>
                <Streamdown>{message.content}</Streamdown>
              </div>
            ))}
            {streamingContent && (
              <div className="p-3 rounded-lg bg-secondary/20 mr-8">
                <p className="text-sm font-semibold mb-1">AI Assistant</p>
                <Streamdown isAnimating>{streamingContent}</Streamdown>
              </div>
            )}
          </>
        )}
        {isLoading && !streamingContent && (
          <div className="p-3 rounded-lg bg-secondary/20 mr-8">
            <p className="text-sm font-semibold mb-1">AI Assistant</p>
            <div className="flex items-center gap-2 text-muted-foreground">
              <Loader2 className="h-4 w-4 animate-spin" />
              <span>Thinking...</span>
            </div>
          </div>
        )}
        <div ref={messagesEndRef} />
      </div>

      <form
        onSubmit={handleSubmit}
        className="w-full flex items-center space-x-2 pt-2 border-t"
      >
        <Input
          name="prompt"
          value={input}
          onChange={(e) => setInput(e.target.value)}
          placeholder="Type your message..."
          className="flex-1"
          autoComplete="off"
          autoFocus
          disabled={isLoading}
        />
        <Button type="submit" size="icon" disabled={isLoading || !input.trim()}>
          {isLoading ? (
            <Loader2 className="h-4 w-4 animate-spin" />
          ) : (
            <Send size={18} />
          )}
        </Button>
      </form>
    </div>
  );
}
{{else}}
"use client";

import { useChat } from "@ai-sdk/react";
import { DefaultChatTransport } from "ai";
import { Send } from "lucide-react";
{{#if (eq webDeploy "cloudflare")}}
import dynamic from "next/dynamic";

const Streamdown = dynamic(
  () => import("streamdown").then((mod) => ({ default: mod.Streamdown })),
  {
    loading: () => (
      <div className="flex h-full items-center justify-center">
        <div className="text-muted-foreground">Loading response...</div>
      </div>
    ),
    ssr: false,
  }
);
{{else}}
import { Streamdown } from "streamdown";
{{/if}}
import { useEffect, useRef, useState } from "react";

import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { env } from "@{{projectName}}/env/web";

export default function AIPage() {
  const [input, setInput] = useState("");
  const { messages, sendMessage, status } = useChat({
    transport: new DefaultChatTransport({
      api: {{#if (eq backend "self")}}"/api/ai"{{else}}\`\${env.NEXT_PUBLIC_SERVER_URL}/ai\`{{/if}},
    }),
  });

  const messagesEndRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  }, [messages]);

  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    const text = input.trim();
    if (!text) return;
    sendMessage({ text });
    setInput("");
  };

  return (
    <div className="grid grid-rows-[1fr_auto] overflow-hidden w-full mx-auto p-4">
      <div className="overflow-y-auto space-y-4 pb-4">
        {messages.length === 0 ? (
          <div className="text-center text-muted-foreground mt-8">
            Ask me anything to get started!
          </div>
        ) : (
          messages.map((message) => (
            <div
              key={message.id}
              className={\`p-3 rounded-lg \${
                message.role === "user"
                  ? "bg-primary/10 ml-8"
                  : "bg-secondary/20 mr-8"
              }\`}
            >
              <p className="text-sm font-semibold mb-1">
                {message.role === "user" ? "You" : "AI Assistant"}
              </p>
              {message.parts?.map((part, index) => {
                if (part.type === "text") {
                  return (
                    <Streamdown
                      key={index}
                      isAnimating={status === "streaming" && message.role === "assistant"}
                    >
                      {part.text}
                    </Streamdown>
                  );
                }
                return null;
              })}
            </div>
          ))
        )}
        <div ref={messagesEndRef} />
      </div>

      <form
        onSubmit={handleSubmit}
        className="w-full flex items-center space-x-2 pt-2 border-t"
      >
        <Input
          name="prompt"
          value={input}
          onChange={(e) => setInput(e.target.value)}
          placeholder="Type your message..."
          className="flex-1"
          autoComplete="off"
          autoFocus
        />
        <Button type="submit" size="icon">
          <Send size={18} />
        </Button>
      </form>
    </div>
  );
}
{{/if}}
`],
  ["auth/stack-auth/web/react/next/src/app/dashboard/dashboard.tsx.hbs", `"use client";

import { UserButton } from "@stackframe/stack";

interface DashboardProps {
  user: {
    id: string;
    displayName?: string | null;
    primaryEmail?: string | null;
  };
}

export default function Dashboard({ user }: DashboardProps) {
  return (
    <div className="min-h-screen p-8">
      <div className="max-w-4xl mx-auto">
        <div className="flex justify-between items-center mb-8">
          <h1 className="text-3xl font-bold">Dashboard</h1>
          <UserButton />
        </div>

        <div className="bg-card rounded-lg shadow p-6">
          <h2 className="text-xl font-semibold mb-4">Welcome!</h2>
          <p className="text-muted-foreground">
            Hello, {user.displayName || user.primaryEmail || "User"}!
          </p>
          <p className="text-muted-foreground mt-2">
            You are now signed in with Stack Auth.
          </p>

          <div className="mt-6 p-4 bg-muted rounded">
            <h3 className="font-medium mb-2">Your Profile</h3>
            <p className="text-sm text-muted-foreground">
              <strong>Email:</strong> {user.primaryEmail || "Not set"}
            </p>
            <p className="text-sm text-muted-foreground">
              <strong>Name:</strong> {user.displayName || "Not set"}
            </p>
          </div>
        </div>
      </div>
    </div>
  );
}
`],
  ["auth/stack-auth/web/react/next/src/app/dashboard/page.tsx.hbs", `import { stackServerApp } from "@/stack/server";
import { redirect } from "next/navigation";
import Dashboard from "./dashboard";

export default async function DashboardPage() {
  const user = await stackServerApp.getUser();

  if (!user) {
    redirect("/handler/sign-in");
  }

  return <Dashboard user={user} />;
}
`],
  ["auth/stack-auth/web/react/next/src/app/login/page.tsx.hbs", `"use client";

import { useState } from "react";
import SignInForm from "@/components/sign-in-form";
import SignUpForm from "@/components/sign-up-form";

export default function LoginPage() {
  const [isSignUp, setIsSignUp] = useState(false);

  return (
    <div className="min-h-screen flex items-center justify-center">
      {isSignUp ? (
        <SignUpForm onSwitchToSignIn={() => setIsSignUp(false)} />
      ) : (
        <SignInForm onSwitchToSignUp={() => setIsSignUp(true)} />
      )}
    </div>
  );
}
`],
  ["auth/nextauth/web/react/next/src/app/dashboard/dashboard.tsx.hbs", `"use client";

import type { User } from "next-auth";
import UserMenu from "@/components/user-menu";
import { AuthProvider } from "@/components/providers";

export default function Dashboard({ user }: { user: User }) {
  return (
    <AuthProvider>
      <div className="min-h-screen bg-background">
        <header className="border-b">
          <div className="container mx-auto px-4 py-4 flex justify-between items-center">
            <h1 className="text-xl font-bold">Dashboard</h1>
            <UserMenu />
          </div>
        </header>
        <main className="container mx-auto px-4 py-8">
          <div className="max-w-2xl mx-auto">
            <h2 className="text-2xl font-bold mb-4">
              Welcome, {user.name || user.email}!
            </h2>
            <p className="text-muted-foreground mb-6">
              You are now signed in with Auth.js (NextAuth).
            </p>
            <div className="bg-card border rounded-lg p-6">
              <h3 className="font-semibold mb-2">Your Profile</h3>
              <dl className="space-y-2">
                {user.name && (
                  <div>
                    <dt className="text-sm text-muted-foreground">Name</dt>
                    <dd className="font-medium">{user.name}</dd>
                  </div>
                )}
                <div>
                  <dt className="text-sm text-muted-foreground">Email</dt>
                  <dd className="font-medium">{user.email}</dd>
                </div>
                <div>
                  <dt className="text-sm text-muted-foreground">User ID</dt>
                  <dd className="font-mono text-sm">{user.id}</dd>
                </div>
              </dl>
            </div>
          </div>
        </main>
      </div>
    </AuthProvider>
  );
}
`],
  ["auth/nextauth/web/react/next/src/app/dashboard/page.tsx.hbs", `import { auth } from "@/lib/auth";
import { redirect } from "next/navigation";
import Dashboard from "./dashboard";

export default async function DashboardPage() {
  const session = await auth();

  if (!session?.user) {
    redirect("/login");
  }

  return <Dashboard user={session.user} />;
}
`],
  ["auth/nextauth/web/react/next/src/app/login/page.tsx.hbs", `"use client";

import { useState } from "react";
import SignInForm from "@/components/sign-in-form";
import SignUpForm from "@/components/sign-up-form";

export default function LoginPage() {
  const [isSignIn, setIsSignIn] = useState(true);

  return (
    <div className="min-h-screen flex items-center justify-center">
      {isSignIn ? (
        <SignInForm onSwitchToSignUp={() => setIsSignIn(false)} />
      ) : (
        <SignUpForm onSwitchToSignIn={() => setIsSignIn(true)} />
      )}
    </div>
  );
}
`],
  ["auth/supabase-auth/web/react/next/src/app/dashboard/dashboard.tsx.hbs", `"use client";

import type { User } from "@supabase/supabase-js";
import UserMenu from "@/components/user-menu";

export default function Dashboard({ user }: { user: User }) {
  return (
    <div className="min-h-screen bg-gray-50">
      <header className="bg-white shadow">
        <div className="max-w-7xl mx-auto py-4 px-4 sm:px-6 lg:px-8 flex justify-between items-center">
          <h1 className="text-2xl font-bold text-gray-900">Dashboard</h1>
          <UserMenu />
        </div>
      </header>

      <main className="max-w-7xl mx-auto py-6 sm:px-6 lg:px-8">
        <div className="px-4 py-6 sm:px-0">
          <div className="bg-white rounded-lg shadow p-6">
            <h2 className="text-lg font-medium text-gray-900 mb-4">
              Welcome, {user.email}
            </h2>
            <p className="text-gray-600">
              You are now signed in with Supabase Auth.
            </p>
            <div className="mt-4 p-4 bg-gray-50 rounded-md">
              <h3 className="text-sm font-medium text-gray-700 mb-2">User Info</h3>
              <pre className="text-xs text-gray-600 overflow-auto">
                {JSON.stringify(
                  {
                    id: user.id,
                    email: user.email,
                    created_at: user.created_at,
                    last_sign_in_at: user.last_sign_in_at,
                  },
                  null,
                  2
                )}
              </pre>
            </div>
          </div>
        </div>
      </main>
    </div>
  );
}
`],
  ["auth/supabase-auth/web/react/next/src/app/dashboard/page.tsx.hbs", `import { redirect } from "next/navigation";
import { createClient } from "@/lib/supabase/server";
import Dashboard from "./dashboard";

export default async function DashboardPage() {
  const supabase = await createClient();

  const { data: { user }, error } = await supabase.auth.getUser();

  if (error || !user) {
    redirect("/login");
  }

  return <Dashboard user={user} />;
}
`],
  ["auth/supabase-auth/web/react/next/src/app/login/page.tsx.hbs", `"use client";

import { useState } from "react";
import SignInForm from "@/components/sign-in-form";
import SignUpForm from "@/components/sign-up-form";

export default function LoginPage() {
  const [isSignUp, setIsSignUp] = useState(false);

  return (
    <div className="min-h-screen flex items-center justify-center">
      {isSignUp ? (
        <SignUpForm onSwitchToSignIn={() => setIsSignUp(false)} />
      ) : (
        <SignInForm onSwitchToSignUp={() => setIsSignUp(true)} />
      )}
    </div>
  );
}
`],
  ["auth/nextauth/server/db/drizzle/postgres/src/schema/auth.ts.hbs", `import { pgTable, text, timestamp, primaryKey, integer } from "drizzle-orm/pg-core";

export const users = pgTable("user", {
  id: text("id")
    .primaryKey()
    .$defaultFn(() => crypto.randomUUID()),
  name: text("name"),
  email: text("email").unique(),
  emailVerified: timestamp("emailVerified", { mode: "date" }),
  image: text("image"),
});

export const accounts = pgTable(
  "account",
  {
    userId: text("userId")
      .notNull()
      .references(() => users.id, { onDelete: "cascade" }),
    type: text("type").notNull(),
    provider: text("provider").notNull(),
    providerAccountId: text("providerAccountId").notNull(),
    refresh_token: text("refresh_token"),
    access_token: text("access_token"),
    expires_at: integer("expires_at"),
    token_type: text("token_type"),
    scope: text("scope"),
    id_token: text("id_token"),
    session_state: text("session_state"),
  },
  (account) => ({
    compoundKey: primaryKey({
      columns: [account.provider, account.providerAccountId],
    }),
  })
);

export const sessions = pgTable("session", {
  sessionToken: text("sessionToken").primaryKey(),
  userId: text("userId")
    .notNull()
    .references(() => users.id, { onDelete: "cascade" }),
  expires: timestamp("expires", { mode: "date" }).notNull(),
});

export const verificationTokens = pgTable(
  "verificationToken",
  {
    identifier: text("identifier").notNull(),
    token: text("token").notNull(),
    expires: timestamp("expires", { mode: "date" }).notNull(),
  },
  (verificationToken) => ({
    compositePk: primaryKey({
      columns: [verificationToken.identifier, verificationToken.token],
    }),
  })
);
`],
  ["auth/nextauth/server/db/drizzle/sqlite/src/schema/auth.ts.hbs", `import { sqliteTable, text, integer, primaryKey } from "drizzle-orm/sqlite-core";

export const users = sqliteTable("user", {
  id: text("id")
    .primaryKey()
    .$defaultFn(() => crypto.randomUUID()),
  name: text("name"),
  email: text("email").unique(),
  emailVerified: integer("emailVerified", { mode: "timestamp" }),
  image: text("image"),
});

export const accounts = sqliteTable(
  "account",
  {
    userId: text("userId")
      .notNull()
      .references(() => users.id, { onDelete: "cascade" }),
    type: text("type").notNull(),
    provider: text("provider").notNull(),
    providerAccountId: text("providerAccountId").notNull(),
    refresh_token: text("refresh_token"),
    access_token: text("access_token"),
    expires_at: integer("expires_at"),
    token_type: text("token_type"),
    scope: text("scope"),
    id_token: text("id_token"),
    session_state: text("session_state"),
  },
  (account) => ({
    compoundKey: primaryKey({
      columns: [account.provider, account.providerAccountId],
    }),
  })
);

export const sessions = sqliteTable("session", {
  sessionToken: text("sessionToken").primaryKey(),
  userId: text("userId")
    .notNull()
    .references(() => users.id, { onDelete: "cascade" }),
  expires: integer("expires", { mode: "timestamp" }).notNull(),
});

export const verificationTokens = sqliteTable(
  "verificationToken",
  {
    identifier: text("identifier").notNull(),
    token: text("token").notNull(),
    expires: integer("expires", { mode: "timestamp" }).notNull(),
  },
  (verificationToken) => ({
    compositePk: primaryKey({
      columns: [verificationToken.identifier, verificationToken.token],
    }),
  })
);
`],
  ["auth/nextauth/server/db/drizzle/mysql/src/schema/auth.ts.hbs", `import { mysqlTable, varchar, text, timestamp, int, primaryKey } from "drizzle-orm/mysql-core";

export const users = mysqlTable("user", {
  id: varchar("id", { length: 255 })
    .primaryKey()
    .$defaultFn(() => crypto.randomUUID()),
  name: varchar("name", { length: 255 }),
  email: varchar("email", { length: 255 }).unique(),
  emailVerified: timestamp("emailVerified", { mode: "date", fsp: 3 }),
  image: varchar("image", { length: 255 }),
});

export const accounts = mysqlTable(
  "account",
  {
    userId: varchar("userId", { length: 255 })
      .notNull()
      .references(() => users.id, { onDelete: "cascade" }),
    type: varchar("type", { length: 255 }).notNull(),
    provider: varchar("provider", { length: 255 }).notNull(),
    providerAccountId: varchar("providerAccountId", { length: 255 }).notNull(),
    refresh_token: text("refresh_token"),
    access_token: text("access_token"),
    expires_at: int("expires_at"),
    token_type: varchar("token_type", { length: 255 }),
    scope: varchar("scope", { length: 255 }),
    id_token: text("id_token"),
    session_state: varchar("session_state", { length: 255 }),
  },
  (account) => ({
    compoundKey: primaryKey({
      columns: [account.provider, account.providerAccountId],
    }),
  })
);

export const sessions = mysqlTable("session", {
  sessionToken: varchar("sessionToken", { length: 255 }).primaryKey(),
  userId: varchar("userId", { length: 255 })
    .notNull()
    .references(() => users.id, { onDelete: "cascade" }),
  expires: timestamp("expires", { mode: "date" }).notNull(),
});

export const verificationTokens = mysqlTable(
  "verificationToken",
  {
    identifier: varchar("identifier", { length: 255 }).notNull(),
    token: varchar("token", { length: 255 }).notNull(),
    expires: timestamp("expires", { mode: "date" }).notNull(),
  },
  (verificationToken) => ({
    compositePk: primaryKey({
      columns: [verificationToken.identifier, verificationToken.token],
    }),
  })
);
`],
  ["auth/clerk/convex/web/react/tanstack-start/src/routes/dashboard.tsx.hbs", `import { SignInButton, UserButton, useUser } from "@clerk/tanstack-react-start";
import { api } from "@{{projectName}}/backend/convex/_generated/api";
import { createFileRoute } from "@tanstack/react-router";
import {
	Authenticated,
	AuthLoading,
	Unauthenticated,
	useQuery,
} from "convex/react";

export const Route = createFileRoute("/dashboard")({
	component: RouteComponent,
});

function RouteComponent() {
	const privateData = useQuery(api.privateData.get);
	const user = useUser();

	return (
		<>
			<Authenticated>
				<div>
					<h1>Dashboard</h1>
					<p>Welcome {user.user?.fullName}</p>
					<p>privateData: {privateData?.message}</p>
					<UserButton />
				</div>
			</Authenticated>
			<Unauthenticated>
				<SignInButton />
			</Unauthenticated>
			<AuthLoading>
				<div>Loading...</div>
			</AuthLoading>
		</>
	);
}
`],
  ["auth/clerk/convex/web/react/react-router/src/routes/dashboard.tsx.hbs", `import { SignInButton, UserButton, useUser } from "@clerk/clerk-react";
import { api } from "@{{projectName}}/backend/convex/_generated/api";
import {
	Authenticated,
	AuthLoading,
	Unauthenticated,
	useQuery,
} from "convex/react";

export default function Dashboard() {
	const privateData = useQuery(api.privateData.get);
	const user = useUser();

	return (
		<>
			<Authenticated>
				<div>
					<h1>Dashboard</h1>
					<p>Welcome {user.user?.fullName}</p>
					<p>privateData: {privateData?.message}</p>
					<UserButton />
				</div>
			</Authenticated>
			<Unauthenticated>
				<SignInButton />
			</Unauthenticated>
			<AuthLoading>
				<div>Loading...</div>
			</AuthLoading>
		</>
	);
}
`],
  ["auth/clerk/convex/web/react/tanstack-router/src/routes/dashboard.tsx.hbs", `import { SignInButton, UserButton, useUser } from "@clerk/clerk-react";
import { api } from "@{{projectName}}/backend/convex/_generated/api";
import { createFileRoute } from "@tanstack/react-router";
import {
	Authenticated,
	AuthLoading,
	Unauthenticated,
	useQuery,
} from "convex/react";

export const Route = createFileRoute("/dashboard")({
	component: RouteComponent,
});

function RouteComponent() {
	const privateData = useQuery(api.privateData.get);
	const user = useUser()

	return (
		<>
			<Authenticated>
				<div>
					<h1>Dashboard</h1>
					<p>Welcome {user.user?.fullName}</p>
					<p>privateData: {privateData?.message}</p>
					<UserButton />
				</div>
			</Authenticated>
			<Unauthenticated>
				<SignInButton />
			</Unauthenticated>
			<AuthLoading>
				<div>Loading...</div>
			</AuthLoading>
		</>
	);
}
`],
  ["auth/stack-auth/fullstack/next/src/app/handler/[...stack]/page.tsx.hbs", `import { StackHandler } from "@stackframe/stack";
import { stackServerApp } from "@/stack/server";

export default function Handler(props: unknown) {
  return <StackHandler fullPage app={stackServerApp} routeProps={props} />;
}
`],
  ["auth/nextauth/server/db/prisma/mysql/prisma/schema/auth.prisma.hbs", `model User {
  id            String    @id @default(cuid())
  name          String?
  email         String?   @unique
  emailVerified DateTime?
  image         String?
  accounts      Account[]
  sessions      Session[]
}

model Account {
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?   @db.Text
  access_token      String?   @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?   @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([provider, providerAccountId])
}

model Session {
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@id([identifier, token])
}
`],
  ["auth/nextauth/server/db/prisma/sqlite/prisma/schema/auth.prisma.hbs", `model User {
  id            String    @id @default(cuid())
  name          String?
  email         String?   @unique
  emailVerified DateTime?
  image         String?
  accounts      Account[]
  sessions      Session[]
}

model Account {
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([provider, providerAccountId])
}

model Session {
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@id([identifier, token])
}
`],
  ["auth/nextauth/server/db/prisma/postgres/prisma/schema/auth.prisma.hbs", `model User {
  id            String    @id @default(cuid())
  name          String?
  email         String?   @unique
  emailVerified DateTime?
  image         String?
  accounts      Account[]
  sessions      Session[]
}

model Account {
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([provider, providerAccountId])
}

model Session {
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@id([identifier, token])
}
`],
  ["auth/better-auth/fullstack/tanstack-start/src/routes/api/auth/$.ts.hbs", `import { auth } from '@{{projectName}}/auth'
import { createFileRoute } from '@tanstack/react-router'

export const Route = createFileRoute('/api/auth/$')({
  server: {
    handlers: {
      GET: ({ request }) => {
        return auth.handler(request)
      },
      POST: ({ request }) => {
        return auth.handler(request)
      },
    },
  },
})
`],
  ["auth/auth0/web/react/next/src/app/dashboard/dashboard.tsx.hbs", `"use client";

import { useAuthClient } from "@/lib/auth-client";

export default function Dashboard() {
  const { user, isLoading, signOut } = useAuthClient();

  if (isLoading) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-indigo-600" />
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gray-50 py-12">
      <div className="max-w-4xl mx-auto px-4">
        <div className="bg-white rounded-lg shadow p-6">
          <div className="flex items-center justify-between mb-6">
            <h1 className="text-2xl font-bold text-gray-900">Dashboard</h1>
            <button
              onClick={signOut}
              className="px-4 py-2 text-sm font-medium text-gray-700 bg-gray-100 rounded-md hover:bg-gray-200"
            >
              Sign Out
            </button>
          </div>

          <div className="border-t border-gray-200 pt-6">
            <h2 className="text-lg font-medium text-gray-900 mb-4">
              Welcome back{user?.name ? \`, \${user.name}\` : ""}!
            </h2>

            <div className="bg-gray-50 rounded-lg p-4">
              <h3 className="text-sm font-medium text-gray-500 mb-2">
                Your Profile
              </h3>
              <dl className="space-y-2">
                {user?.email && (
                  <div>
                    <dt className="text-sm font-medium text-gray-500">Email</dt>
                    <dd className="text-sm text-gray-900">{user.email}</dd>
                  </div>
                )}
                {user?.name && (
                  <div>
                    <dt className="text-sm font-medium text-gray-500">Name</dt>
                    <dd className="text-sm text-gray-900">{user.name}</dd>
                  </div>
                )}
                {user?.id && (
                  <div>
                    <dt className="text-sm font-medium text-gray-500">
                      User ID
                    </dt>
                    <dd className="text-sm text-gray-900 font-mono text-xs">
                      {user.id}
                    </dd>
                  </div>
                )}
              </dl>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}
`],
  ["auth/auth0/web/react/next/src/app/dashboard/page.tsx.hbs", `import Dashboard from "./dashboard";

export default function DashboardPage() {
  return <Dashboard />;
}
`],
  ["auth/auth0/web/react/next/src/app/login/page.tsx.hbs", `"use client";

import SignInForm from "@/components/sign-in-form";

export default function LoginPage() {
  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50">
      <SignInForm />
    </div>
  );
}
`],
  ["examples/todo/web/react/next/src/app/todos/page.tsx.hbs", `"use client"

import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Checkbox } from "@/components/ui/checkbox";
import { Input } from "@/components/ui/input";
import { Loader2, Trash2 } from "lucide-react";
import { useState } from "react";

{{#if (eq backend "convex")}}
import { useMutation, useQuery } from "convex/react";
import { api } from "@{{projectName}}/backend/convex/_generated/api";
import type { Id } from "@{{projectName}}/backend/convex/_generated/dataModel";
{{else}}
import { useMutation, useQuery } from "@tanstack/react-query";
  {{#if (eq api "orpc")}}
import { orpc } from "@/utils/orpc";
  {{/if}}
  {{#if (eq api "trpc")}}
import { trpc } from "@/utils/trpc";
  {{/if}}
{{/if}}


export default function TodosPage() {
  const [newTodoText, setNewTodoText] = useState("");

  {{#if (eq backend "convex")}}
  const todos = useQuery(api.todos.getAll);
  const createTodoMutation = useMutation(api.todos.create);
  const toggleTodoMutation = useMutation(api.todos.toggle);
  const deleteTodoMutation = useMutation(api.todos.deleteTodo);

  const handleAddTodo = async (e: React.FormEvent) => {
    e.preventDefault();
    const text = newTodoText.trim();
    if (!text) return;
    await createTodoMutation({ text });
    setNewTodoText("");
  };

  const handleToggleTodo = (id: Id<"todos">, currentCompleted: boolean) => {
    toggleTodoMutation({ id, completed: !currentCompleted });
  };

  const handleDeleteTodo = (id: Id<"todos">) => {
    deleteTodoMutation({ id });
  };
  {{else}}
    {{#if (eq api "orpc")}}
    const todos = useQuery(orpc.todo.getAll.queryOptions());
    const createMutation = useMutation(
      orpc.todo.create.mutationOptions({
        onSuccess: () => {
          todos.refetch();
          setNewTodoText("");
        },
      }),
    );
    const toggleMutation = useMutation(
      orpc.todo.toggle.mutationOptions({
        onSuccess: () => { todos.refetch() },
      }),
    );
    const deleteMutation = useMutation(
      orpc.todo.delete.mutationOptions({
        onSuccess: () => { todos.refetch() },
      }),
    );
    {{/if}}
    {{#if (eq api "trpc")}}
    const todos = useQuery(trpc.todo.getAll.queryOptions());
    const createMutation = useMutation(
      trpc.todo.create.mutationOptions({
        onSuccess: () => {
          todos.refetch();
          setNewTodoText("");
        },
      }),
    );
    const toggleMutation = useMutation(
      trpc.todo.toggle.mutationOptions({
        onSuccess: () => { todos.refetch() },
      }),
    );
    const deleteMutation = useMutation(
      trpc.todo.delete.mutationOptions({
        onSuccess: () => { todos.refetch() },
      }),
    );
    {{/if}}

  const handleAddTodo = (e: React.FormEvent) => {
    e.preventDefault();
    if (newTodoText.trim()) {
      createMutation.mutate({ text: newTodoText });
    }
  };

  const handleToggleTodo = (id: number, completed: boolean) => {
    toggleMutation.mutate({ id, completed: !completed });
  };

  const handleDeleteTodo = (id: number) => {
    deleteMutation.mutate({ id });
  };
  {{/if}}

  return (
    <div className="mx-auto w-full max-w-md py-10">
      <Card>
        <CardHeader>
          <CardTitle>Todo List</CardTitle>
          <CardDescription>Manage your tasks efficiently</CardDescription>
        </CardHeader>
        <CardContent>
          <form
            onSubmit={handleAddTodo}
            className="mb-6 flex items-center space-x-2"
          >
            <Input
              value={newTodoText}
              onChange={(e) => setNewTodoText(e.target.value)}
              placeholder="Add a new task..."
              {{#if (eq backend "convex")}}
              {{else}}
              disabled={createMutation.isPending}
              {{/if}}
            />
            <Button
              type="submit"
              {{#if (eq backend "convex")}}
              disabled={!newTodoText.trim()}
              {{else}}
              disabled={createMutation.isPending || !newTodoText.trim()}
              {{/if}}
            >
              {{#if (eq backend "convex")}}
                Add
              {{else}}
                {createMutation.isPending ? (
                  <Loader2 className="h-4 w-4 animate-spin" />
                ) : (
                  "Add"
                )}
              {{/if}}
            </Button>
          </form>

          {{#if (eq backend "convex")}}
            {todos === undefined ? (
              <div className="flex justify-center py-4">
                <Loader2 className="h-6 w-6 animate-spin" />
              </div>
            ) : todos.length === 0 ? (
              <p className="py-4 text-center">No todos yet. Add one above!</p>
            ) : (
              <ul className="space-y-2">
                {todos.map((todo) => (
                  <li
                    key={todo._id}
                    className="flex items-center justify-between rounded-md border p-2"
                  >
                    <div className="flex items-center space-x-2">
                      <Checkbox
                        checked={todo.completed}
                        onCheckedChange={() =>
                          handleToggleTodo(todo._id, todo.completed)
                        }
                        id={\`todo-\${todo._id}\`}
                      />
                      <label
                        htmlFor={\`todo-\${todo._id}\`}
                        className={\`\${todo.completed ? "line-through text-muted-foreground" : ""}\`}
                      >
                        {todo.text}
                      </label>
                    </div>
                    <Button
                      variant="ghost"
                      size="icon"
                      onClick={() => handleDeleteTodo(todo._id)}
                      aria-label="Delete todo"
                    >
                      <Trash2 className="h-4 w-4" />
                    </Button>
                  </li>
                ))}
              </ul>
            )}
          {{else}}
            {todos.isLoading ? (
              <div className="flex justify-center py-4">
                <Loader2 className="h-6 w-6 animate-spin" />
              </div>
            ) : todos.data?.length === 0 ? (
              <p className="py-4 text-center">
                No todos yet. Add one above!
              </p>
            ) : (
              <ul className="space-y-2">
                {todos.data?.map((todo) => (
                  <li
                    key={todo.id}
                    className="flex items-center justify-between rounded-md border p-2"
                  >
                    <div className="flex items-center space-x-2">
                      <Checkbox
                        checked={todo.completed}
                        onCheckedChange={() =>
                          handleToggleTodo(todo.id, todo.completed)
                        }
                        id={\`todo-\${todo.id}\`}
                      />
                      <label
                        htmlFor={\`todo-\${todo.id}\`}
                        className={\`\${todo.completed ? "line-through text-muted-foreground" : ""}\`}
                      >
                        {todo.text}
                      </label>
                    </div>
                    <Button
                      variant="ghost"
                      size="icon"
                      onClick={() => handleDeleteTodo(todo.id)}
                      aria-label="Delete todo"
                    >
                      <Trash2 className="h-4 w-4" />
                    </Button>
                  </li>
                ))}
              </ul>
            )}
          {{/if}}
        </CardContent>
      </Card>
    </div>
  );
}
`],
  ["auth/better-auth/web/react/next/src/app/dashboard/dashboard.tsx.hbs", `"use client";
{{#if (eq payments "polar")}}
import { Button } from "@/components/ui/button";
{{/if}}
import { authClient } from "@/lib/auth-client";
{{#if (eq api "orpc")}}
import { useQuery } from "@tanstack/react-query";
import { orpc } from "@/utils/orpc";
{{/if}}
{{#if (eq api "trpc")}}
import { useQuery } from "@tanstack/react-query";
import { trpc } from "@/utils/trpc";
{{/if}}

export default function Dashboard({
	{{#if (eq payments "polar")}}
	customerState,
	{{/if}}
	session
}: {
	{{#if (eq payments "polar")}}
	customerState: ReturnType<typeof authClient.customer.state>;
	{{/if}}
	session: typeof authClient.$Infer.Session;
}) {
	{{#if (eq api "orpc")}}
	const privateData = useQuery(orpc.privateData.queryOptions());
	{{/if}}
	{{#if (eq api "trpc")}}
	const privateData = useQuery(trpc.privateData.queryOptions());
	{{/if}}

	{{#if (eq payments "polar")}}
	const hasProSubscription = customerState?.activeSubscriptions?.length! > 0;
	console.log("Active subscriptions:", customerState?.activeSubscriptions);
	{{/if}}

	return (
		<>
			{{#if (eq api "orpc")}}
			<p>API: {privateData.data?.message}</p>
			{{/if}}
			{{#if (eq api "trpc")}}
			<p>API: {privateData.data?.message}</p>
			{{/if}}
			{{#if (eq payments "polar")}}
			<p>Plan: {hasProSubscription ? "Pro" : "Free"}</p>
			{hasProSubscription ? (
				<Button onClick={async () => await authClient.customer.portal()}>
					Manage Subscription
				</Button>
			) : (
				<Button onClick={async () => await authClient.checkout({ slug: "pro" })}>
					Upgrade to Pro
				</Button>
			)}
			{{/if}}
		</>
	);
}
`],
  ["auth/better-auth/web/react/next/src/app/dashboard/page.tsx.hbs", `import { redirect } from "next/navigation";
import Dashboard from "./dashboard";
import { headers } from "next/headers";
{{#if (eq backend "self")}}
import { auth } from "@{{projectName}}/auth";
{{/if}}
import { authClient } from "@/lib/auth-client";

export default async function DashboardPage() {
	{{#if (eq backend "self")}}
	const session = await auth.api.getSession({
		headers: await headers(),
	});
	{{else}}
	const session = await authClient.getSession({
		fetchOptions: {
			headers: await headers(),
			throw: true
		}
	});
	{{/if}}

	if (!session?.user) {
		redirect("/login");
	}

	{{#if (eq payments "polar")}}
	const { data: customerState } = await authClient.customer.state({
		fetchOptions: {
			headers: await headers(),
		},
	});
	{{/if}}

	return (
		<div>
			<h1>Dashboard</h1>
			<p>Welcome {session.user.name}</p>
			<Dashboard session={session} {{#if (eq payments "polar")}}customerState={customerState}{{/if}} />
		</div>
	);
}
`],
  ["auth/better-auth/web/react/next/src/app/login/page.tsx.hbs", `"use client"

import SignInForm from "@/components/sign-in-form";
import SignUpForm from "@/components/sign-up-form";
import { useState } from "react";


export default function LoginPage() {
  const [showSignIn, setShowSignIn] = useState(false);

  return showSignIn ? (
    <SignInForm onSwitchToSignUp={() => setShowSignIn(false)} />
  ) : (
    <SignUpForm onSwitchToSignIn={() => setShowSignIn(true)} />
  );
}
`],
  ["auth/better-auth/convex/web/react/tanstack-router/src/routes/dashboard.tsx.hbs", `import SignInForm from "@/components/sign-in-form";
import SignUpForm from "@/components/sign-up-form";
import UserMenu from "@/components/user-menu";
import { api } from "@{{projectName}}/backend/convex/_generated/api";
import { createFileRoute } from "@tanstack/react-router";
import {
  Authenticated,
  AuthLoading,
  Unauthenticated,
  useQuery,
} from "convex/react";
import { useState } from "react";

export const Route = createFileRoute("/dashboard")({
  component: RouteComponent,
});

function RouteComponent() {
  const [showSignIn, setShowSignIn] = useState(false);
  const privateData = useQuery(api.privateData.get);

  return (
    <>
      <Authenticated>
        <div>
          <h1>Dashboard</h1>
          <p>privateData: {privateData?.message}</p>
          <UserMenu />
        </div>
      </Authenticated>
      <Unauthenticated>
        {showSignIn ? (
          <SignInForm onSwitchToSignUp={() => setShowSignIn(false)} />
        ) : (
          <SignUpForm onSwitchToSignIn={() => setShowSignIn(true)} />
        )}
      </Unauthenticated>
      <AuthLoading>
        <div>Loading...</div>
      </AuthLoading>
    </>
  );
}
`],
  ["auth/better-auth/convex/web/react/tanstack-router/src/components/user-menu.tsx.hbs", `import { useNavigate } from "@tanstack/react-router";

import {
    DropdownMenu,
    DropdownMenuContent,
    DropdownMenuGroup,
    DropdownMenuItem,
    DropdownMenuLabel,
    DropdownMenuSeparator,
    DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { authClient } from "@/lib/auth-client";
import { useQuery } from "convex/react";
import { api } from "@{{projectName}}/backend/convex/_generated/api";

import { Button } from "./ui/button";

export default function UserMenu() {
    const navigate = useNavigate();
    const user = useQuery(api.auth.getCurrentUser)

    return (
        <DropdownMenu>
            <DropdownMenuTrigger render={<Button variant="outline" />}>
                {user?.name}
            </DropdownMenuTrigger>
            <DropdownMenuContent className="bg-card">
                <DropdownMenuGroup>
                    <DropdownMenuLabel>My Account</DropdownMenuLabel>
                    <DropdownMenuSeparator />
                    <DropdownMenuItem>{user?.email}</DropdownMenuItem>
                    <DropdownMenuItem
                        variant="destructive"
                        onClick={() => {
                            authClient.signOut({
                                fetchOptions: {
                                    onSuccess: () => {
                                        navigate({
                                            to: "/dashboard",
                                        });
                                    },
                                },
                            });
                        }}
                    >
                        Sign Out
                    </DropdownMenuItem>
                </DropdownMenuGroup>
            </DropdownMenuContent>
        </DropdownMenu>
    );
}
`],
  ["auth/better-auth/convex/web/react/tanstack-router/src/components/sign-in-form.tsx.hbs", `import { authClient } from "@/lib/auth-client";
import { useForm } from "@tanstack/react-form";
import { useNavigate } from "@tanstack/react-router";
import { toast } from "sonner";
import z from "zod";
import { Button } from "./ui/button";
import { Input } from "./ui/input";
import { Label } from "./ui/label";

export default function SignInForm({
    onSwitchToSignUp,
}: {
    onSwitchToSignUp: () => void;
}) {
    const navigate = useNavigate({
        from: "/",
    });

    const form = useForm({
        defaultValues: {
            email: "",
            password: "",
        },
        onSubmit: async ({ value }) => {
            await authClient.signIn.email(
                {
                    email: value.email,
                    password: value.password,
                },
                {
                    onSuccess: () => {
                        navigate({
                            to: "/dashboard",
                        });
                        toast.success("Sign in successful");
                    },
                    onError: (error) => {
                        toast.error(error.error.message || error.error.statusText);
                    },
                },
            );
        },
        validators: {
            onSubmit: z.object({
                email: z.email("Invalid email address"),
                password: z.string().min(8, "Password must be at least 8 characters"),
            }),
        },
    });

    return (
        <div className="mx-auto w-full mt-10 max-w-md p-6">
            <h1 className="mb-6 text-center text-3xl font-bold">Welcome Back</h1>

            <form
                onSubmit={(e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    form.handleSubmit();
                }}
                className="space-y-4"
            >
                <div>
                    <form.Field name="email">
                        {(field) => (
                            <div className="space-y-2">
                                <Label htmlFor={field.name}>Email</Label>
                                <Input
                                    id={field.name}
                                    name={field.name}
                                    type="email"
                                    value={field.state.value}
                                    onBlur={field.handleBlur}
                                    onChange={(e) => field.handleChange(e.target.value)}
                                />
                                {field.state.meta.errors.map((error) => (
                                    <p key={error?.message} className="text-red-500">
                                        {error?.message}
                                    </p>
                                ))}
                            </div>
                        )}
                    </form.Field>
                </div>

                <div>
                    <form.Field name="password">
                        {(field) => (
                            <div className="space-y-2">
                                <Label htmlFor={field.name}>Password</Label>
                                <Input
                                    id={field.name}
                                    name={field.name}
                                    type="password"
                                    value={field.state.value}
                                    onBlur={field.handleBlur}
                                    onChange={(e) => field.handleChange(e.target.value)}
                                />
                                {field.state.meta.errors.map((error) => (
                                    <p key={error?.message} className="text-red-500">
                                        {error?.message}
                                    </p>
                                ))}
                            </div>
                        )}
                    </form.Field>
                </div>

                <form.Subscribe>
                    {(state) => (
                        <Button
                            type="submit"
                            className="w-full"
                            disabled={!state.canSubmit || state.isSubmitting}
                        >
                            {state.isSubmitting ? "Submitting..." : "Sign In"}
                        </Button>
                    )}
                </form.Subscribe>
            </form>

            <div className="mt-4 text-center">
                <Button
                    variant="link"
                    onClick={onSwitchToSignUp}
                    className="text-indigo-600 hover:text-indigo-800"
                >
                    Need an account? Sign Up
                </Button>
            </div>
        </div>
    );
}
`],
  ["auth/better-auth/convex/web/react/tanstack-router/src/components/sign-up-form.tsx.hbs", `import { authClient } from "@/lib/auth-client";
import { useForm } from "@tanstack/react-form";
import { useNavigate } from "@tanstack/react-router";
import { toast } from "sonner";
import z from "zod";
import { Button } from "./ui/button";
import { Input } from "./ui/input";
import { Label } from "./ui/label";

export default function SignUpForm({
    onSwitchToSignIn,
}: {
    onSwitchToSignIn: () => void;
}) {
    const navigate = useNavigate({
        from: "/",
    });

    const form = useForm({
        defaultValues: {
            email: "",
            password: "",
            name: "",
        },
        onSubmit: async ({ value }) => {
            await authClient.signUp.email(
                {
                    email: value.email,
                    password: value.password,
                    name: value.name,
                },
                {
                    onSuccess: () => {
                        navigate({
                            to: "/dashboard",
                        });
                        toast.success("Sign up successful");
                    },
                    onError: (error) => {
                        toast.error(error.error.message || error.error.statusText);
                    },
                },
            );
        },
        validators: {
            onSubmit: z.object({
                name: z.string().min(2, "Name must be at least 2 characters"),
                email: z.email("Invalid email address"),
                password: z.string().min(8, "Password must be at least 8 characters"),
            }),
        },
    });

    return (
        <div className="mx-auto w-full mt-10 max-w-md p-6">
            <h1 className="mb-6 text-center text-3xl font-bold">Create Account</h1>

            <form
                onSubmit={(e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    form.handleSubmit();
                }}
                className="space-y-4"
            >
                <div>
                    <form.Field name="name">
                        {(field) => (
                            <div className="space-y-2">
                                <Label htmlFor={field.name}>Name</Label>
                                <Input
                                    id={field.name}
                                    name={field.name}
                                    value={field.state.value}
                                    onBlur={field.handleBlur}
                                    onChange={(e) => field.handleChange(e.target.value)}
                                />
                                {field.state.meta.errors.map((error) => (
                                    <p key={error?.message} className="text-red-500">
                                        {error?.message}
                                    </p>
                                ))}
                            </div>
                        )}
                    </form.Field>
                </div>

                <div>
                    <form.Field name="email">
                        {(field) => (
                            <div className="space-y-2">
                                <Label htmlFor={field.name}>Email</Label>
                                <Input
                                    id={field.name}
                                    name={field.name}
                                    type="email"
                                    value={field.state.value}
                                    onBlur={field.handleBlur}
                                    onChange={(e) => field.handleChange(e.target.value)}
                                />
                                {field.state.meta.errors.map((error) => (
                                    <p key={error?.message} className="text-red-500">
                                        {error?.message}
                                    </p>
                                ))}
                            </div>
                        )}
                    </form.Field>
                </div>

                <div>
                    <form.Field name="password">
                        {(field) => (
                            <div className="space-y-2">
                                <Label htmlFor={field.name}>Password</Label>
                                <Input
                                    id={field.name}
                                    name={field.name}
                                    type="password"
                                    value={field.state.value}
                                    onBlur={field.handleBlur}
                                    onChange={(e) => field.handleChange(e.target.value)}
                                />
                                {field.state.meta.errors.map((error) => (
                                    <p key={error?.message} className="text-red-500">
                                        {error?.message}
                                    </p>
                                ))}
                            </div>
                        )}
                    </form.Field>
                </div>

                <form.Subscribe>
                    {(state) => (
                        <Button
                            type="submit"
                            className="w-full"
                            disabled={!state.canSubmit || state.isSubmitting}
                        >
                            {state.isSubmitting ? "Submitting..." : "Sign Up"}
                        </Button>
                    )}
                </form.Subscribe>
            </form>

            <div className="mt-4 text-center">
                <Button
                    variant="link"
                    onClick={onSwitchToSignIn}
                    className="text-indigo-600 hover:text-indigo-800"
                >
                    Already have an account? Sign In
                </Button>
            </div>
        </div>
    );
}
`],
  ["auth/better-auth/convex/web/react/tanstack-router/src/lib/auth-client.ts.hbs", `import { createAuthClient } from "better-auth/react";
import {
	convexClient,
	crossDomainClient,
} from "@convex-dev/better-auth/client/plugins";
import { env } from "@{{projectName}}/env/web";

export const authClient = createAuthClient({
	baseURL: env.VITE_CONVEX_SITE_URL,
	plugins: [convexClient(), crossDomainClient()],
});`],
  ["auth/better-auth/convex/web/react/next/src/components/user-menu.tsx.hbs", `import {
	DropdownMenu,
	DropdownMenuContent,
	DropdownMenuGroup,
	DropdownMenuItem,
	DropdownMenuLabel,
	DropdownMenuSeparator,
	DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { authClient } from "@/lib/auth-client";
import { Button } from "./ui/button";
import { useRouter } from "next/navigation";
import { useQuery } from "convex/react";
import { api } from "@{{projectName}}/backend/convex/_generated/api";

export default function UserMenu() {
	const router = useRouter();
	const user = useQuery(api.auth.getCurrentUser)

	return (
		<DropdownMenu>
			<DropdownMenuTrigger render={<Button variant="outline" />}>
				{user?.name}
			</DropdownMenuTrigger>
			<DropdownMenuContent className="bg-card">
				<DropdownMenuGroup>
					<DropdownMenuLabel>My Account</DropdownMenuLabel>
					<DropdownMenuSeparator />
					<DropdownMenuItem>{user?.email}</DropdownMenuItem>
					<DropdownMenuItem
						variant="destructive"
						onClick={() => {
							authClient.signOut({
								fetchOptions: {
									onSuccess: () => {
										router.push("/dashboard");
									},
								},
							});
						}}
					>
						Sign Out
					</DropdownMenuItem>
				</DropdownMenuGroup>
			</DropdownMenuContent>
		</DropdownMenu>
	);
}
`],
  ["auth/better-auth/convex/web/react/next/src/components/sign-in-form.tsx.hbs", `import { authClient } from "@/lib/auth-client";
import { useForm } from "@tanstack/react-form";
import { toast } from "sonner";
import z from "zod";
import { Button } from "./ui/button";
import { Input } from "./ui/input";
import { Label } from "./ui/label";
import { useRouter } from "next/navigation";

export default function SignInForm({
	onSwitchToSignUp,
}: {
	onSwitchToSignUp: () => void;
}) {
	const router = useRouter();

	const form = useForm({
		defaultValues: {
			email: "",
			password: "",
		},
		onSubmit: async ({ value }) => {
			await authClient.signIn.email(
				{
					email: value.email,
					password: value.password,
				},
				{
					onSuccess: () => {
						router.push("/dashboard");
						toast.success("Sign in successful");
					},
					onError: (error) => {
						toast.error(error.error.message || error.error.statusText);
					},
				},
			);
		},
		validators: {
			onSubmit: z.object({
				email: z.email("Invalid email address"),
				password: z.string().min(8, "Password must be at least 8 characters"),
			}),
		},
	});

	return (
		<div className="mx-auto w-full mt-10 max-w-md p-6">
			<h1 className="mb-6 text-center text-3xl font-bold">Welcome Back</h1>

			<form
				onSubmit={(e) => {
					e.preventDefault();
					e.stopPropagation();
					form.handleSubmit();
				}}
				className="space-y-4"
			>
				<div>
					<form.Field name="email">
						{(field) => (
							<div className="space-y-2">
								<Label htmlFor={field.name}>Email</Label>
								<Input
									id={field.name}
									name={field.name}
									type="email"
									value={field.state.value}
									onBlur={field.handleBlur}
									onChange={(e) => field.handleChange(e.target.value)}
								/>
								{field.state.meta.errors.map((error) => (
									<p key={error?.message} className="text-red-500">
										{error?.message}
									</p>
								))}
							</div>
						)}
					</form.Field>
				</div>

				<div>
					<form.Field name="password">
						{(field) => (
							<div className="space-y-2">
								<Label htmlFor={field.name}>Password</Label>
								<Input
									id={field.name}
									name={field.name}
									type="password"
									value={field.state.value}
									onBlur={field.handleBlur}
									onChange={(e) => field.handleChange(e.target.value)}
								/>
								{field.state.meta.errors.map((error) => (
									<p key={error?.message} className="text-red-500">
										{error?.message}
									</p>
								))}
							</div>
						)}
					</form.Field>
				</div>

				<form.Subscribe>
					{(state) => (
						<Button
							type="submit"
							className="w-full"
							disabled={!state.canSubmit || state.isSubmitting}
						>
							{state.isSubmitting ? "Submitting..." : "Sign In"}
						</Button>
					)}
				</form.Subscribe>
			</form>

			<div className="mt-4 text-center">
				<Button
					variant="link"
					onClick={onSwitchToSignUp}
					className="text-indigo-600 hover:text-indigo-800"
				>
					Need an account? Sign Up
				</Button>
			</div>
		</div>
	);
}
`],
  ["auth/better-auth/convex/web/react/next/src/components/sign-up-form.tsx.hbs", `import { authClient } from "@/lib/auth-client";
import { useForm } from "@tanstack/react-form";
import { toast } from "sonner";
import z from "zod";
import { Button } from "./ui/button";
import { Input } from "./ui/input";
import { Label } from "./ui/label";
import { useRouter } from "next/navigation";

export default function SignUpForm({
	onSwitchToSignIn,
}: {
	onSwitchToSignIn: () => void;
}) {
	const router = useRouter();

	const form = useForm({
		defaultValues: {
			email: "",
			password: "",
			name: "",
		},
		onSubmit: async ({ value }) => {
			await authClient.signUp.email(
				{
					email: value.email,
					password: value.password,
					name: value.name,
				},
				{
					onSuccess: () => {
						router.push("/dashboard");
						toast.success("Sign up successful");
					},
					onError: (error) => {
						toast.error(error.error.message || error.error.statusText);
					},
				},
			);
		},
		validators: {
			onSubmit: z.object({
				name: z.string().min(2, "Name must be at least 2 characters"),
				email: z.email("Invalid email address"),
				password: z.string().min(8, "Password must be at least 8 characters"),
			}),
		},
	});

	return (
		<div className="mx-auto w-full mt-10 max-w-md p-6">
			<h1 className="mb-6 text-center text-3xl font-bold">Create Account</h1>

			<form
				onSubmit={(e) => {
					e.preventDefault();
					e.stopPropagation();
					form.handleSubmit();
				}}
				className="space-y-4"
			>
				<div>
					<form.Field name="name">
						{(field) => (
							<div className="space-y-2">
								<Label htmlFor={field.name}>Name</Label>
								<Input
									id={field.name}
									name={field.name}
									value={field.state.value}
									onBlur={field.handleBlur}
									onChange={(e) => field.handleChange(e.target.value)}
								/>
								{field.state.meta.errors.map((error) => (
									<p key={error?.message} className="text-red-500">
										{error?.message}
									</p>
								))}
							</div>
						)}
					</form.Field>
				</div>

				<div>
					<form.Field name="email">
						{(field) => (
							<div className="space-y-2">
								<Label htmlFor={field.name}>Email</Label>
								<Input
									id={field.name}
									name={field.name}
									type="email"
									value={field.state.value}
									onBlur={field.handleBlur}
									onChange={(e) => field.handleChange(e.target.value)}
								/>
								{field.state.meta.errors.map((error) => (
									<p key={error?.message} className="text-red-500">
										{error?.message}
									</p>
								))}
							</div>
						)}
					</form.Field>
				</div>

				<div>
					<form.Field name="password">
						{(field) => (
							<div className="space-y-2">
								<Label htmlFor={field.name}>Password</Label>
								<Input
									id={field.name}
									name={field.name}
									type="password"
									value={field.state.value}
									onBlur={field.handleBlur}
									onChange={(e) => field.handleChange(e.target.value)}
								/>
								{field.state.meta.errors.map((error) => (
									<p key={error?.message} className="text-red-500">
										{error?.message}
									</p>
								))}
							</div>
						)}
					</form.Field>
				</div>

				<form.Subscribe>
					{(state) => (
						<Button
							type="submit"
							className="w-full"
							disabled={!state.canSubmit || state.isSubmitting}
						>
							{state.isSubmitting ? "Submitting..." : "Sign Up"}
						</Button>
					)}
				</form.Subscribe>
			</form>

			<div className="mt-4 text-center">
				<Button
					variant="link"
					onClick={onSwitchToSignIn}
					className="text-indigo-600 hover:text-indigo-800"
				>
					Already have an account? Sign In
				</Button>
			</div>
		</div>
	);
}
`],
  ["auth/better-auth/server/db/mongoose/mongodb/src/models/auth.model.ts.hbs", `import mongoose from 'mongoose';

const { Schema, model } = mongoose;

const userSchema = new Schema(
    {
        _id: { type: String },
        name: { type: String, required: true },
        email: { type: String, required: true, unique: true },
        emailVerified: { type: Boolean, required: true },
        image: { type: String },
        createdAt: { type: Date, required: true },
        updatedAt: { type: Date, required: true },
    },
    { collection: 'user' }
);

const sessionSchema = new Schema(
    {
        _id: { type: String },
        expiresAt: { type: Date, required: true },
        token: { type: String, required: true, unique: true },
        createdAt: { type: Date, required: true },
        updatedAt: { type: Date, required: true },
        ipAddress: { type: String },
        userAgent: { type: String },
        userId: { type: String, ref: 'User', required: true },
    },
    { collection: 'session' }
);

const accountSchema = new Schema(
    {
        _id: { type: String },
        accountId: { type: String, required: true },
        providerId: { type: String, required: true },
        userId: { type: String, ref: 'User', required: true },
        accessToken: { type: String },
        refreshToken: { type: String },
        idToken: { type: String },
        accessTokenExpiresAt: { type: Date },
        refreshTokenExpiresAt: { type: Date },
        scope: { type: String },
        password: { type: String },
        createdAt: { type: Date, required: true },
        updatedAt: { type: Date, required: true },
    },
    { collection: 'account' }
);

const verificationSchema = new Schema(
    {
        _id: { type: String },
        identifier: { type: String, required: true },
        value: { type: String, required: true },
        expiresAt: { type: Date, required: true },
        createdAt: { type: Date },
        updatedAt: { type: Date },
    },
    { collection: 'verification' }
);

const User = model('User', userSchema);
const Session = model('Session', sessionSchema);
const Account = model('Account', accountSchema);
const Verification = model('Verification', verificationSchema);

export { User, Session, Account, Verification };
`],
  ["auth/better-auth/convex/web/react/tanstack-start/src/routes/dashboard.tsx.hbs", `import SignInForm from "@/components/sign-in-form";
import SignUpForm from "@/components/sign-up-form";
import UserMenu from "@/components/user-menu";
import { api } from "@{{projectName}}/backend/convex/_generated/api";
import { createFileRoute } from "@tanstack/react-router";
import {
  Authenticated,
  AuthLoading,
  Unauthenticated,
  useQuery,
} from "convex/react";
import { useState } from "react";

export const Route = createFileRoute("/dashboard")({
  component: RouteComponent,
});

function RouteComponent() {
  const [showSignIn, setShowSignIn] = useState(false);
  const privateData = useQuery(api.privateData.get);

  return (
    <>
      <Authenticated>
        <div>
          <h1>Dashboard</h1>
          <p>privateData: {privateData?.message}</p>
          <UserMenu />
        </div>
      </Authenticated>
      <Unauthenticated>
        {showSignIn ? (
          <SignInForm onSwitchToSignUp={() => setShowSignIn(false)} />
        ) : (
          <SignUpForm onSwitchToSignIn={() => setShowSignIn(true)} />
        )}
      </Unauthenticated>
      <AuthLoading>
        <div>Loading...</div>
      </AuthLoading>
    </>
  );
}
`],
  ["auth/better-auth/convex/web/react/tanstack-start/src/lib/auth-server.ts.hbs", `import { convexBetterAuthReactStart } from "@convex-dev/better-auth/react-start";
import { env } from "@{{projectName}}/env/web";

export const {
	handler,
	getToken,
	fetchAuthQuery,
	fetchAuthMutation,
	fetchAuthAction,
} = convexBetterAuthReactStart({
	convexUrl: env.VITE_CONVEX_URL,
	convexSiteUrl: env.VITE_CONVEX_SITE_URL,
});
`],
  ["auth/better-auth/convex/web/react/tanstack-start/src/lib/auth-client.ts.hbs", `import { createAuthClient } from "better-auth/react";
import { convexClient } from "@convex-dev/better-auth/client/plugins";

export const authClient = createAuthClient({
  plugins: [convexClient()],
});`],
  ["auth/better-auth/convex/web/react/tanstack-start/src/components/user-menu.tsx.hbs", `import {
    DropdownMenu,
    DropdownMenuContent,
    DropdownMenuGroup,
    DropdownMenuItem,
    DropdownMenuLabel,
    DropdownMenuSeparator,
    DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { authClient } from "@/lib/auth-client";
import { useQuery } from "convex/react";
import { api } from "@{{projectName}}/backend/convex/_generated/api";

import { Button } from "./ui/button";

export default function UserMenu() {
    const user = useQuery(api.auth.getCurrentUser)

    return (
        <DropdownMenu>
            <DropdownMenuTrigger render={<Button variant="outline" />}>
                {user?.name}
            </DropdownMenuTrigger>
            <DropdownMenuContent className="bg-card">
                <DropdownMenuGroup>
                    <DropdownMenuLabel>My Account</DropdownMenuLabel>
                    <DropdownMenuSeparator />
                    <DropdownMenuItem>{user?.email}</DropdownMenuItem>
                    <DropdownMenuItem
                        variant="destructive"
                        onClick={() => {
                            authClient.signOut({
                                fetchOptions: {
                                    onSuccess: () => {
                                        location.reload();
                                    },
                                },
                            });
                        }}
                    >
                        Sign Out
                    </DropdownMenuItem>
                </DropdownMenuGroup>
            </DropdownMenuContent>
        </DropdownMenu>
    );
}
`],
  ["auth/better-auth/convex/web/react/tanstack-start/src/components/sign-in-form.tsx.hbs", `import { authClient } from "@/lib/auth-client";
import { useForm } from "@tanstack/react-form";
import { useNavigate } from "@tanstack/react-router";
import { toast } from "sonner";
import z from "zod";
import { Button } from "./ui/button";
import { Input } from "./ui/input";
import { Label } from "./ui/label";

export default function SignInForm({
    onSwitchToSignUp,
}: {
    onSwitchToSignUp: () => void;
}) {
    const navigate = useNavigate({
        from: "/",
    });

    const form = useForm({
        defaultValues: {
            email: "",
            password: "",
        },
        onSubmit: async ({ value }) => {
            await authClient.signIn.email(
                {
                    email: value.email,
                    password: value.password,
                },
                {
                    onSuccess: () => {
                        navigate({
                            to: "/dashboard",
                        });
                        toast.success("Sign in successful");
                    },
                    onError: (error) => {
                        toast.error(error.error.message || error.error.statusText);
                    },
                },
            );
        },
        validators: {
            onSubmit: z.object({
                email: z.email("Invalid email address"),
                password: z.string().min(8, "Password must be at least 8 characters"),
            }),
        },
    });

    return (
        <div className="mx-auto w-full mt-10 max-w-md p-6">
            <h1 className="mb-6 text-center text-3xl font-bold">Welcome Back</h1>

            <form
                onSubmit={(e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    form.handleSubmit();
                }}
                className="space-y-4"
            >
                <div>
                    <form.Field name="email">
                        {(field) => (
                            <div className="space-y-2">
                                <Label htmlFor={field.name}>Email</Label>
                                <Input
                                    id={field.name}
                                    name={field.name}
                                    type="email"
                                    value={field.state.value}
                                    onBlur={field.handleBlur}
                                    onChange={(e) => field.handleChange(e.target.value)}
                                />
                                {field.state.meta.errors.map((error) => (
                                    <p key={error?.message} className="text-red-500">
                                        {error?.message}
                                    </p>
                                ))}
                            </div>
                        )}
                    </form.Field>
                </div>

                <div>
                    <form.Field name="password">
                        {(field) => (
                            <div className="space-y-2">
                                <Label htmlFor={field.name}>Password</Label>
                                <Input
                                    id={field.name}
                                    name={field.name}
                                    type="password"
                                    value={field.state.value}
                                    onBlur={field.handleBlur}
                                    onChange={(e) => field.handleChange(e.target.value)}
                                />
                                {field.state.meta.errors.map((error) => (
                                    <p key={error?.message} className="text-red-500">
                                        {error?.message}
                                    </p>
                                ))}
                            </div>
                        )}
                    </form.Field>
                </div>

                <form.Subscribe>
                    {(state) => (
                        <Button
                            type="submit"
                            className="w-full"
                            disabled={!state.canSubmit || state.isSubmitting}
                        >
                            {state.isSubmitting ? "Submitting..." : "Sign In"}
                        </Button>
                    )}
                </form.Subscribe>
            </form>

            <div className="mt-4 text-center">
                <Button
                    variant="link"
                    onClick={onSwitchToSignUp}
                    className="text-indigo-600 hover:text-indigo-800"
                >
                    Need an account? Sign Up
                </Button>
            </div>
        </div>
    );
}
`],
  ["auth/better-auth/convex/web/react/tanstack-start/src/components/sign-up-form.tsx.hbs", `import { authClient } from "@/lib/auth-client";
import { useForm } from "@tanstack/react-form";
import { useNavigate } from "@tanstack/react-router";
import { toast } from "sonner";
import z from "zod";
import { Button } from "./ui/button";
import { Input } from "./ui/input";
import { Label } from "./ui/label";

export default function SignUpForm({
    onSwitchToSignIn,
}: {
    onSwitchToSignIn: () => void;
}) {
    const navigate = useNavigate({
        from: "/",
    });

    const form = useForm({
        defaultValues: {
            email: "",
            password: "",
            name: "",
        },
        onSubmit: async ({ value }) => {
            await authClient.signUp.email(
                {
                    email: value.email,
                    password: value.password,
                    name: value.name,
                },
                {
                    onSuccess: () => {
                        navigate({
                            to: "/dashboard",
                        });
                        toast.success("Sign up successful");
                    },
                    onError: (error) => {
                        toast.error(error.error.message || error.error.statusText);
                    },
                },
            );
        },
        validators: {
            onSubmit: z.object({
                name: z.string().min(2, "Name must be at least 2 characters"),
                email: z.email("Invalid email address"),
                password: z.string().min(8, "Password must be at least 8 characters"),
            }),
        },
    });

    return (
        <div className="mx-auto w-full mt-10 max-w-md p-6">
            <h1 className="mb-6 text-center text-3xl font-bold">Create Account</h1>

            <form
                onSubmit={(e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    form.handleSubmit();
                }}
                className="space-y-4"
            >
                <div>
                    <form.Field name="name">
                        {(field) => (
                            <div className="space-y-2">
                                <Label htmlFor={field.name}>Name</Label>
                                <Input
                                    id={field.name}
                                    name={field.name}
                                    value={field.state.value}
                                    onBlur={field.handleBlur}
                                    onChange={(e) => field.handleChange(e.target.value)}
                                />
                                {field.state.meta.errors.map((error) => (
                                    <p key={error?.message} className="text-red-500">
                                        {error?.message}
                                    </p>
                                ))}
                            </div>
                        )}
                    </form.Field>
                </div>

                <div>
                    <form.Field name="email">
                        {(field) => (
                            <div className="space-y-2">
                                <Label htmlFor={field.name}>Email</Label>
                                <Input
                                    id={field.name}
                                    name={field.name}
                                    type="email"
                                    value={field.state.value}
                                    onBlur={field.handleBlur}
                                    onChange={(e) => field.handleChange(e.target.value)}
                                />
                                {field.state.meta.errors.map((error) => (
                                    <p key={error?.message} className="text-red-500">
                                        {error?.message}
                                    </p>
                                ))}
                            </div>
                        )}
                    </form.Field>
                </div>

                <div>
                    <form.Field name="password">
                        {(field) => (
                            <div className="space-y-2">
                                <Label htmlFor={field.name}>Password</Label>
                                <Input
                                    id={field.name}
                                    name={field.name}
                                    type="password"
                                    value={field.state.value}
                                    onBlur={field.handleBlur}
                                    onChange={(e) => field.handleChange(e.target.value)}
                                />
                                {field.state.meta.errors.map((error) => (
                                    <p key={error?.message} className="text-red-500">
                                        {error?.message}
                                    </p>
                                ))}
                            </div>
                        )}
                    </form.Field>
                </div>

                <form.Subscribe>
                    {(state) => (
                        <Button
                            type="submit"
                            className="w-full"
                            disabled={!state.canSubmit || state.isSubmitting}
                        >
                            {state.isSubmitting ? "Submitting..." : "Sign Up"}
                        </Button>
                    )}
                </form.Subscribe>
            </form>

            <div className="mt-4 text-center">
                <Button
                    variant="link"
                    onClick={onSwitchToSignIn}
                    className="text-indigo-600 hover:text-indigo-800"
                >
                    Already have an account? Sign In
                </Button>
            </div>
        </div>
    );
}
`],
  ["auth/better-auth/server/db/drizzle/mysql/src/schema/auth.ts.hbs", `import { relations } from "drizzle-orm";
import {
  mysqlTable,
  varchar,
  text,
  timestamp,
  boolean,
  index,
} from "drizzle-orm/mysql-core";

export const user = mysqlTable("user", {
  id: varchar("id", { length: 36 }).primaryKey(),
  name: varchar("name", { length: 255 }).notNull(),
  email: varchar("email", { length: 255 }).notNull().unique(),
  emailVerified: boolean("email_verified").default(false).notNull(),
  image: text("image"),
  createdAt: timestamp("created_at", { fsp: 3 }).defaultNow().notNull(),
  updatedAt: timestamp("updated_at", { fsp: 3 })
    .defaultNow()
    .$onUpdate(() => /* @__PURE__ */ new Date())
    .notNull(),
});

export const session = mysqlTable(
  "session",
  {
    id: varchar("id", { length: 36 }).primaryKey(),
    expiresAt: timestamp("expires_at", { fsp: 3 }).notNull(),
    token: varchar("token", { length: 255 }).notNull().unique(),
    createdAt: timestamp("created_at", { fsp: 3 }).defaultNow().notNull(),
    updatedAt: timestamp("updated_at", { fsp: 3 })
      .$onUpdate(() => /* @__PURE__ */ new Date())
      .notNull(),
    ipAddress: text("ip_address"),
    userAgent: text("user_agent"),
    userId: varchar("user_id", { length: 36 })
      .notNull()
      .references(() => user.id, { onDelete: "cascade" }),
  },
  (table) => [index("session_userId_idx").on(table.userId)],
);

export const account = mysqlTable(
  "account",
  {
    id: varchar("id", { length: 36 }).primaryKey(),
    accountId: text("account_id").notNull(),
    providerId: text("provider_id").notNull(),
    userId: varchar("user_id", { length: 36 })
      .notNull()
      .references(() => user.id, { onDelete: "cascade" }),
    accessToken: text("access_token"),
    refreshToken: text("refresh_token"),
    idToken: text("id_token"),
    accessTokenExpiresAt: timestamp("access_token_expires_at", { fsp: 3 }),
    refreshTokenExpiresAt: timestamp("refresh_token_expires_at", { fsp: 3 }),
    scope: text("scope"),
    password: text("password"),
    createdAt: timestamp("created_at", { fsp: 3 }).defaultNow().notNull(),
    updatedAt: timestamp("updated_at", { fsp: 3 })
      .$onUpdate(() => /* @__PURE__ */ new Date())
      .notNull(),
  },
  (table) => [index("account_userId_idx").on(table.userId)],
);

export const verification = mysqlTable(
  "verification",
  {
    id: varchar("id", { length: 36 }).primaryKey(),
    identifier: varchar("identifier", { length: 255 }).notNull(),
    value: text("value").notNull(),
    expiresAt: timestamp("expires_at", { fsp: 3 }).notNull(),
    createdAt: timestamp("created_at", { fsp: 3 }).defaultNow().notNull(),
    updatedAt: timestamp("updated_at", { fsp: 3 })
      .defaultNow()
      .$onUpdate(() => /* @__PURE__ */ new Date())
      .notNull(),
  },
  (table) => [index("verification_identifier_idx").on(table.identifier)],
);

export const userRelations = relations(user, ({ many }) => ({
  sessions: many(session),
  accounts: many(account),
}));

export const sessionRelations = relations(session, ({ one }) => ({
  user: one(user, {
    fields: [session.userId],
    references: [user.id],
  }),
}));

export const accountRelations = relations(account, ({ one }) => ({
  user: one(user, {
    fields: [account.userId],
    references: [user.id],
  }),
}));
`],
  ["auth/better-auth/convex/web/react/next/src/lib/auth-server.ts.hbs", `import { convexBetterAuthNextJs } from "@convex-dev/better-auth/nextjs";
import { env } from "@{{projectName}}/env/web";

export const {
	handler,
	preloadAuthQuery,
	isAuthenticated,
	getToken,
	fetchAuthQuery,
	fetchAuthMutation,
	fetchAuthAction,
} = convexBetterAuthNextJs({
	convexUrl: env.NEXT_PUBLIC_CONVEX_URL,
	convexSiteUrl: env.NEXT_PUBLIC_CONVEX_SITE_URL,
});
`],
  ["auth/better-auth/convex/web/react/next/src/lib/auth-client.ts.hbs", `import { createAuthClient } from "better-auth/react";
import { convexClient } from "@convex-dev/better-auth/client/plugins";

export const authClient = createAuthClient({
  plugins: [convexClient()],
});
`],
  ["auth/better-auth/server/db/prisma/postgres/prisma/schema/auth.prisma.hbs", `model User {
  id            String    @id
  name          String
  email         String
  emailVerified Boolean   @default(false)
  image         String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  sessions      Session[]
  accounts      Account[]

  @@unique([email])
  @@map("user")
}

model Session {
  id        String   @id
  expiresAt DateTime
  token     String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  ipAddress String?
  userAgent String?
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([token])
  @@index([userId])
  @@map("session")
}

model Account {
  id                    String    @id
  accountId             String
  providerId            String
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  @@index([userId])
  @@map("account")
}

model Verification {
  id         String   @id
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([identifier])
  @@map("verification")
}
`],
  ["auth/better-auth/server/db/drizzle/sqlite/src/schema/auth.ts.hbs", `import { relations, sql } from "drizzle-orm";
import { sqliteTable, text, integer, index } from "drizzle-orm/sqlite-core";

export const user = sqliteTable("user", {
  id: text("id").primaryKey(),
  name: text("name").notNull(),
  email: text("email").notNull().unique(),
  emailVerified: integer("email_verified", { mode: "boolean" })
    .default(false)
    .notNull(),
  image: text("image"),
  createdAt: integer("created_at", { mode: "timestamp_ms" })
    .default(sql\`(cast(unixepoch('subsecond') * 1000 as integer))\`)
    .notNull(),
  updatedAt: integer("updated_at", { mode: "timestamp_ms" })
    .default(sql\`(cast(unixepoch('subsecond') * 1000 as integer))\`)
    .$onUpdate(() => /* @__PURE__ */ new Date())
    .notNull(),
});

export const session = sqliteTable(
  "session",
  {
    id: text("id").primaryKey(),
    expiresAt: integer("expires_at", { mode: "timestamp_ms" }).notNull(),
    token: text("token").notNull().unique(),
    createdAt: integer("created_at", { mode: "timestamp_ms" })
      .default(sql\`(cast(unixepoch('subsecond') * 1000 as integer))\`)
      .notNull(),
    updatedAt: integer("updated_at", { mode: "timestamp_ms" })
      .$onUpdate(() => /* @__PURE__ */ new Date())
      .notNull(),
    ipAddress: text("ip_address"),
    userAgent: text("user_agent"),
    userId: text("user_id")
      .notNull()
      .references(() => user.id, { onDelete: "cascade" }),
  },
  (table) => [index("session_userId_idx").on(table.userId)],
);

export const account = sqliteTable(
  "account",
  {
    id: text("id").primaryKey(),
    accountId: text("account_id").notNull(),
    providerId: text("provider_id").notNull(),
    userId: text("user_id")
      .notNull()
      .references(() => user.id, { onDelete: "cascade" }),
    accessToken: text("access_token"),
    refreshToken: text("refresh_token"),
    idToken: text("id_token"),
    accessTokenExpiresAt: integer("access_token_expires_at", {
      mode: "timestamp_ms",
    }),
    refreshTokenExpiresAt: integer("refresh_token_expires_at", {
      mode: "timestamp_ms",
    }),
    scope: text("scope"),
    password: text("password"),
    createdAt: integer("created_at", { mode: "timestamp_ms" })
      .default(sql\`(cast(unixepoch('subsecond') * 1000 as integer))\`)
      .notNull(),
    updatedAt: integer("updated_at", { mode: "timestamp_ms" })
      .$onUpdate(() => /* @__PURE__ */ new Date())
      .notNull(),
  },
  (table) => [index("account_userId_idx").on(table.userId)],
);

export const verification = sqliteTable(
  "verification",
  {
    id: text("id").primaryKey(),
    identifier: text("identifier").notNull(),
    value: text("value").notNull(),
    expiresAt: integer("expires_at", { mode: "timestamp_ms" }).notNull(),
    createdAt: integer("created_at", { mode: "timestamp_ms" })
      .default(sql\`(cast(unixepoch('subsecond') * 1000 as integer))\`)
      .notNull(),
    updatedAt: integer("updated_at", { mode: "timestamp_ms" })
      .default(sql\`(cast(unixepoch('subsecond') * 1000 as integer))\`)
      .$onUpdate(() => /* @__PURE__ */ new Date())
      .notNull(),
  },
  (table) => [index("verification_identifier_idx").on(table.identifier)],
);

export const userRelations = relations(user, ({ many }) => ({
  sessions: many(session),
  accounts: many(account),
}));

export const sessionRelations = relations(session, ({ one }) => ({
  user: one(user, {
    fields: [session.userId],
    references: [user.id],
  }),
}));

export const accountRelations = relations(account, ({ one }) => ({
  user: one(user, {
    fields: [account.userId],
    references: [user.id],
  }),
}));
`],
  ["auth/better-auth/server/db/prisma/mongodb/prisma/schema/auth.prisma.hbs", `model User {
  id            String    @id @map("_id")
  name          String
  email         String
  emailVerified Boolean   @default(false)
  image         String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  sessions      Session[]
  accounts      Account[]

  @@unique([email])
  @@map("user")
}

model Session {
  id        String   @id @map("_id")
  expiresAt DateTime
  token     String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  ipAddress String?
  userAgent String?
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([token])
  @@index([userId])
  @@map("session")
}

model Account {
  id                    String    @id @map("_id")
  accountId             String
  providerId            String
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  @@index([userId])
  @@map("account")
}

model Verification {
  id         String   @id @map("_id")
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([identifier])
  @@map("verification")
}
`],
  ["auth/better-auth/server/db/drizzle/postgres/src/schema/auth.ts.hbs", `import { relations } from "drizzle-orm";
import { pgTable, text, timestamp, boolean, index } from "drizzle-orm/pg-core";

export const user = pgTable("user", {
  id: text("id").primaryKey(),
  name: text("name").notNull(),
  email: text("email").notNull().unique(),
  emailVerified: boolean("email_verified").default(false).notNull(),
  image: text("image"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at")
    .defaultNow()
    .$onUpdate(() => /* @__PURE__ */ new Date())
    .notNull(),
});

export const session = pgTable(
  "session",
  {
    id: text("id").primaryKey(),
    expiresAt: timestamp("expires_at").notNull(),
    token: text("token").notNull().unique(),
    createdAt: timestamp("created_at").defaultNow().notNull(),
    updatedAt: timestamp("updated_at")
      .$onUpdate(() => /* @__PURE__ */ new Date())
      .notNull(),
    ipAddress: text("ip_address"),
    userAgent: text("user_agent"),
    userId: text("user_id")
      .notNull()
      .references(() => user.id, { onDelete: "cascade" }),
  },
  (table) => [index("session_userId_idx").on(table.userId)],
);

export const account = pgTable(
  "account",
  {
    id: text("id").primaryKey(),
    accountId: text("account_id").notNull(),
    providerId: text("provider_id").notNull(),
    userId: text("user_id")
      .notNull()
      .references(() => user.id, { onDelete: "cascade" }),
    accessToken: text("access_token"),
    refreshToken: text("refresh_token"),
    idToken: text("id_token"),
    accessTokenExpiresAt: timestamp("access_token_expires_at"),
    refreshTokenExpiresAt: timestamp("refresh_token_expires_at"),
    scope: text("scope"),
    password: text("password"),
    createdAt: timestamp("created_at").defaultNow().notNull(),
    updatedAt: timestamp("updated_at")
      .$onUpdate(() => /* @__PURE__ */ new Date())
      .notNull(),
  },
  (table) => [index("account_userId_idx").on(table.userId)],
);

export const verification = pgTable(
  "verification",
  {
    id: text("id").primaryKey(),
    identifier: text("identifier").notNull(),
    value: text("value").notNull(),
    expiresAt: timestamp("expires_at").notNull(),
    createdAt: timestamp("created_at").defaultNow().notNull(),
    updatedAt: timestamp("updated_at")
      .defaultNow()
      .$onUpdate(() => /* @__PURE__ */ new Date())
      .notNull(),
  },
  (table) => [index("verification_identifier_idx").on(table.identifier)],
);

export const userRelations = relations(user, ({ many }) => ({
  sessions: many(session),
  accounts: many(account),
}));

export const sessionRelations = relations(session, ({ one }) => ({
  user: one(user, {
    fields: [session.userId],
    references: [user.id],
  }),
}));

export const accountRelations = relations(account, ({ one }) => ({
  user: one(user, {
    fields: [account.userId],
    references: [user.id],
  }),
}));
`],
  ["auth/better-auth/server/db/prisma/sqlite/prisma/schema/auth.prisma.hbs", `model User {
  id            String    @id
  name          String
  email         String
  emailVerified Boolean   @default(false)
  image         String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  sessions      Session[]
  accounts      Account[]

  @@unique([email])
  @@map("user")
}

model Session {
  id        String   @id
  expiresAt DateTime
  token     String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  ipAddress String?
  userAgent String?
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([token])
  @@index([userId])
  @@map("session")
}

model Account {
  id                    String    @id
  accountId             String
  providerId            String
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  @@index([userId])
  @@map("account")
}

model Verification {
  id         String   @id
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([identifier])
  @@map("verification")
}
`],
  ["auth/better-auth/server/db/prisma/mysql/prisma/schema/auth.prisma.hbs", `model User {
  id            String    @id
  name          String    @db.Text
  email         String
  emailVerified Boolean   @default(false)
  image         String?   @db.Text
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  sessions      Session[]
  accounts      Account[]

  @@unique([email])
  @@map("user")
}

model Session {
  id        String   @id
  expiresAt DateTime
  token     String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  ipAddress String?  @db.Text
  userAgent String?  @db.Text
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([token])
  @@index([userId(length: 191)])
  @@map("session")
}

model Account {
  id                    String    @id
  accountId             String    @db.Text
  providerId            String    @db.Text
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?   @db.Text
  refreshToken          String?   @db.Text
  idToken               String?   @db.Text
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?   @db.Text
  password              String?   @db.Text
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  @@index([userId(length: 191)])
  @@map("account")
}

model Verification {
  id         String   @id
  identifier String   @db.Text
  value      String   @db.Text
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([identifier(length: 191)])
  @@map("verification")
}
`],
  ["api/garph/fullstack/next/src/app/api/graphql/route.ts.hbs", `import { createYoga } from "graphql-yoga";
import { createSchema } from "@{{projectName}}/api/routers";
import { createContext } from "@{{projectName}}/api/context";
{{#if (eq auth "better-auth")}}
import { auth } from "@/lib/auth";
import { headers } from "next/headers";
{{/if}}
import type { NextRequest } from "next/server";

const yoga = createYoga({
  graphqlEndpoint: "/api/graphql",
  fetchAPI: { Response },
  context: async ({ request }) => {
{{#if (eq auth "better-auth")}}
    const session = await auth.api.getSession({
      headers: await headers(),
    });
    return createContext(request as NextRequest, session);
{{else}}
    return createContext(request as NextRequest);
{{/if}}
  },
  schema: async ({ request }) => {
{{#if (eq auth "better-auth")}}
    const session = await auth.api.getSession({
      headers: await headers(),
    });
    const ctx = createContext(request as NextRequest, session);
{{else}}
    const ctx = createContext(request as NextRequest);
{{/if}}
    return createSchema(ctx);
  },
});

export async function GET(request: NextRequest) {
  return yoga.handleRequest(request, {});
}

export async function POST(request: NextRequest) {
  return yoga.handleRequest(request, {});
}
`],
  ["api/ts-rest/fullstack/astro/src/pages/api/rest/[...rest].ts.hbs", `import type { APIRoute } from "astro";
import { tsr } from "@ts-rest/serverless";
import { contract } from "@{{projectName}}/api/index";
import { createRouter } from "@{{projectName}}/api/routers";
import { createContext } from "@{{projectName}}/api/context";
{{#if (eq auth "better-auth")}}
import { auth } from "@/lib/auth";
{{/if}}

const handler = tsr.router(contract, async (args) => {
{{#if (eq auth "better-auth")}}
  const request = args.request;
  const session = await auth.api.getSession({
    headers: request.headers,
  });
  const ctx = createContext(args.astroContext, session);
{{else}}
  const ctx = createContext(args.astroContext);
{{/if}}
  const router = createRouter(ctx);

  // Handle nested routes
  const path = args.appRoute.path;
  if (path.startsWith("/todos")) {
    const method = args.appRoute.method;
    if (method === "GET" && path === "/todos") {
      return router.todos.getAll();
    }
    if (method === "POST" && path === "/todos") {
      return router.todos.create(args as any);
    }
    if (method === "PATCH" && path.includes("/toggle")) {
      return router.todos.toggle(args as any);
    }
    if (method === "DELETE") {
      return router.todos.delete(args as any);
    }
  }

  if (path === "/health") {
    return router.healthCheck();
  }
{{#if (eq auth "better-auth")}}
  if (path === "/private") {
    return router.privateData();
  }
{{/if}}

  return { status: 404 as const, body: { message: "Not found" } };
});

export const ALL: APIRoute = async (context) => {
  return handler.fetch(context.request, { astroContext: context });
};
`],
  ["api/ts-rest/fullstack/tanstack-start/src/routes/api/rest/$.ts.hbs", `import { createAPIFileRoute } from "@tanstack/react-start/api";
import { tsr } from "@ts-rest/serverless";
import { contract } from "@{{projectName}}/api/index";
import { createRouter } from "@{{projectName}}/api/routers";
import { createContext } from "@{{projectName}}/api/context";
{{#if (eq auth "better-auth")}}
import { auth } from "@/lib/auth";
{{/if}}

const handler = tsr.router(contract, async (args) => {
{{#if (eq auth "better-auth")}}
  const request = args.request;
  const session = await auth.api.getSession({
    headers: request.headers,
  });
  const ctx = createContext(request, session);
{{else}}
  const ctx = createContext(args.request);
{{/if}}
  const router = createRouter(ctx);

  // Handle nested routes
  const path = args.appRoute.path;
  if (path.startsWith("/todos")) {
    const method = args.appRoute.method;
    if (method === "GET" && path === "/todos") {
      return router.todos.getAll();
    }
    if (method === "POST" && path === "/todos") {
      return router.todos.create(args as any);
    }
    if (method === "PATCH" && path.includes("/toggle")) {
      return router.todos.toggle(args as any);
    }
    if (method === "DELETE") {
      return router.todos.delete(args as any);
    }
  }

  if (path === "/health") {
    return router.healthCheck();
  }
{{#if (eq auth "better-auth")}}
  if (path === "/private") {
    return router.privateData();
  }
{{/if}}

  return { status: 404 as const, body: { message: "Not found" } };
});

export const APIRoute = createAPIFileRoute("/api/rest/$")({
  GET: ({ request }) => handler.fetch(request),
  POST: ({ request }) => handler.fetch(request),
  PATCH: ({ request }) => handler.fetch(request),
  DELETE: ({ request }) => handler.fetch(request),
});
`],
  ["api/trpc/fullstack/tanstack-start/src/routes/api/trpc/$.ts.hbs", `import { fetchRequestHandler } from '@trpc/server/adapters/fetch'
import { appRouter } from '@{{projectName}}/api/routers/index'
import { createContext } from '@{{projectName}}/api/context'
import { createFileRoute } from '@tanstack/react-router'

function handler({ request }: { request: Request }) {
  return fetchRequestHandler({
    req: request,
    router: appRouter,
    createContext,
    endpoint: '/api/trpc',
  })
}

export const Route = createFileRoute('/api/trpc/$')({
  server: {
    handlers: {
      GET: handler,
      POST: handler,
    },
  },
})
`],
  ["api/trpc/fullstack/astro/src/pages/api/trpc/[...trpc].ts.hbs", `import type { APIRoute } from 'astro';
import { fetchRequestHandler } from '@trpc/server/adapters/fetch';
import { appRouter } from '@{{projectName}}/api/routers/index';
import { createContext } from '@{{projectName}}/api/context';

const handler: APIRoute = async ({ request }) => {
	return fetchRequestHandler({
		endpoint: '/api/trpc',
		req: request,
		router: appRouter,
		createContext: () => createContext(request),
	});
};

export const GET = handler;
export const POST = handler;
`],
  ["cms/sanity/web/next/src/app/studio/[[...tool]]/page.tsx.hbs", `import { NextStudio } from "next-sanity/studio";

import config from "../../../../sanity.config";

export const dynamic = "force-static";

export { metadata, viewport } from "next-sanity/studio";

export default function StudioPage() {
  return <NextStudio config={config} />;
}
`],
  ["api/orpc/fullstack/astro/src/pages/api/rpc/[...rest].ts.hbs", `import type { APIRoute } from 'astro';
import { createContext } from '@{{projectName}}/api/context';
import { appRouter } from '@{{projectName}}/api/routers/index';
import { OpenAPIHandler } from '@orpc/openapi/fetch';
import { OpenAPIReferencePlugin } from '@orpc/openapi/plugins';
import { ZodToJsonSchemaConverter } from '@orpc/zod/zod4';
import { RPCHandler } from '@orpc/server/fetch';
import { onError } from '@orpc/server';

const rpcHandler = new RPCHandler(appRouter, {
	interceptors: [
		onError((error) => {
			console.error(error);
		}),
	],
});

const apiHandler = new OpenAPIHandler(appRouter, {
	plugins: [
		new OpenAPIReferencePlugin({
			schemaConverters: [new ZodToJsonSchemaConverter()],
		}),
	],
	interceptors: [
		onError((error) => {
			console.error(error);
		}),
	],
});

const handler: APIRoute = async ({ request }) => {
	const rpcResult = await rpcHandler.handle(request, {
		prefix: '/api/rpc',
		context: await createContext(request),
	});
	if (rpcResult.response) return rpcResult.response;

	const apiResult = await apiHandler.handle(request, {
		prefix: '/api/rpc/api-reference',
		context: await createContext(request),
	});
	if (apiResult.response) return apiResult.response;

	return new Response('Not found', { status: 404 });
};

export const GET = handler;
export const POST = handler;
export const PUT = handler;
export const PATCH = handler;
export const DELETE = handler;
`],
  ["api/orpc/fullstack/tanstack-start/src/routes/api/rpc/$.ts.hbs", `import { createContext } from "@{{projectName}}/api/context";
import { appRouter } from "@{{projectName}}/api/routers/index";
import { OpenAPIHandler } from "@orpc/openapi/fetch";
import { OpenAPIReferencePlugin } from "@orpc/openapi/plugins";
import { ZodToJsonSchemaConverter } from "@orpc/zod/zod4";
import { RPCHandler } from "@orpc/server/fetch";
import { onError } from "@orpc/server";
import { createFileRoute } from "@tanstack/react-router";

const rpcHandler = new RPCHandler(appRouter, {
	interceptors: [
		onError((error) => {
			console.error(error);
		}),
	],
});

const apiHandler = new OpenAPIHandler(appRouter, {
	plugins: [
		new OpenAPIReferencePlugin({
			schemaConverters: [new ZodToJsonSchemaConverter()],
		}),
	],
	interceptors: [
		onError((error) => {
			console.error(error);
		}),
	],
});

async function handle({ request }: { request: Request }) {
	const rpcResult = await rpcHandler.handle(request, {
		prefix: "/api/rpc",
		context: await createContext({ req: request }),
	});
	if (rpcResult.response) return rpcResult.response;

	const apiResult = await apiHandler.handle(request, {
		prefix: "/api/rpc/api-reference",
		context: await createContext({ req: request }),
	});
	if (apiResult.response) return apiResult.response;

	return new Response("Not found", { status: 404 });
}

export const Route = createFileRoute('/api/rpc/$')({
  server: {
    handlers: {
      HEAD: handle,
      GET: handle,
      POST: handle,
      PUT: handle,
      PATCH: handle,
      DELETE: handle,
    },
  },
})`],
  ["auth/auth0/fullstack/next/src/app/api/auth/[auth0]/route.ts.hbs", `import { handleAuth } from "@auth0/nextjs-auth0";

export const GET = handleAuth();
`],
  ["auth/nextauth/fullstack/next/src/app/api/auth/[...nextauth]/route.ts.hbs", `import { handlers } from "@/lib/auth";

export const { GET, POST } = handlers;
`],
  ["auth/supabase-auth/web/react/next/src/app/auth/callback/route.ts.hbs", `import { NextResponse } from "next/server";
import { createClient } from "@/lib/supabase/server";

export async function GET(request: Request) {
  const { searchParams, origin } = new URL(request.url);
  const code = searchParams.get("code");
  // if "next" is in param, use it as the redirect URL
  const next = searchParams.get("next") ?? "/dashboard";

  if (code) {
    const supabase = await createClient();
    const { error } = await supabase.auth.exchangeCodeForSession(code);
    if (!error) {
      const forwardedHost = request.headers.get("x-forwarded-host"); // original origin before load balancer
      const isLocalEnv = process.env.NODE_ENV === "development";
      if (isLocalEnv) {
        // we can be confident that there is no load balancer in between, so no need to watch for X-Forwarded-Host
        return NextResponse.redirect(\`\${origin}\${next}\`);
      } else if (forwardedHost) {
        return NextResponse.redirect(\`https://\${forwardedHost}\${next}\`);
      } else {
        return NextResponse.redirect(\`\${origin}\${next}\`);
      }
    }
  }

  // return the user to an error page with instructions
  return NextResponse.redirect(\`\${origin}/login?error=auth-code-error\`);
}
`],
  ["auth/clerk/convex/web/react/next/src/app/dashboard/page.tsx.hbs", `"use client";

import { api } from "@{{projectName}}/backend/convex/_generated/api";
import { SignInButton, UserButton, useUser } from "@clerk/nextjs";
import { Authenticated, AuthLoading, Unauthenticated, useQuery } from "convex/react";

export default function Dashboard() {
  const user = useUser();
  const privateData = useQuery(api.privateData.get);

  return (
    <>
      <Authenticated>
        <div>
          <h1>Dashboard</h1>
          <p>Welcome {user.user?.fullName}</p>
          <p>privateData: {privateData?.message}</p>
          <UserButton />
        </div>
      </Authenticated>
      <Unauthenticated>
        <SignInButton />
      </Unauthenticated>
      <AuthLoading>
        <div>Loading...</div>
      </AuthLoading>
    </>
  );
}
`],
  ["auth/better-auth/fullstack/next/src/app/api/auth/[...all]/route.ts.hbs", `import { auth } from "@{{projectName}}/auth";
import { toNextJsHandler } from "better-auth/next-js";

export const { GET, POST } = toNextJsHandler(auth.handler);
`],
  ["auth/better-auth/convex/web/react/next/src/app/dashboard/page.tsx.hbs", `"use client"

import SignInForm from "@/components/sign-in-form";
import SignUpForm from "@/components/sign-up-form";
import UserMenu from "@/components/user-menu";
import { api } from "@{{projectName}}/backend/convex/_generated/api";
import {
    Authenticated,
    AuthLoading,
    Unauthenticated,
    useQuery,
} from "convex/react";
import { useState } from "react";

export default function DashboardPage() {
    const [showSignIn, setShowSignIn] = useState(false);
    const privateData = useQuery(api.privateData.get);

    return (
        <>
            <Authenticated>
                <div>
                    <h1>Dashboard</h1>
                    <p>privateData: {privateData?.message}</p>
                    <UserMenu />
                </div>
            </Authenticated>
            <Unauthenticated>
                {showSignIn ? (
                    <SignInForm onSwitchToSignUp={() => setShowSignIn(false)} />
                ) : (
                    <SignUpForm onSwitchToSignIn={() => setShowSignIn(true)} />
                )}
            </Unauthenticated>
            <AuthLoading>
                <div>Loading...</div>
            </AuthLoading>
        </>
    );
}
`],
  ["api/ts-rest/fullstack/next/src/app/api/rest/[[...rest]]/route.ts.hbs", `import { createNextHandler } from "@ts-rest/serverless/next";
import { contract } from "@{{projectName}}/api/index";
import { createRouter } from "@{{projectName}}/api/routers";
import { createContext } from "@{{projectName}}/api/context";
{{#if (eq auth "better-auth")}}
import { auth } from "@/lib/auth";
import { headers } from "next/headers";
{{/if}}

const handler = createNextHandler(
  contract,
  async (args, { request }) => {
{{#if (eq auth "better-auth")}}
    const session = await auth.api.getSession({
      headers: await headers(),
    });
    const ctx = createContext(request, session);
{{else}}
    const ctx = createContext(request);
{{/if}}
    const router = createRouter(ctx);
    
    // Handle nested routes
    const path = args.appRoute.path;
    if (path.startsWith("/todos")) {
      const method = args.appRoute.method;
      if (method === "GET" && path === "/todos") {
        return router.todos.getAll();
      }
      if (method === "POST" && path === "/todos") {
        return router.todos.create(args as any);
      }
      if (method === "PATCH" && path.includes("/toggle")) {
        return router.todos.toggle(args as any);
      }
      if (method === "DELETE") {
        return router.todos.delete(args as any);
      }
    }
    
    if (path === "/health") {
      return router.healthCheck();
    }
{{#if (eq auth "better-auth")}}
    if (path === "/private") {
      return router.privateData();
    }
{{/if}}
    
    return { status: 404 as const, body: { message: "Not found" } };
  },
  {
    basePath: "/api/rest",
    jsonQuery: true,
  }
);

export { handler as GET, handler as POST, handler as PATCH, handler as DELETE };
`],
  ["api/trpc/fullstack/next/src/app/api/trpc/[trpc]/route.ts.hbs", `import { fetchRequestHandler } from "@trpc/server/adapters/fetch";
import { appRouter } from "@{{projectName}}/api/routers/index";
import { createContext } from "@{{projectName}}/api/context";
import { NextRequest } from "next/server";

function handler(req: NextRequest) {
	return fetchRequestHandler({
		endpoint: "/api/trpc",
		req,
		router: appRouter,
		createContext: () => createContext(req),
	});
}
export { handler as GET, handler as POST };
`],
  ["api/orpc/fullstack/next/src/app/api/rpc/[[...rest]]/route.ts.hbs", `import { createContext } from "@{{projectName}}/api/context";
import { appRouter } from "@{{projectName}}/api/routers/index";
import { OpenAPIHandler } from "@orpc/openapi/fetch";
import { OpenAPIReferencePlugin } from "@orpc/openapi/plugins";
import { ZodToJsonSchemaConverter } from "@orpc/zod/zod4";
import { RPCHandler } from "@orpc/server/fetch";
import { onError } from "@orpc/server";
import { NextRequest } from "next/server";

const rpcHandler = new RPCHandler(appRouter, {
	interceptors: [
		onError((error) => {
			console.error(error);
		}),
	],
});
const apiHandler = new OpenAPIHandler(appRouter, {
	plugins: [
		new OpenAPIReferencePlugin({
			schemaConverters: [new ZodToJsonSchemaConverter()],
		}),
	],
	interceptors: [
		onError((error) => {
			console.error(error);
		}),
	],
});

async function handleRequest(req: NextRequest) {
	const rpcResult = await rpcHandler.handle(req, {
		prefix: "/api/rpc",
		context: await createContext(req),
	});
	if (rpcResult.response) return rpcResult.response;

	const apiResult = await apiHandler.handle(req, {
		prefix: "/api/rpc/api-reference",
		context: await createContext(req),
	});
	if (apiResult.response) return apiResult.response;

	return new Response("Not found", { status: 404 });
}

export const GET = handleRequest;
export const POST = handleRequest;
export const PUT = handleRequest;
export const PATCH = handleRequest;
export const DELETE = handleRequest;`],
  ["auth/better-auth/convex/web/react/tanstack-start/src/routes/api/auth/$.ts.hbs", `import { createFileRoute } from "@tanstack/react-router";
import { handler } from "@/lib/auth-server";

export const Route = createFileRoute("/api/auth/$")({
  server: {
    handlers: {
      GET: ({ request }) => handler(request),
      POST: ({ request }) => handler(request),
    },
  },
});
`],
  ["auth/better-auth/convex/web/react/next/src/app/api/auth/[...all]/route.ts.hbs", `import { handler } from "@/lib/auth-server";

export const { GET, POST } = handler;
`]
]);

export const TEMPLATE_COUNT = 852;

// Auto-generated - DO NOT EDIT
// Run 'bun run generate-templates' to regenerate

export const EMBEDDED_TEMPLATES: Map<string, string> = new Map([
  ["rust-base/.env.example", `# Application
RUST_LOG=debug
APP_ENV=development

# Server
HOST=127.0.0.1
PORT=3000

# gRPC (if using tonic)
# GRPC_PORT=50051

# Database (if using)
# DATABASE_URL=postgres://user:password@localhost:5432/dbname
# DATABASE_URL=sqlite:./data.db

# JWT Secret (if using jsonwebtoken)
# JWT_SECRET=your-secret-key-here
`],
  ["rust-base/Cargo.toml.hbs", `[workspace]
resolver = "2"
members = [
    "crates/server",
{{#if (eq rustApi "tonic")}}
    "crates/proto",
{{/if}}
{{#if (eq rustFrontend "leptos")}}
    "crates/client",
{{/if}}
{{#if (eq rustFrontend "dioxus")}}
    "crates/dioxus-client",
{{/if}}
{{#if (eq rustCli "clap")}}
    "crates/cli",
{{/if}}
{{#if (eq rustCli "ratatui")}}
    "crates/tui",
{{/if}}
]

[workspace.package]
version = "0.1.0"
edition = "2021"
authors = ["Your Name <your.email@example.com>"]
license = "MIT"
repository = ""

[workspace.dependencies]
# Async runtime
tokio = { version = "1.43", features = ["full"] }

# Serialization
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"

# Error handling
thiserror = "2.0"
anyhow = "1.0"

# Logging
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter"] }

# Environment variables
dotenvy = "0.15"

{{#if (eq rustWebFramework "axum")}}
# Web framework (Axum)
axum = "0.8"
tower = "0.5"
tower-http = { version = "0.6", features = ["cors", "trace"] }
{{/if}}
{{#if (eq rustWebFramework "actix-web")}}
# Web framework (Actix-web)
actix-web = "4"
actix-rt = "2"
actix-cors = "0.7"
{{/if}}

{{#if (eq rustOrm "sqlx")}}
# Database (SQLx)
sqlx = { version = "0.8", features = ["runtime-tokio", "postgres", "sqlite", "mysql", "migrate"] }
{{/if}}
{{#if (eq rustOrm "sea-orm")}}
# Database (SeaORM)
sea-orm = { version = "1.1", features = ["runtime-tokio-rustls", "sqlx-postgres", "sqlx-sqlite", "sqlx-mysql"] }
sea-orm-migration = "1.1"
{{/if}}

{{#if (eq rustApi "tonic")}}
# gRPC (Tonic)
tonic = "0.12"
tonic-build = "0.12"
prost = "0.13"
{{/if}}
{{#if (eq rustApi "async-graphql")}}
# GraphQL (async-graphql)
async-graphql = "7"
{{#if (eq rustWebFramework "axum")}}
async-graphql-axum = "7"
{{/if}}
{{#if (eq rustWebFramework "actix-web")}}
async-graphql-actix-web = "7"
{{/if}}
{{/if}}

{{#if (eq rustFrontend "leptos")}}
# Frontend (Leptos)
leptos = { version = "0.7", features = ["csr"] }
leptos_router = { version = "0.7", features = ["csr"] }
leptos_meta = { version = "0.7", features = ["csr"] }
console_error_panic_hook = "0.1"
console_log = "1"
log = "0.4"
wasm-bindgen = "0.2"
wasm-bindgen-futures = "0.4"
web-sys = { version = "0.3", features = ["Window", "Document", "Element", "HtmlElement", "console"] }
{{/if}}
{{#if (eq rustFrontend "dioxus")}}
# Frontend (Dioxus)
dioxus = { version = "0.6", features = ["router"] }
dioxus-router = "0.6"
dioxus-logger = "0.6"
console_error_panic_hook = "0.1"
wasm-bindgen = "0.2"
{{/if}}

{{#if (eq rustCli "clap")}}
# CLI (Clap)
clap = { version = "4", features = ["derive"] }
{{/if}}
{{#if (eq rustCli "ratatui")}}
# TUI (Ratatui)
ratatui = "0.29"
crossterm = "0.28"
tracing-appender = "0.2"
{{/if}}

{{#if (includes rustLibraries "validator")}}
# Validation
validator = { version = "0.19", features = ["derive"] }
{{/if}}
{{#if (includes rustLibraries "jsonwebtoken")}}
# JWT
jsonwebtoken = "9"
{{/if}}
{{#if (includes rustLibraries "argon2")}}
# Password hashing
argon2 = "0.5"
{{/if}}
{{#if (includes rustLibraries "tokio-test")}}
# Testing
tokio-test = "0.4"
{{/if}}
{{#if (includes rustLibraries "mockall")}}
# Mocking
mockall = "0.13"
{{/if}}

[profile.dev]
opt-level = 0

[profile.release]
opt-level = 3
lto = true
codegen-units = 1
`],
  ["rust-base/rust-toolchain.toml.hbs", `[toolchain]
channel = "stable"
components = ["rustfmt", "clippy"]
{{#if (or (eq rustFrontend "leptos") (eq rustFrontend "dioxus"))}}
targets = ["wasm32-unknown-unknown"]
{{/if}}
`],
  ["rust-base/_gitignore", `# Generated by Cargo
/target/
Cargo.lock

# IDE
.idea/
.vscode/
*.swp
*.swo
*~

# OS
.DS_Store
Thumbs.db

# Environment
.env
.env.local
.env.*.local

# Build artifacts
*.pdb

# Debug
debug/

# Documentation (generated)
/target/doc/
`],
  ["base/package.json.hbs", `{
  "name": "better-fullstack",
  "private": true,
  "type": "module",
  "workspaces": [
    "apps/*",
    "packages/*"
  ],
  "scripts": {}
}
`],
  ["base/tsconfig.json.hbs", `{
  "extends": "@{{projectName}}/config/tsconfig.base.json",
}
`],
  ["base/_gitignore", `# Dependencies
node_modules
.pnp
.pnp.js

# Build outputs
dist
build
*.tsbuildinfo

# Environment variables
.env
.env*.local

# IDEs and editors
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json
.idea
*.swp
*.swo
*~
.DS_Store

# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Turbo
.turbo

# Better Fullstack
.alchemy

# Testing
coverage
.nyc_output

# Misc
*.tgz
.cache
tmp
temp`],
  ["extras/env.d.ts.hbs", `import { type server } from "@{{projectName}}/infra/alchemy.run";

// This file infers types for the cloudflare:workers environment from your Alchemy Worker.
// @see https://alchemy.run/concepts/bindings/#type-safe-bindings

export type CloudflareEnv = typeof server.Env;

declare global {
  type Env = CloudflareEnv;
}

declare module "cloudflare:workers" {
  namespace Cloudflare {
    export interface Env extends CloudflareEnv {}
  }
}
`],
  ["extras/bunfig.toml.hbs", `[install]
{{#if (or (includes frontend "nuxt"))}}
linker = "hoisted" # having issues with Nuxt when linker is isolated
{{else}}
linker = "isolated"
{{/if}}`],
  ["extras/pnpm-workspace.yaml", `packages:
  - "apps/*"
  - "packages/*"
`],
  ["extras/_npmrc.hbs", `node-linker=isolated
{{#if (includes frontend "nuxt")}}
shamefully-hoist=true
strict-peer-dependencies=false
{{/if}}`],
  ["frontend/qwik/package.json.hbs", `{
  "name": "web",
  "private": true,
  "type": "module",
  "scripts": {
    "build": "qwik build",
    "build.client": "vite build",
    "build.preview": "vite build --ssr src/entry.preview.tsx",
    "build.types": "tsc --incremental --noEmit",
    "dev": "vite --mode ssr",
    "dev.debug": "node --inspect-brk ./node_modules/vite/bin/vite.js --mode ssr --force",
    "preview": "qwik build preview && vite preview --open",
    "start": "vite --open --mode ssr",
    "qwik": "qwik"
  },
  "dependencies": {
    "@builder.io/qwik": "^1.14.1",
    "@builder.io/qwik-city": "^1.14.1"
  },
  "devDependencies": {
    "@types/node": "^22.13.14",
    "typescript": "^5.7.3",
    "vite": "^6.3.5",
    "vite-tsconfig-paths": "^5.1.4"
  }
}
`],
  ["frontend/qwik/tsconfig.json.hbs", `{
  "compilerOptions": {
    "allowJs": true,
    "target": "ES2021",
    "module": "ES2020",
    "lib": ["ES2021", "DOM", "DOM.Iterable"],
    "jsx": "react-jsx",
    "jsxImportSource": "@builder.io/qwik",
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "moduleResolution": "Bundler",
    "esModuleInterop": true,
    "skipLibCheck": true,
    "incremental": true,
    "isolatedModules": true,
    "outDir": "tmp",
    "noEmit": true,
    "types": ["node", "vite/client"],
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["src/**/*.ts", "src/**/*.tsx"]
}
`],
  ["frontend/qwik/vite.config.ts.hbs", `import { qwikVite } from "@builder.io/qwik/optimizer";
import { qwikCity } from "@builder.io/qwik-city/vite";
import { defineConfig } from "vite";
import tsconfigPaths from "vite-tsconfig-paths";

export default defineConfig(() => {
  return {
    plugins: [qwikCity(), qwikVite(), tsconfigPaths()],
    server: {
      port: 3001,
    },
    preview: {
      headers: {
        "Cache-Control": "public, max-age=600",
      },
    },
  };
});
`],
  ["frontend/qwik/_gitignore", `# Dependencies
node_modules

# Build outputs
dist
server
tmp

# Logs
*.log

# Editor directories and files
.idea
.vscode
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

# Local env files
.env
.env.local
.env.*.local

# Qwik specific
.vercel
.netlify
`],
  ["frontend/solid/package.json.hbs", `{
  "name": "web",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "vite dev",
    "build": "vite build",
    "serve": "vite preview",
    "test": "vitest run"
  },
  "dependencies": {
    "@tailwindcss/vite": "^4.1.13",
    "@tanstack/router-plugin": "^1.131.44",
    "@tanstack/solid-form": "^1.20.0",
    "@tanstack/solid-router": "^1.131.44",
    "lucide-solid": "^0.544.0",
    "solid-js": "^1.9.9",
    "tailwindcss": "^4.1.13"
  },
  "devDependencies": {
    "vite": "^7.1.5",
    "vite-plugin-solid": "^2.11.8"
  }
}
`],
  ["frontend/solid/index.html", `<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" href="/favicon.ico" />
    <meta name="theme-color" content="#000000" />
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
`],
  ["frontend/solid/tsconfig.json.hbs", `{
  "include": ["**/*.ts", "**/*.tsx"],
  "compilerOptions": {
    "target": "ES2022",
    "jsx": "preserve",
    "jsxImportSource": "solid-js",
    "module": "ESNext",
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "types": ["vite/client"],

    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "noEmit": true,

    "skipLibCheck": true,
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true,

    "rootDirs": ["."],
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  }
}
`],
  ["frontend/solid/vite.config.ts.hbs", `import { defineConfig } from "vite";
import { tanstackRouter } from "@tanstack/router-plugin/vite";
import solidPlugin from "vite-plugin-solid";
import tailwindcss from "@tailwindcss/vite";
import path from "node:path";

export default defineConfig({
  plugins: [
    tanstackRouter({ target: "solid", autoCodeSplitting: true }),
    solidPlugin(),
    tailwindcss(),
  ],
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "./src"),
    },
  },
  server: {
    port: 3001,
  },
});`],
  ["frontend/solid/_gitignore", `node_modules
.DS_Store
dist
dist-ssr
*.local
.env
.env.*

.wrangler
.alchemy
.dev.vars*`],
  ["frontend/redwood/graphql.config.js", `const { getPaths } = require("@redwoodjs/project-config");

const redwoodPaths = getPaths();

module.exports = {
  schema: redwoodPaths.generated.schema,
  documents: "./web/src/**/!(*.d).{ts,tsx,js,jsx}",
};
`],
  ["frontend/redwood/package.json.hbs", `{
  "name": "{{projectName}}",
  "private": true,
  "workspaces": {
    "packages": [
      "api",
      "web"
    ]
  },
  "devDependencies": {
    "@redwoodjs/core": "^8.8.0"
  },
  "eslintConfig": {
    "extends": "@redwoodjs/eslint-config",
    "root": true
  },
  "engines": {
    "node": ">=20.x"
  },
  "packageManager": "{{packageManager}}@latest"
}
`],
  ["frontend/redwood/redwood.toml.hbs", `# Redwood Configuration
# https://redwoodjs.com/docs/app-configuration-redwood-toml

[web]
  title = "{{projectName}}"
  port = 8910
  apiUrl = "/.redwood/functions"
  includeEnvironmentVariables = []

[api]
  port = 8911

[browser]
  open = true

[notifications]
  versionUpdates = ["latest"]
`],
  ["frontend/redwood/_gitignore", `# RedwoodJS
.redwood/
.netlify/
.vercel/
dist/
node_modules/
*.log

# Prisma
api/db/dev.db
api/db/dev.db-journal
api/db/migrations/

# Environment
.env
.env.local
.env.*.local

# IDE
.idea/
.vscode/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db

# Build
web/dist/
api/dist/
`],
  ["frontend/fresh/dev.ts", `#!/usr/bin/env -S deno run -A --watch=static/,routes/

import dev from "$fresh/dev.ts";

import config from "./fresh.config.ts";

await dev(import.meta.url, "./main.ts", config);
`],
  ["frontend/fresh/utils.ts", `import { createDefine } from "$fresh/server.ts";

export interface State {
  // Add your state properties here
  title?: string;
}

export const define = createDefine<State>();
`],
  ["frontend/fresh/main.ts", `/// <reference lib="deno.ns" />

import { App, staticFiles } from "$fresh/server.ts";

export const app = new App({ root: import.meta.url }).use(staticFiles());

// To add custom routes, import { define } from "./utils.ts"
// app.get("/api/example", define.handlers(() => new Response("Hello!")));

if (import.meta.main) {
  await app.listen();
}
`],
  ["frontend/fresh/tailwind.config.ts.hbs", `{{#if (eq cssFramework "tailwind")}}
import type { Config } from "tailwindcss";

export default {
  content: [
    "{routes,islands,components}/**/*.{ts,tsx}",
    "src/**/*.{ts,tsx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [{{#if (eq uiLibrary "daisyui")}}
    require("daisyui"),
  {{/if}}],
{{#if (eq uiLibrary "daisyui")}}
  daisyui: {
    themes: ["dark", "light"],
  },
{{/if}}
} satisfies Config;
{{/if}}
`],
  ["frontend/fresh/fresh.config.ts.hbs", `import { defineConfig } from "$fresh/server.ts";
{{#if (eq cssFramework "tailwind")}}
import tailwind from "$fresh/plugins/tailwind.ts";

export default defineConfig({
  plugins: [tailwind()],
});
{{else}}
export default defineConfig({});
{{/if}}
`],
  ["frontend/fresh/deno.json.hbs", `{
  "lock": false,
  "tasks": {
    "check": "deno fmt --check && deno lint && deno check **/*.ts && deno check **/*.tsx",
    "cli": "echo \\"import '\\\\$fresh/src/dev/cli.ts'\\" | deno run --unstable -A -",
    "manifest": "deno task cli manifest $(pwd)",
    "dev": "deno run -A --watch=static/,routes/ dev.ts",
    "build": "deno run -A dev.ts build",
    "preview": "deno run -A main.ts",
    "update": "deno run -A -r jsr:@fresh/update ."
  },
  "lint": {
    "rules": {
      "tags": [
        "fresh",
        "recommended"
      ]
    }
  },
  "exclude": [
    "**/_fresh/*"
  ],
  "imports": {
    "$fresh/": "jsr:@fresh/core@^2.0.0-alpha/",
    "preact": "npm:preact@^10.25.4",
    "preact/": "npm:preact@^10.25.4/",
    "@preact/signals": "npm:@preact/signals@^2.0.0",
    "@preact/signals-core": "npm:@preact/signals-core@^2.0.0"{{#if (eq cssFramework "tailwind")}},
    "tailwindcss": "npm:tailwindcss@^3.4.17",
    "tailwindcss/plugin": "npm:tailwindcss@^3.4.17/plugin.js"{{/if}}
  },
  "compilerOptions": {
    "lib": [
      "dom",
      "dom.asynciterable",
      "deno.ns"
    ],
    "jsx": "react-jsx",
    "jsxImportSource": "preact"
  },
  "nodeModulesDir": "auto"
}
`],
  ["frontend/fresh/_gitignore", `# Fresh build output
_fresh/

# Deno
.deno/

# Editor directories
.idea/
.vscode/

# OS generated files
.DS_Store
Thumbs.db

# Environment files
.env
.env.local
.env.*.local

# Logs
logs
*.log
`],
  ["frontend/svelte/svelte.config.js.hbs", `import adapter from '@sveltejs/adapter-auto';
import { vitePreprocess } from '@sveltejs/vite-plugin-svelte';

/** @type {import('@sveltejs/kit').Config} */
const config = {
	// Consult https://svelte.dev/docs/kit/integrations
	// for more information about preprocessors
	preprocess: vitePreprocess(),

	kit: {
		// adapter-auto only supports some environments, see https://svelte.dev/docs/kit/adapter-auto for a list.
		// If your environment is not supported, or you settled on a specific environment, switch out the adapter.
		// See https://svelte.dev/docs/kit/adapters for more information about adapters.
		adapter: adapter()
	}
};

export default config;
`],
  ["frontend/svelte/package.json.hbs", `{
	"name": "web",
	"private": true,
	"version": "0.0.1",
	"type": "module",
	"scripts": {
		"dev": "vite dev",
		"build": "vite build",
		"preview": "vite preview",
		"prepare": "svelte-kit sync || echo ''",
		"check": "svelte-kit sync && svelte-check --tsconfig ./tsconfig.json",
		"check:watch": "svelte-kit sync && svelte-check --tsconfig ./tsconfig.json --watch"
	},
	"devDependencies": {
		"@sveltejs/adapter-auto": "^6.1.0",
		"@sveltejs/kit": "^2.31.1",
		"@sveltejs/vite-plugin-svelte": "^6.1.2",
		"@tailwindcss/vite": "^4.1.12",
		"svelte": "^5.38.1",
		"svelte-check": "^4.3.1",
		"tailwindcss": "^4.1.12",
		"vite": "^7.1.2"
	},
	"dependencies": {
		"@tanstack/svelte-form": "^1.19.2"
	}
}
`],
  ["frontend/svelte/_npmrc", `engine-strict=true
`],
  ["frontend/svelte/tsconfig.json.hbs", `{
	"extends": "./.svelte-kit/tsconfig.json",
	"compilerOptions": {
		"allowJs": true,
		"checkJs": true,
		"esModuleInterop": true,
		"forceConsistentCasingInFileNames": true,
		"resolveJsonModule": true,
		"skipLibCheck": true,
		"sourceMap": true,
		"strict": true,
		"moduleResolution": "bundler"
	}
	// Path aliases are handled by https://svelte.dev/docs/kit/configuration#alias
	// except $lib which is handled by https://svelte.dev/docs/kit/configuration#files
	//
	// If you want to overwrite includes/excludes, make sure to copy over the relevant includes/excludes
	// from the referenced tsconfig.json - TypeScript does not merge them in
}
`],
  ["frontend/svelte/vite.config.ts.hbs", `import tailwindcss from "@tailwindcss/vite";
import { sveltekit } from "@sveltejs/kit/vite";
import { defineConfig } from "vite";

export default defineConfig({
  plugins: [tailwindcss(), sveltekit()],
});
`],
  ["frontend/svelte/_gitignore", `node_modules

# Output
.output
.vercel
.netlify
.wrangler
.alchemy
/.svelte-kit
/build

# OS
.DS_Store
Thumbs.db

# Env
.env
.env.*
!.env.example
!.env.test

# Vite
vite.config.js.timestamp-*
vite.config.ts.timestamp-*
`],
  ["frontend/astro/astro.config.mjs.hbs", `import { defineConfig } from 'astro/config';
import tailwindcss from '@tailwindcss/vite';
{{#if (eq astroIntegration "react")}}
import react from '@astrojs/react';
{{/if}}
{{#if (eq astroIntegration "vue")}}
import vue from '@astrojs/vue';
{{/if}}
{{#if (eq astroIntegration "svelte")}}
import svelte from '@astrojs/svelte';
{{/if}}
{{#if (eq astroIntegration "solid")}}
import solidJs from '@astrojs/solid-js';
{{/if}}
{{#if (eq backend "self")}}
import node from '@astrojs/node';
{{/if}}
{{#if (eq runtime "workers")}}
import cloudflare from '@astrojs/cloudflare';
{{/if}}

export default defineConfig({
	integrations: [
{{#if (eq astroIntegration "react")}}
		react(),
{{/if}}
{{#if (eq astroIntegration "vue")}}
		vue(),
{{/if}}
{{#if (eq astroIntegration "svelte")}}
		svelte(),
{{/if}}
{{#if (eq astroIntegration "solid")}}
		solidJs(),
{{/if}}
	],
	vite: {
		plugins: [tailwindcss()],
	},
{{#if (or (eq backend "self") (eq runtime "workers"))}}
	output: 'server',
{{#if (eq backend "self")}}
	adapter: node({ mode: 'standalone' }),
{{else if (eq runtime "workers")}}
	adapter: cloudflare(),
{{/if}}
{{/if}}
});
`],
  ["frontend/astro/package.json.hbs", `{
	"name": "web",
	"private": true,
	"version": "0.0.1",
	"type": "module",
	"scripts": {
		"dev": "astro dev",
		"build": "astro build",
		"preview": "astro preview",
		"astro": "astro"
	},
	"dependencies": {
		"astro": "^5.7.10"
{{#if (eq astroIntegration "react")}}
		,"@astrojs/react": "^4.2.1"
		,"react": "^19.1.0"
		,"react-dom": "^19.1.0"
{{/if}}
{{#if (eq astroIntegration "vue")}}
		,"@astrojs/vue": "^5.0.6"
		,"vue": "^3.5.17"
{{/if}}
{{#if (eq astroIntegration "svelte")}}
		,"@astrojs/svelte": "^7.0.8"
		,"svelte": "^5.33.0"
{{/if}}
{{#if (eq astroIntegration "solid")}}
		,"@astrojs/solid-js": "^5.0.6"
		,"solid-js": "^1.9.5"
{{/if}}
{{#if (eq backend "self")}}
		,"@astrojs/node": "^9.1.3"
{{/if}}
{{#if (eq runtime "workers")}}
		,"@astrojs/cloudflare": "^12.3.1"
{{/if}}
	},
	"devDependencies": {
		"@tailwindcss/vite": "^4.1.12",
		"tailwindcss": "^4.1.12"
{{#if (eq astroIntegration "react")}}
		,"@types/react": "^19.1.6"
		,"@types/react-dom": "^19.1.5"
{{/if}}
	}
}
`],
  ["frontend/astro/_npmrc", `shamefully-hoist=true
`],
  ["frontend/astro/tsconfig.json.hbs", `{
	"extends": "astro/tsconfigs/strict",
	"compilerOptions": {
		"baseUrl": ".",
		"paths": {
			"@/*": ["./src/*"]
		}
{{#if (eq astroIntegration "react")}}
		,"jsx": "react-jsx",
		"jsxImportSource": "react"
{{/if}}
{{#if (eq astroIntegration "solid")}}
		,"jsx": "preserve",
		"jsxImportSource": "solid-js"
{{/if}}
	},
	"include": ["src/**/*", "env.d.ts"]
}
`],
  ["frontend/astro/_gitignore", `# build output
dist/
.output/

# generated types
.astro/

# dependencies
node_modules/

# logs
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*

# environment variables
.env
.env.production
.env.local

# macOS-specific files
.DS_Store
`],
  ["frontend/angular/package.json.hbs", `{
  "name": "web",
  "private": true,
  "type": "module",
  "scripts": {
    "ng": "ng",
    "dev": "ng serve --port 3001",
    "start": "ng serve --port 3001",
    "build": "ng build",
    "watch": "ng build --watch --configuration development"
  },
  "dependencies": {
    "@angular/animations": "^19.2.0",
    "@angular/common": "^19.2.0",
    "@angular/compiler": "^19.2.0",
    "@angular/core": "^19.2.0",
    "@angular/forms": "^19.2.0",
    "@angular/platform-browser": "^19.2.0",
    "@angular/platform-browser-dynamic": "^19.2.0",
    "@angular/router": "^19.2.0",
    "rxjs": "^7.8.1",
    "tslib": "^2.8.1",
    "zone.js": "^0.15.0"
  },
  "devDependencies": {
    "@angular-devkit/build-angular": "^19.2.0",
    "@angular/cli": "^19.2.0",
    "@angular/compiler-cli": "^19.2.0",
    "typescript": "~5.7.0"
  }
}
`],
  ["frontend/angular/tsconfig.app.json", `{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "outDir": "./out-tsc/app",
    "types": []
  },
  "files": ["src/main.ts"],
  "include": ["src/**/*.d.ts"]
}
`],
  ["frontend/angular/angular.json.hbs", `{
  "$schema": "./node_modules/@angular/cli/lib/config/schema.json",
  "version": 1,
  "newProjectRoot": "projects",
  "projects": {
    "web": {
      "projectType": "application",
      "schematics": {
        "@schematics/angular:component": {
          "style": "{{#if (eq cssFramework "scss")}}scss{{else if (eq cssFramework "less")}}less{{else}}css{{/if}}",
          "standalone": true
        }
      },
      "root": "",
      "sourceRoot": "src",
      "prefix": "app",
      "architect": {
        "build": {
          "builder": "@angular-devkit/build-angular:application",
          "options": {
            "outputPath": "dist/web",
            "index": "src/index.html",
            "browser": "src/main.ts",
            "polyfills": ["zone.js"],
            "tsConfig": "tsconfig.app.json",
            {{#if (eq cssFramework "tailwind")}}
            "styles": ["src/styles.css"],
            {{else if (eq cssFramework "scss")}}
            "styles": ["src/styles.scss"],
            {{else if (eq cssFramework "less")}}
            "styles": ["src/styles.less"],
            {{else}}
            "styles": ["src/styles.css"],
            {{/if}}
            "scripts": [],
            "assets": [
              {
                "glob": "**/*",
                "input": "public"
              }
            ]
          },
          "configurations": {
            "production": {
              "budgets": [
                {
                  "type": "initial",
                  "maximumWarning": "500kB",
                  "maximumError": "1MB"
                },
                {
                  "type": "anyComponentStyle",
                  "maximumWarning": "4kB",
                  "maximumError": "8kB"
                }
              ],
              "outputHashing": "all"
            },
            "development": {
              "optimization": false,
              "extractLicenses": false,
              "sourceMap": true
            }
          },
          "defaultConfiguration": "production"
        },
        "serve": {
          "builder": "@angular-devkit/build-angular:dev-server",
          "configurations": {
            "production": {
              "buildTarget": "web:build:production"
            },
            "development": {
              "buildTarget": "web:build:development"
            }
          },
          "defaultConfiguration": "development"
        }
      }
    }
  }
}
`],
  ["frontend/angular/tsconfig.json.hbs", `{
  "compileOnSave": false,
  "compilerOptions": {
    "outDir": "./dist/out-tsc",
    "strict": true,
    "noImplicitOverride": true,
    "noPropertyAccessFromIndexSignature": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "skipLibCheck": true,
    "isolatedModules": true,
    "esModuleInterop": true,
    "sourceMap": true,
    "declaration": false,
    "experimentalDecorators": true,
    "moduleResolution": "bundler",
    "importHelpers": true,
    "target": "ES2022",
    "module": "ES2022",
    "lib": ["ES2022", "dom"],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "angularCompilerOptions": {
    "enableI18nLegacyMessageIdFormat": false,
    "strictInjectionParameters": true,
    "strictInputAccessModifiers": true,
    "strictTemplates": true
  }
}
`],
  ["frontend/angular/_gitignore", `# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# Compiled output
/dist
/tmp
/out-tsc
/bazel-out

# Node
/node_modules
npm-debug.log
yarn-error.log

# IDEs and editors
.idea/
.project
.classpath
.c9/
*.launch
.settings/
*.sublime-workspace

# Visual Studio Code
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json
.history/*

# Miscellaneous
/.angular/cache
.sass-cache/
/connect.lock
/coverage
/libpeerconnection.log
testem.log
/typings

# System files
.DS_Store
Thumbs.db

# Environment
.env
.env.local
`],
  ["frontend/nuxt/package.json.hbs", `{
  "name": "web",
  "private": true,
  "type": "module",
  "scripts": {
    "build": "nuxt build",
    "dev": "nuxt dev",
    "generate": "nuxt generate",
    "preview": "nuxt preview",
    "postinstall": "nuxt prepare"
  },
  "dependencies": {
    "@nuxt/ui": "4.2.1",
    "@nuxt/content": "^3.7.1",
    "@nuxtjs/mdc": "^0.17.4",
    "nuxt": "^4.1.2",
    "vue": "^3.5.21",
    "vue-router": "^4.5.1"
  },
  "devDependencies": {
    "tailwindcss": "^4.1.13",
    "@iconify-json/lucide": "^1.2.57"
  }
}
`],
  ["frontend/nuxt/nuxt.config.ts.hbs", `import "@{{projectName}}/env/web";

// https://nuxt.com/docs/api/configuration/nuxt-config
export default defineNuxtConfig({
  compatibilityDate: 'latest',
  devtools: { enabled: true },
  modules: [
    '@nuxt/ui'
    {{#if (eq backend "convex")}},
    'convex-nuxt'
    {{/if}}
  ],
  css: ['~/assets/css/main.css'],
  devServer: {
    port: 3001
  },
  ssr: true,
  {{#if (eq backend "convex")}}
  convex: {
    url: process.env.NUXT_PUBLIC_CONVEX_URL,
  },
  {{else}}
  runtimeConfig: {
    public: {
      serverUrl: process.env.NUXT_PUBLIC_SERVER_URL,
    }
  },
  {{/if}}
})
`],
  ["frontend/nuxt/tsconfig.json.hbs", `{
  // https://nuxt.com/docs/guide/concepts/typescript
  "files": [],
  "references": [
    {
      "path": "./.nuxt/tsconfig.app.json"
    },
    {
      "path": "./.nuxt/tsconfig.server.json"
    },
    {
      "path": "./.nuxt/tsconfig.shared.json"
    },
    {
      "path": "./.nuxt/tsconfig.node.json"
    }
  ]
}
`],
  ["frontend/nuxt/_gitignore", `# Nuxt dev/build outputs
.output
.data
.nuxt
.nitro
.cache
dist
.wrangler
.alchemy

# Node dependencies
node_modules

# Logs
logs
*.log

# Misc
.DS_Store
.fleet
.idea

# Local env files
.env
.env.*
!.env.example

`],
  ["packages/env/package.json.hbs", `{
	"name": "@{{projectName}}/env",
	"version": "0.0.0",
	"private": true,
	"type": "module",
	"exports": {}
}`],
  ["packages/env/tsconfig.json.hbs", `{
  "extends": "@{{projectName}}/config/tsconfig.base.json",
}
`],
  ["packages/infra/alchemy.run.ts.hbs", `import alchemy from "alchemy";
{{#if (eq webDeploy "cloudflare")}}
{{#if (includes frontend "next")}}
import { Nextjs } from "alchemy/cloudflare";
{{else if (includes frontend "nuxt")}}
import { Nuxt } from "alchemy/cloudflare";
{{else if (includes frontend "svelte")}}
import { SvelteKit } from "alchemy/cloudflare";
{{else if (includes frontend "tanstack-start")}}
import { TanStackStart } from "alchemy/cloudflare";
{{else if (includes frontend "tanstack-router")}}
import { Vite } from "alchemy/cloudflare";
{{else if (includes frontend "react-router")}}
import { ReactRouter } from "alchemy/cloudflare";
{{else if (includes frontend "solid")}}
import { Vite } from "alchemy/cloudflare";
{{/if}}
{{/if}}
{{#if (eq serverDeploy "cloudflare")}}
import { Worker } from "alchemy/cloudflare";
{{/if}}
{{#if (and (or (eq serverDeploy "cloudflare") (and (eq webDeploy "cloudflare") (eq backend "self"))) (eq dbSetup "d1"))}}
import { D1Database } from "alchemy/cloudflare";
{{/if}}
import { config } from "dotenv";

{{#if (and (eq webDeploy "cloudflare") (eq serverDeploy "cloudflare"))}}
config({ path: "./.env" });
config({ path: "../../apps/web/.env" });
config({ path: "../../apps/server/.env" });
{{else if (eq webDeploy "cloudflare")}}
config({ path: "./.env" });
config({ path: "../../apps/web/.env" });
{{else if (eq serverDeploy "cloudflare")}}
config({ path: "./.env" });
config({ path: "../../apps/server/.env" });
{{/if}}

const app = await alchemy("{{projectName}}");

{{#if (and (or (eq serverDeploy "cloudflare") (and (eq webDeploy "cloudflare") (eq backend "self"))) (eq dbSetup "d1"))}}
const db = await D1Database("database", {
	{{#if (eq orm "prisma")}}
	migrationsDir: "../../packages/db/prisma/migrations",
	{{else if (eq orm "drizzle")}}
	migrationsDir: "../../packages/db/src/migrations",
	{{/if}}
});
{{/if}}

{{#if (eq webDeploy "cloudflare")}}
{{#if (includes frontend "next")}}
export const web = await Nextjs("web", {
  cwd: "../../apps/web",
  bindings: {
    {{#if (eq backend "convex")}}
    NEXT_PUBLIC_CONVEX_URL: alchemy.env.NEXT_PUBLIC_CONVEX_URL!,
    {{#if (eq auth "better-auth")}}
    NEXT_PUBLIC_CONVEX_SITE_URL: alchemy.env.NEXT_PUBLIC_CONVEX_SITE_URL!,
    {{/if}}
    {{else if (ne backend "self")}}
    NEXT_PUBLIC_SERVER_URL: alchemy.env.NEXT_PUBLIC_SERVER_URL!,
    {{/if}}
    {{#if (eq dbSetup "d1")}}
    DB: db,
    {{else if (ne database "none")}}
    DATABASE_URL: alchemy.secret.env.DATABASE_URL!,
    {{/if}}
    {{#if (ne backend "convex")}}
    CORS_ORIGIN: alchemy.env.CORS_ORIGIN!,
    {{#if (eq auth "better-auth")}}
    BETTER_AUTH_SECRET: alchemy.secret.env.BETTER_AUTH_SECRET!,
    BETTER_AUTH_URL: alchemy.env.BETTER_AUTH_URL!,
    {{/if}}
    {{/if}}
    {{#if (eq auth "clerk")}}
    CLERK_SECRET_KEY: alchemy.secret.env.CLERK_SECRET_KEY!,
    {{/if}}
    {{#if (and (includes examples "ai") (ne backend "convex"))}}
    GOOGLE_GENERATIVE_AI_API_KEY: alchemy.secret.env.GOOGLE_GENERATIVE_AI_API_KEY!,
    {{/if}}
    {{#if (eq payments "polar")}}
    POLAR_ACCESS_TOKEN: alchemy.secret.env.POLAR_ACCESS_TOKEN!,
    POLAR_SUCCESS_URL: alchemy.env.POLAR_SUCCESS_URL!,
    {{/if}}
    {{#if (eq dbSetup "turso")}}
    DATABASE_AUTH_TOKEN: alchemy.secret.env.DATABASE_AUTH_TOKEN!,
    {{/if}}
    {{#if (eq database "mysql")}}
    {{#if (eq orm "drizzle")}}
    DATABASE_HOST: alchemy.env.DATABASE_HOST!,
    DATABASE_USERNAME: alchemy.env.DATABASE_USERNAME!,
    DATABASE_PASSWORD: alchemy.secret.env.DATABASE_PASSWORD!,
    {{/if}}
    {{/if}}
  }
});
{{else if (includes frontend "nuxt")}}
export const web = await Nuxt("web", {
  cwd: "../../apps/web",
  bindings: {
    {{#if (eq backend "convex")}}
    NUXT_PUBLIC_CONVEX_URL: alchemy.env.NUXT_PUBLIC_CONVEX_URL!,
    {{#if (eq auth "better-auth")}}
    NUXT_PUBLIC_CONVEX_SITE_URL: alchemy.env.NUXT_PUBLIC_CONVEX_SITE_URL!,
    {{/if}}
    {{else if (ne backend "self")}}
    NUXT_PUBLIC_SERVER_URL: alchemy.env.NUXT_PUBLIC_SERVER_URL!,
    {{/if}}
  }
});
{{else if (includes frontend "svelte")}}
export const web = await SvelteKit("web", {
  cwd: "../../apps/web",
  bindings: {
    {{#if (eq backend "convex")}}
    PUBLIC_CONVEX_URL: alchemy.env.PUBLIC_CONVEX_URL!,
    {{#if (eq auth "better-auth")}}
    PUBLIC_CONVEX_SITE_URL: alchemy.env.PUBLIC_CONVEX_SITE_URL!,
    {{/if}}
    {{else if (ne backend "self")}}
    PUBLIC_SERVER_URL: alchemy.env.PUBLIC_SERVER_URL!,
    {{/if}}
  }
});
{{else if (includes frontend "tanstack-start")}}
export const web = await TanStackStart("web", {
  cwd: "../../apps/web",
  bindings: {
    {{#if (eq backend "convex")}}
    VITE_CONVEX_URL: alchemy.env.VITE_CONVEX_URL!,
    {{#if (eq auth "better-auth")}}
    VITE_CONVEX_SITE_URL: alchemy.env.VITE_CONVEX_SITE_URL!,
    {{/if}}
    {{else if (ne backend "self")}}
    VITE_SERVER_URL: alchemy.env.VITE_SERVER_URL!,
    {{/if}}
    {{#if (eq dbSetup "d1")}}
    DB: db,
    {{else if (ne database "none")}}
    DATABASE_URL: alchemy.secret.env.DATABASE_URL!,
    {{/if}}
    {{#if (ne backend "convex")}}
    CORS_ORIGIN: alchemy.env.CORS_ORIGIN!,
    {{#if (eq auth "better-auth")}}
    BETTER_AUTH_SECRET: alchemy.secret.env.BETTER_AUTH_SECRET!,
    BETTER_AUTH_URL: alchemy.env.BETTER_AUTH_URL!,
    {{/if}}
    {{/if}}
    {{#if (eq auth "clerk")}}
    CLERK_SECRET_KEY: alchemy.secret.env.CLERK_SECRET_KEY!,
    {{/if}}
    {{#if (and (includes examples "ai") (ne backend "convex"))}}
    GOOGLE_GENERATIVE_AI_API_KEY: alchemy.secret.env.GOOGLE_GENERATIVE_AI_API_KEY!,
    {{/if}}
    {{#if (eq payments "polar")}}
    POLAR_ACCESS_TOKEN: alchemy.secret.env.POLAR_ACCESS_TOKEN!,
    POLAR_SUCCESS_URL: alchemy.env.POLAR_SUCCESS_URL!,
    {{/if}}
    {{#if (eq dbSetup "turso")}}
    DATABASE_AUTH_TOKEN: alchemy.secret.env.DATABASE_AUTH_TOKEN!,
    {{/if}}
    {{#if (eq database "mysql")}}
    {{#if (eq orm "drizzle")}}
    DATABASE_HOST: alchemy.env.DATABASE_HOST!,
    DATABASE_USERNAME: alchemy.env.DATABASE_USERNAME!,
    DATABASE_PASSWORD: alchemy.secret.env.DATABASE_PASSWORD!,
    {{/if}}
    {{/if}}
  }
});
{{else if (includes frontend "tanstack-router")}}
export const web = await Vite("web", {
  cwd: "../../apps/web",
  assets: "dist",
  bindings: {
    {{#if (eq backend "convex")}}
    VITE_CONVEX_URL: alchemy.env.VITE_CONVEX_URL!,
    {{#if (eq auth "better-auth")}}
    VITE_CONVEX_SITE_URL: alchemy.env.VITE_CONVEX_SITE_URL!,
    {{/if}}
    {{else if (ne backend "self")}}
    VITE_SERVER_URL: alchemy.env.VITE_SERVER_URL!,
    {{/if}}
  }
});
{{else if (includes frontend "react-router")}}
export const web = await ReactRouter("web", {
  cwd: "../../apps/web",
  bindings: {
    {{#if (eq backend "convex")}}
    VITE_CONVEX_URL: alchemy.env.VITE_CONVEX_URL!,
    {{#if (eq auth "better-auth")}}
    VITE_CONVEX_SITE_URL: alchemy.env.VITE_CONVEX_SITE_URL!,
    {{/if}}
    {{else if (ne backend "self")}}
    VITE_SERVER_URL: alchemy.env.VITE_SERVER_URL!,
    {{/if}}
  }
});
{{else if (includes frontend "solid")}}
export const web = await Vite("web", {
  cwd: "../../apps/web",
  assets: "dist",
  bindings: {
    {{#if (eq backend "convex")}}
    VITE_CONVEX_URL: alchemy.env.VITE_CONVEX_URL!,
    {{#if (eq auth "better-auth")}}
    VITE_CONVEX_SITE_URL: alchemy.env.VITE_CONVEX_SITE_URL!,
    {{/if}}
    {{else if (ne backend "self")}}
    VITE_SERVER_URL: alchemy.env.VITE_SERVER_URL!,
    {{/if}}
  }
});
{{/if}}
{{/if}}

{{#if (eq serverDeploy "cloudflare")}}
export const server = await Worker("server", {
  cwd: "../../apps/server",
  entrypoint: "src/index.ts",
  compatibility: "node",
  bindings: {
    {{#if (eq dbSetup "d1")}}
    DB: db,
    {{else if (ne database "none")}}
    DATABASE_URL: alchemy.secret.env.DATABASE_URL!,
    {{/if}}
    CORS_ORIGIN: alchemy.env.CORS_ORIGIN!,
    {{#if (eq auth "better-auth")}}
    BETTER_AUTH_SECRET: alchemy.secret.env.BETTER_AUTH_SECRET!,
    BETTER_AUTH_URL: alchemy.env.BETTER_AUTH_URL!,
    {{/if}}
    {{#if (eq auth "clerk")}}
    CLERK_SECRET_KEY: alchemy.secret.env.CLERK_SECRET_KEY!,
    {{/if}}
    {{#if (includes examples "ai")}}
    GOOGLE_GENERATIVE_AI_API_KEY: alchemy.secret.env.GOOGLE_GENERATIVE_AI_API_KEY!,
    {{/if}}
    {{#if (eq payments "polar")}}
    POLAR_ACCESS_TOKEN: alchemy.secret.env.POLAR_ACCESS_TOKEN!,
    POLAR_SUCCESS_URL: alchemy.env.POLAR_SUCCESS_URL!,
    {{/if}}
    {{#if (eq dbSetup "turso")}}
    DATABASE_AUTH_TOKEN: alchemy.secret.env.DATABASE_AUTH_TOKEN!,
    {{/if}}
    {{#if (eq database "mysql")}}
    {{#if (eq orm "drizzle")}}
    DATABASE_HOST: alchemy.env.DATABASE_HOST!,
    DATABASE_USERNAME: alchemy.env.DATABASE_USERNAME!,
    DATABASE_PASSWORD: alchemy.secret.env.DATABASE_PASSWORD!,
    {{/if}}
    {{/if}}
  },
  dev: {
		port: 3000,
	},
});
{{/if}}

{{#if (and (eq webDeploy "cloudflare") (eq serverDeploy "cloudflare"))}}
console.log(\`Web    -> \${web.url}\`);
console.log(\`Server -> \${server.url}\`);
{{else if (eq webDeploy "cloudflare")}}
console.log(\`Web    -> \${web.url}\`);
{{else if (eq serverDeploy "cloudflare")}}
console.log(\`Server -> \${server.url}\`);
{{/if}}

await app.finalize();
`],
  ["packages/infra/package.json.hbs", `{
  "name": "@{{projectName}}/infra",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "alchemy dev",
    "deploy": "alchemy deploy",
    "destroy": "alchemy destroy"
  }
}
`],
  ["packages/config/package.json.hbs", `{
  "name": "@{{projectName}}/config",
  "version": "0.0.0",
  "private": true
}
`],
  ["packages/config/tsconfig.base.json.hbs", `{
  "$schema": "https://json.schemastore.org/tsconfig",
  "compilerOptions": {
    "target": "ESNext",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "lib": ["ESNext"],
    "verbatimModuleSyntax": true,
    "strict": true,
    "skipLibCheck": true,
    "resolveJsonModule": true,
    "allowSyntheticDefaultImports": true,
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "isolatedModules": true,
    "noUncheckedIndexedAccess": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "types": [
      {{#if (eq runtime "node")}}
        "node"
      {{else if (eq runtime "bun")}}
        "bun"
      {{else if (eq runtime "workers")}}
        "node"
      {{else}}
        "node"
      {{/if}}{{#if (or (eq serverDeploy "cloudflare") (eq webDeploy "cloudflare"))}},
      "@cloudflare/workers-types"{{/if}}
    ]
  }
}`],
  ["db/base/package.json.hbs", `{
  "name": "@{{projectName}}/db",
  "type": "module",
  "exports": {
    ".": {
      "default": "./src/index.ts"
    },
    "./*": {
      "default": "./src/*.ts"
    }
  },
  "scripts": {},
  "devDependencies": {}
}`],
  ["db/base/tsconfig.json.hbs", `{
  "extends": "@{{projectName}}/config/tsconfig.base.json",
  "compilerOptions": {
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "outDir": "dist",
    "composite": true
  }
}`],
  ["db/base/_gitignore", `# dependencies (bun install)
node_modules

# output
out
dist
*.tgz
/prisma/generated

# code coverage
coverage
*.lcov

# logs
logs
_.log
report.[0-9]_.[0-9]_.[0-9]_.[0-9]_.json

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# caches
.eslintcache
.cache
*.tsbuildinfo

# IntelliJ based IDEs
.idea

# Finder (MacOS) folder config
.DS_Store
`],
  ["addons/biome/biome.json.hbs", `{
    "$schema": "./node_modules/@biomejs/biome/configuration_schema.json",
	"vcs": {
		"enabled": false,
		"clientKind": "git",
		"useIgnoreFile": false
	},
	"files": {
		"ignoreUnknown": false,
		"includes": [
			"**",
			"!**/.next",
			"!**/dist",
			"!**/.turbo",
			"!**/dev-dist",
			"!**/.zed",
			"!**/.vscode",
			"!**/routeTree.gen.ts",
			"!**/src-tauri",
			"!**/.nuxt",
			"!bts.jsonc",
			"!**/.expo",
			"!**/.wrangler",
			"!**/.alchemy",
			"!**/.svelte-kit",
			"!**/wrangler.jsonc",
			"!**/.source",
			"!**/convex/_generated"
		]
	},
	"formatter": {
		"enabled": true,
		"indentStyle": "tab"
	},
	"assist": { "actions": { "source": { "organizeImports": "on" } } },
	"linter": {
		"enabled": true,
		"rules": {
			"recommended": true,
			"correctness": {
				"useExhaustiveDependencies": "info"
			},
			"nursery": {
				"useSortedClasses": {
					"level": "warn",
					"fix": "safe",
					"options": {
						"functions": ["clsx", "cva", "cn"]
					}
				}
			},
			"style": {
				"noParameterAssign": "error",
				"useAsConstAssertion": "error",
				"useDefaultParameterLast": "error",
				"useEnumInitializers": "error",
				"useSelfClosingElements": "error",
				"useSingleVarDeclarator": "error",
				"noUnusedTemplateLiteral": "error",
				"useNumberNamespace": "error",
				"noInferrableTypes": "error",
				"noUselessElse": "error"
			}
		}
	},
	"javascript": {
		"formatter": {
			"quoteStyle": "double"
		}
	},
	"css": {
		"parser": {
			"tailwindDirectives": true
		}
	}
	{{#if (or (includes frontend "svelte") (includes frontend "nuxt"))}}
	,
	"overrides": [
		{
			"includes": ["**/*.svelte", "**/*.vue"],
			"linter": {
				"rules": {
					"style": {
						"useConst": "off",
						"useImportType": "off"
					},
					"correctness": {
						"noUnusedVariables": "off",
						"noUnusedImports": "off"
					}
				}
			}
		}
	]
	{{/if}}
}
`],
  ["addons/lefthook/lefthook.yml.hbs", `# Lefthook configuration
# https://github.com/evilmartians/lefthook

pre-commit:
  parallel: true
  jobs:
{{#if (includes addons "biome")}}
    - name: biome
      glob: "*.{js,ts,cjs,mjs,d.cts,d.mts,jsx,tsx,json,jsonc}"
      run: {{packageManager}} biome check --write --no-errors-on-unmatched --files-ignore-unknown=true {staged_files}
      stage_fixed: true
{{else if (includes addons "oxlint")}}
    - name: oxlint
      run: {{packageManager}} oxlint --fix {staged_files}
      stage_fixed: true
    - name: oxfmt
      run: {{packageManager}} oxfmt --write {staged_files}
      stage_fixed: true
{{else}}
    # Add your pre-commit commands here
    # Example:
    # - name: lint
    #   run: {{packageManagerRunCmd}} lint
{{/if}}
`],
  ["rust-base/crates/client/Trunk.toml.hbs", `[build]
target = "index.html"
dist = "dist"

[watch]
watch = ["src", "style", "index.html"]
ignore = ["dist"]

[serve]
address = "127.0.0.1"
port = 8080
open = false

[clean]
dist = "dist"
`],
  ["rust-base/crates/client/Cargo.toml.hbs", `[package]
name = "{{projectName}}-client"
version.workspace = true
edition.workspace = true
authors.workspace = true
license.workspace = true

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
# Leptos framework
leptos.workspace = true
leptos_router.workspace = true
leptos_meta.workspace = true

# Logging
log.workspace = true
console_log.workspace = true

# WASM utilities
wasm-bindgen.workspace = true
wasm-bindgen-futures.workspace = true
web-sys.workspace = true
console_error_panic_hook.workspace = true

# Serialization
serde.workspace = true
serde_json.workspace = true

[features]
default = []
hydrate = ["leptos/hydrate", "leptos_router/hydrate", "leptos_meta/hydrate"]
ssr = ["leptos/ssr", "leptos_router/ssr", "leptos_meta/ssr"]
`],
  ["rust-base/crates/client/index.html.hbs", `<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="description" content="{{projectName}} - A Rust WASM application built with Leptos" />
    <title>{{projectName}}</title>
    <link data-trunk rel="css" href="style/main.css" />
    <link data-trunk rel="rust" href="Cargo.toml" data-wasm-opt="z" />
  </head>
  <body></body>
</html>
`],
  ["rust-base/crates/dioxus-client/Dioxus.toml.hbs", `[application]
name = "{{projectName}}"
default_platform = "web"

[web.app]
title = "{{projectName}}"

[web.watcher]
reload_html = true
watch_path = ["src", "assets"]

[web.resource]
dev_serve_crate = true
style = ["assets/main.css"]

[web.https]
enabled = false
`],
  ["rust-base/crates/dioxus-client/Cargo.toml.hbs", `[package]
name = "{{projectName}}-client"
version.workspace = true
edition.workspace = true
authors.workspace = true
license.workspace = true

[[bin]]
name = "{{projectName}}-client"
path = "src/main.rs"

[dependencies]
# Dioxus framework
dioxus.workspace = true
dioxus-router.workspace = true

# Logging
tracing.workspace = true
dioxus-logger.workspace = true

# WASM utilities
wasm-bindgen.workspace = true
console_error_panic_hook.workspace = true

# Serialization
serde.workspace = true
serde_json.workspace = true

[features]
default = ["web"]
web = ["dioxus/web"]
desktop = ["dioxus/desktop"]
`],
  ["rust-base/crates/cli/Cargo.toml.hbs", `[package]
name = "{{projectName}}-cli"
version.workspace = true
edition.workspace = true
authors.workspace = true
license.workspace = true
description = "Command-line interface for {{projectName}}"

[dependencies]
# CLI argument parsing
clap.workspace = true

# Async runtime
tokio.workspace = true

# Serialization
serde.workspace = true
serde_json.workspace = true

# Error handling
anyhow.workspace = true

# Logging
tracing.workspace = true
tracing-subscriber.workspace = true

# Environment
dotenvy.workspace = true

[[bin]]
name = "cli"
path = "src/main.rs"
`],
  ["rust-base/crates/tui/Cargo.toml.hbs", `[package]
name = "{{projectName}}-tui"
version.workspace = true
edition.workspace = true
authors.workspace = true
license.workspace = true
description = "Terminal user interface for {{projectName}}"

[dependencies]
# TUI framework
ratatui.workspace = true
crossterm.workspace = true

# Async runtime
tokio.workspace = true

# Serialization
serde.workspace = true
serde_json.workspace = true

# Error handling
anyhow.workspace = true

# Logging
tracing.workspace = true
tracing-subscriber.workspace = true
tracing-appender.workspace = true

# Environment
dotenvy.workspace = true

[[bin]]
name = "tui"
path = "src/main.rs"
`],
  ["rust-base/crates/proto/build.rs.hbs", `fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Compile the protobuf definitions
    tonic_build::configure()
        .build_server(true)
        .build_client(true)
        .out_dir("src/generated")
        .compile_protos(&["proto/greeter.proto"], &["proto"])?;

    // Tell Cargo to rerun this build script if the proto files change
    println!("cargo:rerun-if-changed=proto/greeter.proto");

    Ok(())
}
`],
  ["rust-base/crates/proto/Cargo.toml.hbs", `[package]
name = "{{projectName}}-proto"
version.workspace = true
edition.workspace = true
authors.workspace = true
license.workspace = true

[dependencies]
tonic.workspace = true
prost.workspace = true

[build-dependencies]
tonic-build.workspace = true
`],
  ["rust-base/crates/server/Cargo.toml.hbs", `[package]
name = "{{projectName}}-server"
version.workspace = true
edition.workspace = true
authors.workspace = true
license.workspace = true

[dependencies]
# Async runtime
tokio.workspace = true

# Serialization
serde.workspace = true
serde_json.workspace = true

# Error handling
thiserror.workspace = true
anyhow.workspace = true

# Logging
tracing.workspace = true
tracing-subscriber.workspace = true

# Environment
dotenvy.workspace = true

{{#if (eq rustWebFramework "axum")}}
# Web framework
axum.workspace = true
tower.workspace = true
tower-http.workspace = true
{{/if}}
{{#if (eq rustWebFramework "actix-web")}}
# Web framework
actix-web.workspace = true
actix-rt.workspace = true
actix-cors.workspace = true
{{/if}}

{{#if (eq rustOrm "sqlx")}}
# Database
sqlx.workspace = true
{{/if}}
{{#if (eq rustOrm "sea-orm")}}
# Database
sea-orm.workspace = true
{{/if}}

{{#if (eq rustApi "tonic")}}
# gRPC
tonic.workspace = true
prost.workspace = true
{{projectName}}-proto = { path = "../proto" }
tokio-stream = "0.1"
{{/if}}
{{#if (eq rustApi "async-graphql")}}
# GraphQL
async-graphql.workspace = true
{{#if (eq rustWebFramework "axum")}}
async-graphql-axum.workspace = true
{{/if}}
{{#if (eq rustWebFramework "actix-web")}}
async-graphql-actix-web.workspace = true
{{/if}}
{{/if}}

{{#if (includes rustLibraries "validator")}}
validator.workspace = true
{{/if}}
{{#if (includes rustLibraries "jsonwebtoken")}}
jsonwebtoken.workspace = true
{{/if}}
{{#if (includes rustLibraries "argon2")}}
argon2.workspace = true
{{/if}}
{{#if (eq rustCli "clap")}}

# CLI
clap.workspace = true
{{/if}}

[[bin]]
name = "server"
path = "src/main.rs"

{{#if (or (includes rustLibraries "tokio-test") (includes rustLibraries "mockall"))}}
[dev-dependencies]
{{#if (includes rustLibraries "tokio-test")}}
tokio-test.workspace = true
{{/if}}
{{#if (includes rustLibraries "mockall")}}
mockall.workspace = true
{{/if}}
{{/if}}
`],
  ["frontend/qwik/public/manifest.json", `{
  "short_name": "Better T Stack",
  "name": "Better T Stack - Qwik",
  "icons": [
    {
      "src": "/favicon.svg",
      "sizes": "any",
      "type": "image/svg+xml"
    }
  ],
  "start_url": "/",
  "background_color": "#0a0a0a",
  "display": "standalone",
  "scope": "/",
  "theme_color": "#AC7EF4"
}
`],
  ["frontend/qwik/public/robots.txt", `User-agent: *
Allow: /
`],
  ["frontend/qwik/public/favicon.svg", `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 200">
  <rect width="200" height="200" rx="20" fill="#AC7EF4"/>
  <text x="100" y="140" font-family="Arial Black, sans-serif" font-size="120" text-anchor="middle" fill="white">Q</text>
</svg>
`],
  ["frontend/qwik/src/entry.preview.tsx", `import { createQwikCity } from "@builder.io/qwik-city/middleware/node";
import qwikCityPlan from "@qwik-city-plan";

import render from "./entry.ssr";

const { router, notFound } = createQwikCity({ render, qwikCityPlan });

export { notFound, router };
`],
  ["frontend/qwik/src/root.tsx.hbs", `import { component$ } from "@builder.io/qwik";
import {
  QwikCityProvider,
  RouterOutlet,
  ServiceWorkerRegister,
} from "@builder.io/qwik-city";
import { RouterHead } from "./components/router-head/router-head";

import "./global.css";

export default component$(() => {
  return (
    <QwikCityProvider>
      <head>
        <meta charset="utf-8" />
        <link rel="manifest" href="/manifest.json" />
        <RouterHead />
        <ServiceWorkerRegister />
      </head>
      <body lang="en">
        <RouterOutlet />
      </body>
    </QwikCityProvider>
  );
});
`],
  ["frontend/qwik/src/entry.ssr.tsx", `import { renderToStream, type RenderToStreamOptions } from "@builder.io/qwik/server";
import { manifest } from "@qwik-client-manifest";

import Root from "./root";

export default function (opts: RenderToStreamOptions) {
  return renderToStream(<Root />, {
    manifest,
    ...opts,
    containerAttributes: {
      lang: "en-us",
      ...opts.containerAttributes,
    },
    serverData: {
      ...opts.serverData,
    },
  });
}
`],
  ["frontend/qwik/src/global.css.hbs", `{{#if (eq cssFramework "tailwind")}}
@import "tailwindcss";
{{else}}
:root {
  --bg-color: #ffffff;
  --text-color: #1a1a1a;
  --border-color: #e5e7eb;
  --muted-color: #6b7280;
}

@media (prefers-color-scheme: dark) {
  :root {
    --bg-color: #0a0a0a;
    --text-color: #fafafa;
    --border-color: #27272a;
    --muted-color: #a1a1aa;
  }
}

* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
  background-color: var(--bg-color);
  color: var(--text-color);
  line-height: 1.5;
}

a {
  color: inherit;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}
{{/if}}
`],
  ["frontend/solid/public/robots.txt", `# https://www.robotstxt.org/robotstxt.html
User-agent: *
Disallow:
`],
  ["frontend/solid/src/styles.css", `@import "tailwindcss";

body {
  @apply bg-neutral-950 text-neutral-100;
}
`],
  ["frontend/solid/src/main.tsx.hbs", `import { RouterProvider, createRouter } from "@tanstack/solid-router";
import { render } from "solid-js/web";
import { routeTree } from "./routeTree.gen";
import "./styles.css";
{{#if (eq api "orpc")}}
import { QueryClientProvider } from "@tanstack/solid-query";
import { orpc, queryClient } from "./utils/orpc";
{{/if}}

const router = createRouter({
  routeTree,
  defaultPreload: "intent",
  scrollRestoration: true,
  defaultPreloadStaleTime: 0,
  {{#if (eq api "orpc")}}
  context: { orpc, queryClient },
  {{/if}}
});

declare module "@tanstack/solid-router" {
  interface Register {
    router: typeof router;
  }
}

function App() {
  return (
    {{#if (eq api "orpc")}}
    <QueryClientProvider client={queryClient}>
    {{/if}}
      <RouterProvider router={router} />
    {{#if (eq api "orpc")}}
    </QueryClientProvider>
    {{/if}}
  );
}

const rootElement = document.getElementById("app");
if (rootElement) {
  render(() => <App />, rootElement);
}
`],
  ["frontend/redwood/web/package.json.hbs", `{
  "name": "web",
  "private": true,
  "type": "module",
  "dependencies": {
    "@redwoodjs/forms": "^8.6.1",
    "@redwoodjs/router": "^8.6.1",
    "@redwoodjs/web": "^8.6.1",
    "react": "^19.1.0",
    "react-dom": "^19.1.0"
  },
  "devDependencies": {
    "@redwoodjs/vite": "^8.6.1",
    "@types/react": "^19.1.6",
    "@types/react-dom": "^19.1.5",
    "typescript": "^5.7.3"
  }
}
`],
  ["frontend/redwood/web/tsconfig.json", `{
  "compilerOptions": {
    "noEmit": true,
    "allowJs": true,
    "esModuleInterop": true,
    "target": "esnext",
    "module": "esnext",
    "moduleResolution": "bundler",
    "baseUrl": "./",
    "strict": true,
    "skipLibCheck": true,
    "jsx": "preserve",
    "rootDirs": [
      "./src",
      "../.redwood/types/mirror/web/src",
      "../api/src",
      "../.redwood/types/mirror/api/src"
    ],
    "paths": {
      "src/*": ["./src/*", "../.redwood/types/mirror/web/src/*"],
      "$api/*": ["../api/src/*", "../.redwood/types/mirror/api/src/*"],
      "types/*": ["./types/*", "../.redwood/types/mirror/web/types/*"],
      "@redwoodjs/testing": ["../node_modules/@redwoodjs/testing/web"]
    },
    "typeRoots": ["../node_modules/@types", "./node_modules/@types"],
    "types": ["node"],
    "lib": ["esnext", "dom"]
  },
  "include": [
    "src",
    "../.redwood/types/includes/all-*",
    "../.redwood/types/includes/web-*",
    "./types"
  ]
}
`],
  ["frontend/redwood/scripts/seed.ts", `import type { Prisma } from "@prisma/client";

import { db } from "api/src/lib/db";

export default async () => {
  try {
    // If using dbAuth, you can seed users here.
    // If you're using a different auth provider, you can seed users there.

    // Example seeding posts
    const posts: Prisma.PostCreateInput[] = [
      {
        title: "Welcome to RedwoodJS",
        body: "RedwoodJS is a full-stack web framework that brings together the best parts of React, GraphQL, Prisma, and serverless.",
      },
      {
        title: "Getting Started",
        body: "Run \`yarn rw dev\` to start the development server. Your app will be available at http://localhost:8910.",
      },
    ];

    for (const post of posts) {
      await db.post.create({ data: post });
    }

    console.log("Database has been seeded. ");
  } catch (error) {
    console.warn("Please define your seed data.");
    console.error(error);
  }
};
`],
  ["frontend/redwood/api/package.json.hbs", `{
  "name": "api",
  "private": true,
  "type": "module",
  "dependencies": {
    "@redwoodjs/api": "^8.6.1",
    "@redwoodjs/graphql-server": "^8.6.1"
  }
}
`],
  ["frontend/redwood/api/tsconfig.json", `{
  "compilerOptions": {
    "noEmit": true,
    "allowJs": true,
    "esModuleInterop": true,
    "target": "esnext",
    "module": "esnext",
    "moduleResolution": "bundler",
    "baseUrl": "./",
    "strict": true,
    "skipLibCheck": true,
    "rootDirs": ["./src", "../.redwood/types/mirror/api/src"],
    "paths": {
      "src/*": ["./src/*", "../.redwood/types/mirror/api/src/*"],
      "$api/*": ["./src/*", "../.redwood/types/mirror/api/src/*"],
      "types/*": ["./types/*", "../.redwood/types/mirror/api/types/*"],
      "@redwoodjs/testing": ["../node_modules/@redwoodjs/testing/api"]
    },
    "typeRoots": ["../node_modules/@types", "./node_modules/@types"],
    "types": ["node"]
  },
  "include": [
    "src",
    "../.redwood/types/includes/all-*",
    "../.redwood/types/includes/api-*",
    "./types"
  ]
}
`],
  ["frontend/fresh/static/styles.css.hbs", `{{#if (eq cssFramework "tailwind")}}
@tailwind base;
@tailwind components;
@tailwind utilities;
{{else}}
/* Base styles */
*,
*::before,
*::after {
  box-sizing: border-box;
}

body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
  background: linear-gradient(to bottom right, #0f172a, #581c87, #0f172a);
  min-height: 100vh;
  color: #e2e8f0;
}

header {
  background: rgba(0, 0, 0, 0.2);
  backdrop-filter: blur(12px);
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

nav {
  max-width: 1200px;
  margin: 0 auto;
  padding: 1rem;
  display: flex;
  align-items: center;
  justify-content: space-between;
}

a {
  color: inherit;
  text-decoration: none;
}

main {
  max-width: 1200px;
  margin: 0 auto;
  padding: 4rem 1rem;
}

h1 {
  font-size: 3rem;
  font-weight: bold;
  margin-bottom: 1.5rem;
}

button {
  cursor: pointer;
  border: none;
  padding: 0.5rem 1rem;
  border-radius: 0.5rem;
  font-weight: 600;
  background: #06b6d4;
  color: white;
}

button:hover {
  background: #0891b2;
}
{{/if}}
`],
  ["frontend/fresh/static/favicon.svg", `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100">
  <defs>
    <linearGradient id="freshGradient" x1="0%" y1="0%" x2="100%" y2="100%">
      <stop offset="0%" style="stop-color:#06b6d4"/>
      <stop offset="100%" style="stop-color:#8b5cf6"/>
    </linearGradient>
  </defs>
  <circle cx="50" cy="50" r="45" fill="url(#freshGradient)"/>
  <text x="50" y="62" font-family="Arial, sans-serif" font-size="40" font-weight="bold" fill="white" text-anchor="middle">F</text>
</svg>
`],
  ["frontend/svelte/src/app.d.ts", `// See https://svelte.dev/docs/kit/types#app.d.ts
// for information about these interfaces
declare global {
  namespace App {
    // interface Error {}
    // interface Locals {}
    // interface PageData {}
    // interface PageState {}
    // interface Platform {}
  }
}

export {};
`],
  ["frontend/svelte/src/app.html", `<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%sveltekit.assets%/favicon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    %sveltekit.head%
  </head>
  <body data-sveltekit-preload-data="hover">
    <div style="display: contents">%sveltekit.body%</div>
  </body>
</html>
`],
  ["frontend/svelte/src/app.css", `@import "tailwindcss";

body {
  @apply bg-neutral-950 text-neutral-100;
}
`],
  ["frontend/svelte/static/favicon.png", `[Binary file]`],
  ["frontend/astro/public/favicon.svg", `<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32" fill="none">
  <rect width="32" height="32" rx="8" fill="#7C3AED"/>
  <path d="M16 6L8 26h4l2-5h4l2 5h4L16 6zm0 8l2 5h-4l2-5z" fill="white"/>
</svg>
`],
  ["frontend/astro/src/env.d.ts", `/// <reference path="../.astro/types.d.ts" />
`],
  ["frontend/native/unistyles/index.js.hbs", `import 'expo-router/entry';
import './unistyles';
`],
  ["frontend/native/unistyles/metro.config.js.hbs", `const { getDefaultConfig } = require("expo/metro-config");

const config = getDefaultConfig(__dirname);

module.exports = config;
`],
  ["frontend/native/unistyles/breakpoints.ts.hbs", `export const breakpoints = {
  xs: 0,
  sm: 576,
  md: 768,
  lg: 992,
  xl: 1200,
  superLarge: 2000,
  tvLike: 4000,
} as const;
`],
  ["frontend/native/unistyles/package.json.hbs", `{
  "name": "native",
  "version": "1.0.0",
  "private": true,
  "main": "index.js",
  "scripts": {
    "dev": "expo start --clear",
    "android": "expo run:android",
    "ios": "expo run:ios",
    "web": "expo start --web"
  },
  "dependencies": {
    "@expo/vector-icons": "^15.0.2",
    "@react-navigation/bottom-tabs": "^7.3.10",
    "@react-navigation/drawer": "^7.3.9",
    "@react-navigation/native": "^7.1.6",
    {{#if (includes examples "ai")}}
    "@stardazed/streams-text-encoding": "^1.0.2",
    "@ungap/structured-clone": "^1.3.0",
    {{/if}}
    "@tanstack/react-form": "^1.0.5",
    "expo": "^54.0.0",
    "expo-constants": "~18.0.8",
    "expo-crypto": "~15.0.6",
    "expo-linking": "~8.0.7",
    "expo-router": "~6.0.0",
    "expo-secure-store": "~15.0.6",
    "expo-splash-screen": "~31.0.8",
		"expo-status-bar": "^3.0.7",
    "expo-system-ui": "~6.0.7",
		"expo-dev-client": "~6.0.11",
    "expo-web-browser": "~15.0.6",
    "react": "19.1.0",
    "react-dom": "19.1.0",
    "react-native": "0.81.4",
		"react-native-edge-to-edge": "^1.7.0",
    "react-native-gesture-handler": "~2.28.0",
		"react-native-nitro-modules": "^0.29.4",
    "react-native-reanimated": "~4.1.0",
    "react-native-safe-area-context": "~5.6.0",
    "react-native-screens": "~4.16.0",
		"react-native-unistyles": "^3.0.12",
    "react-native-web": "^0.21.0",
    "react-native-worklets": "^0.5.1"
  },
  "devDependencies": {
    "ajv": "^8.17.1",
    "@babel/core": "^7.28.0",
    "@types/react": "~19.1.10"
  }
}
`],
  ["frontend/native/unistyles/theme.ts.hbs", `const sharedColors = {
  success: "#22C55E",
  destructive: "#EF4444",
  warning: "#F59E0B",
  info: "#3B82F6",
} as const;

export const lightTheme = {
  colors: {
    ...sharedColors,
    typography: "hsl(0 0% 0%)",
    background: "hsl(0 0% 100%)",
    foreground: "hsl(0 0% 0%)",
    card: "hsl(0 0% 98%)",
    cardForeground: "hsl(0 0% 0%)",
    primary: "hsl(0 0% 10%)",
    primaryForeground: "hsl(0 0% 100%)",
    secondary: "hsl(0 0% 95%)",
    secondaryForeground: "hsl(0 0% 0%)",
    muted: "hsl(0 0% 96%)",
    mutedForeground: "hsl(0 0% 45%)",
    accent: "hsl(0 0% 96%)",
    accentForeground: "hsl(0 0% 0%)",
    border: "hsl(0 0% 90%)",
    input: "hsl(0 0% 90%)",
    ring: "hsl(0 0% 20%)",
  },
  spacing: {
    xs: 4,
    sm: 8,
    md: 16,
    lg: 24,
    xl: 32,
    xxl: 48,
  },
  borderRadius: {
    sm: 6,
    md: 8,
    lg: 12,
    xl: 16,
  },
  fontSize: {
    xs: 12,
    sm: 14,
    base: 16,
    lg: 18,
    xl: 20,
    "2xl": 24,
    "3xl": 30,
    "4xl": 36,
  },
} as const;

export const darkTheme = {
  colors: {
    ...sharedColors,
    typography: "hsl(0 0% 100%)",
    background: "hsl(0 0% 0%)",
    foreground: "hsl(0 0% 100%)",
    card: "hsl(0 0% 2%)",
    cardForeground: "hsl(0 0% 100%)",
    primary: "hsl(0 0% 90%)",
    primaryForeground: "hsl(0 0% 0%)",
    secondary: "hsl(0 0% 10%)",
    secondaryForeground: "hsl(0 0% 100%)",
    muted: "hsl(0 0% 8%)",
    mutedForeground: "hsl(0 0% 65%)",
    accent: "hsl(0 0% 8%)",
    accentForeground: "hsl(0 0% 100%)",
    border: "hsl(0 0% 15%)",
    input: "hsl(0 0% 15%)",
    ring: "hsl(0 0% 80%)",
  },
  spacing: {
    xs: 4,
    sm: 8,
    md: 16,
    lg: 24,
    xl: 32,
    xxl: 48,
  },
  borderRadius: {
    sm: 6,
    md: 8,
    lg: 12,
    xl: 16,
  },
  fontSize: {
    xs: 12,
    sm: 14,
    base: 16,
    lg: 18,
    xl: 20,
    "2xl": 24,
    "3xl": 30,
    "4xl": 36,
  },
} as const;
`],
  ["frontend/native/unistyles/app.json.hbs", `{
  "expo": {
    "name": "{{projectName}}",
    "slug": "{{projectName}}",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/images/icon.png",
    "scheme": "mybettertapp",
    "userInterfaceStyle": "automatic",
    "newArchEnabled": true,
    "ios": {
      "supportsTablet": true
    },
    "android": {
      "adaptiveIcon": {
        "backgroundColor": "#E6F4FE",
        "foregroundImage": "./assets/images/android-icon-foreground.png",
        "backgroundImage": "./assets/images/android-icon-background.png",
        "monochromeImage": "./assets/images/android-icon-monochrome.png"
      },
      "edgeToEdgeEnabled": true,
      "predictiveBackGestureEnabled": false,
      "package": "com.anonymous.mybettertapp"
    },
    "web": {
      "output": "static",
      "favicon": "./assets/images/favicon.png"
    },
    "plugins": [
      "expo-router",
      [
        "expo-splash-screen",
        {
          "image": "./assets/images/splash-icon.png",
          "imageWidth": 200,
          "resizeMode": "contain",
          "backgroundColor": "#ffffff",
          "dark": {
            "backgroundColor": "#000000"
          }
        }
      ]
    ],
    "experiments": {
      "typedRoutes": true,
      "reactCompiler": true
    }
  }
}
`],
  ["frontend/native/unistyles/babel.config.js.hbs", `module.exports = (api) => {
	api.cache(true);
	const plugins = [];

	plugins.push([
		"react-native-unistyles/plugin",
		{
			root: "src",
			autoProcessRoot: "app",
			autoProcessImports: ["@/components"],
		},
	]);

	plugins.push("react-native-worklets/plugin");

	return {
		presets: ["babel-preset-expo"],

		plugins,
	};
};
`],
  ["frontend/native/unistyles/tsconfig.json.hbs", `{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "strict": true,
    "jsx": "react-jsx",
    "baseUrl": ".",
    "paths": {
      "@/*": ["*"]
    }
  },
  "include": ["**/*.ts", "**/*.tsx", ".expo/types/**/*.ts", "expo-env.d.ts"]
}
`],
  ["frontend/native/unistyles/unistyles.ts.hbs", `import { StyleSheet } from "react-native-unistyles";

import { breakpoints } from "./breakpoints";
import { darkTheme, lightTheme } from "./theme";

type AppBreakpoints = typeof breakpoints;

type AppThemes = {
  light: typeof lightTheme;
  dark: typeof darkTheme;
};

declare module "react-native-unistyles" {
  export interface UnistylesBreakpoints extends AppBreakpoints {}
  export interface UnistylesThemes extends AppThemes {}
}

StyleSheet.configure({
  breakpoints,
  themes: {
    light: lightTheme,
    dark: darkTheme,
  },
  settings: {
    adaptiveThemes: true,
  },
});
`],
  ["frontend/native/unistyles/_gitignore", `node_modules/
.expo/
dist/
npm-debug.*
*.jks
*.p8
*.p12
*.key
*.mobileprovision
*.orig.*
web-build/
# expo router
expo-env.d.ts

.env

ios
android

# macOS
.DS_Store

# Temporary files created by Metro to check the health of the file watcher
.metro-health-check*`],
  ["frontend/angular/src/styles.css.hbs", `{{#if (eq cssFramework "tailwind")}}
@import "tailwindcss";
{{/if}}

:root {
  --background: #ffffff;
  --foreground: #0a0a0a;
  --muted-color: #6b7280;
  --border-color: #e5e7eb;
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
    --muted-color: #9ca3af;
    --border-color: #374151;
  }
}

* {
  box-sizing: border-box;
  padding: 0;
  margin: 0;
}

html,
body {
  max-width: 100vw;
  overflow-x: hidden;
}

body {
  color: var(--foreground);
  background: var(--background);
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen,
    Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

a {
  color: inherit;
  text-decoration: none;
}
`],
  ["frontend/angular/src/main.ts", `import { bootstrapApplication } from "@angular/platform-browser";

import { AppComponent } from "./app/app.component";
import { appConfig } from "./app/app.config";

bootstrapApplication(AppComponent, appConfig).catch((err) => console.error(err));
`],
  ["frontend/angular/src/index.html", `<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Better T Stack - Angular</title>
    <base href="/" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="icon" type="image/svg+xml" href="favicon.svg" />
  </head>
  <body>
    <app-root></app-root>
  </body>
</html>
`],
  ["frontend/angular/public/favicon.svg", `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 256">
  <rect width="256" height="256" fill="#0f0f0f" rx="32"/>
  <text x="128" y="170" text-anchor="middle" font-family="monospace" font-size="140" font-weight="bold" fill="#fafafa">T</text>
</svg>
`],
  ["frontend/native/uniwind/metro.config.js.hbs", `const { getDefaultConfig } = require("expo/metro-config");
const { withUniwindConfig } = require("uniwind/metro");

/** @type {import('expo/metro-config').MetroConfig} */
const config = getDefaultConfig(__dirname);

const uniwindConfig = withUniwindConfig(config, {
  cssEntryFile: "./global.css",
  dtsFile: "./uniwind-types.d.ts",
});

module.exports = uniwindConfig;

`],
  ["frontend/native/uniwind/global.css", `@import "tailwindcss";
@import "uniwind";
@import "heroui-native/styles";

@source './node_modules/heroui-native/lib';
`],
  ["frontend/native/uniwind/package.json.hbs", `{
  "name": "native",
  "version": "1.0.0",
  "private": true,
  "main": "expo-router/entry",
  "scripts": {
    "start": "expo start",
    "dev": "expo start --clear",
    "android": "expo run:android",
    "ios": "expo run:ios",
    "prebuild": "expo prebuild",
    "web": "expo start --web"
  },
  "dependencies": {
    "@expo/metro-runtime": "~6.1.2",
    "@expo/vector-icons": "^15.0.3",
    "@gorhom/bottom-sheet": "^5",
    "@react-navigation/drawer": "^7.3.9",
    "@react-navigation/elements": "^2.8.1",
    {{#if (includes examples "ai")}}
    "@stardazed/streams-text-encoding": "^1.0.2",
    "@ungap/structured-clone": "^1.3.0",
    {{/if}}
    "expo": "^54.0.23",
    "expo-constants": "~18.0.10",
    "expo-font": "~14.0.9",
    "expo-haptics": "^15.0.7",
    "expo-linking": "~8.0.8",
    "expo-network": "~8.0.7",
    "expo-router": "~6.0.14",
    "expo-secure-store": "~15.0.7",
    "expo-status-bar": "~3.0.8",
    "heroui-native": "^1.0.0-beta.9",
    "react": "19.1.0",
    "react-dom": "19.1.0",
    "react-native": "0.81.5",
    "react-native-gesture-handler": "^2.28.0",
    "react-native-keyboard-controller": "1.18.5",
    "react-native-reanimated": "~4.1.1",
    "react-native-safe-area-context": "~5.6.0",
    "react-native-screens": "~4.16.0",
    "react-native-svg": "15.12.1",
    "react-native-web": "^0.21.0",
    "react-native-worklets": "0.5.1",
    "tailwind-merge": "^3.4.0",
    "tailwind-variants": "^3.2.2",
    "tailwindcss": "^4.1.18",
    "uniwind": "^1.2.2"
  },
  "devDependencies": {
    "@types/node": "^24.10.0",
    "@types/react": "~19.1.0"
  }
}`],
  ["frontend/native/uniwind/app.json.hbs", `{
  "expo": {
    "scheme": "{{projectName}}",
    "userInterfaceStyle": "automatic",
    "orientation": "default",
    "web": {
      "bundler": "metro"
    },
    "name": "{{projectName}}",
    "slug": "{{projectName}}",
    "plugins": [
      "expo-font"
    ],
    "experiments": {
      "typedRoutes": true,
      "reactCompiler": true
    }
  }
}
`],
  ["frontend/native/uniwind/tsconfig.json.hbs", `{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "strict": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": [
    "**/*.ts",
    "**/*.tsx"
  ]
}`],
  ["frontend/native/uniwind/_gitignore", `node_modules/
.expo/
dist/
npm-debug.*
*.jks
*.p8
*.p12
*.key
*.mobileprovision
*.orig.*
web-build/

# macOS
.DS_Store

# Temporary files created by Metro to check the health of the file watcher
.metro-health-check*

# UniWind generated types
uniwind-types.d.ts

`],
  ["frontend/nuxt/app/app.vue.hbs", `<script setup lang="ts">
{{#if (eq api "orpc")}}
import { VueQueryDevtools } from '@tanstack/vue-query-devtools'
{{/if}}
</script>

<template>
    <NuxtLoadingIndicator />
    <UApp>
        <NuxtLayout>
            <NuxtPage />
        </NuxtLayout>
    </UApp>
    {{#if (eq api "orpc")}}
    <VueQueryDevtools />
    {{/if}}
</template>
`],
  ["frontend/nuxt/app/app.config.ts.hbs", `export default defineAppConfig({
  // https://ui.nuxt.com/getting-started/theme#design-system
  ui: {
    colors: {
      primary: 'emerald',
      neutral: 'neutral',
    },
    button: {
      defaultVariants: {
        // Set default button color to neutral
        // color: 'neutral'
      }
    }
  }
})
`],
  ["frontend/native/bare/metro.config.js.hbs", `// Learn more https://docs.expo.io/guides/customizing-metro
const { getDefaultConfig } = require("expo/metro-config");

const config = getDefaultConfig(__dirname);

config.resolver.unstable_enablePackageExports = true;

module.exports = config;

`],
  ["frontend/native/bare/package.json.hbs", `{
  "name": "native",
  "version": "1.0.0",
  "main": "expo-router/entry",
  "scripts": {
    "dev": "expo start --clear",
    "android": "expo run:android",
    "ios": "expo run:ios",
    "prebuild": "expo prebuild",
    "web": "expo start --web"
  },
  "dependencies": {
    "@expo/vector-icons": "^15.0.2",
    "@react-navigation/bottom-tabs": "^7.2.0",
    "@react-navigation/drawer": "^7.1.1",
    "@react-navigation/native": "^7.0.14",
    "@tanstack/react-form": "^1.0.5",
    "@tanstack/react-query": "^5.85.5",
    {{#if (includes examples "ai")}}
    "@stardazed/streams-text-encoding": "^1.0.2",
    "@ungap/structured-clone": "^1.3.0",
    {{/if}}
		"expo": "^54.0.1",
    "expo-constants": "~18.0.8",
    "expo-crypto": "~15.0.6",
    "expo-linking": "~8.0.7",
    "expo-navigation-bar": "~5.0.8",
    "expo-network": "~8.0.7",
    "expo-router": "~6.0.0",
    "expo-secure-store": "~15.0.6",
    "expo-splash-screen": "~31.0.8",
    "expo-status-bar": "~3.0.7",
    "expo-system-ui": "~6.0.7",
    "expo-web-browser": "~15.0.6",
    "react": "19.1.0",
    "react-dom": "19.1.0",
    "react-native": "0.81.4",
    "react-native-gesture-handler": "~2.28.0",
    "react-native-reanimated": "~4.1.0",
    "react-native-safe-area-context": "~5.6.0",
    "react-native-screens": "~4.16.0",
    "react-native-web": "^0.21.0",
    "react-native-worklets": "^0.5.1"
  },
  "devDependencies": {
    "@babel/core": "^7.26.10",
    "@types/react": "~19.1.10"
  },
  "private": true
}

`],
  ["frontend/native/bare/app.json.hbs", `{
	"expo": {
		"name": "{{projectName}}",
		"slug": "{{projectName}}",
		"version": "1.0.0",
		"orientation": "portrait",
		"icon": "./assets/images/icon.png",
		"scheme": "mybettertapp",
		"userInterfaceStyle": "automatic",
		"newArchEnabled": true,
		"ios": {
			"supportsTablet": true
		},
		"android": {
			"adaptiveIcon": {
				"backgroundColor": "#E6F4FE",
				"foregroundImage": "./assets/images/android-icon-foreground.png",
				"backgroundImage": "./assets/images/android-icon-background.png",
				"monochromeImage": "./assets/images/android-icon-monochrome.png"
			},
			"edgeToEdgeEnabled": true,
			"predictiveBackGestureEnabled": false,
			"package": "com.anonymous.mybettertapp"
		},
		"web": {
			"output": "static",
			"favicon": "./assets/images/favicon.png"
		},
		"plugins": [
			"expo-router",
			[
				"expo-splash-screen",
				{
					"image": "./assets/images/splash-icon.png",
					"imageWidth": 200,
					"resizeMode": "contain",
					"backgroundColor": "#ffffff",
					"dark": {
						"backgroundColor": "#000000"
					}
				}
			]
		],
		"experiments": {
			"typedRoutes": true,
			"reactCompiler": true
		}
	}
}

`],
  ["frontend/native/bare/tsconfig.json.hbs", `{
	"extends": "expo/tsconfig.base",
	"compilerOptions": {
		"strict": true,
		"paths": {
			"@/*": ["./*"]
		}
	},
	"include": ["**/*.ts", "**/*.tsx", ".expo/types/**/*.ts", "expo-env.d.ts"]
}

`],
  ["frontend/native/bare/_gitignore", `node_modules/
.expo/
dist/
npm-debug.*
*.jks
*.p8
*.p12
*.key
*.mobileprovision
*.orig.*
web-build/

# macOS
.DS_Store

# Temporary files created by Metro to check the health of the file watcher
.metro-health-check*

`],
  ["frontend/nuxt/server/tsconfig.json", `{
  "extends": "../.nuxt/tsconfig.server.json"
}
`],
  ["frontend/nuxt/public/favicon.ico", `[Binary file]`],
  ["frontend/nuxt/public/robots.txt", `User-Agent: *
Disallow:
`],
  ["frontend/react/react-router/react-router.config.ts", `import type { Config } from "@react-router/dev/config";

export default {
  ssr: false,
  appDirectory: "src",
} satisfies Config;
`],
  ["frontend/react/react-router/package.json.hbs", `{
  "name": "web",
  "private": true,
  "type": "module",
  "scripts": {
    "build": "react-router build",
    "dev": "react-router dev",
    "start": "react-router-serve ./build/server/index.js",
    "typecheck": "react-router typegen && tsc"
  },
  "dependencies": {
{{#if (eq uiLibrary "shadcn-ui")}}
    "@base-ui/react": "^1.0.0",
    "shadcn": "^3.6.2",
    "@tanstack/react-form": "^1.27.3",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "lucide-react": "^0.511.0",
    "next-themes": "^0.4.6",
    "sonner": "^2.0.3",
    "tailwind-merge": "^3.3.0",
{{/if}}
{{#if (eq cssFramework "tailwind")}}
    "tw-animate-css": "^1.3.2",
{{/if}}
    "@react-router/fs-routes": "^7.10.1",
    "@react-router/node": "^7.10.1",
    "@react-router/serve": "^7.10.1",
    "isbot": "^5.1.28",
    "react": "19.2.3",
    "react-dom": "19.2.3",
    "react-router": "^7.10.1"
  },
  "devDependencies": {
    "@react-router/dev": "^7.10.1",
{{#if (eq cssFramework "tailwind")}}
    "@tailwindcss/vite": "^4.1.18",
    "tailwindcss": "^4.1.18",
{{/if}}
    "@types/node": "^20",
    "@types/react": "~19.2.7",
    "@types/react-dom": "^19.2.3",
    "react-router-devtools": "^1.1.0",
    "typescript": "^5.8.3",
    "vite": "^7.2.7",
    "vite-tsconfig-paths": "^5.1.4"
  }
}
`],
  ["frontend/react/react-router/tsconfig.json.hbs", `{
  "include": [
    "**/*",
    "**/.server/**/*",
    "**/.client/**/*",
    ".react-router/types/**/*"
  ],
  "compilerOptions": {
    "lib": ["DOM", "DOM.Iterable", "ES2022"],
    "types": ["node", "vite/client"],
    "target": "ES2022",
    "module": "ES2022",
    "moduleResolution": "bundler",
    "jsx": "react-jsx",
    "rootDirs": [".", "./.react-router/types"],
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    },
    "esModuleInterop": true,
    "verbatimModuleSyntax": true,
    "noEmit": true,
    "resolveJsonModule": true,
    "skipLibCheck": true,
    "strict": true
  }
}
`],
  ["frontend/react/react-router/vite.config.ts.hbs", `import { reactRouter } from "@react-router/dev/vite";
import tailwindcss from "@tailwindcss/vite";
import { defineConfig } from "vite";
import tsconfigPaths from "vite-tsconfig-paths";

export default defineConfig({
  plugins: [
    tailwindcss(),
    reactRouter(),
    tsconfigPaths(),
  ],
});`],
  ["packages/env/src/web.ts.hbs", `{{#if (includes frontend "next")}}
import { createEnv } from "@t3-oss/env-nextjs";
{{else if (includes frontend "nuxt")}}
import { createEnv } from "@t3-oss/env-nuxt";
{{else}}
import { createEnv } from "@t3-oss/env-core";
{{/if}}
import { z } from "zod";

{{#if (includes frontend "nuxt")}}
/**
 * Nuxt env validation - validates at build time when imported in nuxt.config.ts
 * For runtime access in components/plugins, use useRuntimeConfig() instead:
 *   const config = useRuntimeConfig()
 *   config.public.serverUrl (NUXT_PUBLIC_SERVER_URL maps to serverUrl)
 */
{{/if}}
export const env = createEnv({
{{#if (eq backend "convex")}}
{{#if (includes frontend "next")}}
	client: {
		NEXT_PUBLIC_CONVEX_URL: z.url(),
{{#if (eq auth "better-auth")}}
		NEXT_PUBLIC_CONVEX_SITE_URL: z.url(),
{{/if}}
{{#if (eq auth "clerk")}}
		NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY: z.string().min(1),
{{/if}}
	},
	runtimeEnv: {
		NEXT_PUBLIC_CONVEX_URL: process.env.NEXT_PUBLIC_CONVEX_URL,
{{#if (eq auth "better-auth")}}
		NEXT_PUBLIC_CONVEX_SITE_URL: process.env.NEXT_PUBLIC_CONVEX_SITE_URL,
{{/if}}
{{#if (eq auth "clerk")}}
		NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY: process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY,
{{/if}}
	},
{{else if (includes frontend "nuxt")}}
	client: {
		NUXT_PUBLIC_CONVEX_URL: z.url(),
	},
{{else if (includes frontend "svelte")}}
	clientPrefix: "PUBLIC_",
	client: {
		PUBLIC_CONVEX_URL: z.url(),
	},
	runtimeEnv: (import.meta as any).env,
{{else}}
	clientPrefix: "VITE_",
	client: {
		VITE_CONVEX_URL: z.url(),
{{#if (eq auth "better-auth")}}
		VITE_CONVEX_SITE_URL: z.url(),
{{/if}}
{{#if (eq auth "clerk")}}
		VITE_CLERK_PUBLISHABLE_KEY: z.string().min(1),
{{/if}}
	},
	runtimeEnv: (import.meta as any).env,
{{/if}}
{{else if (eq backend "self")}}
{{#if (includes frontend "next")}}
	client: {},
	runtimeEnv: {},
{{else}}
	clientPrefix: "VITE_",
	client: {},
	runtimeEnv: (import.meta as any).env,
{{/if}}
{{else if (ne backend "none")}}
{{#if (includes frontend "next")}}
	client: {
		NEXT_PUBLIC_SERVER_URL: z.url(),
	},
	runtimeEnv: {
		NEXT_PUBLIC_SERVER_URL: process.env.NEXT_PUBLIC_SERVER_URL,
	},
{{else if (includes frontend "nuxt")}}
	client: {
		NUXT_PUBLIC_SERVER_URL: z.url(),
	},
{{else if (includes frontend "svelte")}}
	clientPrefix: "PUBLIC_",
	client: {
		PUBLIC_SERVER_URL: z.url(),
	},
	runtimeEnv: (import.meta as any).env,
{{else}}
	clientPrefix: "VITE_",
	client: {
		VITE_SERVER_URL: z.url(),
	},
	runtimeEnv: (import.meta as any).env,
{{/if}}
{{/if}}
	emptyStringAsUndefined: true,
});`],
  ["packages/env/src/server.ts.hbs", `{{#if (eq serverDeploy "cloudflare")}}
/// <reference path="../env.d.ts" />
// For Cloudflare Workers, env is accessed via cloudflare:workers module
// Types are defined in env.d.ts based on your alchemy.run.ts bindings
export { env } from "cloudflare:workers";
{{else}}
import "dotenv/config";
import { createEnv } from "@t3-oss/env-core";
import { z } from "zod";

export const env = createEnv({
	server: {
{{#if (ne database "none")}}
{{#if (eq dbSetup "planetscale")}}
		DATABASE_HOST: z.string().min(1),
		DATABASE_USERNAME: z.string().min(1),
		DATABASE_PASSWORD: z.string().min(1),
{{else}}
		DATABASE_URL: z.string().min(1),
{{#if (eq dbSetup "turso")}}
		DATABASE_AUTH_TOKEN: z.string().min(1),
{{/if}}
{{/if}}
{{/if}}
{{#if (eq auth "better-auth")}}
		BETTER_AUTH_SECRET: z.string().min(32),
		BETTER_AUTH_URL: z.url(),
{{/if}}
{{#if (eq payments "polar")}}
		POLAR_ACCESS_TOKEN: z.string().min(1),
		POLAR_SUCCESS_URL: z.url(),
{{/if}}
		CORS_ORIGIN: z.url(),
		NODE_ENV: z.enum(["development", "production", "test"]).default("development"),
	},
	runtimeEnv: process.env,
	emptyStringAsUndefined: true,
});
{{/if}}`],
  ["packages/env/src/native.ts.hbs", `import { createEnv } from "@t3-oss/env-core";
import { z } from "zod";

export const env = createEnv({
	clientPrefix: "EXPO_PUBLIC_",
	client: {
{{#if (eq backend "convex")}}
		EXPO_PUBLIC_CONVEX_URL: z.url(),
{{#if (eq auth "better-auth")}}
		EXPO_PUBLIC_CONVEX_SITE_URL: z.url(),
{{/if}}
{{#if (eq auth "clerk")}}
		EXPO_PUBLIC_CLERK_PUBLISHABLE_KEY: z.string().min(1),
{{/if}}
{{else}}
		EXPO_PUBLIC_SERVER_URL: z.url(),
{{/if}}
	},
	runtimeEnv: process.env,
	emptyStringAsUndefined: true,
});`],
  ["frontend/react/tanstack-router/package.json.hbs", `{
	"name": "web",
	"version": "0.0.0",
	"private": true,
	"type": "module",
	"scripts": {
		"dev": "vite dev",
		"build": "vite build",
		"serve": "vite preview",
		"start": "vite",
		"check-types": "tsc --noEmit"
	},
	"dependencies": {
{{#if (eq uiLibrary "shadcn-ui")}}
        "@hookform/resolvers": "^5.1.1",
        "@base-ui/react": "^1.0.0",
        "shadcn": "^3.6.2",
        "@tanstack/react-form": "^1.12.3",
		"class-variance-authority": "^0.7.1",
		"clsx": "^2.1.1",
		"lucide-react": "^0.473.0",
        "next-themes": "^0.4.6",
        "sonner": "^2.0.5",
		"tailwind-merge": "^3.3.1",
{{/if}}
{{#if (eq cssFramework "tailwind")}}
		"@tailwindcss/vite": "^4.0.15",
		"tw-animate-css": "^1.2.5",
{{/if}}
		"@tanstack/react-router": "^1.141.1",
		"react": "19.2.3",
		"react-dom": "19.2.3"
	},
	"devDependencies": {
		"@tanstack/react-router-devtools": "^1.141.1",
		"@tanstack/router-plugin": "^1.141.1",
		"@types/node": "^22.13.14",
		"@types/react": "19.2.7",
		"@types/react-dom": "19.2.3",
		"@vitejs/plugin-react": "^4.3.4",
{{#if (eq cssFramework "tailwind")}}
		"postcss": "^8.5.3",
		"tailwindcss": "^4.0.15",
{{/if}}
		"vite": "^6.2.2"
	}
}
`],
  ["frontend/react/tanstack-router/index.html.hbs", `<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>{{projectName}}</title>
  </head>

  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
`],
  ["frontend/react/tanstack-router/tsconfig.json.hbs", `{
  "compilerOptions": {
    "strict": true,
    "esModuleInterop": true,
    "jsx": "react-jsx",
    "target": "ESNext",
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "verbatimModuleSyntax": true,
    "skipLibCheck": true,
    "types": ["vite/client"],
    "rootDirs": ["."],
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  }
}
`],
  ["frontend/react/tanstack-router/vite.config.ts.hbs", `import tailwindcss from "@tailwindcss/vite";
import { tanstackRouter } from "@tanstack/router-plugin/vite";
import react from "@vitejs/plugin-react";
import path from "node:path";
import { defineConfig } from "vite";

export default defineConfig({
  plugins: [
    tailwindcss(),
    tanstackRouter({}),
    react(),
  ],
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "./src"),
    },
  },
  server: {
    port: 3001,
  },
});`],
  ["frontend/react/next/package.json.hbs", `{
  "name": "web",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --port 3001",
    "build": "next build",
    "start": "next start"
  },
  "dependencies": {
{{#if (eq uiLibrary "shadcn-ui")}}
    "@base-ui/react": "^1.0.0",
    "shadcn": "^3.6.2",
    "@tanstack/react-form": "^1.27.3",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "lucide-react": "^0.546.0",
    "next-themes": "^0.4.6",
    "sonner": "^2.0.5",
    "tailwind-merge": "^3.3.1",
{{/if}}
{{#if (eq cssFramework "tailwind")}}
    "tw-animate-css": "^1.3.4",
{{/if}}
    "next": "^16.1.1",
    "react": "^19.2.3",
    "react-dom": "^19.2.3",
    "babel-plugin-react-compiler": "^1.0.0"
  },
  "devDependencies": {
{{#if (eq cssFramework "tailwind")}}
    "@tailwindcss/postcss": "^4.1.10",
    "tailwindcss": "^4.1.10",
{{/if}}
    "@types/node": "^20",
    "@types/react": "^19.2.7",
    "@types/react-dom": "^19.2.3",
    "typescript": "^5"
  }
}
`],
  ["frontend/react/next/next-env.d.ts.hbs", `/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.
`],
  ["frontend/react/next/next.config.ts.hbs", `import "@{{projectName}}/env/web";
{{#if (eq webDeploy "cloudflare")}}
import { initOpenNextCloudflareForDev } from "@opennextjs/cloudflare";
{{/if}}
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
	typedRoutes: true,
	reactCompiler: true,
	{{#if (includes examples "ai")}}
	transpilePackages: ["shiki"],
	{{/if}}
	{{#if (eq dbSetup "turso")}}
	serverExternalPackages: ["libsql", "@libsql/client"],
	{{/if}}
};

export default nextConfig;

{{#if (eq webDeploy "cloudflare")}}
initOpenNextCloudflareForDev();
{{/if}}
`],
  ["frontend/react/next/postcss.config.mjs.hbs", `const config = {
  plugins: ["@tailwindcss/postcss"],
};

export default config;
`],
  ["frontend/react/next/tsconfig.json.hbs", `{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "verbatimModuleSyntax": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }{{#if (or (eq serverDeploy "cloudflare") (eq webDeploy "cloudflare"))}},
    "types": [
      "@cloudflare/workers-types"
    ]{{/if}}
  },
  "include": [
    {{#if (eq serverDeploy "cloudflare")}}
    "../server/env.d.ts",
    {{/if}}
    "./next-env.d.ts",
    "./**/*.ts",
    "./**/*.tsx",
    "./.next/types/**/*.ts"
  ],
  "exclude": [
    "./node_modules"
  ]
}
`],
  ["frontend/react/web-base/components.json.hbs", `{{#if (eq uiLibrary "shadcn-ui")}}
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "base-lyra",
  "rsc": false,
  "tsx": true,
  "tailwind": {
    "config": "",
    "css": "src/index.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "iconLibrary": "lucide",
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "menuColor": "default",
  "menuAccent": "subtle",
  "registries": {}
}
{{/if}}
`],
  ["frontend/react/web-base/_gitignore", `# Dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# Testing
/coverage

# Build outputs
/.next/
/out/
/build/
/dist/
.vinxi
.output
.react-router/
.tanstack/
.nitro/

# Deployment
.vercel
.netlify
.wrangler
.alchemy

# Environment & local files
.env*
!.env.example
.DS_Store
*.pem
*.local

# Logs
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*
*.log*

# TypeScript
*.tsbuildinfo
next-env.d.ts

# IDE
.vscode/*
!.vscode/extensions.json
.idea

# Other
dev-dist

.wrangler
.dev.vars*

.open-next
`],
  ["frontend/react/tanstack-start/package.json.hbs", `{
  "name": "web",
  "private": true,
  "type": "module",
  "scripts": {
    "build": "vite build",
    "serve": "vite preview",
    "dev": "vite dev"
  },
  "dependencies": {
{{#if (eq uiLibrary "shadcn-ui")}}
    "@base-ui/react": "^1.0.0",
    "shadcn": "^3.6.2",
    "@tanstack/react-form": "^1.23.5",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "lucide-react": "^0.525.0",
    "next-themes": "^0.4.6",
    "sonner": "^2.0.3",
    "tailwind-merge": "^3.3.1",
{{/if}}
{{#if (eq cssFramework "tailwind")}}
    "@tailwindcss/vite": "^4.1.8",
    "tailwindcss": "^4.1.3",
    "tw-animate-css": "^1.2.5",
{{/if}}
    "@tanstack/react-query": "^5.80.6",
    "@tanstack/react-router": "^1.141.1",
    "@tanstack/react-router-with-query": "^1.130.17",
    "@tanstack/react-start": "^1.141.1",
    "@tanstack/router-plugin": "^1.141.1",
    "react": "19.2.3",
    "react-dom": "19.2.3",
    "vite-tsconfig-paths": "^5.1.4"
  },
  "devDependencies": {
    "@tanstack/react-router-devtools": "^1.141.1",
    "@testing-library/dom": "^10.4.0",
    "@testing-library/react": "^16.2.0",
    "@types/react": "19.2.7",
    "@types/react-dom": "19.2.3",
    "@vitejs/plugin-react": "^5.0.4",
    "jsdom": "^26.0.0",
    "vite": "^7.0.2",
    "web-vitals": "^5.0.3"
  }
}
`],
  ["frontend/react/tanstack-start/tsconfig.json.hbs", `{
  "include": ["**/*.ts", "**/*.tsx"],
  "compilerOptions": {
    "target": "ES2022",
    "jsx": "react-jsx",
    "module": "ESNext",
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "types": ["vite/client"],

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "noEmit": true,

    /* Linting */
    "skipLibCheck": true,
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  }
}
`],
  ["frontend/react/tanstack-start/vite.config.ts.hbs", `import { defineConfig } from "vite";
import tsconfigPaths from "vite-tsconfig-paths";
import { tanstackStart } from "@tanstack/react-start/plugin/vite";
import tailwindcss from "@tailwindcss/vite";
import viteReact from "@vitejs/plugin-react";

export default defineConfig({
  plugins: [
    tsconfigPaths(),
    tailwindcss(),
    tanstackStart(),
    viteReact(),
  ],
  server: {
    port: 3001,
  },
{{#if (and (eq backend "convex") (eq auth "better-auth"))}}
  ssr: {
    noExternal: ["@convex-dev/better-auth"],
  },
{{/if}}
});
`],
  ["backend/server/encore/package.json.hbs", `{
	"name": "server",
	"main": "src/index.ts",
	"type": "module",
	"scripts": {
		"dev": "encore run",
		"build": "encore build",
		"check-types": "tsc -b",
		"test": "encore test"
	},
	"dependencies": {},
	"devDependencies": {}
}
`],
  ["backend/server/encore/encore.app.hbs", `{
	"id": "{{projectName}}-server"
}
`],
  ["backend/server/encore/encore.service.ts.hbs", `import { Service } from "encore.dev/service";

export default new Service("api");
`],
  ["backend/server/encore/tsconfig.json.hbs", `{
	"compilerOptions": {
		"target": "ESNext",
		"module": "ESNext",
		"moduleResolution": "bundler",
		"strict": true,
		"esModuleInterop": true,
		"skipLibCheck": true,
		"forceConsistentCasingInFileNames": true,
		"resolveJsonModule": true,
		"declaration": true,
		"declarationMap": true,
		"noEmit": true,
		"paths": {
			"~encore/*": ["./encore.gen/*"]
		}
	},
	"include": ["**/*.ts"],
	"exclude": ["node_modules"]
}
`],
  ["backend/server/encore/_gitignore", `# Encore.ts generated files
encore.gen/
.encore/

# Dependencies
node_modules/

# Build outputs
dist/

# Environment files
.env
.env.local
.env.*.local

# IDE
.vscode/
.idea/
*.swp
*.swo
`],
  ["backend/server/base/tsdown.config.ts.hbs", `import { defineConfig } from 'tsdown';

export default defineConfig({
    entry: './src/index.ts',
    format: 'esm',
    outDir: './dist',
    clean: true,
    noExternal: [/@{{projectName}}\\/.*/]
});
`],
  ["backend/server/base/package.json.hbs", `{
	"name": "server",
	"main": "src/index.ts",
	"type": "module",
	"scripts": {
		"build": "tsdown",
		"check-types": "tsc -b",
		"compile": "bun build --compile --minify --sourcemap --bytecode ./src/index.ts --outfile server"
	},
	"dependencies": {},
	{{#if (eq dbSetup 'supabase')}}
	"trustedDependencies": [
        "supabase"
    ],
    {{/if}}
	"devDependencies": {}
}
`],
  ["backend/server/base/tsconfig.json.hbs", `{
  "extends": "@{{projectName}}/config/tsconfig.base.json",
  "compilerOptions": {
    "composite": true,
		"outDir": "dist",
		"baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    },
    "jsx": "react-jsx"{{#if (eq backend "hono")}},
    "jsxImportSource": "hono/jsx"{{/if}}
  }
}
`],
  ["backend/server/base/_gitignore", `# prod
dist/
/build
/out/

# dev
.yarn/
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions
.vscode/*
!.vscode/launch.json
!.vscode/*.code-snippets
.idea/workspace.xml
.idea/usage.statistics.xml
.idea/shelf
.wrangler
.alchemy
/.next/
.vercel
prisma/generated/


# deps
node_modules/
/node_modules
/.pnp
.pnp.*

# env
.env*
.env.production
!.env.example
.dev.vars

# logs
logs/
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

# misc
.DS_Store
*.pem

# local db
*.db*

# typescript
*.tsbuildinfo
next-env.d.ts
`],
  ["backend/server/adonisjs/package.json.hbs", `{
	"name": "server",
	"main": "bin/server.js",
	"type": "module",
	"scripts": {
		"dev": "node ace serve --watch",
		"build": "node ace build",
		"start": "node bin/server.js",
		"check-types": "tsc -b",
		"test": "node ace test"
	},
	"dependencies": {},
	"devDependencies": {}
}
`],
  ["backend/server/adonisjs/adonisrc.ts.hbs", `import { defineConfig } from "@adonisjs/core/app";

export default defineConfig({
	commands: [],
	providers: [
		() => import("@adonisjs/core/providers/app_provider"),
		() => import("@adonisjs/core/providers/hash_provider"),
		{
			file: () => import("@adonisjs/core/providers/repl_provider"),
			environment: ["repl", "test"],
		},
	],
	preloads: [() => import("#start/routes")],
	directories: {
		config: "config",
		start: "start",
		tmp: "tmp",
	},
	metaFiles: [
		{
			pattern: "public/**",
			reloadServer: false,
		},
	],
});
`],
  ["backend/server/adonisjs/tsconfig.json.hbs", `{
	"extends": "@adonisjs/tsconfig/tsconfig.app.json",
	"compilerOptions": {
		"outDir": "./build",
		"rootDir": ".",
		"paths": {
			"#controllers/*": ["./app/controllers/*.js"],
			"#middleware/*": ["./app/middleware/*.js"],
			"#start/*": ["./start/*.js"],
			"#config/*": ["./config/*.js"]
		}
	},
	"include": ["**/*.ts"],
	"exclude": ["node_modules", "build"]
}
`],
  ["backend/server/adonisjs/_gitignore", `build
tmp
node_modules
.env
`],
  ["backend/server/nitro/package.json.hbs", `{
	"name": "server",
	"type": "module",
	"scripts": {
		"dev": "nitro dev",
		"build": "nitro build",
		"start": "node .output/server/index.mjs",
		"check-types": "tsc --noEmit"
	},
	"dependencies": {},
	"devDependencies": {}
}
`],
  ["backend/server/nitro/nitro.config.ts.hbs", `import { defineNitroConfig } from "nitropack/config";

export default defineNitroConfig({
	// Server configuration
	compatibilityDate: "2025-01-01",
{{#if (eq runtime "node")}}
	preset: "node-server",
{{/if}}
{{#if (eq runtime "bun")}}
	preset: "bun",
{{/if}}
{{#if (eq runtime "workers")}}
	preset: "cloudflare-module",
{{/if}}
	// Enable source maps for debugging
	sourcemap: true,
	// Route rules
	routeRules: {
		"/**": {
			cors: true,
			headers: {
				"Access-Control-Allow-Origin": "*",
				"Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, OPTIONS",
{{#if (eq auth "better-auth")}}
				"Access-Control-Allow-Headers": "Content-Type, Authorization",
				"Access-Control-Allow-Credentials": "true",
{{else}}
				"Access-Control-Allow-Headers": "Content-Type",
{{/if}}
			},
		},
	},
});
`],
  ["backend/server/nitro/tsconfig.json.hbs", `{
	"compilerOptions": {
		"target": "ESNext",
		"module": "ESNext",
		"moduleResolution": "bundler",
		"strict": true,
		"skipLibCheck": true,
		"esModuleInterop": true,
		"resolveJsonModule": true,
		"isolatedModules": true,
		"noEmit": true,
		"types": ["nitropack"]
	},
	"include": ["**/*.ts", "nitro.config.ts"],
	"exclude": ["node_modules", ".output", ".nitro"]
}
`],
  ["backend/server/nitro/_gitignore", `# Nitro output
.output
.nitro

# Dependencies
node_modules

# Environment
.env
.env.local
.env.*.local

# IDE
.idea
.vscode

# OS
.DS_Store
Thumbs.db
`],
  ["api/garph/server/package.json.hbs", `{
  "name": "@{{projectName}}/api",
  "exports": {
    ".": {
      "default": "./src/index.ts"
    },
    "./*": {
      "default": "./src/*.ts"
    }
  },
  "type": "module",
  "scripts": {},
  "devDependencies": {}
}
`],
  ["api/garph/server/tsconfig.json.hbs", `{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "./dist",
    "rootDir": "./src"
  },
  "include": ["src/**/*"]
}
`],
  ["api/garph/server/_gitignore", `dist
node_modules
`],
  ["api/orpc/server/package.json.hbs", `{
  "name": "@{{projectName}}/api",
  "exports": {
    ".": {
      "default": "./src/index.ts"
    },
    "./*": {
      "default": "./src/*.ts"
    }
  },
  "type": "module",
  "scripts": {},
  "devDependencies": {},
  "dependencies": {}
}`],
  ["api/orpc/server/tsconfig.json.hbs", `{
  "extends": "@{{projectName}}/config/tsconfig.base.json",
  "compilerOptions": {
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "outDir": "dist",
    "composite": true
  }
}`],
  ["api/orpc/server/_gitignore", `# dependencies (bun install)
node_modules

# output
out
dist
*.tgz

# code coverage
coverage
*.lcov

# logs
logs
_.log
report.[0-9]_.[0-9]_.[0-9]_.[0-9]_.json

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# caches
.eslintcache
.cache
*.tsbuildinfo

# IntelliJ based IDEs
.idea

# Finder (MacOS) folder config
.DS_Store
`],
  ["api/ts-rest/server/package.json.hbs", `{
  "name": "@{{projectName}}/api",
  "exports": {
    ".": {
      "default": "./src/index.ts"
    },
    "./*": {
      "default": "./src/*.ts"
    }
  },
  "type": "module",
  "scripts": {},
  "devDependencies": {}
}
`],
  ["api/ts-rest/server/tsconfig.json.hbs", `{
  "extends": "../../tooling/typescript/base.json",
  "compilerOptions": {
    "outDir": "./dist",
    "rootDir": "./src"
  },
  "include": ["src/**/*.ts"]
}
`],
  ["api/ts-rest/server/_gitignore", `dist
`],
  ["api/trpc/server/package.json.hbs", `{
  "name": "@{{projectName}}/api",
  "exports": {
    ".": {
      "default": "./src/index.ts"
    },
    "./*": {
      "default": "./src/*.ts"
    }
  },
  "type": "module",
  "scripts": {},
  "devDependencies": {}
}`],
  ["api/trpc/server/tsconfig.json.hbs", `{
  "extends": "@{{projectName}}/config/tsconfig.base.json",
  "compilerOptions": {
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "outDir": "dist",
    "composite": true
  }
}`],
  ["api/trpc/server/_gitignore", `# dependencies (bun install)
node_modules

# output
out
dist
*.tgz

# code coverage
coverage
*.lcov

# logs
logs
_.log
report.[0-9]_.[0-9]_.[0-9]_.[0-9]_.json

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# caches
.eslintcache
.cache
*.tsbuildinfo

# IntelliJ based IDEs
.idea

# Finder (MacOS) folder config
.DS_Store
`],
  ["db-setup/docker-compose/mysql/docker-compose.yml.hbs", `name: {{projectName}}

services:
  mysql:
    image: mysql
    container_name: {{projectName}}-mysql
    environment:
      MYSQL_ROOT_PASSWORD: password
      MYSQL_DATABASE: {{projectName}}
      MYSQL_USER: user
      MYSQL_PASSWORD: password
    ports:
      - "3306:3306"
    volumes:
      - {{projectName}}_mysql_data:/var/lib/mysql
    healthcheck:
      test: ["CMD", "mysqladmin", "ping", "-h", "localhost"]
      interval: 10s
      timeout: 5s
      retries: 5
    restart: unless-stopped

volumes:
  {{projectName}}_mysql_data:`],
  ["db-setup/docker-compose/postgres/docker-compose.yml.hbs", `name: {{projectName}}

services:
  postgres:
    image: postgres
    container_name: {{projectName}}-postgres
    environment:
      POSTGRES_DB: {{projectName}}
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: password
    ports:
      - "5432:5432"
    volumes:
      - {{projectName}}_postgres_data:/var/lib/postgresql
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 10s
      timeout: 5s
      retries: 5
    restart: unless-stopped

volumes:
  {{projectName}}_postgres_data:`],
  ["db-setup/docker-compose/mongodb/docker-compose.yml.hbs", `name: {{projectName}}

services:
  mongodb:
    image: mongo
    container_name: {{projectName}}-mongodb
    environment:
      MONGO_INITDB_ROOT_USERNAME: root
      MONGO_INITDB_ROOT_PASSWORD: password
      MONGO_INITDB_DATABASE: {{projectName}}
    ports:
      - "27017:27017"
    volumes:
      - {{projectName}}_mongodb_data:/data/db
    healthcheck:
      test: ["CMD", "mongosh", "--eval", "db.adminCommand('ping')"]
      interval: 10s
      timeout: 5s
      retries: 5
    restart: unless-stopped

volumes:
  {{projectName}}_mongodb_data:`],
  ["db/prisma/postgres/prisma.config.ts.hbs", `import path from "node:path";
import { defineConfig, env } from 'prisma/config'
import dotenv from 'dotenv'

dotenv.config({
    {{#if (eq backend "self")}}
    path: "../../apps/web/.env",
    {{else}}
    path: "../../apps/server/.env",
    {{/if}}
})

export default defineConfig({
  schema: path.join("prisma", "schema"),
  migrations: {
    path: path.join("prisma", "migrations"),
    },
    datasource: {
        url: env('DATABASE_URL'),
    },
})
`],
  ["db/prisma/sqlite/prisma.config.ts.hbs", `import path from "node:path";
import { defineConfig, env } from "prisma/config";
import dotenv from "dotenv";

dotenv.config({
  {{#if (eq backend "self")}}
  path: "../../apps/web/.env",
  {{else}}
  path: "../../apps/server/.env",
  {{/if}}
});

export default defineConfig({
  schema: path.join("prisma", "schema"),
  migrations: {
    path: path.join("prisma", "migrations"),
  },
  datasource: {
    {{#if (eq dbSetup "turso")}}
    url: "file:./dev.db",
    {{else}}
    url: env("DATABASE_URL"),
    {{/if}}
  },
});`],
  ["db/prisma/mysql/prisma.config.ts.hbs", `import path from "node:path";
import { defineConfig, env } from "prisma/config";
import dotenv from "dotenv";

dotenv.config({
  {{#if (eq backend "self")}}
  path: "../../apps/web/.env",
  {{else}}
  path: "../../apps/server/.env",
  {{/if}}
});

export default defineConfig({
  schema: path.join("prisma", "schema"),
  migrations: {
    path: path.join("prisma", "migrations"),
  },
  datasource: {
    url: env("DATABASE_URL"),
  },
});`],
  ["db/prisma/mongodb/prisma.config.ts.hbs", `import path from "node:path";
import type { PrismaConfig } from "prisma";
import dotenv from "dotenv";

dotenv.config({
    {{#if (eq backend "self")}}
    path: "../../apps/web/.env",
    {{else}}
    path: "../../apps/server/.env",
    {{/if}}
});

export default {
  schema: path.join("prisma", "schema"),
  migrations: {
    path: path.join("prisma", "migrations"),
  }
} satisfies PrismaConfig;
`],
  ["addons/ruler/.ruler/ruler.toml.hbs", `# Ruler Configuration File
# See https://okigu.com/ruler for documentation.

# Default agents to run when --agents is not specified
default_agents = []

# --- Global MCP Server Configuration ---
[mcp]
# Enable/disable MCP propagation globally (default: true)
enabled = true
# Global merge strategy: 'merge' or 'overwrite' (default: 'merge')
merge_strategy = "merge"

# --- MCP Server Definitions ---
[mcp_servers.context7]
command = "npx"
args = ["-y", "@upstash/context7-mcp"]

{{#if (or (eq runtime "workers") (eq webDeploy "wrangler"))}}
[mcp_servers.cloudflare]
command = "npx"
args = ["mcp-remote", "https://docs.mcp.cloudflare.com/sse"]
{{/if}}

{{#if (eq backend "convex")}}
[mcp_servers.convex]
command = "npx"
args = ["-y", "convex@latest", "mcp", "start"]
{{/if}}

{{#if (or (includes frontend "tanstack-router") (includes frontend "react-router") (includes frontend "tanstack-start") (includes frontend "next"))}}
[mcp_servers.shadcn]
command = "npx"
args = ["shadcn@latest", "mcp"]
{{/if}}

{{#if (eq dbSetup "planetscale")}}
[mcp_servers.planetscale]
command = "pscale"
args = ["mcp", "server"]
{{/if}}

{{#if (eq dbSetup "prisma-postgres")}}
[mcp_servers.prisma]
command = "npx"
args = ["-y", "prisma", "mcp"]
{{/if}}

{{#if (eq dbSetup "neon")}}
[mcp_servers.neon]
command = "npx"
args = ["-y", "mcp-remote@latest", "https://mcp.neon.tech/mcp"]
{{/if}}

{{#if (eq dbSetup "mongodb-atlas")}}
[mcp_servers.mongodb]
command = "npx"
args = ["-y", "mongodb-mcp-server", "--connectionString", "mongodb://localhost:27017/myDatabase", "--readOnly"]
{{/if}}

{{#if (eq auth "better-auth")}}
[mcp_servers.better-auth]
url = "https://mcp.chonkie.ai/better-auth/better-auth-builder/mcp"
{{/if}}

{{#if (includes frontend "nuxt")}}
[mcp_servers.nuxt-ui]
url = "https://ui.nuxt.com/mcp"
{{/if}}

{{#if (includes frontend "next")}}
[mcp_servers.next-devtools]
command = "npx"
args = ["-y", "next-devtools-mcp@latest"]
{{/if}}

# --- Global .gitignore Configuration ---
[gitignore]
# Enable/disable automatic .gitignore updates (default: true)
enabled = true`],
  ["addons/ruler/.ruler/bts.md.hbs", `# Better Fullstack Project Rules

This is a {{projectName}} project created with Better Fullstack CLI.

## Project Structure

This is a monorepo with the following structure:

{{#if (or (includes frontend "tanstack-router") (includes frontend "react-router") (includes frontend "tanstack-start")
(includes frontend "next") (includes frontend "nuxt") (includes frontend "svelte") (includes frontend "solid"))}}
- **\`apps/web/\`** - {{#if (eq backend "self")}}Fullstack application{{else}}Frontend application{{/if}}{{#if (includes frontend "tanstack-router")}} (React with TanStack Router){{else if (includes frontend "react-router")}} (React with React Router){{else if (includes frontend "tanstack-start")}} (TanStack Start){{else if (includes frontend "next")}} (Next.js){{else if (includes frontend "nuxt")}} (Nuxt.js){{else if (includes frontend "svelte")}} (SvelteKit){{else if (includes frontend "solid")}} (SolidStart){{/if}}
{{/if}}

{{#if (ne backend "convex")}}
{{#if (and (ne backend "none") (ne backend "self"))}}
- **\`apps/server/\`** - Backend server{{#if (eq backend "hono")}} (Hono){{else if (eq backend "express")}} (Express){{else if (eq backend "fastify")}} (Fastify){{else if (eq backend "elysia")}} (Elysia){{/if}}
{{/if}}
{{else}}
- **\`packages/backend/\`** - Convex backend functions
{{/if}}

{{#if (or (includes frontend "native-bare") (includes frontend "native-uniwind") (includes frontend "native-unistyles"))}}
- **\`apps/native/\`** - React Native mobile app{{#if (includes frontend "native-uniwind")}} (with NativeWind){{else if (includes frontend "native-unistyles")}} (with Unistyles){{else if (includes frontend "native-bare")}} (bare styling){{/if}}
{{/if}}

{{#if (ne backend "convex")}}
{{#if (ne api "none")}}
- **\`packages/api/\`** - Shared API logic and types
{{/if}}
{{#if (and (ne auth "none") (ne backend "convex"))}}
- **\`packages/auth/\`** - Authentication logic and utilities
{{/if}}
{{#if (and (ne database "none") (ne orm "none"))}}
- **\`packages/db/\`** - Database schema and utilities
{{/if}}
- **\`packages/env/\`** - Shared environment variables and validation
- **\`packages/config/\`** - Shared TypeScript configuration
{{#if (or (eq webDeploy "cloudflare") (eq serverDeploy "cloudflare"))}}
- **\`packages/infra/\`** - Infrastructure as code (Alchemy for Cloudflare)
{{/if}}
{{/if}}

## Available Scripts

- \`{{packageManager}} run dev\` - Start all apps in development mode
{{#if (and (or (includes frontend "tanstack-router") (includes frontend "react-router") (includes frontend "tanstack-start")
(includes frontend "next") (includes frontend "nuxt") (includes frontend "svelte") (includes frontend "solid")) (ne backend "self"))}}
- \`{{packageManager}} run dev:web\` - Start only the web app
{{/if}}
{{#if (and (ne backend "none") (ne backend "convex") (ne backend "self"))}}
- \`{{packageManager}} run dev:server\` - Start only the server
{{/if}}
{{#if (or (includes frontend "native-bare") (includes frontend "native-uniwind") (includes frontend "native-unistyles"))}}
- \`{{packageManager}} run dev:native\` - Start only the native app
{{/if}}
- \`{{packageManager}} run build\` - Build all apps
- \`{{packageManager}} run lint\` - Lint all packages
- \`{{packageManager}} run typecheck\` - Type check all packages

{{#if (and (ne database "none") (ne orm "none") (ne backend "convex"))}}
## Database Commands

All database operations should be run from the {{#if (eq backend "self")}}web{{else}}server{{/if}} workspace:

- \`{{packageManager}} run db:push\` - Push schema changes to database
- \`{{packageManager}} run db:studio\` - Open database studio
- \`{{packageManager}} run db:generate\` - Generate {{#if (eq orm "drizzle")}}Drizzle{{else if (eq orm "prisma")}}Prisma{{else}}{{orm}}{{/if}} files
- \`{{packageManager}} run db:migrate\` - Run database migrations

{{#if (eq orm "drizzle")}}
Database schema files are located in {{#if (eq backend "self")}}\`apps/web/src/db/schema/\`{{else}}\`packages/db/src/schema/\`{{/if}}
{{else if (eq orm "prisma")}}
Database schema is located in {{#if (eq backend "self")}}\`apps/web/prisma/schema.prisma\`{{else}}\`packages/db/prisma/schema.prisma\`{{/if}}
{{else if (eq orm "mongoose")}}
Database models are located in {{#if (eq backend "self")}}\`apps/web/src/db/models/\`{{else}}\`packages/db/src/models/\`{{/if}}
{{/if}}
{{/if}}

{{#if (ne api "none")}}
## API Structure

{{#if (eq api "trpc")}}
- tRPC routers are in \`packages/api/src/routers/\`
- Client-side tRPC utils are in \`apps/web/src/utils/trpc.ts\`
{{else if (eq api "orpc")}}
- oRPC contracts and routers are in \`packages/api/src/\`
- Client-side oRPC client is in \`apps/web/src/utils/orpc.ts\`
{{/if}}
{{/if}}

{{#if (eq auth "better-auth")}}
## Authentication

Authentication is powered by Better Auth:
- Auth configuration is in \`packages/auth/src/\`
{{#if (or (includes frontend "tanstack-router") (includes frontend "react-router") (includes frontend "tanstack-start")
(includes frontend "next") (includes frontend "nuxt") (includes frontend "svelte") (includes frontend "solid"))}}
- Web app auth client is in \`apps/web/src/lib/auth-client.ts\`
{{/if}}
{{#if (or (includes frontend "native-bare") (includes frontend "native-uniwind") (includes frontend "native-unistyles"))}}
- Native app auth client is in \`apps/native/src/lib/auth-client.ts\`
{{/if}}
{{/if}}

## Project Configuration

This project includes a \`bts.jsonc\` configuration file that stores your Better Fullstack settings:

- Contains your selected stack configuration (database, ORM, backend, frontend, etc.)
- Used by the CLI to understand your project structure
- Safe to delete if not needed

## Key Points

- This is a {{#if (includes addons "turborepo")}}Turborepo {{/if}}monorepo using {{packageManager}} workspaces
- Each app has its own \`package.json\` and dependencies
- Run commands from the root to execute across all workspaces
- Run workspace-specific commands with \`{{packageManager}} run command-name\`
{{#if (includes addons "turborepo")}}
- Turborepo handles build caching and parallel execution
{{/if}}
{{#if (or (includes addons "husky") (includes addons "lefthook"))}}
- Git hooks are configured with {{#if (includes addons "husky")}}Husky{{else}}Lefthook{{/if}} for pre-commit checks
{{/if}}
`],
  ["addons/husky/.husky/pre-commit", `lint-staged
`],
  ["db/drizzle/mysql/drizzle.config.ts.hbs", `import { defineConfig } from "drizzle-kit";
import dotenv from "dotenv";

dotenv.config({
    {{#if (eq backend "self")}}
    path: "../../apps/web/.env",
    {{else}}
    path: "../../apps/server/.env",
    {{/if}}
});

export default defineConfig({
  schema: "./src/schema",
  out: "./src/migrations",
  dialect: "mysql",
  dbCredentials: {
    url: process.env.DATABASE_URL || "",
  },
});
`],
  ["db/drizzle/sqlite/drizzle.config.ts.hbs", `import { defineConfig } from "drizzle-kit";
import dotenv from "dotenv";

dotenv.config({
    {{#if (eq backend "self")}}
    path: "../../apps/web/.env",
    {{else}}
    path: "../../apps/server/.env",
    {{/if}}
});

export default defineConfig({
  schema: "./src/schema",
  out: "./src/migrations",
  {{#if (eq dbSetup "d1")}}
  // DOCS: https://orm.drizzle.team/docs/guides/d1-http-with-drizzle-kit
  dialect: "sqlite",
  driver: "d1-http",
  {{else}}
  dialect: "turso",
  dbCredentials: {
    url: process.env.DATABASE_URL || "",
    {{#if (eq dbSetup "turso")}}
    authToken: process.env.DATABASE_AUTH_TOKEN,
    {{/if}}
  },
  {{/if}}
});
`],
  ["db/drizzle/postgres/drizzle.config.ts.hbs", `import { defineConfig } from "drizzle-kit";
import dotenv from "dotenv";

dotenv.config({
    {{#if (eq backend "self")}}
    path: "../../apps/web/.env",
    {{else}}
    path: "../../apps/server/.env",
    {{/if}}
});

export default defineConfig({
  schema: "./src/schema",
  out: "./src/migrations",
  dialect: "postgresql",
  dbCredentials: {
    url: process.env.DATABASE_URL || "",
  },
});
`],
  ["cms/sanity/web/next/sanity.cli.ts.hbs", `import { defineCliConfig } from "sanity/cli";

const projectId = process.env.NEXT_PUBLIC_SANITY_PROJECT_ID!;
const dataset = process.env.NEXT_PUBLIC_SANITY_DATASET!;

export default defineCliConfig({
  api: {
    projectId,
    dataset,
  },
});
`],
  ["cms/sanity/web/next/sanity.config.ts.hbs", `"use client";

import { defineConfig } from "sanity";
import { structureTool } from "sanity/structure";
import { visionTool } from "@sanity/vision";

import { schemaTypes } from "./src/sanity/schemas";

const projectId = process.env.NEXT_PUBLIC_SANITY_PROJECT_ID!;
const dataset = process.env.NEXT_PUBLIC_SANITY_DATASET!;

export default defineConfig({
  name: "{{projectName}}",
  title: "{{projectName}}",

  projectId,
  dataset,

  basePath: "/studio",

  plugins: [structureTool(), visionTool()],

  schema: {
    types: schemaTypes,
  },
});
`],
  ["rust-base/crates/client/style/main.css", `/* Leptos Application Styles */

:root {
  --bg-color: #1a1a2e;
  --text-color: #eaeaea;
  --primary-color: #e94560;
  --secondary-color: #16213e;
  --accent-color: #0f3460;
}

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family:
    -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans",
    "Helvetica Neue", sans-serif;
  background-color: var(--bg-color);
  color: var(--text-color);
  min-height: 100vh;
  display: flex;
  justify-content: center;
  align-items: center;
}

.container {
  max-width: 800px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

h1 {
  font-size: 2.5rem;
  margin-bottom: 1rem;
  color: var(--primary-color);
}

h2 {
  font-size: 1.5rem;
  margin: 1.5rem 0 1rem;
  color: var(--text-color);
}

p {
  font-size: 1.1rem;
  line-height: 1.6;
  margin-bottom: 1rem;
  opacity: 0.9;
}

.home,
.about {
  background: var(--secondary-color);
  border-radius: 12px;
  padding: 2rem;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
}

.counter {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 1rem;
  margin: 2rem 0;
}

.count {
  font-size: 2rem;
  font-weight: bold;
  min-width: 4rem;
  padding: 0.5rem 1rem;
  background: var(--accent-color);
  border-radius: 8px;
}

.btn {
  font-size: 1.5rem;
  padding: 0.5rem 1.5rem;
  background: var(--primary-color);
  color: white;
  border: none;
  border-radius: 8px;
  cursor: pointer;
  transition:
    transform 0.1s,
    background 0.2s;
}

.btn:hover {
  background: #ff6b6b;
}

.btn:active {
  transform: scale(0.95);
}

nav {
  margin-top: 2rem;
}

nav a {
  color: var(--primary-color);
  text-decoration: none;
  font-weight: 500;
  padding: 0.5rem 1rem;
  border: 2px solid var(--primary-color);
  border-radius: 6px;
  transition: all 0.2s;
}

nav a:hover {
  background: var(--primary-color);
  color: white;
}

ul {
  list-style: none;
  text-align: left;
  max-width: 400px;
  margin: 0 auto;
}

ul li {
  padding: 0.5rem 0;
  padding-left: 1.5rem;
  position: relative;
}

ul li::before {
  content: "\\2713";
  position: absolute;
  left: 0;
  color: var(--primary-color);
}
`],
  ["rust-base/crates/client/src/lib.rs.hbs", `use leptos::prelude::*;
use leptos_meta::*;
use leptos_router::components::*;
use leptos_router::path;

/// Main application component
#[component]
pub fn App() -> impl IntoView {
    // Provides context for managing document head metadata
    provide_meta_context();

    view! {
        <Stylesheet id="leptos" href="/pkg/{{projectName}}_client.css"/>
        <Title text="{{projectName}} - Built with Leptos"/>
        <Meta name="description" content="A Rust WASM application built with Leptos"/>

        <Router>
            <main class="container">
                <Routes fallback=|| "Page not found.".into_view()>
                    <Route path=path!("/") view=HomePage/>
                    <Route path=path!("/about") view=AboutPage/>
                </Routes>
            </main>
        </Router>
    }
}

/// Home page component
#[component]
fn HomePage() -> impl IntoView {
    let (count, set_count) = signal(0);

    view! {
        <div class="home">
            <h1>"Welcome to {{projectName}}"</h1>
            <p>"A full-stack Rust application powered by Leptos"</p>

            <div class="counter">
                <button
                    class="btn"
                    on:click=move |_| set_count.update(|n| *n -= 1)
                >
                    "-"
                </button>
                <span class="count">{count}</span>
                <button
                    class="btn"
                    on:click=move |_| set_count.update(|n| *n += 1)
                >
                    "+"
                </button>
            </div>

            <nav>
                <a href="/about">"About"</a>
            </nav>
        </div>
    }
}

/// About page component
#[component]
fn AboutPage() -> impl IntoView {
    view! {
        <div class="about">
            <h1>"About"</h1>
            <p>"This application was generated with Better-Fullstack using the Leptos framework."</p>

            <h2>"Technology Stack"</h2>
            <ul>
                <li>"Leptos - Fine-grained reactive framework"</li>
                <li>"Rust + WebAssembly - High-performance frontend"</li>
{{#if (eq rustWebFramework "axum")}}
                <li>"Axum - Ergonomic web framework by Tokio team"</li>
{{/if}}
{{#if (eq rustWebFramework "actix-web")}}
                <li>"Actix-web - Powerful, pragmatic web framework"</li>
{{/if}}
            </ul>

            <nav>
                <a href="/">"Back to Home"</a>
            </nav>
        </div>
    }
}

/// Initialize the Leptos client-side app
#[wasm_bindgen::prelude::wasm_bindgen(start)]
pub fn main() {
    // Set up better panic messages in console
    console_error_panic_hook::set_once();

    // Initialize logging
    _ = console_log::init_with_level(log::Level::Debug);

    log::info!("Starting Leptos client application");

    leptos::mount::mount_to_body(App);
}
`],
  ["rust-base/crates/dioxus-client/assets/main.css", `/* Dioxus Application Styles */

:root {
  --bg-color: #1a1a2e;
  --text-color: #eaeaea;
  --primary-color: #00b4d8;
  --secondary-color: #16213e;
  --accent-color: #0f3460;
}

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family:
    -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans",
    "Helvetica Neue", sans-serif;
  background-color: var(--bg-color);
  color: var(--text-color);
  min-height: 100vh;
  display: flex;
  justify-content: center;
  align-items: center;
}

.container {
  max-width: 800px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

h1 {
  font-size: 2.5rem;
  margin-bottom: 1rem;
  color: var(--primary-color);
}

h2 {
  font-size: 1.5rem;
  margin: 1.5rem 0 1rem;
  color: var(--text-color);
}

p {
  font-size: 1.1rem;
  line-height: 1.6;
  margin-bottom: 1rem;
  opacity: 0.9;
}

.home,
.about {
  background: var(--secondary-color);
  border-radius: 12px;
  padding: 2rem;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
}

.counter {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 1rem;
  margin: 2rem 0;
}

.count {
  font-size: 2rem;
  font-weight: bold;
  min-width: 4rem;
  padding: 0.5rem 1rem;
  background: var(--accent-color);
  border-radius: 8px;
}

.btn {
  font-size: 1.5rem;
  padding: 0.5rem 1.5rem;
  background: var(--primary-color);
  color: white;
  border: none;
  border-radius: 8px;
  cursor: pointer;
  transition:
    transform 0.1s,
    background 0.2s;
}

.btn:hover {
  background: #48cae4;
}

.btn:active {
  transform: scale(0.95);
}

nav {
  margin-top: 2rem;
}

nav a {
  color: var(--primary-color);
  text-decoration: none;
  font-weight: 500;
  padding: 0.5rem 1rem;
  border: 2px solid var(--primary-color);
  border-radius: 6px;
  transition: all 0.2s;
}

nav a:hover {
  background: var(--primary-color);
  color: white;
}

ul {
  list-style: none;
  text-align: left;
  max-width: 400px;
  margin: 0 auto;
}

ul li {
  padding: 0.5rem 0;
  padding-left: 1.5rem;
  position: relative;
}

ul li::before {
  content: "\\2713";
  position: absolute;
  left: 0;
  color: var(--primary-color);
}
`],
  ["rust-base/crates/dioxus-client/src/main.rs.hbs", `#![allow(non_snake_case)]

use dioxus::prelude::*;
use dioxus_router::prelude::*;
use tracing::info;

/// Application routes
#[derive(Clone, Routable, Debug, PartialEq)]
enum Route {
    #[route("/")]
    Home {},
    #[route("/about")]
    About {},
}

fn main() {
    // Set up better panic messages in console
    console_error_panic_hook::set_once();

    // Initialize logging
    dioxus_logger::init(tracing::Level::INFO).expect("Failed to init logger");

    info!("Starting Dioxus client application");

    launch(App);
}

/// Main application component
fn App() -> Element {
    rsx! {
        Router::<Route> {}
    }
}

/// Home page component
#[component]
fn Home() -> Element {
    let mut count = use_signal(|| 0);

    rsx! {
        div { class: "container",
            div { class: "home",
                h1 { "Welcome to {{projectName}}" }
                p { "A full-stack Rust application powered by Dioxus" }

                div { class: "counter",
                    button {
                        class: "btn",
                        onclick: move |_| count -= 1,
                        "-"
                    }
                    span { class: "count", "{count}" }
                    button {
                        class: "btn",
                        onclick: move |_| count += 1,
                        "+"
                    }
                }

                nav {
                    Link { to: Route::About {}, "About" }
                }
            }
        }
    }
}

/// About page component
#[component]
fn About() -> Element {
    rsx! {
        div { class: "container",
            div { class: "about",
                h1 { "About" }
                p { "This application was generated with Better-Fullstack using the Dioxus framework." }

                h2 { "Technology Stack" }
                ul {
                    li { "Dioxus - React-like reactive framework" }
                    li { "Rust + WebAssembly - High-performance frontend" }
{{#if (eq rustWebFramework "axum")}}
                    li { "Axum - Ergonomic web framework by Tokio team" }
{{/if}}
{{#if (eq rustWebFramework "actix-web")}}
                    li { "Actix-web - Powerful, pragmatic web framework" }
{{/if}}
                }

                nav {
                    Link { to: Route::Home {}, "Back to Home" }
                }
            }
        }
    }
}
`],
  ["rust-base/crates/cli/src/main.rs.hbs", `use anyhow::Result;
use clap::{Parser, Subcommand};
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};

/// {{projectName}} CLI - Command-line interface
#[derive(Parser, Debug)]
#[command(name = "{{projectName}}")]
#[command(author, version, about, long_about = None)]
struct Cli {
    /// Turn on verbose output
    #[arg(short, long, global = true)]
    verbose: bool,

    /// Config file path
    #[arg(short, long, global = true)]
    config: Option<String>,

    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand, Debug)]
enum Commands {
    /// Start the application
    Start {
        /// Port to listen on
        #[arg(short, long, default_value = "3000")]
        port: u16,

        /// Host to bind to
        #[arg(short = 'H', long, default_value = "127.0.0.1")]
        host: String,
    },

    /// Check configuration and health
    Check {
        /// Check database connection
        #[arg(long)]
        database: bool,

        /// Check all services
        #[arg(long)]
        all: bool,
    },

    /// Run database migrations
    Migrate {
        /// Run pending migrations
        #[arg(long)]
        up: bool,

        /// Rollback last migration
        #[arg(long)]
        down: bool,

        /// Migration status
        #[arg(long)]
        status: bool,
    },

    /// Generate project components
    Generate {
        /// Component type to generate
        #[arg(value_enum)]
        component: GenerateComponent,

        /// Name for the generated component
        name: String,
    },
}

#[derive(clap::ValueEnum, Clone, Debug)]
enum GenerateComponent {
    /// Generate a new model
    Model,
    /// Generate a new handler/controller
    Handler,
    /// Generate a new service
    Service,
    /// Generate a new migration
    Migration,
}

#[tokio::main]
async fn main() -> Result<()> {
    // Load environment variables
    dotenvy::dotenv().ok();

    let cli = Cli::parse();

    // Initialize tracing with verbosity level
    let filter = if cli.verbose { "debug" } else { "info" };
    tracing_subscriber::registry()
        .with(tracing_subscriber::EnvFilter::try_from_default_env().unwrap_or_else(|_| filter.into()))
        .with(tracing_subscriber::fmt::layer())
        .init();

    if let Some(config_path) = &cli.config {
        tracing::info!("Using config file: {}", config_path);
    }

    match cli.command {
        Commands::Start { port, host } => {
            tracing::info!("Starting server on {}:{}", host, port);
            // TODO: Implement server start logic
            // This is where you would start your Axum/Actix server
            println!("Server would start on {}:{}", host, port);
        }

        Commands::Check { database, all } => {
            tracing::info!("Running health checks...");

            if database || all {
                tracing::info!("Checking database connection...");
                // TODO: Implement database check
                println!("Database check: Not implemented");
            }

            if all {
                tracing::info!("Checking all services...");
                // TODO: Implement other service checks
                println!("All checks complete");
            }

            if !database && !all {
                println!("No checks specified. Use --database or --all");
            }
        }

        Commands::Migrate { up, down, status } => {
            if status {
                tracing::info!("Checking migration status...");
                // TODO: Implement migration status check
                println!("Migration status: Not implemented");
            } else if up {
                tracing::info!("Running pending migrations...");
                // TODO: Implement migration up
                println!("Migrations run: Not implemented");
            } else if down {
                tracing::info!("Rolling back last migration...");
                // TODO: Implement migration down
                println!("Migration rollback: Not implemented");
            } else {
                println!("No migration action specified. Use --up, --down, or --status");
            }
        }

        Commands::Generate { component, name } => {
            tracing::info!("Generating {:?}: {}", component, name);
            match component {
                GenerateComponent::Model => {
                    println!("Would generate model: {}", name);
                    // TODO: Implement model generation
                }
                GenerateComponent::Handler => {
                    println!("Would generate handler: {}", name);
                    // TODO: Implement handler generation
                }
                GenerateComponent::Service => {
                    println!("Would generate service: {}", name);
                    // TODO: Implement service generation
                }
                GenerateComponent::Migration => {
                    println!("Would generate migration: {}", name);
                    // TODO: Implement migration generation
                }
            }
        }
    }

    Ok(())
}
`],
  ["rust-base/crates/tui/src/main.rs.hbs", `use std::io;
use std::time::Duration;

use anyhow::Result;
use crossterm::{
    event::{self, DisableMouseCapture, EnableMouseCapture, Event, KeyCode, KeyEventKind},
    execute,
    terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},
};
use ratatui::{
    prelude::*,
    widgets::{Block, Borders, List, ListItem, ListState, Paragraph, Tabs},
};
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};

/// Application state
struct App {
    /// Current tab index
    tab_index: usize,
    /// Menu items for the sidebar
    menu_items: Vec<&'static str>,
    /// Current menu selection state
    menu_state: ListState,
    /// Counter value for demo
    counter: i32,
    /// Status messages
    status: String,
    /// Whether the app should quit
    should_quit: bool,
}

impl Default for App {
    fn default() -> Self {
        let mut menu_state = ListState::default();
        menu_state.select(Some(0));

        Self {
            tab_index: 0,
            menu_items: vec!["Dashboard", "Settings", "Logs", "Help"],
            menu_state,
            counter: 0,
            status: String::from("Ready"),
            should_quit: false,
        }
    }
}

impl App {
    /// Handle key events
    fn handle_key(&mut self, key: KeyCode) {
        match key {
            KeyCode::Char('q') | KeyCode::Esc => {
                self.should_quit = true;
            }
            KeyCode::Tab => {
                self.tab_index = (self.tab_index + 1) % 3;
            }
            KeyCode::BackTab => {
                self.tab_index = if self.tab_index == 0 { 2 } else { self.tab_index - 1 };
            }
            KeyCode::Up | KeyCode::Char('k') => {
                self.menu_previous();
            }
            KeyCode::Down | KeyCode::Char('j') => {
                self.menu_next();
            }
            KeyCode::Enter => {
                if let Some(selected) = self.menu_state.selected() {
                    self.status = format!("Selected: {}", self.menu_items[selected]);
                }
            }
            KeyCode::Char('+') | KeyCode::Char('=') => {
                self.counter += 1;
                self.status = format!("Counter incremented to {}", self.counter);
            }
            KeyCode::Char('-') => {
                self.counter -= 1;
                self.status = format!("Counter decremented to {}", self.counter);
            }
            _ => {}
        }
    }

    /// Select previous menu item
    fn menu_previous(&mut self) {
        let i = match self.menu_state.selected() {
            Some(i) => {
                if i == 0 {
                    self.menu_items.len() - 1
                } else {
                    i - 1
                }
            }
            None => 0,
        };
        self.menu_state.select(Some(i));
    }

    /// Select next menu item
    fn menu_next(&mut self) {
        let i = match self.menu_state.selected() {
            Some(i) => {
                if i >= self.menu_items.len() - 1 {
                    0
                } else {
                    i + 1
                }
            }
            None => 0,
        };
        self.menu_state.select(Some(i));
    }
}

fn main() -> Result<()> {
    // Load environment variables
    dotenvy::dotenv().ok();

    // Initialize tracing to a file (can't use terminal while TUI is running)
    let file_appender = tracing_appender::rolling::daily("logs", "tui.log");
    let (non_blocking, _guard) = tracing_appender::non_blocking(file_appender);
    tracing_subscriber::registry()
        .with(tracing_subscriber::EnvFilter::try_from_default_env().unwrap_or_else(|_| "info".into()))
        .with(tracing_subscriber::fmt::layer().with_writer(non_blocking))
        .init();

    tracing::info!("Starting {{projectName}} TUI");

    // Setup terminal
    enable_raw_mode()?;
    let mut stdout = io::stdout();
    execute!(stdout, EnterAlternateScreen, EnableMouseCapture)?;
    let backend = CrosstermBackend::new(stdout);
    let mut terminal = Terminal::new(backend)?;

    // Create app state
    let mut app = App::default();

    // Main loop
    let result = run_app(&mut terminal, &mut app);

    // Restore terminal
    disable_raw_mode()?;
    execute!(
        terminal.backend_mut(),
        LeaveAlternateScreen,
        DisableMouseCapture
    )?;
    terminal.show_cursor()?;

    if let Err(err) = result {
        tracing::error!("Application error: {:?}", err);
        eprintln!("Error: {:?}", err);
    }

    tracing::info!("{{projectName}} TUI exited");
    Ok(())
}

/// Run the application main loop
fn run_app<B: Backend>(terminal: &mut Terminal<B>, app: &mut App) -> Result<()> {
    loop {
        terminal.draw(|f| ui(f, app))?;

        // Poll for events with a timeout
        if event::poll(Duration::from_millis(100))? {
            if let Event::Key(key) = event::read()? {
                if key.kind == KeyEventKind::Press {
                    app.handle_key(key.code);
                }
            }
        }

        if app.should_quit {
            return Ok(());
        }
    }
}

/// Render the UI
fn ui(f: &mut Frame, app: &mut App) {
    let chunks = Layout::default()
        .direction(Direction::Vertical)
        .constraints([
            Constraint::Length(3), // Tabs
            Constraint::Min(0),    // Main content
            Constraint::Length(3), // Status bar
        ])
        .split(f.area());

    // Render tabs
    let tabs = Tabs::new(vec!["Main", "Stats", "Config"])
        .block(Block::default().borders(Borders::ALL).title(" {{projectName}} TUI "))
        .select(app.tab_index)
        .style(Style::default().fg(Color::White))
        .highlight_style(Style::default().fg(Color::Yellow).bold());
    f.render_widget(tabs, chunks[0]);

    // Render main content area
    let main_chunks = Layout::default()
        .direction(Direction::Horizontal)
        .constraints([Constraint::Percentage(30), Constraint::Percentage(70)])
        .split(chunks[1]);

    // Render sidebar menu
    let menu_items: Vec<ListItem> = app
        .menu_items
        .iter()
        .map(|i| ListItem::new(*i).style(Style::default().fg(Color::White)))
        .collect();
    let menu = List::new(menu_items)
        .block(Block::default().borders(Borders::ALL).title(" Menu "))
        .highlight_style(Style::default().bg(Color::Blue).fg(Color::White).bold())
        .highlight_symbol(" ");
    f.render_stateful_widget(menu, main_chunks[0], &mut app.menu_state);

    // Render content based on selected tab
    let content = match app.tab_index {
        0 => {
            let text = vec![
                Line::from("Welcome to {{projectName}} TUI!"),
                Line::from(""),
                Line::from(format!("Counter: {}", app.counter)),
                Line::from(""),
                Line::from("Keybindings:"),
                Line::from("  Tab / Shift+Tab  - Switch tabs"),
                Line::from("  j/k or /       - Navigate menu"),
                Line::from("  Enter            - Select item"),
                Line::from("  +/-              - Increment/Decrement counter"),
                Line::from("  q or Esc         - Quit"),
            ];
            Paragraph::new(text)
                .block(Block::default().borders(Borders::ALL).title(" Dashboard "))
                .style(Style::default().fg(Color::White))
        }
        1 => {
            let text = vec![
                Line::from("Statistics"),
                Line::from(""),
                Line::from(format!("Current counter value: {}", app.counter)),
                Line::from(format!("Menu items: {}", app.menu_items.len())),
                Line::from(format!(
                    "Selected menu item: {}",
                    app.menu_state
                        .selected()
                        .map(|i| app.menu_items[i])
                        .unwrap_or("None")
                )),
            ];
            Paragraph::new(text)
                .block(Block::default().borders(Borders::ALL).title(" Stats "))
                .style(Style::default().fg(Color::Cyan))
        }
        _ => {
            let text = vec![
                Line::from("Configuration"),
                Line::from(""),
                Line::from("This is where you would configure the application."),
                Line::from(""),
                Line::from("Environment variables:"),
                Line::from(format!("  RUST_LOG: {}", std::env::var("RUST_LOG").unwrap_or_else(|_| "not set".to_string()))),
            ];
            Paragraph::new(text)
                .block(Block::default().borders(Borders::ALL).title(" Config "))
                .style(Style::default().fg(Color::Green))
        }
    };
    f.render_widget(content, main_chunks[1]);

    // Render status bar
    let status = Paragraph::new(app.status.as_str())
        .block(Block::default().borders(Borders::ALL).title(" Status "))
        .style(Style::default().fg(Color::Gray));
    f.render_widget(status, chunks[2]);
}
`],
  ["rust-base/crates/proto/src/lib.rs.hbs", `//! Protocol buffer definitions for {{projectName}}.
//!
//! This crate contains the generated code from protobuf definitions.
//! The generated code is committed to version control to avoid requiring
//! protoc at build time.

/// Generated gRPC service definitions
pub mod greeter {
    include!("generated/greeter.rs");
}

pub use greeter::greeter_server::{Greeter, GreeterServer};
pub use greeter::greeter_client::GreeterClient;
pub use greeter::{HelloRequest, HelloReply};
`],
  ["rust-base/crates/proto/proto/greeter.proto.hbs", `syntax = "proto3";

package greeter;

// The greeting service definition.
service Greeter {
  // Sends a greeting
  rpc SayHello (HelloRequest) returns (HelloReply) {}

  // Sends a streaming greeting
  rpc SayHelloStream (HelloRequest) returns (stream HelloReply) {}
}

// The request message containing the user's name.
message HelloRequest {
  string name = 1;
}

// The response message containing the greeting.
message HelloReply {
  string message = 1;
}
`],
  ["rust-base/crates/server/src/main.rs.hbs", `{{#if (eq rustWebFramework "axum")}}
use axum::{routing::get, Json, Router};
use serde::Serialize;
use tower_http::cors::CorsLayer;
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};
{{#if (eq rustOrm "sea-orm")}}
use sea_orm::{Database, DatabaseConnection};
use std::sync::Arc;
{{/if}}
{{#if (eq rustOrm "sqlx")}}
use sqlx::postgres::PgPoolOptions;
use sqlx::PgPool;
{{/if}}
{{#if (eq rustApi "tonic")}}

mod grpc;
{{/if}}
{{#if (eq rustApi "async-graphql")}}
use async_graphql::http::GraphiQLSource;
use async_graphql_axum::GraphQL;
use axum::{
    response::{Html, IntoResponse},
    routing::post,
};

mod graphql;
{{/if}}

#[derive(Serialize)]
struct HealthResponse {
    status: &'static str,
    message: &'static str,
{{#if (or (eq rustOrm "sea-orm") (eq rustOrm "sqlx"))}}
    database: &'static str,
{{/if}}
}

{{#if (eq rustOrm "sea-orm")}}
#[derive(Clone)]
pub struct AppState {
    pub db: Arc<DatabaseConnection>,
}

async fn health(
    axum::extract::State(state): axum::extract::State<AppState>,
) -> Json<HealthResponse> {
    let db_status = if state.db.ping().await.is_ok() {
        "connected"
    } else {
        "disconnected"
    };
    Json(HealthResponse {
        status: "ok",
        message: "Server is running",
        database: db_status,
    })
}
{{else if (eq rustOrm "sqlx")}}
#[derive(Clone)]
pub struct AppState {
    pub db: PgPool,
}

async fn health(
    axum::extract::State(state): axum::extract::State<AppState>,
) -> Json<HealthResponse> {
    let db_status = if state.db.acquire().await.is_ok() {
        "connected"
    } else {
        "disconnected"
    };
    Json(HealthResponse {
        status: "ok",
        message: "Server is running",
        database: db_status,
    })
}
{{else}}
async fn health() -> Json<HealthResponse> {
    Json(HealthResponse {
        status: "ok",
        message: "Server is running",
    })
}
{{/if}}

{{#if (eq rustApi "async-graphql")}}
/// GraphiQL IDE handler
async fn graphiql() -> impl IntoResponse {
    Html(
        GraphiQLSource::build()
            .endpoint("/graphql")
            .finish(),
    )
}
{{/if}}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // Load environment variables
    dotenvy::dotenv().ok();

    // Initialize tracing
    tracing_subscriber::registry()
        .with(tracing_subscriber::EnvFilter::try_from_default_env().unwrap_or_else(|_| "debug".into()))
        .with(tracing_subscriber::fmt::layer())
        .init();

{{#if (eq rustOrm "sea-orm")}}
    // Initialize database connection
    let database_url = std::env::var("DATABASE_URL")
        .expect("DATABASE_URL must be set");

    tracing::info!("Connecting to database...");
    let db = Database::connect(&database_url).await?;
    tracing::info!("Database connected successfully");

    let state = AppState { db: Arc::new(db) };

{{#if (eq rustApi "async-graphql")}}
    // Build GraphQL schema with database connection
    let schema = graphql::build_schema(state.db.clone());

    // Build router with GraphQL and state
    let app = Router::new()
        .route("/health", get(health))
        .route("/graphql", post(GraphQL::new(schema)))
        .route("/graphiql", get(graphiql))
        .layer(CorsLayer::permissive())
        .with_state(state);

    tracing::info!("GraphQL endpoint: /graphql");
    tracing::info!("GraphiQL IDE: /graphiql");
{{else}}
    // Build router with state
    let app = Router::new()
        .route("/health", get(health))
        .layer(CorsLayer::permissive())
        .with_state(state);
{{/if}}
{{else if (eq rustOrm "sqlx")}}
    // Initialize database connection pool
    let database_url = std::env::var("DATABASE_URL")
        .expect("DATABASE_URL must be set");

    tracing::info!("Connecting to database...");
    let pool = PgPoolOptions::new()
        .max_connections(5)
        .connect(&database_url)
        .await?;
    tracing::info!("Database connected successfully");

    let state = AppState { db: pool.clone() };

{{#if (eq rustApi "async-graphql")}}
    // Build GraphQL schema with database pool
    let schema = graphql::build_schema(pool);

    // Build router with GraphQL and state
    let app = Router::new()
        .route("/health", get(health))
        .route("/graphql", post(GraphQL::new(schema)))
        .route("/graphiql", get(graphiql))
        .layer(CorsLayer::permissive())
        .with_state(state);

    tracing::info!("GraphQL endpoint: /graphql");
    tracing::info!("GraphiQL IDE: /graphiql");
{{else}}
    // Build router with state
    let app = Router::new()
        .route("/health", get(health))
        .layer(CorsLayer::permissive())
        .with_state(state);
{{/if}}
{{else}}
{{#if (eq rustApi "async-graphql")}}
    // Build GraphQL schema
    let schema = graphql::build_schema();

    // Build router with GraphQL
    let app = Router::new()
        .route("/health", get(health))
        .route("/graphql", post(GraphQL::new(schema)))
        .route("/graphiql", get(graphiql))
        .layer(CorsLayer::permissive());

    tracing::info!("GraphQL endpoint: /graphql");
    tracing::info!("GraphiQL IDE: /graphiql");
{{else}}
    // Build router
    let app = Router::new()
        .route("/health", get(health))
        .layer(CorsLayer::permissive());
{{/if}}
{{/if}}

    // Get host and port from environment
    let host = std::env::var("HOST").unwrap_or_else(|_| "127.0.0.1".to_string());
    let port = std::env::var("PORT").unwrap_or_else(|_| "3000".to_string());
    let addr = format!("{}:{}", host, port);

    tracing::info!("Starting HTTP server at http://{}", addr);

{{#if (eq rustApi "tonic")}}
    // Start gRPC server on a separate port
    let grpc_port = std::env::var("GRPC_PORT").unwrap_or_else(|_| "50051".to_string());
    let grpc_addr = format!("{}:{}", host, grpc_port).parse()?;

    tracing::info!("Starting gRPC server at {}", grpc_addr);

    let grpc_server = tonic::transport::Server::builder()
        .add_service(grpc::create_grpc_server())
        .serve(grpc_addr);

    // Start HTTP server
    let listener = tokio::net::TcpListener::bind(&addr).await?;
    let http_server = axum::serve(listener, app);

    // Run both servers concurrently
    tokio::select! {
        result = http_server => {
            if let Err(e) = result {
                tracing::error!("HTTP server error: {}", e);
            }
        }
        result = grpc_server => {
            if let Err(e) = result {
                tracing::error!("gRPC server error: {}", e);
            }
        }
    }
{{else}}
    // Start server
    let listener = tokio::net::TcpListener::bind(&addr).await?;
    axum::serve(listener, app).await?;
{{/if}}

    Ok(())
}
{{else if (eq rustWebFramework "actix-web")}}
use actix_cors::Cors;
use actix_web::{get, web, App, HttpResponse, HttpServer, Responder};
use serde::Serialize;
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};
{{#if (eq rustOrm "sea-orm")}}
use sea_orm::{Database, DatabaseConnection};
use std::sync::Arc;
{{/if}}
{{#if (eq rustOrm "sqlx")}}
use sqlx::postgres::PgPoolOptions;
use sqlx::PgPool;
{{/if}}
{{#if (eq rustApi "tonic")}}

mod grpc;
{{/if}}
{{#if (eq rustApi "async-graphql")}}
use async_graphql::http::GraphiQLSource;
use async_graphql_actix_web::{GraphQLRequest, GraphQLResponse};

mod graphql;
{{/if}}

#[derive(Serialize)]
struct HealthResponse {
    status: &'static str,
    message: &'static str,
{{#if (or (eq rustOrm "sea-orm") (eq rustOrm "sqlx"))}}
    database: &'static str,
{{/if}}
}

{{#if (eq rustOrm "sea-orm")}}
pub struct AppState {
    pub db: Arc<DatabaseConnection>,
}

#[get("/health")]
async fn health(data: web::Data<AppState>) -> impl Responder {
    let db_status = if data.db.ping().await.is_ok() {
        "connected"
    } else {
        "disconnected"
    };
    HttpResponse::Ok().json(HealthResponse {
        status: "ok",
        message: "Server is running",
        database: db_status,
    })
}
{{else if (eq rustOrm "sqlx")}}
pub struct AppState {
    pub db: PgPool,
}

#[get("/health")]
async fn health(data: web::Data<AppState>) -> impl Responder {
    let db_status = if data.db.acquire().await.is_ok() {
        "connected"
    } else {
        "disconnected"
    };
    HttpResponse::Ok().json(HealthResponse {
        status: "ok",
        message: "Server is running",
        database: db_status,
    })
}
{{else}}
#[get("/health")]
async fn health() -> impl Responder {
    HttpResponse::Ok().json(HealthResponse {
        status: "ok",
        message: "Server is running",
    })
}
{{/if}}

{{#if (eq rustApi "async-graphql")}}
/// GraphQL endpoint handler
async fn graphql_handler(
    schema: web::Data<graphql::GraphQLSchema>,
    req: GraphQLRequest,
) -> GraphQLResponse {
    schema.execute(req.into_inner()).await.into()
}

/// GraphiQL IDE handler
#[get("/graphiql")]
async fn graphiql() -> impl Responder {
    HttpResponse::Ok()
        .content_type("text/html; charset=utf-8")
        .body(
            GraphiQLSource::build()
                .endpoint("/graphql")
                .finish(),
        )
}
{{/if}}

#[actix_web::main]
async fn main() -> anyhow::Result<()> {
    // Load environment variables
    dotenvy::dotenv().ok();

    // Initialize tracing
    tracing_subscriber::registry()
        .with(tracing_subscriber::EnvFilter::try_from_default_env().unwrap_or_else(|_| "debug".into()))
        .with(tracing_subscriber::fmt::layer())
        .init();

{{#if (eq rustOrm "sea-orm")}}
    // Initialize database connection
    let database_url = std::env::var("DATABASE_URL")
        .expect("DATABASE_URL must be set");

    tracing::info!("Connecting to database...");
    let db = Database::connect(&database_url).await?;
    tracing::info!("Database connected successfully");

    let db_arc = Arc::new(db);
    let state = web::Data::new(AppState { db: db_arc.clone() });
{{#if (eq rustApi "async-graphql")}}

    // Build GraphQL schema with database
    let schema = web::Data::new(graphql::build_schema(db_arc));
    tracing::info!("GraphQL endpoint: /graphql");
    tracing::info!("GraphiQL IDE: /graphiql");
{{/if}}
{{/if}}
{{#if (eq rustOrm "sqlx")}}
    // Initialize database connection pool
    let database_url = std::env::var("DATABASE_URL")
        .expect("DATABASE_URL must be set");

    tracing::info!("Connecting to database...");
    let pool = PgPoolOptions::new()
        .max_connections(5)
        .connect(&database_url)
        .await?;
    tracing::info!("Database connected successfully");

    let state = web::Data::new(AppState { db: pool.clone() });
{{#if (eq rustApi "async-graphql")}}

    // Build GraphQL schema with database pool
    let schema = web::Data::new(graphql::build_schema(pool));
    tracing::info!("GraphQL endpoint: /graphql");
    tracing::info!("GraphiQL IDE: /graphiql");
{{/if}}
{{/if}}
{{#if (and (not (eq rustOrm "sea-orm")) (not (eq rustOrm "sqlx")) (eq rustApi "async-graphql"))}}
    // Build GraphQL schema
    let schema = web::Data::new(graphql::build_schema());
    tracing::info!("GraphQL endpoint: /graphql");
    tracing::info!("GraphiQL IDE: /graphiql");
{{/if}}

    // Get host and port from environment
    let host = std::env::var("HOST").unwrap_or_else(|_| "127.0.0.1".to_string());
    let port: u16 = std::env::var("PORT")
        .unwrap_or_else(|_| "3000".to_string())
        .parse()?;

    tracing::info!("Starting HTTP server at http://{}:{}", host, port);

{{#if (eq rustApi "tonic")}}
    // Start gRPC server on a separate port
    let grpc_port = std::env::var("GRPC_PORT").unwrap_or_else(|_| "50051".to_string());
    let grpc_host = host.clone();
    let grpc_addr = format!("{}:{}", grpc_host, grpc_port).parse()?;

    tracing::info!("Starting gRPC server at {}", grpc_addr);

    // Spawn gRPC server in a separate task
    let grpc_handle = tokio::spawn(async move {
        tonic::transport::Server::builder()
            .add_service(grpc::create_grpc_server())
            .serve(grpc_addr)
            .await
    });

    // Start HTTP server
{{#if (or (eq rustOrm "sea-orm") (eq rustOrm "sqlx"))}}
    let http_server = HttpServer::new(move || {
        let cors = Cors::permissive();
        App::new()
            .wrap(cors)
            .app_data(state.clone())
            .service(health)
    })
{{else}}
    let http_server = HttpServer::new(|| {
        let cors = Cors::permissive();
        App::new()
            .wrap(cors)
            .service(health)
    })
{{/if}}
    .bind((host, port))?
    .run();

    // Run both servers concurrently
    tokio::select! {
        result = http_server => {
            if let Err(e) = result {
                tracing::error!("HTTP server error: {}", e);
            }
        }
        result = grpc_handle => {
            match result {
                Ok(Ok(())) => {}
                Ok(Err(e)) => tracing::error!("gRPC server error: {}", e),
                Err(e) => tracing::error!("gRPC task error: {}", e),
            }
        }
    }
{{else if (eq rustApi "async-graphql")}}
    // Start server with GraphQL
{{#if (or (eq rustOrm "sea-orm") (eq rustOrm "sqlx"))}}
    HttpServer::new(move || {
        let cors = Cors::permissive();
        App::new()
            .wrap(cors)
            .app_data(state.clone())
            .app_data(schema.clone())
            .service(health)
            .service(graphiql)
            .route("/graphql", web::post().to(graphql_handler))
    })
{{else}}
    HttpServer::new(move || {
        let cors = Cors::permissive();
        App::new()
            .wrap(cors)
            .app_data(schema.clone())
            .service(health)
            .service(graphiql)
            .route("/graphql", web::post().to(graphql_handler))
    })
{{/if}}
    .bind((host, port))?
    .run()
    .await?;
{{else}}
    // Start server
{{#if (or (eq rustOrm "sea-orm") (eq rustOrm "sqlx"))}}
    HttpServer::new(move || {
        let cors = Cors::permissive();
        App::new()
            .wrap(cors)
            .app_data(state.clone())
            .service(health)
    })
{{else}}
    HttpServer::new(|| {
        let cors = Cors::permissive();
        App::new()
            .wrap(cors)
            .service(health)
    })
{{/if}}
    .bind((host, port))?
    .run()
    .await?;
{{/if}}

    Ok(())
}
{{else}}
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};
{{#if (eq rustApi "tonic")}}

mod grpc;
{{/if}}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // Load environment variables
    dotenvy::dotenv().ok();

    // Initialize tracing
    tracing_subscriber::registry()
        .with(tracing_subscriber::EnvFilter::try_from_default_env().unwrap_or_else(|_| "debug".into()))
        .with(tracing_subscriber::fmt::layer())
        .init();

{{#if (eq rustApi "tonic")}}
    // Get host and port from environment
    let host = std::env::var("HOST").unwrap_or_else(|_| "127.0.0.1".to_string());
    let grpc_port = std::env::var("GRPC_PORT").unwrap_or_else(|_| "50051".to_string());
    let grpc_addr = format!("{}:{}", host, grpc_port).parse()?;

    tracing::info!("Starting gRPC server at {}", grpc_addr);

    tonic::transport::Server::builder()
        .add_service(grpc::create_grpc_server())
        .serve(grpc_addr)
        .await?;
{{else}}
    tracing::info!("Hello from {{projectName}}!");
    tracing::info!("Add a web framework (axum or actix-web) to start building your API.");
{{/if}}

    Ok(())
}
{{/if}}
`],
  ["rust-base/crates/server/src/graphql.rs.hbs", `use async_graphql::{Context, EmptySubscription, Object, Schema};
{{#if (eq rustOrm "sea-orm")}}
use sea_orm::DatabaseConnection;
use std::sync::Arc;
{{/if}}
{{#if (eq rustOrm "sqlx")}}
use sqlx::PgPool;
{{/if}}

/// GraphQL Query root
pub struct QueryRoot;

#[Object]
impl QueryRoot {
    /// Returns a greeting message
    async fn hello(&self, name: Option<String>) -> String {
        format!("Hello, {}!", name.unwrap_or_else(|| "World".to_string()))
    }

    /// Returns the server status
    async fn status(&self) -> &'static str {
        "Server is running"
    }

{{#if (eq rustOrm "sea-orm")}}
    /// Example query using database connection
    async fn db_status(&self, ctx: &Context<'_>) -> async_graphql::Result<String> {
        let db = ctx.data::<Arc<DatabaseConnection>>()?;
        match db.ping().await {
            Ok(_) => Ok("Database connected".to_string()),
            Err(e) => Ok(format!("Database error: {}", e)),
        }
    }
{{/if}}
{{#if (eq rustOrm "sqlx")}}
    /// Example query using database pool
    async fn db_status(&self, ctx: &Context<'_>) -> async_graphql::Result<String> {
        let pool = ctx.data::<PgPool>()?;
        match pool.acquire().await {
            Ok(_) => Ok("Database connected".to_string()),
            Err(e) => Ok(format!("Database error: {}", e)),
        }
    }
{{/if}}
}

/// GraphQL Mutation root
pub struct MutationRoot;

#[Object]
impl MutationRoot {
    /// Example mutation that echoes back a message
    async fn echo(&self, message: String) -> String {
        message
    }
}

/// The GraphQL schema type
pub type GraphQLSchema = Schema<QueryRoot, MutationRoot, EmptySubscription>;

/// Build the GraphQL schema with optional data sources
{{#if (eq rustOrm "sea-orm")}}
pub fn build_schema(db: Arc<DatabaseConnection>) -> GraphQLSchema {
    Schema::build(QueryRoot, MutationRoot, EmptySubscription)
        .data(db)
        .finish()
}
{{else if (eq rustOrm "sqlx")}}
pub fn build_schema(pool: PgPool) -> GraphQLSchema {
    Schema::build(QueryRoot, MutationRoot, EmptySubscription)
        .data(pool)
        .finish()
}
{{else}}
pub fn build_schema() -> GraphQLSchema {
    Schema::build(QueryRoot, MutationRoot, EmptySubscription)
        .finish()
}
{{/if}}
`],
  ["rust-base/crates/server/src/grpc.rs.hbs", `//! gRPC service implementations for {{projectName}}.

use {{projectName}}_proto::{Greeter, GreeterServer, HelloReply, HelloRequest};
use tokio_stream::wrappers::ReceiverStream;
use tonic::{Request, Response, Status};

/// Implementation of the Greeter gRPC service.
#[derive(Debug, Default)]
pub struct GreeterService;

#[tonic::async_trait]
impl Greeter for GreeterService {
    /// Handle a unary greeting request.
    async fn say_hello(
        &self,
        request: Request<HelloRequest>,
    ) -> Result<Response<HelloReply>, Status> {
        let name = request.into_inner().name;
        tracing::info!("Received gRPC request: SayHello from '{}'", name);

        let reply = HelloReply {
            message: format!("Hello, {}!", name),
        };

        Ok(Response::new(reply))
    }

    type SayHelloStreamStream = ReceiverStream<Result<HelloReply, Status>>;

    /// Handle a streaming greeting request.
    async fn say_hello_stream(
        &self,
        request: Request<HelloRequest>,
    ) -> Result<Response<Self::SayHelloStreamStream>, Status> {
        let name = request.into_inner().name;
        tracing::info!("Received gRPC streaming request: SayHelloStream from '{}'", name);

        let (tx, rx) = tokio::sync::mpsc::channel(4);

        tokio::spawn(async move {
            for i in 1..=5 {
                let reply = HelloReply {
                    message: format!("Hello #{} to {}!", i, name),
                };
                if tx.send(Ok(reply)).await.is_err() {
                    break;
                }
                tokio::time::sleep(tokio::time::Duration::from_millis(500)).await;
            }
        });

        Ok(Response::new(ReceiverStream::new(rx)))
    }
}

/// Create and configure the gRPC server.
pub fn create_grpc_server() -> GreeterServer<GreeterService> {
    GreeterServer::new(GreeterService::default())
}
`],
  ["examples/ai/native/bare/polyfills.js", `import structuredClone from "@ungap/structured-clone";
import { Platform } from "react-native";

if (Platform.OS !== "web") {
  const setupPolyfills = async () => {
    const { polyfillGlobal } = await import("react-native/Libraries/Utilities/PolyfillFunctions");

    const { TextEncoderStream, TextDecoderStream } =
      await import("@stardazed/streams-text-encoding");

    if (!("structuredClone" in global)) {
      polyfillGlobal("structuredClone", () => structuredClone);
    }

    polyfillGlobal("TextEncoderStream", () => TextEncoderStream);
    polyfillGlobal("TextDecoderStream", () => TextDecoderStream);
  };

  setupPolyfills();
}

export {};
`],
  ["examples/ai/native/unistyles/polyfills.js", `import structuredClone from "@ungap/structured-clone";
import { Platform } from "react-native";

if (Platform.OS !== "web") {
  const setupPolyfills = async () => {
    const { polyfillGlobal } = await import("react-native/Libraries/Utilities/PolyfillFunctions");

    const { TextEncoderStream, TextDecoderStream } =
      await import("@stardazed/streams-text-encoding");

    if (!("structuredClone" in global)) {
      polyfillGlobal("structuredClone", () => structuredClone);
    }

    polyfillGlobal("TextEncoderStream", () => TextEncoderStream);
    polyfillGlobal("TextDecoderStream", () => TextDecoderStream);
  };

  setupPolyfills();
}

export {};
`],
  ["examples/ai/native/uniwind/polyfills.js", `import structuredClone from "@ungap/structured-clone";
import { Platform } from "react-native";

if (Platform.OS !== "web") {
  const setupPolyfills = async () => {
    const { polyfillGlobal } = await import("react-native/Libraries/Utilities/PolyfillFunctions");

    const { TextEncoderStream, TextDecoderStream } =
      await import("@stardazed/streams-text-encoding");

    if (!("structuredClone" in global)) {
      polyfillGlobal("structuredClone", () => structuredClone);
    }

    polyfillGlobal("TextEncoderStream", () => TextEncoderStream);
    polyfillGlobal("TextDecoderStream", () => TextDecoderStream);
  };

  setupPolyfills();
}

export {};
`],
  ["job-queue/trigger-dev/server/base/trigger.config.ts.hbs", `import { defineConfig } from "@trigger.dev/sdk/v3";

/**
 * Trigger.dev configuration
 * @see https://trigger.dev/docs/config/config-file
 */
export default defineConfig({
  // Your project ref from the Trigger.dev dashboard
  // Get this from: https://cloud.trigger.dev/
  project: process.env.TRIGGER_PROJECT_ID || "<your-project-ref>",

  // Directories containing your task definitions
  dirs: ["./src/trigger"],

  // Retry configuration for all tasks (can be overridden per task)
  retries: {
    // Enable retries during development
    enabledInDev: true,
    // Default retry settings
    default: {
      maxAttempts: 3,
      minTimeoutInMs: 1000,
      maxTimeoutInMs: 10000,
      factor: 2,
      randomize: true,
    },
  },

  // Maximum duration for tasks in seconds (can be overridden per task)
  maxDuration: 300, // 5 minutes

  // Runtime configuration
  runtime: "node",

  // Log level for debugging
  logLevel: "info",

  // Build configuration
  build: {
    // Automatically detect external packages
    autoDetectExternal: true,
    // Keep function names for better debugging
    keepNames: true,
  },

  // Global lifecycle hooks (optional)
  // onStart: async ({ payload, ctx }) => {
  //   console.log("Task started:", ctx.task.id);
  // },
  // onSuccess: async ({ payload, output, ctx }) => {
  //   console.log("Task completed:", ctx.task.id);
  // },
  // onFailure: async ({ payload, error, ctx }) => {
  //   console.error("Task failed:", ctx.task.id, error);
  // },
});
`],
  ["auth/better-auth/server/base/package.json.hbs", `{
  "name": "@{{projectName}}/auth",
  "exports": {
    ".": {
      "default": "./src/index.ts"
    },
    "./*": {
      "default": "./src/*.ts"
    }
  },
  "type": "module",
  "scripts": {},
  "devDependencies": {}
}`],
  ["auth/better-auth/server/base/tsconfig.json.hbs", `{
  "extends": "@{{projectName}}/config/tsconfig.base.json",
  "compilerOptions": {
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "outDir": "dist",
    "composite": true
  }
}`],
  ["auth/better-auth/server/base/_gitignore", `# dependencies (bun install)
node_modules

# output
out
dist
*.tgz

# code coverage
coverage
*.lcov

# logs
logs
_.log
report.[0-9]_.[0-9]_.[0-9]_.[0-9]_.json

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# caches
.eslintcache
.cache
*.tsbuildinfo

# IntelliJ based IDEs
.idea

# Finder (MacOS) folder config
.DS_Store
`],
  ["frontend/qwik/src/routes/index.tsx.hbs", `import { component$ } from "@builder.io/qwik";
import type { DocumentHead } from "@builder.io/qwik-city";

const TITLE_TEXT = \`
  
 
                 
                 
               
                

          
      
                      
                      
                     
                      
\`;

export default component$(() => {
  return (
    {{#if (eq cssFramework "tailwind")}}
    <div class="container mx-auto max-w-3xl px-4 py-2">
      <pre class="overflow-x-auto font-mono text-sm whitespace-pre">{TITLE_TEXT}</pre>
      <div class="grid gap-6 mt-6">
        <section class="rounded-lg border border-gray-200 dark:border-gray-800 p-4">
          <h2 class="mb-2 font-medium">Welcome to Qwik</h2>
          <p class="text-sm text-gray-600 dark:text-gray-400">
            Qwik is a resumable framework that delivers instant apps at scale.
            It achieves this by serializing the application state and resuming
            execution on the client without re-running the entire application.
          </p>
        </section>
        <section class="rounded-lg border border-gray-200 dark:border-gray-800 p-4">
          <h2 class="mb-2 font-medium">Key Features</h2>
          <ul class="list-disc list-inside text-sm text-gray-600 dark:text-gray-400 space-y-1">
            <li>Resumability - No hydration overhead</li>
            <li>Lazy loading by default</li>
            <li>Familiar JSX syntax</li>
            <li>Built-in optimizations</li>
          </ul>
        </section>
      </div>
    </div>
    {{else}}
    <div style=\\{{ maxWidth: "48rem", margin: "0 auto", padding: "0.5rem 1rem" }}>
      <pre style=\\{{ overflow: "auto", fontFamily: "monospace", fontSize: "0.875rem", whiteSpace: "pre" }}>{TITLE_TEXT}</pre>
      <div style=\\{{ display: "grid", gap: "1.5rem", marginTop: "1.5rem" }}>
        <section style=\\{{ borderRadius: "0.5rem", border: "1px solid var(--border-color)", padding: "1rem" }}>
          <h2 style=\\{{ marginBottom: "0.5rem", fontWeight: 500 }}>Welcome to Qwik</h2>
          <p style=\\{{ fontSize: "0.875rem", color: "var(--muted-color)" }}>
            Qwik is a resumable framework that delivers instant apps at scale.
            It achieves this by serializing the application state and resuming
            execution on the client without re-running the entire application.
          </p>
        </section>
        <section style=\\{{ borderRadius: "0.5rem", border: "1px solid var(--border-color)", padding: "1rem" }}>
          <h2 style=\\{{ marginBottom: "0.5rem", fontWeight: 500 }}>Key Features</h2>
          <ul style=\\{{ fontSize: "0.875rem", color: "var(--muted-color)", listStyleType: "disc", paddingLeft: "1.5rem" }}>
            <li>Resumability - No hydration overhead</li>
            <li>Lazy loading by default</li>
            <li>Familiar JSX syntax</li>
            <li>Built-in optimizations</li>
          </ul>
        </section>
      </div>
    </div>
    {{/if}}
  );
});

export const head: DocumentHead = {
  title: "Better T Stack - Qwik",
  meta: [
    {
      name: "description",
      content: "Better T Stack with Qwik - Resumable framework with instant load times",
    },
  ],
};
`],
  ["frontend/qwik/src/routes/layout.tsx.hbs", `import { component$, Slot } from "@builder.io/qwik";
import type { RequestHandler } from "@builder.io/qwik-city";
import Header from "@/components/header";

export const onGet: RequestHandler = async ({ cacheControl }) => {
  cacheControl({
    staleWhileRevalidate: 60 * 60 * 24 * 7,
    maxAge: 5,
  });
};

export default component$(() => {
  return (
    {{#if (eq cssFramework "tailwind")}}
    <div class="grid grid-rows-[auto_1fr] min-h-screen">
      <Header />
      <main>
        <Slot />
      </main>
    </div>
    {{else}}
    <div style=\\{{ display: "grid", gridTemplateRows: "auto 1fr", minHeight: "100vh" }}>
      <Header />
      <main>
        <Slot />
      </main>
    </div>
    {{/if}}
  );
});
`],
  ["frontend/solid/src/components/loader.tsx", `import { Loader2 } from "lucide-solid";

export default function Loader() {
  return (
    <div class="flex h-full items-center justify-center pt-8">
      <Loader2 class="animate-spin" />
    </div>
  );
}
`],
  ["frontend/solid/src/components/header.tsx.hbs", `import { Link } from "@tanstack/solid-router";
{{#if (eq auth "better-auth")}}
import UserMenu from "./user-menu";
{{/if}}
import { For } from "solid-js";

export default function Header() {
  const links = [
    { to: "/", label: "Home" },
    {{#if (eq auth "better-auth")}}
    { to: "/dashboard", label: "Dashboard" },
    {{/if}}
    {{#if (includes examples "todo")}}
    { to: "/todos", label: "Todos" },
    {{/if}}
    {{#if (includes examples "ai")}}
    { to: "/ai", label: "AI Chat" },
    {{/if}}
  ];

  return (
    <div>
      <div class="flex flex-row items-center justify-between px-2 py-1">
        <nav class="flex gap-4 text-lg">
          <For each={links}>
            {(link) => <Link to={link.to}>{link.label}</Link>}
          </For>
        </nav>
        <div class="flex items-center gap-2">
          {{#if (eq auth "better-auth")}}
          <UserMenu />
          {{/if}}
        </div>
      </div>
      <hr />
    </div>
  );
}
`],
  ["frontend/solid/src/routes/__root.tsx.hbs", `import Header from "@/components/header";
import { Outlet, createRootRouteWithContext } from "@tanstack/solid-router";
import { TanStackRouterDevtools } from "@tanstack/solid-router-devtools";
{{#if (eq api "orpc")}}
import { SolidQueryDevtools } from "@tanstack/solid-query-devtools";
import type { QueryClient } from "@tanstack/solid-query";
import type { orpc } from "../utils/orpc";

export interface RouterContext {
  orpc: typeof orpc;
  queryClient: QueryClient;
}
{{else}}
export interface RouterContext {}
{{/if}}

export const Route = createRootRouteWithContext<RouterContext>()({
  component: RootComponent,
});

function RootComponent() {
  return (
    <>
      <div class="grid grid-rows-[auto_1fr] h-svh">
        <Header />
        <Outlet />
      </div>
      {{#if (eq api "orpc")}}
      <SolidQueryDevtools />
      {{/if}}
      <TanStackRouterDevtools />
    </>
  );
}
`],
  ["frontend/solid/src/routes/index.tsx.hbs", `import { createFileRoute } from "@tanstack/solid-router";
{{#if (eq api "orpc")}}
import { useQuery } from "@tanstack/solid-query";
import { orpc } from "../utils/orpc";
import { Match, Switch } from "solid-js";
{{else}}
{{/if}}

export const Route = createFileRoute("/")({
  component: App,
});

const TITLE_TEXT = \`
  
 
                 
                 
               
                

          
      
                      
                      
                     
                      
 \`;

function App() {
  {{#if (eq api "orpc")}}
  const healthCheck = useQuery(() => orpc.healthCheck.queryOptions());
  {{/if}}

  return (
    <div class="container mx-auto max-w-3xl px-4 py-2">
      <pre class="overflow-x-auto font-mono text-sm">{TITLE_TEXT}</pre>
      <div class="grid gap-6">
        {{#if (eq api "orpc")}}
        <section class="rounded-lg border p-4">
          <h2 class="mb-2 font-medium">API Status</h2>
          <Switch>
            <Match when={healthCheck.isPending}>
              <div class="flex items-center gap-2">
                <div class="h-2 w-2 rounded-full bg-gray-500 animate-pulse" />{" "}
                <span class="text-sm text-muted-foreground">Checking...</span>
              </div>
            </Match>
            <Match when={healthCheck.isError}>
              <div class="flex items-center gap-2">
                <div class="h-2 w-2 rounded-full bg-red-500" />
                <span class="text-sm text-muted-foreground">Disconnected</span>
              </div>
            </Match>
            <Match when={healthCheck.isSuccess}>
              <div class="flex items-center gap-2">
                <div
                  class={\`h-2 w-2 rounded-full \${healthCheck.data ? "bg-green-500" : "bg-red-500"}\`}
                />
                <span class="text-sm text-muted-foreground">
                  {healthCheck.data
                    ? "Connected"
                    : "Disconnected"}
                </span>
              </div>
            </Match>
          </Switch>
        </section>
        {{/if}}
      </div>
    </div>
  );
}
`],
  ["frontend/redwood/web/public/robots.txt", `User-agent: *
Disallow:
`],
  ["frontend/redwood/web/public/favicon.svg", `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100">
  <rect width="100" height="100" rx="10" fill="#bf4722"/>
  <path d="M25 75V25h15l10 25 10-25h15v50h-12V45l-8 20h-10l-8-20v30H25z" fill="white"/>
</svg>
`],
  ["frontend/qwik/src/components/header.tsx.hbs", `import { component$ } from "@builder.io/qwik";
import { Link } from "@builder.io/qwik-city";

export default component$(() => {
  const links = [
    { href: "/", label: "Home" },
    {{#if (eq auth "better-auth")}}
    { href: "/dashboard", label: "Dashboard" },
    {{/if}}
    {{#if (includes examples "todo")}}
    { href: "/todos", label: "Todos" },
    {{/if}}
    {{#if (includes examples "ai")}}
    { href: "/ai", label: "AI Chat" },
    {{/if}}
  ];

  return (
    <header>
      {{#if (eq cssFramework "tailwind")}}
      <div class="flex flex-row items-center justify-between px-4 py-2">
        <nav class="flex gap-4 text-lg">
          {links.map((link) => (
            <Link key={link.href} href={link.href} class="hover:underline">
              {link.label}
            </Link>
          ))}
        </nav>
        <div class="flex items-center gap-2">
          {{#if (eq auth "better-auth")}}
          {/* User menu component would go here */}
          {{/if}}
        </div>
      </div>
      <hr class="border-gray-200 dark:border-gray-800" />
      {{else}}
      <div style=\\{{ display: "flex", justifyContent: "space-between", alignItems: "center", padding: "0.5rem 1rem" }}>
        <nav style=\\{{ display: "flex", gap: "1rem", fontSize: "1.125rem" }}>
          {links.map((link) => (
            <Link key={link.href} href={link.href}>
              {link.label}
            </Link>
          ))}
        </nav>
        <div style=\\{{ display: "flex", alignItems: "center", gap: "0.5rem" }}>
          {{#if (eq auth "better-auth")}}
          {/* User menu component would go here */}
          {{/if}}
        </div>
      </div>
      <hr style=\\{{ borderColor: "var(--border-color)" }} />
      {{/if}}
    </header>
  );
});
`],
  ["frontend/redwood/web/src/index.css.hbs", `{{#if (eq cssFramework "tailwind")}}
@tailwind base;
@tailwind components;
@tailwind utilities;
{{else}}
* {
  box-sizing: border-box;
}

body {
  margin: 0;
  padding: 0;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", "Oxygen", "Ubuntu", "Cantarell", "Fira Sans", "Droid Sans", "Helvetica Neue", sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  background-color: #0f172a;
  color: #f8fafc;
  min-height: 100vh;
}

a {
  color: #38bdf8;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}
{{/if}}
`],
  ["frontend/redwood/web/src/App.tsx", `import { FatalErrorBoundary, RedwoodProvider } from "@redwoodjs/web";
import { RedwoodApolloProvider } from "@redwoodjs/web/apollo";
import FatalErrorPage from "src/pages/FatalErrorPage/FatalErrorPage";
import Routes from "src/Routes";

import "./index.css";

const App = () => (
  <FatalErrorBoundary page={FatalErrorPage}>
    <RedwoodProvider titleTemplate="%PageTitle | %AppTitle">
      <RedwoodApolloProvider>
        <Routes />
      </RedwoodApolloProvider>
    </RedwoodProvider>
  </FatalErrorBoundary>
);

export default App;
`],
  ["frontend/redwood/web/src/index.html", `<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
  </head>
  <body>
    <div id="redwood-app">
      <!-- content -->
    </div>
  </body>
</html>
`],
  ["frontend/redwood/web/src/entry.client.tsx", `import { hydrateRoot, createRoot } from "react-dom/client";

import App from "./App";

/**
 * When \`#redwood-app\` isn't empty then it's very likely that you're using
 * prerendering. So React attaches event listeners to the existing markup
 * rather than replacing it.
 * https://reactjs.org/docs/react-dom-client.html#hydrateroot
 */
const redwoodAppElement = document.getElementById("redwood-app");

if (redwoodAppElement!.children?.length > 0) {
  hydrateRoot(redwoodAppElement!, <App />);
} else {
  const root = createRoot(redwoodAppElement!);
  root.render(<App />);
}
`],
  ["frontend/redwood/web/src/Routes.tsx", `// In this file, all Page components from 'src/pages\` are auto-imported. Nested
// directories are supported, and should be uppercase. Each subdirectory will be
// prepended onto the component name.
//
// Examples:
//
// 'src/pages/HomePage/HomePage.js'         -> HomePage
// 'src/pages/Admin/BooksPage/BooksPage.js' -> AdminBooksPage

import { Router, Route } from "@redwoodjs/router";

const Routes = () => {
  return (
    <Router>
      <Route path="/" page={HomePage} name="home" />
      <Route notfound page={NotFoundPage} />
    </Router>
  );
};

export default Routes;
`],
  ["frontend/redwood/api/db/schema.prisma", `// Don't forget to tell Prisma about your database:
// https://www.prisma.io/docs/reference/database-reference/connection-urls

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

generator client {
  provider      = "prisma-client-js"
  binaryTargets = "native"
}

// Define your own datamodels here and run \`yarn rw prisma migrate dev\`
// to create migrations for them and apply to your dev DB.

model Post {
  id        Int      @id @default(autoincrement())
  title     String
  body      String
  createdAt DateTime @default(now())
}
`],
  ["frontend/svelte/src/routes/+page.svelte.hbs", `{{#if (eq backend "convex")}}
<script lang="ts">
import { useQuery } from 'convex-svelte';
import { api } from "@{{projectName}}/backend/convex/_generated/api";

const healthCheck = useQuery(api.healthCheck.get, {});

const TITLE_TEXT = \`
    
   
                   
                   
                 
                  

            
        
                        
                        
                       
                        
   \`;
</script>

<div class="container mx-auto max-w-3xl px-4 py-2">
	<pre class="overflow-x-auto font-mono text-sm">{TITLE_TEXT}</pre>
	<div class="grid gap-6">
		<section class="rounded-lg border p-4">
			<h2 class="mb-2 font-medium">API Status</h2>
			<div class="flex items-center gap-2">
				<div
					class={\`h-2 w-2 rounded-full \${healthCheck.data ? "bg-green-500" : "bg-red-500"}\`}
				></div>
				<span class="text-muted-foreground text-sm">
					{healthCheck.isLoading
						? "Checking..."
						: healthCheck.data
							? "Connected"
							: "Disconnected"}
				</span>
			</div>
		</section>
	</div>
</div>
{{else}}
<script lang="ts">
{{#if (eq api "orpc")}}
import { orpc } from "$lib/orpc";
import { createQuery } from "@tanstack/svelte-query";
const healthCheck = createQuery(orpc.healthCheck.queryOptions());
{{/if}}

const TITLE_TEXT = \`
    
   
                   
                   
                 
                  

            
        
                        
                        
                       
                        
   \`;
</script>

<div class="container mx-auto max-w-3xl px-4 py-2">
	<pre class="overflow-x-auto font-mono text-sm">{TITLE_TEXT}</pre>
	<div class="grid gap-6">
	    {{#if (eq api "orpc")}}
		<section class="rounded-lg border p-4">
			<h2 class="mb-2 font-medium">API Status</h2>
			<div class="flex items-center gap-2">
				<div
					class={\`h-2 w-2 rounded-full \${$healthCheck.data ? "bg-green-500" : "bg-red-500"}\`}
				></div>
				<span class="text-muted-foreground text-sm">
					{$healthCheck.isLoading
						? "Checking..."
						: $healthCheck.data
							? "Connected"
							: "Disconnected"}
				</span>
			</div>
		</section>
	    {{/if}}
	</div>
</div>
{{/if}}
`],
  ["frontend/svelte/src/routes/+layout.svelte.hbs", `{{#if (eq backend "convex")}}
<script lang="ts">
	import '../app.css';
    import Header from '../components/Header.svelte';
    import { PUBLIC_CONVEX_URL } from '$env/static/public';
	import { setupConvex } from 'convex-svelte';

	const { children } = $props();
	setupConvex(PUBLIC_CONVEX_URL);
</script>

<div class="grid h-svh grid-rows-[auto_1fr]">
	<Header />
	<main class="overflow-y-auto">
		{@render children()}
	</main>
</div>
{{else}}
  {{#if (eq api "orpc")}}
<script lang="ts">
    import { QueryClientProvider } from '@tanstack/svelte-query';
    import { SvelteQueryDevtools } from '@tanstack/svelte-query-devtools'
	import '../app.css';
    import { queryClient } from '$lib/orpc';
    import Header from '../components/Header.svelte';

	const { children } = $props();
</script>

<QueryClientProvider client={queryClient}>
    <div class="grid h-svh grid-rows-[auto_1fr]">
		<Header />
		<main class="overflow-y-auto">
			{@render children()}
		</main>
    </div>
    <SvelteQueryDevtools />
</QueryClientProvider>
  {{else}}
<script lang="ts">
	import '../app.css';
    import Header from '../components/Header.svelte';

	const { children } = $props();
</script>

<div class="grid h-svh grid-rows-[auto_1fr]">
	<Header />
	<main class="overflow-y-auto">
		{@render children()}
	</main>
</div>
  {{/if}}
{{/if}}
`],
  ["frontend/fresh/src/routes/_layout.tsx.hbs", `import type { PageProps } from "$fresh/server.ts";
import Header from "../components/Header.tsx";

export default function Layout({ Component, state }: PageProps) {
  return (
    <html lang="en">
      <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>{state.title ?? "{{projectName}}"}</title>
        <link rel="stylesheet" href="/styles.css" />
      </head>
      <body{{#if (eq cssFramework "tailwind")}} class="bg-gradient-to-br from-slate-900 via-purple-900 to-slate-900 min-h-screen"{{/if}}>
        <Header />
        <Component />
      </body>
    </html>
  );
}
`],
  ["frontend/fresh/src/routes/index.tsx.hbs", `import { define } from "../../utils.ts";
import Counter from "../islands/Counter.tsx";

export const handler = define.handlers({
  GET(ctx) {
    ctx.state.title = "Home | {{projectName}}";
    return ctx.render();
  },
});

export default define.page(function Home() {
  return (
    <main{{#if (eq cssFramework "tailwind")}} class="container mx-auto px-4 py-16"{{/if}}>
      <div{{#if (eq cssFramework "tailwind")}} class="flex flex-col items-center justify-center text-center"{{/if}}>
        <h1{{#if (eq cssFramework "tailwind")}} class="text-5xl font-bold text-white mb-6"{{/if}}>
          Welcome to <span{{#if (eq cssFramework "tailwind")}} class="text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-purple-500"{{/if}}>Fresh</span>
        </h1>
        <p{{#if (eq cssFramework "tailwind")}} class="text-xl text-gray-300 mb-8 max-w-2xl"{{/if}}>
          A Deno-native full-stack web framework with islands architecture for optimal performance.
        </p>

        <div{{#if (eq cssFramework "tailwind")}} class="bg-white/10 backdrop-blur-lg rounded-2xl p-8 border border-white/20"{{/if}}>
          <h2{{#if (eq cssFramework "tailwind")}} class="text-2xl font-semibold text-white mb-4"{{/if}}>Interactive Island</h2>
          <Counter start={0} />
        </div>

        <div{{#if (eq cssFramework "tailwind")}} class="mt-12 grid grid-cols-1 md:grid-cols-3 gap-6"{{/if}}>
          <FeatureCard
            title="Islands Architecture"
            description="Ship zero JavaScript by default, hydrate only interactive components."
          />
          <FeatureCard
            title="Deno Native"
            description="Built for Deno with first-class TypeScript support and modern APIs."
          />
          <FeatureCard
            title="Fast by Default"
            description="No build step for development, instant page loads with streaming."
          />
        </div>
      </div>
    </main>
  );
});

function FeatureCard({ title, description }: { title: string; description: string }) {
  return (
    <div{{#if (eq cssFramework "tailwind")}} class="bg-white/5 backdrop-blur rounded-xl p-6 border border-white/10 hover:border-cyan-500/50 transition-colors"{{/if}}>
      <h3{{#if (eq cssFramework "tailwind")}} class="text-lg font-semibold text-white mb-2"{{/if}}>{title}</h3>
      <p{{#if (eq cssFramework "tailwind")}} class="text-gray-400"{{/if}}>{description}</p>
    </div>
  );
}
`],
  ["frontend/fresh/src/islands/Counter.tsx.hbs", `import { useSignal } from "@preact/signals";

interface CounterProps {
  start: number;
}

export default function Counter({ start }: CounterProps) {
  const count = useSignal(start);

  return (
    <div{{#if (eq cssFramework "tailwind")}} class="flex items-center gap-4"{{/if}}>
      <button
        onClick={() => count.value--}
        {{#if (eq cssFramework "tailwind")}}class="px-4 py-2 bg-cyan-500 hover:bg-cyan-600 text-white rounded-lg font-semibold transition-colors"{{/if}}
      >
        -
      </button>
      <span{{#if (eq cssFramework "tailwind")}} class="text-3xl font-bold text-white min-w-[60px] text-center"{{/if}}>
        {count}
      </span>
      <button
        onClick={() => count.value++}
        {{#if (eq cssFramework "tailwind")}}class="px-4 py-2 bg-cyan-500 hover:bg-cyan-600 text-white rounded-lg font-semibold transition-colors"{{/if}}
      >
        +
      </button>
    </div>
  );
}
`],
  ["frontend/svelte/src/lib/index.ts", `// place files you want to import through the \`$lib\` alias in this folder.
export {};
`],
  ["frontend/fresh/src/components/Header.tsx.hbs", `export default function Header() {
  return (
    <header{{#if (eq cssFramework "tailwind")}} class="bg-black/20 backdrop-blur-md border-b border-white/10"{{/if}}>
      <nav{{#if (eq cssFramework "tailwind")}} class="container mx-auto px-4 py-4 flex items-center justify-between"{{/if}}>
        <a href="/"{{#if (eq cssFramework "tailwind")}} class="text-xl font-bold text-white hover:text-cyan-400 transition-colors"{{/if}}>
          {{projectName}}
        </a>
        <div{{#if (eq cssFramework "tailwind")}} class="flex items-center gap-6"{{/if}}>
          <a
            href="https://fresh.deno.dev/docs"
            target="_blank"
            rel="noopener noreferrer"
            {{#if (eq cssFramework "tailwind")}}class="text-gray-300 hover:text-white transition-colors"{{/if}}
          >
            Docs
          </a>
          <a
            href="https://github.com/denoland/fresh"
            target="_blank"
            rel="noopener noreferrer"
            {{#if (eq cssFramework "tailwind")}}class="text-gray-300 hover:text-white transition-colors"{{/if}}
          >
            GitHub
          </a>
        </div>
      </nav>
    </header>
  );
}
`],
  ["frontend/svelte/src/components/Header.svelte.hbs", `<script lang="ts">

    {{#if (eq auth "better-auth")}}
	import UserMenu from './UserMenu.svelte';
    {{/if}}
    const links = [
        { to: "/", label: "Home" },
        {{#if (eq auth "better-auth")}}
        { to: "/dashboard", label: "Dashboard" },
        {{/if}}
        {{#if (includes examples "todo")}}
        { to: "/todos", label: "Todos" },
        {{/if}}
        {{#if (includes examples "ai")}}
        { to: "/ai", label: "AI Chat" },
        {{/if}}
    ];

</script>

<div>
	<div class="flex flex-row items-center justify-between px-4 py-2 md:px-6">
		<nav class="flex gap-4 text-lg">
			{#each links as link (link.to)}
				<a
					href={link.to}
					class="hover:text-neutral-400 transition-colors"
				>
					{link.label}
				</a>
			{/each}
		</nav>
		<div class="flex items-center gap-2">
		    {{#if (eq auth "better-auth")}}
            <UserMenu />
             {{/if}}
		</div>
	</div>
	<hr class="border-neutral-800" />
</div>
`],
  ["frontend/astro/src/layouts/Layout.astro.hbs", `---
import '@/styles/global.css';
import Header from '@/components/Header.astro';

interface Props {
	title: string;
}

const { title } = Astro.props;
---

<!doctype html>
<html lang="en" class="dark">
	<head>
		<meta charset="UTF-8" />
		<meta name="description" content="Astro website built with Better Fullstack" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<link rel="icon" type="image/svg+xml" href="/favicon.svg" />
		<meta name="generator" content={Astro.generator} />
		<title>{title}</title>
	</head>
	<body class="min-h-screen bg-background text-foreground antialiased">
		<Header />
		<main class="container mx-auto px-4 py-8">
			<slot />
		</main>
	</body>
</html>
`],
  ["frontend/astro/src/styles/global.css.hbs", `@import "tailwindcss";

@theme {
	--color-background: oklch(100% 0 0);
	--color-foreground: oklch(14.08% 0.004 285.82);
	--color-card: oklch(100% 0 0);
	--color-card-foreground: oklch(14.08% 0.004 285.82);
	--color-primary: oklch(20.47% 0.006 285.88);
	--color-primary-foreground: oklch(98.51% 0.001 106.42);
	--color-secondary: oklch(96.76% 0.001 286.38);
	--color-secondary-foreground: oklch(20.47% 0.006 285.88);
	--color-muted: oklch(96.76% 0.001 286.38);
	--color-muted-foreground: oklch(55.19% 0.014 285.94);
	--color-accent: oklch(96.76% 0.001 286.38);
	--color-accent-foreground: oklch(20.47% 0.006 285.88);
	--color-border: oklch(91.97% 0.004 286.32);
	--color-input: oklch(91.97% 0.004 286.32);
	--color-ring: oklch(14.08% 0.004 285.82);

	--radius-sm: 0.25rem;
	--radius-md: 0.375rem;
	--radius-lg: 0.5rem;
}

.dark {
	--color-background: oklch(14.08% 0.004 285.82);
	--color-foreground: oklch(98.51% 0.001 106.42);
	--color-card: oklch(14.08% 0.004 285.82);
	--color-card-foreground: oklch(98.51% 0.001 106.42);
	--color-primary: oklch(98.51% 0.001 106.42);
	--color-primary-foreground: oklch(20.47% 0.006 285.88);
	--color-secondary: oklch(26.96% 0.005 286.03);
	--color-secondary-foreground: oklch(98.51% 0.001 106.42);
	--color-muted: oklch(26.96% 0.005 286.03);
	--color-muted-foreground: oklch(70.67% 0.01 286.07);
	--color-accent: oklch(26.96% 0.005 286.03);
	--color-accent-foreground: oklch(98.51% 0.001 106.42);
	--color-border: oklch(26.96% 0.005 286.03);
	--color-input: oklch(26.96% 0.005 286.03);
	--color-ring: oklch(83.53% 0.005 286.29);
}
`],
  ["frontend/astro/src/components/Header.astro.hbs", `---
{{#if (eq astroIntegration "react")}}
import ModeToggle from '@/components/ModeToggle';
{{/if}}
---

<header class="sticky top-0 z-50 w-full border-b border-border bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60">
	<div class="container mx-auto flex h-14 items-center justify-between px-4">
		<a href="/" class="flex items-center space-x-2">
			<span class="text-xl font-bold">{{projectName}}</span>
		</a>
		<nav class="flex items-center gap-4">
			<a
				href="https://github.com"
				target="_blank"
				rel="noopener noreferrer"
				class="text-sm font-medium text-muted-foreground transition-colors hover:text-foreground"
			>
				GitHub
			</a>
{{#if (eq astroIntegration "react")}}
			<ModeToggle client:load />
{{else}}
			<button
				id="theme-toggle"
				class="rounded-md p-2 hover:bg-accent"
				aria-label="Toggle theme"
			>
				<svg class="dark:hidden h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
					<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" />
				</svg>
				<svg class="hidden dark:block h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
					<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />
				</svg>
			</button>
			<script>
				const toggle = document.getElementById('theme-toggle');
				toggle?.addEventListener('click', () => {
					document.documentElement.classList.toggle('dark');
				});
			</script>
{{/if}}
		</nav>
	</div>
</header>
`],
  ["frontend/astro/src/pages/index.astro.hbs", `---
import Layout from '@/layouts/Layout.astro';
{{#if (ne astroIntegration "none")}}
{{#if (eq astroIntegration "react")}}
import Counter from '@/components/Counter';
{{/if}}
{{#if (eq astroIntegration "vue")}}
import Counter from '@/components/Counter.vue';
{{/if}}
{{#if (eq astroIntegration "svelte")}}
import Counter from '@/components/Counter.svelte';
{{/if}}
{{#if (eq astroIntegration "solid")}}
import Counter from '@/components/Counter';
{{/if}}
{{/if}}
---

<Layout title="{{projectName}}">
	<div class="flex flex-col items-center justify-center gap-8 py-12">
		<div class="text-center">
			<h1 class="mb-4 text-4xl font-bold tracking-tight sm:text-5xl">
				Welcome to <span class="text-primary">{{projectName}}</span>
			</h1>
			<p class="text-lg text-muted-foreground">
				Built with Astro and Better Fullstack
			</p>
		</div>

{{#if (ne astroIntegration "none")}}
		<div class="mt-8 rounded-lg border border-border bg-card p-6 shadow-sm">
			<h2 class="mb-4 text-xl font-semibold">Interactive Counter</h2>
			<p class="mb-4 text-sm text-muted-foreground">
				This is an island component using {{astroIntegration}} with client-side hydration.
			</p>
			<Counter client:load />
		</div>
{{else}}
		<div class="mt-8 rounded-lg border border-border bg-card p-6 shadow-sm">
			<h2 class="mb-4 text-xl font-semibold">Static Site</h2>
			<p class="text-sm text-muted-foreground">
				This is a static Astro site without client-side JavaScript framework.
			</p>
		</div>
{{/if}}

		<div class="mt-8 grid gap-4 sm:grid-cols-2 lg:grid-cols-3">
			<a
				href="https://docs.astro.build/"
				target="_blank"
				rel="noopener noreferrer"
				class="rounded-lg border border-border bg-card p-4 transition-colors hover:border-primary"
			>
				<h3 class="font-semibold">Astro Docs</h3>
				<p class="text-sm text-muted-foreground">Learn about Astro's features and API.</p>
			</a>
			<a
				href="https://better-fullstack-web.vercel.app"
				target="_blank"
				rel="noopener noreferrer"
				class="rounded-lg border border-border bg-card p-4 transition-colors hover:border-primary"
			>
				<h3 class="font-semibold">Better Fullstack</h3>
				<p class="text-sm text-muted-foreground">Full-stack TypeScript development.</p>
			</a>
			<a
				href="https://astro.build/integrations/"
				target="_blank"
				rel="noopener noreferrer"
				class="rounded-lg border border-border bg-card p-4 transition-colors hover:border-primary"
			>
				<h3 class="font-semibold">Integrations</h3>
				<p class="text-sm text-muted-foreground">Extend Astro with plugins and frameworks.</p>
			</a>
		</div>
	</div>
</Layout>
`],
  ["frontend/native/unistyles/app/+not-found.tsx.hbs", `import { Link, Stack } from "expo-router";
import { Text, View } from "react-native";
import { StyleSheet } from "react-native-unistyles";
import { Container } from "@/components/container";

export default function NotFoundScreen() {
  return (
    <>
      <Stack.Screen options=\\{{ title: "Oops!" }} />
      <Container>
        <View style={styles.container}>
          <View style={styles.content}>
            <Text style={styles.emoji}></Text>
            <Text style={styles.title}>Page Not Found</Text>
            <Text style={styles.description}>
              Sorry, the page you're looking for doesn't exist.
            </Text>
            <Link href="/" style={styles.button}>
              <Text style={styles.buttonText}>Go to Home</Text>
            </Link>
          </View>
        </View>
      </Container>
    </>
  );
}

const styles = StyleSheet.create((theme) => ({
  container: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    padding: theme.spacing.lg,
  },
  content: {
    alignItems: "center",
  },
  emoji: {
    fontSize: 64,
    marginBottom: theme.spacing.md,
  },
  title: {
    fontSize: theme.fontSize["2xl"],
    fontWeight: "bold",
    color: theme.colors.foreground,
    marginBottom: theme.spacing.sm,
    textAlign: "center",
  },
  description: {
    color: theme.colors.mutedForeground,
    textAlign: "center",
    marginBottom: theme.spacing.xl,
    maxWidth: 280,
  },
  button: {
    backgroundColor: \`\${theme.colors.primary}1A\`, // 10% opacity
    paddingHorizontal: theme.spacing.lg,
    paddingVertical: theme.spacing.sm + 4,
    borderRadius: theme.borderRadius.lg,
  },
  buttonText: {
    color: theme.colors.primary,
    fontWeight: "500",
  },
}));
`],
  ["frontend/native/unistyles/app/modal.tsx.hbs", `import { Container } from "@/components/container";
import { Text, View } from "react-native";
import { StyleSheet } from "react-native-unistyles";

export default function Modal() {
  return (
    <Container>
      <View style={styles.container}>
        <View style={styles.header}>
          <Text style={styles.title}>Modal</Text>
        </View>
      </View>
    </Container>
  );
}

const styles = StyleSheet.create((theme) => ({
  container: {
    flex: 1,
    padding: theme.spacing.lg,
  },
  header: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    marginBottom: theme.spacing.xl,
  },
  title: {
    fontSize: theme.fontSize["2xl"],
    fontWeight: "bold",
    color: theme.colors.foreground,
  },
}));
`],
  ["frontend/native/unistyles/app/_layout.tsx.hbs", `{{#if (includes examples "ai")}}
import "@/polyfills";
{{/if}}
{{#if (eq api "trpc")}}
import { queryClient } from "@/utils/trpc";
{{/if}}
{{#if (eq api "orpc")}}
import { queryClient } from "@/utils/orpc";
{{/if}}
{{#if (eq backend "convex")}}
{{#if (eq auth "better-auth")}}
import { ConvexReactClient } from "convex/react";
import { ConvexBetterAuthProvider } from "@convex-dev/better-auth/react";
import { authClient } from "@/lib/auth-client";
import { env } from "@{{projectName}}/env/native";
{{else}}
import { ConvexProvider, ConvexReactClient } from "convex/react";
import { env } from "@{{projectName}}/env/native";
{{/if}}
{{#if (eq auth "clerk")}}
import { ClerkProvider, useAuth } from "@clerk/clerk-expo";
import { ConvexProviderWithClerk } from "convex/react-clerk";
import { tokenCache } from "@clerk/clerk-expo/token-cache";
{{/if}}
{{else}}
  {{#unless (eq api "none")}}
import { QueryClientProvider } from "@tanstack/react-query";
  {{/unless}}
{{/if}}
import { Stack } from "expo-router";
import { GestureHandlerRootView } from "react-native-gesture-handler";
import { useUnistyles } from "react-native-unistyles";
import { StatusBar } from "expo-status-bar";

export const unstable_settings = {
  initialRouteName: "(drawer)",
};

{{#if (eq backend "convex")}}
const convex = new ConvexReactClient(env.EXPO_PUBLIC_CONVEX_URL, {
  unsavedChangesWarning: false,
});
{{/if}}

export default function RootLayout() {
  const { theme } = useUnistyles();

  return (
    {{#if (eq backend "convex")}}
    {{#if (eq auth "clerk")}}
    <ClerkProvider
      tokenCache={tokenCache}
      publishableKey={env.EXPO_PUBLIC_CLERK_PUBLISHABLE_KEY}
    >
      <ConvexProviderWithClerk client={convex} useAuth={useAuth}>
        <GestureHandlerRootView style=\\{{ flex: 1 }}>
          <Stack
            screenOptions=\\{{
              headerStyle: {
                backgroundColor: theme.colors.background,
              },
              headerTitleStyle: {
                color: theme.colors.foreground,
              },
              headerTintColor: theme.colors.foreground,
            }}
          >
            <Stack.Screen name="(drawer)" options=\\{{ headerShown: false }} />
            <Stack.Screen name="(auth)" options=\\{{ headerShown: false }} />
            <Stack.Screen
              name="modal"
              options=\\{{ title: "Modal", presentation: "modal" }}
            />
          </Stack>
        </GestureHandlerRootView>
      </ConvexProviderWithClerk>
    </ClerkProvider>
    {{else if (eq auth "better-auth")}}
    <ConvexBetterAuthProvider client={convex} authClient={authClient}>
      <GestureHandlerRootView style=\\{{ flex: 1 }}>
        <Stack
          screenOptions=\\{{
            headerStyle: {
              backgroundColor: theme.colors.background,
            },
            headerTitleStyle: {
              color: theme.colors.foreground,
            },
            headerTintColor: theme.colors.foreground,
          }}
        >
          <Stack.Screen name="(drawer)" options=\\{{ headerShown: false }} />
          <Stack.Screen
            name="modal"
            options=\\{{ title: "Modal", presentation: "modal" }}
          />
        </Stack>
      </GestureHandlerRootView>
    </ConvexBetterAuthProvider>
    {{else}}
    <ConvexProvider client={convex}>
      <GestureHandlerRootView style=\\{{ flex: 1 }}>
        <Stack
          screenOptions=\\{{
            headerStyle: {
              backgroundColor: theme.colors.background,
            },
            headerTitleStyle: {
              color: theme.colors.foreground,
            },
            headerTintColor: theme.colors.foreground,
          }}
        >
          <Stack.Screen name="(drawer)" options=\\{{ headerShown: false }} />
          <Stack.Screen
            name="modal"
            options=\\{{ title: "Modal", presentation: "modal" }}
          />
        </Stack>
      </GestureHandlerRootView>
    </ConvexProvider>
    {{/if}}
    {{else}}
      {{#unless (eq api "none")}}
    <QueryClientProvider client={queryClient}>
      <GestureHandlerRootView style=\\{{ flex: 1 }}>
        <Stack
          screenOptions=\\{{
            headerStyle: {
              backgroundColor: theme.colors.background,
            },
            headerTitleStyle: {
              color: theme.colors.foreground,
            },
            headerTintColor: theme.colors.foreground,
          }}
        >
          <Stack.Screen name="(drawer)" options=\\{{ headerShown: false }} />
          <Stack.Screen
            name="modal"
            options=\\{{ title: "Modal", presentation: "modal" }}
          />
        </Stack>
      </GestureHandlerRootView>
    </QueryClientProvider>
      {{else}}
      <GestureHandlerRootView style=\\{{ flex: 1 }}>
        <Stack
          screenOptions=\\{{
            headerStyle: {
              backgroundColor: theme.colors.background,
            },
            headerTitleStyle: {
              color: theme.colors.foreground,
            },
            headerTintColor: theme.colors.foreground,
          }}
        >
          <Stack.Screen name="(drawer)" options=\\{{ headerShown: false }} />
          <Stack.Screen
            name="modal"
            options=\\{{ title: "Modal", presentation: "modal" }}
          />
        </Stack>
      </GestureHandlerRootView>
      {{/unless}}
    {{/if}}
  );
}
`],
  ["frontend/native/unistyles/components/tabbar-icon.tsx.hbs", `import FontAwesome from "@expo/vector-icons/FontAwesome";

export const TabBarIcon = (props: {
  name: React.ComponentProps<typeof FontAwesome>["name"];
  color: string;
}) => {
  return <FontAwesome size={24} style=\\{{ marginBottom: -3 }} {...props} />;
};
`],
  ["frontend/native/unistyles/components/container.tsx.hbs", `import React from "react";
import { SafeAreaView } from "react-native-safe-area-context";
import { StyleSheet } from "react-native-unistyles";

export const Container = ({ children }: { children: React.ReactNode }) => {
  return <SafeAreaView style={styles.container}>{children}</SafeAreaView>;
};

const styles = StyleSheet.create((theme, rt) => ({
  container: {
    flex: 1,
    backgroundColor: theme.colors.background,
    paddingBottom: rt.insets.bottom,
  },
}));
`],
  ["frontend/native/unistyles/components/header-button.tsx.hbs", `import FontAwesome from "@expo/vector-icons/FontAwesome";
import { forwardRef } from "react";
import { Pressable } from "react-native";
import { StyleSheet } from "react-native-unistyles";

export const HeaderButton = forwardRef<
  typeof Pressable,
  { onPress?: () => void }
>(({ onPress }, ref) => {
  return (
    <Pressable onPress={onPress} style={styles.button}>
      {({ pressed }) => (
        <FontAwesome
          name="info-circle"
          size={20}
          color={styles.icon.color}
          style=\\{{
            opacity: pressed ? 0.7 : 1,
          }}
        />
      )}
    </Pressable>
  );
});

const styles = StyleSheet.create((theme) => ({
  button: {
    padding: theme.spacing.sm,
    marginRight: theme.spacing.sm,
    borderRadius: theme.borderRadius.lg,
    backgroundColor: \`\${theme.colors.secondary}80\`, // 50% opacity
  },
  icon: {
    color: theme.colors.secondaryForeground,
  },
}));
`],
  ["frontend/angular/src/app/app.routes.ts", `import { Routes } from "@angular/router";

import { HomeComponent } from "./pages/home/home.component";

export const routes: Routes = [{ path: "", component: HomeComponent }];
`],
  ["frontend/angular/src/app/app.config.ts", `import { ApplicationConfig, provideZoneChangeDetection } from "@angular/core";
import { provideRouter } from "@angular/router";

import { routes } from "./app.routes";

export const appConfig: ApplicationConfig = {
  providers: [provideZoneChangeDetection({ eventCoalescing: true }), provideRouter(routes)],
};
`],
  ["frontend/angular/src/app/app.component.ts.hbs", `import { Component } from '@angular/core';
import { RouterOutlet } from '@angular/router';
import { HeaderComponent } from './components/header.component';

@Component({
  selector: 'app-root',
  standalone: true,
  imports: [RouterOutlet, HeaderComponent],
  template: \`
    {{#if (eq cssFramework "tailwind")}}
    <div class="grid grid-rows-[auto_1fr] min-h-screen">
      <app-header />
      <main>
        <router-outlet />
      </main>
    </div>
    {{else}}
    <div [style.display]="'grid'" [style.gridTemplateRows]="'auto 1fr'" [style.minHeight]="'100vh'">
      <app-header />
      <main>
        <router-outlet />
      </main>
    </div>
    {{/if}}
  \`,
})
export class AppComponent {
  title = 'Better T Stack';
}
`],
  ["frontend/native/uniwind/app/+not-found.tsx.hbs", `import { Link, Stack } from "expo-router";
import { Button, Surface } from "heroui-native";
import { Text, View } from "react-native";

import { Container } from "@/components/container";

export default function NotFoundScreen() {
	return (
		<>
			<Stack.Screen options=\\{{ title: "Not Found" }} />
			<Container>
				<View className="flex-1 justify-center items-center p-4">
					<Surface variant="secondary" className="items-center p-6 max-w-sm rounded-lg">
						<Text className="text-4xl mb-3"></Text>
						<Text className="text-foreground font-medium text-lg mb-1">Page Not Found</Text>
						<Text className="text-muted text-sm text-center mb-4">
							The page you're looking for doesn't exist.
						</Text>
						<Link href="/" asChild>
							<Button size="sm">Go Home</Button>
						</Link>
					</Surface>
				</View>
			</Container>
		</>
	);
}
`],
  ["frontend/native/uniwind/app/modal.tsx.hbs", `import { Ionicons } from "@expo/vector-icons";
import { router } from "expo-router";
import { Button, Surface, useThemeColor } from "heroui-native";
import { Text, View } from "react-native";

import { Container } from "@/components/container";

function Modal() {
	const accentForegroundColor = useThemeColor("accent-foreground");

	function handleClose() {
		router.back();
	}

	return (
		<Container>
			<View className="flex-1 justify-center items-center p-4">
				<Surface variant="secondary" className="p-5 w-full max-w-sm rounded-lg">
					<View className="items-center">
						<View className="w-12 h-12 bg-accent rounded-lg items-center justify-center mb-3">
							<Ionicons name="checkmark" size={24} color={accentForegroundColor} />
						</View>
						<Text className="text-foreground font-medium text-lg mb-1">Modal Screen</Text>
						<Text className="text-muted text-sm text-center mb-4">
							This is an example modal screen for dialogs and confirmations.
						</Text>
					</View>
					<Button onPress={handleClose} className="w-full" size="sm">
						<Button.Label>Close</Button.Label>
					</Button>
				</Surface>
			</View>
		</Container>
	);
}

export default Modal;
`],
  ["frontend/native/uniwind/app/_layout.tsx.hbs", `{{#if (includes examples "ai")}}
import "@/polyfills";
{{/if}}

import "@/global.css";

{{#if (eq backend "convex")}}
  {{#if (eq auth "better-auth")}}
    import { ConvexReactClient } from "convex/react";
    import { ConvexBetterAuthProvider } from "@convex-dev/better-auth/react";
    import { authClient } from "@/lib/auth-client";
    import { env } from "@{{projectName}}/env/native";
  {{else}}
    import { ConvexProvider, ConvexReactClient } from "convex/react";
    import { env } from "@{{projectName}}/env/native";
  {{/if}}

  {{#if (eq auth "clerk")}}
    import { ClerkProvider, useAuth } from "@clerk/clerk-expo";
    import { ConvexProviderWithClerk } from "convex/react-clerk";
    import { tokenCache } from "@clerk/clerk-expo/token-cache";
  {{/if}}
{{else}}
  {{#unless (eq api "none")}}
    import { QueryClientProvider } from "@tanstack/react-query";
  {{/unless}}
{{/if}}

import { Stack } from "expo-router";
import { HeroUINativeProvider } from "heroui-native";
import { GestureHandlerRootView } from "react-native-gesture-handler";
import { KeyboardProvider } from "react-native-keyboard-controller";
import { AppThemeProvider } from "@/contexts/app-theme-context";

{{#if (eq api "trpc")}}
  import { queryClient } from "@/utils/trpc";
{{/if}}
{{#if (eq api "orpc")}}
  import { queryClient } from "@/utils/orpc";
{{/if}}

export const unstable_settings = {
  initialRouteName: "(drawer)",
};

{{#if (eq backend "convex")}}
  const convex = new ConvexReactClient(env.EXPO_PUBLIC_CONVEX_URL, {
    unsavedChangesWarning: false,
  });
{{/if}}

function StackLayout() {
  return (
    <Stack screenOptions=\\{{}}>
      <Stack.Screen name="(drawer)" options=\\{{ headerShown: false }} />
      {{#if (eq auth "clerk")}}
        <Stack.Screen name="(auth)" options=\\{{ headerShown: false }} />
      {{/if}}
      <Stack.Screen name="modal" options=\\{{ title: "Modal", presentation: "modal" }} />
    </Stack>
  );
}

export default function Layout() {
  return (
    {{#if (eq backend "convex")}}
      {{#if (eq auth "clerk")}}
        <ClerkProvider tokenCache={tokenCache} publishableKey={env.EXPO_PUBLIC_CLERK_PUBLISHABLE_KEY}>
          <ConvexProviderWithClerk client={convex} useAuth={useAuth}>
            <GestureHandlerRootView style=\\{{ flex: 1 }}>
              <KeyboardProvider>
                <AppThemeProvider>
                  <HeroUINativeProvider>
                    <StackLayout />
                  </HeroUINativeProvider>
                </AppThemeProvider>
              </KeyboardProvider>
            </GestureHandlerRootView>
          </ConvexProviderWithClerk>
        </ClerkProvider>
      {{else if (eq auth "better-auth")}}
        <ConvexBetterAuthProvider client={convex} authClient={authClient}>
          <GestureHandlerRootView style=\\{{ flex: 1 }}>
            <KeyboardProvider>
              <AppThemeProvider>
                <HeroUINativeProvider>
                  <StackLayout />
                </HeroUINativeProvider>
              </AppThemeProvider>
            </KeyboardProvider>
          </GestureHandlerRootView>
        </ConvexBetterAuthProvider>
      {{else}}
        <ConvexProvider client={convex}>
          <GestureHandlerRootView style=\\{{ flex: 1 }}>
            <KeyboardProvider>
              <AppThemeProvider>
                <HeroUINativeProvider>
                  <StackLayout />
                </HeroUINativeProvider>
              </AppThemeProvider>
            </KeyboardProvider>
          </GestureHandlerRootView>
        </ConvexProvider>
      {{/if}}
    {{else}}
      {{#unless (eq api "none")}}
        <QueryClientProvider client={queryClient}>
          <GestureHandlerRootView style=\\{{ flex: 1 }}>
            <KeyboardProvider>
              <AppThemeProvider>
                <HeroUINativeProvider>
                  <StackLayout />
                </HeroUINativeProvider>
              </AppThemeProvider>
            </KeyboardProvider>
          </GestureHandlerRootView>
        </QueryClientProvider>
      {{else}}
        <GestureHandlerRootView style=\\{{ flex: 1 }}>
          <KeyboardProvider>
            <AppThemeProvider>
              <HeroUINativeProvider>
                <StackLayout />
              </HeroUINativeProvider>
            </AppThemeProvider>
          </KeyboardProvider>
        </GestureHandlerRootView>
      {{/unless}}
    {{/if}}
  );
}`],
  ["frontend/nuxt/app/components/Header.vue.hbs", `<script setup lang="ts">
import type { NavigationMenuItem } from '@nuxt/ui'
{{#if (eq auth "better-auth")}}
import UserMenu from './UserMenu.vue'
{{/if}}

const route = useRoute()

const items = computed<NavigationMenuItem[]>(() => [
    { label: "Home", to: "/", active: route.path === "/" },
    {{#if (or (eq auth "better-auth") (eq auth "clerk"))}}
    { label: "Dashboard", to: "/dashboard", active: route.path.startsWith("/dashboard") },
    {{/if}}
    {{#if (includes examples "todo")}}
    { label: "Todos", to: "/todos", active: route.path.startsWith("/todos") },
    {{/if}}
    {{#if (includes examples "ai")}}
    { label: "AI Chat", to: "/ai", active: route.path.startsWith("/ai") },
    {{/if}}
])
</script>

<template>
  <UHeader>
    <template #left>
      <UNavigationMenu :items="items" />
    </template>

    <template #right>
      <UColorModeButton />
      {{#if (eq auth "better-auth")}}
      <UserMenu />
      {{/if}}
    </template>

    <template #body>
      <UNavigationMenu :items="items" orientation="vertical" class="-mx-2.5" />
    </template>
  </UHeader>
</template>
`],
  ["frontend/nuxt/app/pages/index.vue.hbs", `<script setup lang="ts">
{{#if (eq backend "convex")}}
import { api } from "@{{ projectName }}/backend/convex/_generated/api";
import { useConvexQuery } from "convex-vue";
{{else}}
  {{#unless (eq api "none")}}
const { $orpc } = useNuxtApp()
import { useQuery } from '@tanstack/vue-query'
  {{/unless}}
{{/if}}

const TITLE_TEXT = \`
  
 
                 
                 
               
                

          
      
                      
                      
                     
                      
 \`;

{{#if (eq backend "convex")}}
const healthCheck = useConvexQuery(api.healthCheck.get, {});
{{else}}
  {{#unless (eq api "none")}}
const healthCheck = useQuery($orpc.healthCheck.queryOptions())
  {{/unless}}
{{/if}}
</script>

<template>
  <UContainer class="py-8">
    <pre class="overflow-x-auto font-mono text-sm whitespace-pre-wrap">\\{{ TITLE_TEXT }}</pre>

    <div class="grid gap-6 mt-6">
      <UCard>
        <template #header>
          <div class="font-medium">API Status</div>
        </template>

        {{#if (eq backend "convex")}}
        <div class="flex items-center gap-2">
          <UIcon
            :name="healthCheck === undefined ? 'i-lucide-loader-2' : healthCheck.data.value === 'OK' ? 'i-lucide-check-circle' : 'i-lucide-x-circle'"
            :class="[
              healthCheck === undefined ? 'animate-spin text-muted' : '',
              healthCheck?.data.value === 'OK' ? 'text-success' : 'text-error'
            ]"
          />
          <span class="text-sm">
            \\{{
              healthCheck === undefined
                ? "Checking..."
                : healthCheck.data.value === "OK"
                  ? "Connected"
                  : "Error"
            }}
          </span>
        </div>
        {{else}}
        {{#unless (eq api "none")}}
        <div class="flex items-center gap-2">
          <UIcon
            :name="healthCheck.isLoading.value ? 'i-lucide-loader-2' : healthCheck.isSuccess.value ? 'i-lucide-check-circle' : 'i-lucide-x-circle'"
            :class="[
              healthCheck.isLoading.value ? 'animate-spin text-muted' : '',
              healthCheck.isSuccess.value ? 'text-success' : '',
              healthCheck.isError.value ? 'text-error' : ''
            ]"
          />
          <span class="text-sm">
            <template v-if="healthCheck.isLoading.value">
              Checking...
            </template>
            <template v-else-if="healthCheck.isSuccess.value">
              Connected (\\{{ healthCheck.data.value }})
            </template>
            <template v-else-if="healthCheck.isError.value">
              Error: \\{{ healthCheck.error.value?.message || 'Failed to connect' }}
            </template>
            <template v-else>
              Idle
            </template>
          </span>
        </div>
        {{/unless}}
        {{/if}}
      </UCard>
    </div>
  </UContainer>
</template>
`],
  ["frontend/native/uniwind/contexts/app-theme-context.tsx.hbs", `import React, { createContext, useCallback, useContext, useMemo } from 'react';
import { Uniwind, useUniwind } from 'uniwind';

type ThemeName = 'light' | 'dark';

type AppThemeContextType = {
    currentTheme: string;
    isLight: boolean;
    isDark: boolean;
    setTheme: (theme: ThemeName) => void;
    toggleTheme: () => void;
}

const AppThemeContext = createContext<AppThemeContextType | undefined>(
    undefined
);

export const AppThemeProvider = ({ children }: { children: React.ReactNode }) => {
    const { theme } = useUniwind();

    const isLight = useMemo(() => {
        return theme === 'light';
    }, [theme]);

    const isDark = useMemo(() => {
        return theme === 'dark';
    }, [theme]);

    const setTheme = useCallback((newTheme: ThemeName) => {
        Uniwind.setTheme(newTheme);
    }, []);

    const toggleTheme = useCallback(() => {
        Uniwind.setTheme(theme === 'light' ? 'dark' : 'light');
    }, [theme]);

    const value = useMemo(
        () => ({
            currentTheme: theme,
            isLight,
            isDark,
            setTheme,
            toggleTheme,
        }),
        [theme, isLight, isDark, setTheme, toggleTheme]
    );

    return (
        <AppThemeContext.Provider value={value}>
            {children}
        </AppThemeContext.Provider>
    );
};

export function useAppTheme() {
    const context = useContext(AppThemeContext);
    if (!context) {
        throw new Error('useAppTheme must be used within AppThemeProvider');
    }
    return context;
}

`],
  ["frontend/native/bare/app/+not-found.tsx.hbs", `import { Container } from "@/components/container";
import { Link, Stack } from "expo-router";
import { Text, View, StyleSheet } from "react-native";
import { useColorScheme } from "@/lib/use-color-scheme";
import { NAV_THEME } from "@/lib/constants";

export default function NotFoundScreen() {
  const { colorScheme } = useColorScheme();
  const theme = colorScheme === "dark" ? NAV_THEME.dark : NAV_THEME.light;

  return (
    <>
      <Stack.Screen options=\\{{ title: "Oops!" }} />
      <Container>
        <View style={styles.container}>
          <View style={styles.content}>
            <Text style={styles.emoji}></Text>
            <Text style={[styles.title, { color: theme.text }]}>
              Page Not Found
            </Text>
            <Text style={[styles.subtitle, { color: theme.text, opacity: 0.7 }]}>
              Sorry, the page you're looking for doesn't exist.
            </Text>
            <Link href="/" asChild>
              <Text style={[styles.link, { color: theme.primary, backgroundColor: \`\${theme.primary}1a\` }]}>
                Go to Home
              </Text>
            </Link>
          </View>
        </View>
      </Container>
    </>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    padding: 16,
  },
  content: {
    alignItems: "center",
  },
  emoji: {
    fontSize: 48,
    marginBottom: 16,
  },
  title: {
    fontSize: 20,
    fontWeight: "bold",
    marginBottom: 8,
    textAlign: "center",
  },
  subtitle: {
    fontSize: 14,
    textAlign: "center",
    marginBottom: 24,
  },
  link: {
    padding: 12,
  },
});

`],
  ["frontend/native/bare/app/modal.tsx.hbs", `import { Container } from "@/components/container";
import { Text, View, StyleSheet } from "react-native";
import { useColorScheme } from "@/lib/use-color-scheme";
import { NAV_THEME } from "@/lib/constants";

export default function Modal() {
  const { colorScheme } = useColorScheme();
  const theme = colorScheme === "dark" ? NAV_THEME.dark : NAV_THEME.light;

  return (
    <Container>
      <View style={styles.container}>
        <View style={styles.header}>
          <Text style={[styles.title, { color: theme.text }]}>Modal</Text>
        </View>
      </View>
    </Container>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16,
  },
  header: {
    marginBottom: 16,
  },
  title: {
    fontSize: 20,
    fontWeight: "bold",
  },
});

`],
  ["frontend/native/bare/app/_layout.tsx.hbs", `{{#if (includes examples "ai")}}
import "@/polyfills";
{{/if}}

{{#if (eq backend "convex")}}
  {{#if (eq auth "better-auth")}}
    import { ConvexReactClient } from "convex/react";
    import { ConvexBetterAuthProvider } from "@convex-dev/better-auth/react";
    import { authClient } from "@/lib/auth-client";
    import { env } from "@{{projectName}}/env/native";
  {{else}}
    import { ConvexProvider, ConvexReactClient } from "convex/react";
    import { env } from "@{{projectName}}/env/native";
  {{/if}}
  {{#if (eq auth "clerk")}}
    import { ClerkProvider, useAuth } from "@clerk/clerk-expo";
    import { ConvexProviderWithClerk } from "convex/react-clerk";
    import { tokenCache } from "@clerk/clerk-expo/token-cache";
  {{/if}}
{{else}}
  {{#unless (eq api "none")}}
    import { QueryClientProvider } from "@tanstack/react-query";
  {{/unless}}
{{/if}}

import { Stack } from "expo-router";
import {
  DarkTheme,
  DefaultTheme,
  type Theme,
  ThemeProvider,
} from "@react-navigation/native";
import { StatusBar } from "expo-status-bar";
import { GestureHandlerRootView } from "react-native-gesture-handler";
{{#if (eq api "trpc")}}
import { queryClient } from "@/utils/trpc";
{{/if}}
{{#if (eq api "orpc")}}
import { queryClient } from "@/utils/orpc";
{{/if}}
import { NAV_THEME } from "@/lib/constants";
import React, { useRef } from "react";
import { useColorScheme } from "@/lib/use-color-scheme";
import { Platform, StyleSheet } from "react-native";
import { setAndroidNavigationBar } from "@/lib/android-navigation-bar";

const LIGHT_THEME: Theme = {
  ...DefaultTheme,
  colors: NAV_THEME.light,
};
const DARK_THEME: Theme = {
  ...DarkTheme,
  colors: NAV_THEME.dark,
};

export const unstable_settings = {
  initialRouteName: "(drawer)",
};

{{#if (eq backend "convex")}}
const convex = new ConvexReactClient(env.EXPO_PUBLIC_CONVEX_URL, {
  unsavedChangesWarning: false,
});
{{/if}}

const useIsomorphicLayoutEffect =
  Platform.OS === "web" && typeof window === "undefined"
    ? React.useEffect
    : React.useLayoutEffect;

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
});

export default function RootLayout() {
  const hasMounted = useRef(false);
  const { colorScheme, isDarkColorScheme } = useColorScheme();
  const [isColorSchemeLoaded, setIsColorSchemeLoaded] = React.useState(false);

  useIsomorphicLayoutEffect(() => {
    if (hasMounted.current) {
      return;
    }
    setAndroidNavigationBar(colorScheme);
    setIsColorSchemeLoaded(true);
    hasMounted.current = true;
  }, []);

  if (!isColorSchemeLoaded) {
    return null;
  }

  return (
    <>
      {{#if (eq backend "convex")}}
        {{#if (eq auth "clerk")}}
          <ClerkProvider tokenCache={tokenCache} publishableKey={env.EXPO_PUBLIC_CLERK_PUBLISHABLE_KEY}>
            <ConvexProviderWithClerk client={convex} useAuth={useAuth}>
              <ThemeProvider value={isDarkColorScheme ? DARK_THEME : LIGHT_THEME}>
                <StatusBar style={isDarkColorScheme ? "light" : "dark"} />
                <GestureHandlerRootView style={styles.container}>
                  <Stack>
                    <Stack.Screen name="(drawer)" options=\\{{ headerShown: false }} />
                    <Stack.Screen name="(auth)" options=\\{{ headerShown: false }} />
                    <Stack.Screen name="modal" options=\\{{ title: "Modal", presentation: "modal" }} />
                  </Stack>
                </GestureHandlerRootView>
              </ThemeProvider>
            </ConvexProviderWithClerk>
          </ClerkProvider>
        {{else if (eq auth "better-auth")}}
          <ConvexBetterAuthProvider client={convex} authClient={authClient}>
            <ThemeProvider value={isDarkColorScheme ? DARK_THEME : LIGHT_THEME}>
              <StatusBar style={isDarkColorScheme ? "light" : "dark"} />
              <GestureHandlerRootView style={styles.container}>
                <Stack>
                  <Stack.Screen name="(drawer)" options=\\{{ headerShown: false }} />
                  <Stack.Screen name="modal" options=\\{{ title: "Modal", presentation: "modal" }} />
                </Stack>
              </GestureHandlerRootView>
            </ThemeProvider>
          </ConvexBetterAuthProvider>
        {{else}}
          <ConvexProvider client={convex}>
            <ThemeProvider value={isDarkColorScheme ? DARK_THEME : LIGHT_THEME}>
              <StatusBar style={isDarkColorScheme ? "light" : "dark"} />
              <GestureHandlerRootView style={styles.container}>
                <Stack>
                  <Stack.Screen name="(drawer)" options=\\{{ headerShown: false }} />
                  <Stack.Screen name="modal" options=\\{{ title: "Modal", presentation: "modal" }} />
                </Stack>
              </GestureHandlerRootView>
            </ThemeProvider>
          </ConvexProvider>
        {{/if}}
      {{else}}
        {{#unless (eq api "none")}}
          <QueryClientProvider client={queryClient}>
            <ThemeProvider value={isDarkColorScheme ? DARK_THEME : LIGHT_THEME}>
              <StatusBar style={isDarkColorScheme ? "light" : "dark"} />
              <GestureHandlerRootView style={styles.container}>
                <Stack>
                  <Stack.Screen name="(drawer)" options=\\{{ headerShown: false }} />
                  <Stack.Screen name="modal" options=\\{{ title: "Modal", presentation: "modal" }} />
                </Stack>
              </GestureHandlerRootView>
            </ThemeProvider>
          </QueryClientProvider>
        {{else}}
          <ThemeProvider value={isDarkColorScheme ? DARK_THEME : LIGHT_THEME}>
            <StatusBar style={isDarkColorScheme ? "light" : "dark"} />
            <GestureHandlerRootView style={styles.container}>
              <Stack>
                <Stack.Screen name="(drawer)" options=\\{{ headerShown: false }} />
                <Stack.Screen name="modal" options=\\{{ title: "Modal", presentation: "modal" }} />
              </Stack>
            </GestureHandlerRootView>
          </ThemeProvider>
        {{/unless}}
      {{/if}}
    </>
  );
}`],
  ["frontend/native/uniwind/components/container.tsx.hbs", `import { cn } from "heroui-native";
import { type PropsWithChildren } from "react";
import { ScrollView, View, type ViewProps } from "react-native";
import Animated, { type AnimatedProps } from "react-native-reanimated";
import { useSafeAreaInsets } from "react-native-safe-area-context";

const AnimatedView = Animated.createAnimatedComponent(View);

type Props = AnimatedProps<ViewProps> & {
	className?: string;
};

export function Container({
	children,
	className,
	...props
}: PropsWithChildren<Props>) {
	const insets = useSafeAreaInsets();

	return (
		<AnimatedView
			className={cn("flex-1 bg-background", className)}
			style=\\{{
				paddingBottom: insets.bottom,
			}}
			{...props}
		>
			<ScrollView contentContainerStyle=\\{{ flexGrow: 1 }}>
				{children}
			</ScrollView>
		</AnimatedView>
	);
}
`],
  ["frontend/native/uniwind/components/theme-toggle.tsx.hbs", `import { Ionicons } from '@expo/vector-icons';
import * as Haptics from 'expo-haptics';
import { Platform, Pressable } from 'react-native';
import Animated, { FadeOut, ZoomIn } from 'react-native-reanimated';
import { withUniwind } from 'uniwind';
import { useAppTheme } from '@/contexts/app-theme-context';

const StyledIonicons = withUniwind(Ionicons);

export function ThemeToggle() {
	const { toggleTheme, isLight } = useAppTheme();

	return (
		<Pressable
			onPress={() => {
				if (Platform.OS === 'ios') {
					Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
				}
				toggleTheme();
			}}
			className="px-2.5"
		>
			{isLight ? (
				<Animated.View key="moon" entering={ZoomIn} exiting={FadeOut}>
					<StyledIonicons name="moon" size={20} className="text-foreground" />
				</Animated.View>
			) : (
				<Animated.View key="sun" entering={ZoomIn} exiting={FadeOut}>
					<StyledIonicons name="sunny" size={20} className="text-foreground" />
				</Animated.View>
			)}
		</Pressable>
	);
}

`],
  ["frontend/native/bare/lib/constants.ts.hbs", `export const NAV_THEME = {
  light: {
    background: "hsl(0 0% 100%)",
    border: "hsl(220 13% 91%)",
    card: "hsl(0 0% 100%)",
    notification: "hsl(0 84.2% 60.2%)",
    primary: "hsl(221.2 83.2% 53.3%)",
    text: "hsl(222.2 84% 4.9%)",
  },
  dark: {
    background: "hsl(222.2 84% 4.9%)",
    border: "hsl(217.2 32.6% 17.5%)",
    card: "hsl(222.2 84% 4.9%)",
    notification: "hsl(0 72% 51%)",
    primary: "hsl(217.2 91.2% 59.8%)",
    text: "hsl(210 40% 98%)",
  },
};

`],
  ["frontend/native/bare/lib/use-color-scheme.ts.hbs", `import { useColorScheme as useRNColorScheme } from "react-native";

export function useColorScheme() {
  const systemColorScheme = useRNColorScheme();
  const colorScheme = systemColorScheme ?? "light";
  
  return {
    colorScheme: colorScheme as "light" | "dark",
    isDarkColorScheme: colorScheme === "dark",
    setColorScheme: () => {
      // Color scheme is managed by the system in bare mode
      console.warn("setColorScheme is not available in bare mode. Color scheme is managed by the system.");
    },
    toggleColorScheme: () => {
      // Color scheme is managed by the system in bare mode
      console.warn("toggleColorScheme is not available in bare mode. Color scheme is managed by the system.");
    },
  };
}

`],
  ["frontend/native/bare/lib/android-navigation-bar.tsx.hbs", `import * as NavigationBar from "expo-navigation-bar";
import { Platform } from "react-native";
import { NAV_THEME } from "@/lib/constants";

export async function setAndroidNavigationBar(theme: "light" | "dark") {
  if (Platform.OS !== "android") return;
  await NavigationBar.setButtonStyleAsync(theme === "dark" ? "light" : "dark");
  await NavigationBar.setBackgroundColorAsync(
    theme === "dark" ? NAV_THEME.dark.background : NAV_THEME.light.background,
  );
}

`],
  ["frontend/native/bare/components/tabbar-icon.tsx.hbs", `import FontAwesome from "@expo/vector-icons/FontAwesome";

export const TabBarIcon = (props: {
  name: React.ComponentProps<typeof FontAwesome>["name"];
  color: string;
}) => {
  return <FontAwesome size={24} style=\\{{ marginBottom: -3 }} {...props} />;
};

`],
  ["frontend/native/bare/components/container.tsx.hbs", `import React from "react";
import { SafeAreaView } from "react-native-safe-area-context";
import { useColorScheme } from "@/lib/use-color-scheme";
import { NAV_THEME } from "@/lib/constants";
import { StyleSheet } from "react-native";

export function Container({ children }: { children: React.ReactNode }) {
  const { colorScheme } = useColorScheme();
  const backgroundColor = colorScheme === "dark" 
    ? NAV_THEME.dark.background 
    : NAV_THEME.light.background;

  return (
    <SafeAreaView style={[styles.container, { backgroundColor }]}>
      {children}
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
});

`],
  ["frontend/native/bare/components/header-button.tsx.hbs", `import FontAwesome from "@expo/vector-icons/FontAwesome";
import { forwardRef } from "react";
import { Pressable, StyleSheet, View } from "react-native";
import { useColorScheme } from "@/lib/use-color-scheme";
import { NAV_THEME } from "@/lib/constants";

export const HeaderButton = forwardRef<
  View,
  { onPress?: () => void }
>(({ onPress }, ref) => {
  const { colorScheme } = useColorScheme();
  const theme = colorScheme === "dark" ? NAV_THEME.dark : NAV_THEME.light;

  return (
    <Pressable
      ref={ref}
      onPress={onPress}
      style={({ pressed }) => [
        styles.button,
        {
          backgroundColor: pressed 
            ? theme.background 
            : theme.card,
        },
      ]}
    >
      {({ pressed }) => (
        <FontAwesome
          name="info-circle"
          size={20}
          color={theme.text}
          style=\\{{
            opacity: pressed ? 0.7 : 1,
          }}
        />
      )}
    </Pressable>
  );
});

const styles = StyleSheet.create({
  button: {
    padding: 8,
    marginRight: 8,
  },
});

`],
  ["frontend/nuxt/app/layouts/default.vue.hbs", `<script setup></script>

<template>
  <div class="grid grid-rows-[auto_1fr] h-svh">
    <Header />
    <UMain>
      <slot />
    </UMain>
  </div>
</template>
`],
  ["frontend/react/react-router/public/favicon.ico", `[Binary file]`],
  ["frontend/react/react-router/src/routes.ts", `import { type RouteConfig } from "@react-router/dev/routes";
import { flatRoutes } from "@react-router/fs-routes";

export default flatRoutes() satisfies RouteConfig;
`],
  ["frontend/react/react-router/src/root.tsx.hbs", `import {
  isRouteErrorResponse,
  Links,
  Meta,
  Outlet,
  Scripts,
  ScrollRestoration,
} from "react-router";
import type { Route } from "./+types/root";
import "./index.css";
import Header from "./components/header";
import { ThemeProvider } from "./components/theme-provider";
import { Toaster } from "./components/ui/sonner";

{{#if (eq backend "convex")}}
import { ConvexReactClient } from "convex/react";
import { env } from "@{{projectName}}/env/web";
{{#if (eq auth "clerk")}}
import { ClerkProvider, useAuth } from "@clerk/clerk-react";
import { ConvexProviderWithClerk } from "convex/react-clerk";
{{else}}
import { ConvexProvider } from "convex/react";
{{/if}}
{{else}}
  {{#unless (eq api "none")}}
import { QueryClientProvider } from "@tanstack/react-query";
import { ReactQueryDevtools } from "@tanstack/react-query-devtools";
    {{#if (eq api "orpc")}}
import { queryClient } from "./utils/orpc";
    {{/if}}
    {{#if (eq api "trpc")}}
import { queryClient } from "./utils/trpc";
    {{/if}}
  {{/unless}}
{{/if}}

export const links: Route.LinksFunction = () => [
  { rel: "preconnect", href: "https://fonts.googleapis.com" },
  { rel: "preconnect", href: "https://fonts.gstatic.com", crossOrigin: "anonymous" },
  {
    rel: "stylesheet",
    href:
      "https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap",
  },
];

export function Layout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en">
      <head>
        <meta charSet="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <Meta />
        <Links />
      </head>
      <body>
        {children}
        <ScrollRestoration />
        <Scripts />
      </body>
    </html>
  );
}

{{#if (eq backend "convex")}}
export default function App() {
  const convex = new ConvexReactClient(env.VITE_CONVEX_URL);
  {{#if (eq auth "clerk")}}
  return (
    <ClerkProvider publishableKey={env.VITE_CLERK_PUBLISHABLE_KEY}>
      <ConvexProviderWithClerk client={convex} useAuth={useAuth}>
        <ThemeProvider
          attribute="class"
          defaultTheme="dark"
          disableTransitionOnChange
          storageKey="vite-ui-theme"
        >
          <div className="grid grid-rows-[auto_1fr] h-svh">
            <Header />
            <Outlet />
          </div>
          <Toaster richColors />
        </ThemeProvider>
      </ConvexProviderWithClerk>
    </ClerkProvider>
  );
  {{else}}
  return (
    <ConvexProvider client={convex}>
      <ThemeProvider
        attribute="class"
        defaultTheme="dark"
        disableTransitionOnChange
        storageKey="vite-ui-theme"
      >
        <div className="grid grid-rows-[auto_1fr] h-svh">
          <Header />
          <Outlet />
        </div>
        <Toaster richColors />
      </ThemeProvider>
    </ConvexProvider>
  );
  {{/if}}
}
{{else if (eq api "orpc")}}
export default function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <ThemeProvider
        attribute="class"
        defaultTheme="dark"
        disableTransitionOnChange
        storageKey="vite-ui-theme"
      >
        <div className="grid grid-rows-[auto_1fr] h-svh">
          <Header />
          <Outlet />
        </div>
        <Toaster richColors />
      </ThemeProvider>
      <ReactQueryDevtools position="bottom" buttonPosition="bottom-right" />
    </QueryClientProvider>
  );
}
{{else if (eq api "trpc")}}
export default function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <ThemeProvider
        attribute="class"
        defaultTheme="dark"
        disableTransitionOnChange
        storageKey="vite-ui-theme"
      >
        <div className="grid grid-rows-[auto_1fr] h-svh">
          <Header />
          <Outlet />
        </div>
        <Toaster richColors />
      </ThemeProvider>
      <ReactQueryDevtools position="bottom" buttonPosition="bottom-right" />
    </QueryClientProvider>
  );
}
{{else}}
export default function App() {
  return (
    <ThemeProvider
      attribute="class"
      defaultTheme="dark"
      disableTransitionOnChange
      storageKey="vite-ui-theme"
    >
      <div className="grid grid-rows-[auto_1fr] h-svh">
        <Header />
        <Outlet />
      </div>
      <Toaster richColors />
    </ThemeProvider>
  );
}
{{/if}}

export function ErrorBoundary({ error }: Route.ErrorBoundaryProps) {
  let message = "Oops!";
  let details = "An unexpected error occurred.";
  let stack: string | undefined;
  if (isRouteErrorResponse(error)) {
    message = error.status === 404 ? "404" : "Error";
    details =
      error.status === 404
        ? "The requested page could not be found."
        : error.statusText || details;
  } else if (import.meta.env.DEV && error && error instanceof Error) {
    details = error.message;
    stack = error.stack;
  }
  return (
    <main className="pt-16 p-4 container mx-auto">
      <h1>{message}</h1>
      <p>{details}</p>
      {stack && (
        <pre className="w-full p-4 overflow-x-auto">
          <code>{stack}</code>
        </pre>
      )}
    </main>
  );
}
`],
  ["backend/convex/packages/backend/package.json.hbs", `{
  "name": "@{{projectName}}/backend",
  "version": "1.0.0",
  "scripts": {
    "dev": "convex dev",
    "dev:setup": "convex dev --configure --until-success"
  },
  "author": "",
  "license": "ISC",
  "description": "",
  "devDependencies": {
    "@types/node": "^24.3.0"
  },
  "dependencies": {}
}
`],
  ["backend/convex/packages/backend/_gitignore", `
.env.local
`],
  ["frontend/react/tanstack-router/src/main.tsx.hbs", `import { RouterProvider, createRouter } from "@tanstack/react-router";
import ReactDOM from "react-dom/client";
import Loader from "./components/loader";
import { routeTree } from "./routeTree.gen";

{{#if (eq api "orpc")}}
  import { QueryClientProvider } from "@tanstack/react-query";
  import { orpc, queryClient } from "./utils/orpc";
{{/if}}
{{#if (eq api "trpc")}}
  import { QueryClientProvider } from "@tanstack/react-query";
  import { queryClient, trpc } from "./utils/trpc";
{{/if}}
{{#if (eq backend "convex")}}
  import { ConvexReactClient } from "convex/react";
  import { env } from "@{{projectName}}/env/web";
  {{#if (eq auth "clerk")}}
  import { ClerkProvider, useAuth } from "@clerk/clerk-react";
  import { ConvexProviderWithClerk } from "convex/react-clerk";
  {{else if (eq auth "better-auth")}}
  import { ConvexBetterAuthProvider } from "@convex-dev/better-auth/react";
  import { authClient } from "@/lib/auth-client";
  {{else}}
  import { ConvexProvider } from "convex/react";
  {{/if}}
  const convex = new ConvexReactClient(env.VITE_CONVEX_URL);
{{/if}}

const router = createRouter({
  routeTree,
  defaultPreload: "intent",
  defaultPendingComponent: () => <Loader />,
  {{#if (eq api "orpc")}}
  context: { orpc, queryClient },
  Wrap: function WrapComponent({ children }: { children: React.ReactNode }) {
    return (
      <QueryClientProvider client={queryClient}>
        {children}
      </QueryClientProvider>
    );
  },
  {{else if (eq api "trpc")}}
  context: { trpc, queryClient },
  Wrap: function WrapComponent({ children }: { children: React.ReactNode }) {
    return (
      <QueryClientProvider client={queryClient}>
        {children}
      </QueryClientProvider>
    );
  },
  {{else if (eq backend "convex")}}
  context: {},
  Wrap: function WrapComponent({ children }: { children: React.ReactNode }) {
    {{#if (eq auth "clerk")}}
    return (
      <ClerkProvider
        publishableKey={env.VITE_CLERK_PUBLISHABLE_KEY}
      >
        <ConvexProviderWithClerk client={convex} useAuth={useAuth}>
          {children}
        </ConvexProviderWithClerk>
      </ClerkProvider>
    );
    {{else if (eq auth "better-auth")}}
    return <ConvexBetterAuthProvider client={convex} authClient={authClient}>{children}</ConvexBetterAuthProvider>;
    {{else}}
    return <ConvexProvider client={convex}>{children}</ConvexProvider>;
    {{/if}}
  },
  {{else}}
  context: {},
  {{/if}}
});

declare module "@tanstack/react-router" {
  interface Register {
    router: typeof router;
  }
}

const rootElement = document.getElementById("app");

if (!rootElement) {
  throw new Error("Root element not found");
}

if (!rootElement.innerHTML) {
  const root = ReactDOM.createRoot(rootElement);
  root.render(<RouterProvider router={router} />);
}
`],
  ["frontend/react/tanstack-start/public/robots.txt", `# https://www.robotstxt.org/robotstxt.html
User-agent: *
Disallow:
`],
  ["frontend/react/web-base/src/index.css.hbs", `{{#if (eq cssFramework "tailwind")}}
@import 'tailwindcss';
@import 'tw-animate-css';
{{#if (eq uiLibrary "shadcn-ui")}}
@import 'shadcn/tailwind.css';
{{/if}}
{{#if (includes examples "ai")}}
@source "../node_modules/streamdown/dist/*.js";
{{/if}}

@custom-variant dark (&:is(.dark *));

{{#if (eq uiLibrary "shadcn-ui")}}
:root {
  --background: oklch(1 0 0);
  --foreground: oklch(0.145 0 0);
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.145 0 0);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.145 0 0);
  --primary: oklch(0.205 0 0);
  --primary-foreground: oklch(0.985 0 0);
  --secondary: oklch(0.97 0 0);
  --secondary-foreground: oklch(0.205 0 0);
  --muted: oklch(0.97 0 0);
  --muted-foreground: oklch(0.556 0 0);
  --accent: oklch(0.97 0 0);
  --accent-foreground: oklch(0.205 0 0);
  --destructive: oklch(0.58 0.22 27);
  --border: oklch(0.922 0 0);
  --input: oklch(0.922 0 0);
  --ring: oklch(0.708 0 0);
  --chart-1: oklch(0.809 0.105 251.813);
  --chart-2: oklch(0.623 0.214 259.815);
  --chart-3: oklch(0.546 0.245 262.881);
  --chart-4: oklch(0.488 0.243 264.376);
  --chart-5: oklch(0.424 0.199 265.638);
  --radius: 0.625rem;
  --sidebar: oklch(0.985 0 0);
  --sidebar-foreground: oklch(0.145 0 0);
  --sidebar-primary: oklch(0.205 0 0);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.97 0 0);
  --sidebar-accent-foreground: oklch(0.205 0 0);
  --sidebar-border: oklch(0.922 0 0);
  --sidebar-ring: oklch(0.708 0 0);
}

.dark {
  --background: oklch(0.145 0 0);
  --foreground: oklch(0.985 0 0);
  --card: oklch(0.205 0 0);
  --card-foreground: oklch(0.985 0 0);
  --popover: oklch(0.205 0 0);
  --popover-foreground: oklch(0.985 0 0);
  --primary: oklch(0.87 0 0);
  --primary-foreground: oklch(0.205 0 0);
  --secondary: oklch(0.269 0 0);
  --secondary-foreground: oklch(0.985 0 0);
  --muted: oklch(0.269 0 0);
  --muted-foreground: oklch(0.708 0 0);
  --accent: oklch(0.371 0 0);
  --accent-foreground: oklch(0.985 0 0);
  --destructive: oklch(0.704 0.191 22.216);
  --border: oklch(1 0 0 / 10%);
  --input: oklch(1 0 0 / 15%);
  --ring: oklch(0.556 0 0);
  --chart-1: oklch(0.809 0.105 251.813);
  --chart-2: oklch(0.623 0.214 259.815);
  --chart-3: oklch(0.546 0.245 262.881);
  --chart-4: oklch(0.488 0.243 264.376);
  --chart-5: oklch(0.424 0.199 265.638);
  --sidebar: oklch(0.205 0 0);
  --sidebar-foreground: oklch(0.985 0 0);
  --sidebar-primary: oklch(0.488 0.243 264.376);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.269 0 0);
  --sidebar-accent-foreground: oklch(0.985 0 0);
  --sidebar-border: oklch(1 0 0 / 10%);
  --sidebar-ring: oklch(0.556 0 0);
}

@theme inline {
  --font-sans: 'Inter Variable', sans-serif;
  --color-sidebar-ring: var(--sidebar-ring);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar: var(--sidebar);
  --color-chart-5: var(--chart-5);
  --color-chart-4: var(--chart-4);
  --color-chart-3: var(--chart-3);
  --color-chart-2: var(--chart-2);
  --color-chart-1: var(--chart-1);
  --color-ring: var(--ring);
  --color-input: var(--input);
  --color-border: var(--border);
  --color-destructive: var(--destructive);
  --color-accent-foreground: var(--accent-foreground);
  --color-accent: var(--accent);
  --color-muted-foreground: var(--muted-foreground);
  --color-muted: var(--muted);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-secondary: var(--secondary);
  --color-primary-foreground: var(--primary-foreground);
  --color-primary: var(--primary);
  --color-popover-foreground: var(--popover-foreground);
  --color-popover: var(--popover);
  --color-card-foreground: var(--card-foreground);
  --color-card: var(--card);
  --color-foreground: var(--foreground);
  --color-background: var(--background);
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
  --radius-2xl: calc(var(--radius) + 8px);
  --radius-3xl: calc(var(--radius) + 12px);
  --radius-4xl: calc(var(--radius) + 16px);
}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply font-sans bg-background text-foreground;
  }
  html {
    @apply font-sans;
  }
}
{{else}}
/* Basic Tailwind setup without shadcn-ui theme */
@layer base {
  body {
    font-family: 'Inter Variable', system-ui, sans-serif;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }
}
{{/if}}
{{else}}
/* Non-Tailwind CSS framework styles */
:root {
  --color-background: #ffffff;
  --color-foreground: #1a1a1a;
  --color-primary: #3b82f6;
  --color-secondary: #64748b;
}

.dark {
  --color-background: #1a1a1a;
  --color-foreground: #fafafa;
  --color-primary: #60a5fa;
  --color-secondary: #94a3b8;
}

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: 'Inter Variable', system-ui, sans-serif;
  background-color: var(--color-background);
  color: var(--color-foreground);
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}
{{/if}}
`],
  ["frontend/react/tanstack-start/src/router.tsx.hbs", `{{#if (eq backend "convex")}}
import { createRouter as createTanStackRouter } from "@tanstack/react-router";
import { QueryClient } from "@tanstack/react-query";
import { setupRouterSsrQueryIntegration } from "@tanstack/react-router-ssr-query";
import { ConvexQueryClient } from "@convex-dev/react-query";
import { routeTree } from "./routeTree.gen";
import Loader from "./components/loader";
import "./index.css";
import { env } from "@{{projectName}}/env/web";
{{else}}
import { createRouter as createTanStackRouter } from "@tanstack/react-router";
import Loader from "./components/loader";
import "./index.css";
import { routeTree } from "./routeTree.gen";
{{#if (eq api "trpc")}}
import { QueryCache, QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { createTRPCClient, httpBatchLink } from "@trpc/client";
import { createTRPCOptionsProxy } from "@trpc/tanstack-react-query";
import { toast } from "sonner";
import type { AppRouter } from "@{{projectName}}/api/routers/index";
import { TRPCProvider } from "./utils/trpc";
{{#unless (eq backend "self")}}
import { env } from "@{{projectName}}/env/web";
{{/unless}}
{{else if (eq api "orpc")}}
import { QueryClientProvider } from "@tanstack/react-query";
import { orpc, queryClient } from "./utils/orpc";
{{/if}}
{{/if}}

{{#if (eq backend "convex")}}
export function getRouter() {
	const convexUrl = env.VITE_CONVEX_URL;
	if (!convexUrl) {
		throw new Error("VITE_CONVEX_URL is not set");
	}

	const convexQueryClient = new ConvexQueryClient(convexUrl);

	const queryClient: QueryClient = new QueryClient({
		defaultOptions: {
			queries: {
				queryKeyHashFn: convexQueryClient.hashFn(),
				queryFn: convexQueryClient.queryFn(),
			},
		},
	});
	convexQueryClient.connect(queryClient);

	const router = createTanStackRouter({
		routeTree,
		defaultPreload: "intent",
		defaultPendingComponent: () => <Loader />,
		defaultNotFoundComponent: () => <div>Not Found</div>,
		context: { queryClient, convexQueryClient },
	});

	setupRouterSsrQueryIntegration({
		router,
		queryClient,
	});

	return router;
}
{{else}}
{{#if (eq api "trpc")}}
export const queryClient = new QueryClient({
	queryCache: new QueryCache({
		onError: (error, query) => {
			toast.error(error.message, {
				action: {
					label: "retry",
					onClick: query.invalidate,
				},
			});
		},
	}),
	defaultOptions: { queries: { staleTime: 60 * 1000 } },
});

const trpcClient = createTRPCClient<AppRouter>({
	links: [
		httpBatchLink({
			url: {{#if (eq backend "self")}}"/api/trpc"{{else}}\`\${env.VITE_SERVER_URL}/trpc\`{{/if}},
{{#if (eq auth "better-auth")}}
			fetch(url, options) {
				return fetch(url, {
					...options,
					credentials: "include",
				});
			},
{{/if}}
		}),
	],
});

const trpc = createTRPCOptionsProxy({
	client: trpcClient,
	queryClient: queryClient,
});
{{else if (eq api "orpc")}}
{{/if}}

export const getRouter = () => {
	const router = createTanStackRouter({
		routeTree,
		scrollRestoration: true,
		defaultPreloadStaleTime: 0,
{{#if (eq api "trpc")}}
		context: { trpc, queryClient },
{{else if (eq api "orpc")}}
		context: { orpc, queryClient },
{{else}}
		context: {},
{{/if}}
		defaultPendingComponent: () => <Loader />,
		defaultNotFoundComponent: () => <div>Not Found</div>,
{{#if (eq api "trpc")}}
		Wrap: ({ children }) => (
			<QueryClientProvider client={queryClient}>
				<TRPCProvider trpcClient={trpcClient} queryClient={queryClient}>
					{children}
				</TRPCProvider>
			</QueryClientProvider>
		),
{{else if (eq api "orpc")}}
		Wrap: ({ children }) => (
			<QueryClientProvider client={queryClient}>
				{children}
			</QueryClientProvider>
		),
{{else}}
		Wrap: ({ children }) => <>{children}</>,
{{/if}}
	});
	return router;
};
{{/if}}

declare module "@tanstack/react-router" {
	interface Register {
		router: ReturnType<typeof getRouter>;
	}
}
`],
  ["backend/server/encore/src/index.ts.hbs", `import { api } from "encore.dev/api";
{{#if (eq auth "better-auth")}}
import { auth } from "@{{projectName}}/auth";
{{/if}}
{{#if (and (includes examples "ai") (or (eq runtime "bun") (eq runtime "node")))}}
import { streamText, convertToModelMessages, wrapLanguageModel } from "ai";
import { google } from "@ai-sdk/google";
import { devToolsMiddleware } from "@ai-sdk/devtools";
{{/if}}

interface Response {
	message: string;
}

interface HealthResponse {
	status: string;
	timestamp: string;
}

// Health check endpoint
export const health = api(
	{ expose: true, method: "GET", path: "/health" },
	async (): Promise<HealthResponse> => {
		return {
			status: "ok",
			timestamp: new Date().toISOString(),
		};
	}
);

// Hello world endpoint
export const hello = api(
	{ expose: true, method: "GET", path: "/hello/:name" },
	async ({ name }: { name: string }): Promise<Response> => {
		return { message: \`Hello \${name}!\` };
	}
);

// Root endpoint
export const root = api(
	{ expose: true, method: "GET", path: "/" },
	async (): Promise<Response> => {
		return { message: "OK" };
	}
);
{{#if (and (includes examples "ai") (or (eq runtime "bun") (eq runtime "node")))}}

interface AIRequest {
	messages: Array<{ role: string; content: string }>;
}

// AI chat endpoint (Encore.ts uses native streaming)
export const chat = api(
	{ expose: true, method: "POST", path: "/ai" },
	async (req: AIRequest): Promise<Response> => {
		const model = wrapLanguageModel({
			model: google("gemini-2.5-flash"),
			middleware: devToolsMiddleware(),
		});

		const result = await streamText({
			model,
			messages: await convertToModelMessages(req.messages),
		});

		// For simple response - streaming would need Encore's streaming API
		const text = await result.text;
		return { message: text };
	}
);
{{/if}}
`],
  ["backend/server/fets/src/index.ts.hbs", `import { env } from "@{{projectName}}/env/server";
{{#if (eq api "orpc")}}
import { OpenAPIHandler } from "@orpc/openapi/fetch";
import { OpenAPIReferencePlugin } from "@orpc/openapi/plugins";
import { ZodToJsonSchemaConverter } from "@orpc/zod/zod4";
import { RPCHandler } from "@orpc/server/fetch";
import { onError } from "@orpc/server";
import { createContext } from "@{{projectName}}/api/context";
import { appRouter } from "@{{projectName}}/api/routers/index";
{{/if}}
{{#if (eq api "trpc")}}
import { fetchRequestHandler } from "@trpc/server/adapters/fetch";
import { createContext } from "@{{projectName}}/api/context";
import { appRouter } from "@{{projectName}}/api/routers/index";
{{/if}}
{{#if (eq auth "better-auth")}}
import { auth } from "@{{projectName}}/auth";
{{/if}}
import { createRouter, Response } from "fets";
{{#if (and (includes examples "ai") (or (eq runtime "bun") (eq runtime "node")))}}
import { streamText, convertToModelMessages, wrapLanguageModel } from "ai";
import { google } from "@ai-sdk/google";
import { devToolsMiddleware } from "@ai-sdk/devtools";
{{/if}}
{{#if (and (includes examples "ai") (eq runtime "workers"))}}
import { streamText, convertToModelMessages, wrapLanguageModel } from "ai";
import { createGoogleGenerativeAI } from "@ai-sdk/google";
import { devToolsMiddleware } from "@ai-sdk/devtools";
{{/if}}

const router = createRouter({
	openAPI: {
		info: {
			title: "{{projectName}} API",
			version: "1.0.0",
		},
	},
	swaggerUI: {
		endpoint: "/docs",
	},
})
	.route({
		method: "GET",
		path: "/",
		schemas: {
			responses: {
				200: {
					type: "object",
					properties: {
						status: { type: "string" },
					},
					required: ["status"],
					additionalProperties: false,
				},
			},
		},
		handler: () => Response.json({ status: "OK" }),
	})
{{#if (eq auth "better-auth")}}
	.route({
		method: "GET",
		path: "/api/auth/*",
		handler: (request) => auth.handler(request),
	})
	.route({
		method: "POST",
		path: "/api/auth/*",
		handler: (request) => auth.handler(request),
	})
{{/if}}
{{#if (eq api "trpc")}}
	.route({
		method: "GET",
		path: "/trpc/*",
		handler: (request) =>
			fetchRequestHandler({
				endpoint: "/trpc",
				req: request,
				router: appRouter,
				createContext: () => createContext({ context: request }),
			}),
	})
	.route({
		method: "POST",
		path: "/trpc/*",
		handler: (request) =>
			fetchRequestHandler({
				endpoint: "/trpc",
				req: request,
				router: appRouter,
				createContext: () => createContext({ context: request }),
			}),
	})
{{/if}}
{{#if (eq api "orpc")}}
	.route({
		method: "GET",
		path: "/rpc/*",
		handler: async (request) => {
			const context = await createContext({ context: request });
			const rpcHandler = new RPCHandler(appRouter, {
				interceptors: [
					onError((error) => {
						console.error(error);
					}),
				],
			});
			const result = await rpcHandler.handle(request, {
				prefix: "/rpc",
				context,
			});
			if (result.matched) {
				return result.response;
			}
			return Response.json({ error: "Not found" }, { status: 404 });
		},
	})
	.route({
		method: "POST",
		path: "/rpc/*",
		handler: async (request) => {
			const context = await createContext({ context: request });
			const rpcHandler = new RPCHandler(appRouter, {
				interceptors: [
					onError((error) => {
						console.error(error);
					}),
				],
			});
			const result = await rpcHandler.handle(request, {
				prefix: "/rpc",
				context,
			});
			if (result.matched) {
				return result.response;
			}
			return Response.json({ error: "Not found" }, { status: 404 });
		},
	})
	.route({
		method: "GET",
		path: "/api-reference/*",
		handler: async (request) => {
			const context = await createContext({ context: request });
			const apiHandler = new OpenAPIHandler(appRouter, {
				plugins: [
					new OpenAPIReferencePlugin({
						schemaConverters: [new ZodToJsonSchemaConverter()],
					}),
				],
				interceptors: [
					onError((error) => {
						console.error(error);
					}),
				],
			});
			const result = await apiHandler.handle(request, {
				prefix: "/api-reference",
				context,
			});
			if (result.matched) {
				return result.response;
			}
			return Response.json({ error: "Not found" }, { status: 404 });
		},
	})
{{/if}}
{{#if (and (includes examples "ai") (or (eq runtime "bun") (eq runtime "node")))}}
	.route({
		method: "POST",
		path: "/ai",
		handler: async (request) => {
			const body = await request.json();
			const uiMessages = body.messages || [];
			const model = wrapLanguageModel({
				model: google("gemini-2.5-flash"),
				middleware: devToolsMiddleware(),
			});
			const result = streamText({
				model,
				messages: await convertToModelMessages(uiMessages),
			});
			return result.toUIMessageStreamResponse();
		},
	})
{{/if}}
{{#if (and (includes examples "ai") (eq runtime "workers"))}}
	.route({
		method: "POST",
		path: "/ai",
		handler: async (request) => {
			const body = await request.json();
			const uiMessages = body.messages || [];
			const google = createGoogleGenerativeAI({
				apiKey: env.GOOGLE_GENERATIVE_AI_API_KEY,
			});
			const model = wrapLanguageModel({
				model: google("gemini-2.5-flash"),
				middleware: devToolsMiddleware(),
			});
			const result = streamText({
				model,
				messages: await convertToModelMessages(uiMessages),
			});
			return result.toUIMessageStreamResponse();
		},
	})
{{/if}};

{{#if (eq runtime "node")}}
import { createServer } from "node:http";

// Add CORS middleware wrapper
const corsOrigin = env.CORS_ORIGIN;

const corsMiddleware = (handler: typeof router) => {
	return async (request: Request): Promise<globalThis.Response> => {
		// Handle preflight OPTIONS request
		if (request.method === "OPTIONS") {
			return new globalThis.Response(null, {
				status: 204,
				headers: {
					"Access-Control-Allow-Origin": corsOrigin,
					"Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, OPTIONS",
{{#if (eq auth "better-auth")}}
					"Access-Control-Allow-Headers": "Content-Type, Authorization",
					"Access-Control-Allow-Credentials": "true",
{{else}}
					"Access-Control-Allow-Headers": "Content-Type",
{{/if}}
				},
			});
		}

		const response = await handler.fetch(request);
		const newHeaders = new Headers(response.headers);
		newHeaders.set("Access-Control-Allow-Origin", corsOrigin);
		newHeaders.set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS");
{{#if (eq auth "better-auth")}}
		newHeaders.set("Access-Control-Allow-Headers", "Content-Type, Authorization");
		newHeaders.set("Access-Control-Allow-Credentials", "true");
{{else}}
		newHeaders.set("Access-Control-Allow-Headers", "Content-Type");
{{/if}}

		return new globalThis.Response(response.body, {
			status: response.status,
			statusText: response.statusText,
			headers: newHeaders,
		});
	};
};

const handler = corsMiddleware(router);

createServer((req, res) => {
	const url = new URL(req.url || "/", \`http://\${req.headers.host}\`);
	const headers: Record<string, string> = {};
	for (const [key, value] of Object.entries(req.headers)) {
		if (value) headers[key] = Array.isArray(value) ? value.join(", ") : value;
	}

	const body: Buffer[] = [];
	req.on("data", (chunk) => body.push(chunk));
	req.on("end", async () => {
		const request = new Request(url.href, {
			method: req.method,
			headers,
			body: req.method !== "GET" && req.method !== "HEAD" ? Buffer.concat(body) : undefined,
		});

		const response = await handler(request);
		res.statusCode = response.status;
		response.headers.forEach((value, key) => {
			res.setHeader(key, value);
		});
		const responseBody = await response.arrayBuffer();
		res.end(Buffer.from(responseBody));
	});
}).listen(3000, () => {
	console.log("Server is running on http://localhost:3000");
	console.log("Swagger UI is available at http://localhost:3000/docs");
});
{{else}}
{{#if (eq runtime "bun")}}
const corsOrigin = env.CORS_ORIGIN;

const corsMiddleware = (handler: typeof router) => {
	return async (request: Request): Promise<globalThis.Response> => {
		if (request.method === "OPTIONS") {
			return new globalThis.Response(null, {
				status: 204,
				headers: {
					"Access-Control-Allow-Origin": corsOrigin,
					"Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, OPTIONS",
{{#if (eq auth "better-auth")}}
					"Access-Control-Allow-Headers": "Content-Type, Authorization",
					"Access-Control-Allow-Credentials": "true",
{{else}}
					"Access-Control-Allow-Headers": "Content-Type",
{{/if}}
				},
			});
		}

		const response = await handler.fetch(request);
		const newHeaders = new Headers(response.headers);
		newHeaders.set("Access-Control-Allow-Origin", corsOrigin);
		newHeaders.set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS");
{{#if (eq auth "better-auth")}}
		newHeaders.set("Access-Control-Allow-Headers", "Content-Type, Authorization");
		newHeaders.set("Access-Control-Allow-Credentials", "true");
{{else}}
		newHeaders.set("Access-Control-Allow-Headers", "Content-Type");
{{/if}}

		return new globalThis.Response(response.body, {
			status: response.status,
			statusText: response.statusText,
			headers: newHeaders,
		});
	};
};

const server = Bun.serve({
	port: 3000,
	fetch: corsMiddleware(router),
});

console.log(\`Server is running on http://localhost:\${server.port}\`);
console.log(\`Swagger UI is available at http://localhost:\${server.port}/docs\`);
{{/if}}
{{#if (eq runtime "workers")}}
export default router;
{{/if}}
{{/if}}
`],
  ["backend/server/express/src/index.ts.hbs", `import { env } from "@{{projectName}}/env/server";
{{#if (eq api "trpc")}}
import { createExpressMiddleware } from "@trpc/server/adapters/express";
import { createContext } from "@{{projectName}}/api/context";
import { appRouter } from "@{{projectName}}/api/routers/index";
{{/if}}
{{#if (eq api "orpc")}}
import { OpenAPIHandler } from "@orpc/openapi/node";
import { OpenAPIReferencePlugin } from "@orpc/openapi/plugins";
import { ZodToJsonSchemaConverter } from "@orpc/zod/zod4";
import { RPCHandler } from "@orpc/server/node";
import { onError } from "@orpc/server";
import { appRouter } from "@{{projectName}}/api/routers/index";
{{#if (eq auth "better-auth")}}
import { createContext } from "@{{projectName}}/api/context";
{{/if}}
{{/if}}
import cors from "cors";
import express from "express";
{{#if (includes examples "ai")}}
import { streamText, type UIMessage, convertToModelMessages, wrapLanguageModel } from "ai";
import { google } from "@ai-sdk/google";
import { devToolsMiddleware } from "@ai-sdk/devtools";
{{/if}}
{{#if (eq auth "better-auth")}}
import { auth } from "@{{projectName}}/auth";
import { toNodeHandler } from "better-auth/node";
{{/if}}

const app = express();

app.use(
	cors({
		origin: env.CORS_ORIGIN,
		methods: ["GET", "POST", "OPTIONS"],
{{#if (eq auth "better-auth")}}
		allowedHeaders: ["Content-Type", "Authorization"],
		credentials: true,
{{/if}}
	})
);

{{#if (eq auth "better-auth")}}
app.all("/api/auth{/*path}", toNodeHandler(auth));
{{/if}}

{{#if (eq api "trpc")}}
app.use(
	"/trpc",
	createExpressMiddleware({
		router: appRouter,
		createContext,
	})
);
{{/if}}

{{#if (eq api "orpc")}}
const rpcHandler = new RPCHandler(appRouter, {
	interceptors: [
		onError((error) => {
			console.error(error);
		}),
	],
});
const apiHandler = new OpenAPIHandler(appRouter, {
	plugins: [
		new OpenAPIReferencePlugin({
			schemaConverters: [new ZodToJsonSchemaConverter()],
		}),
	],
	interceptors: [
		onError((error) => {
			console.error(error);
		}),
	],
});

app.use(async (req, res, next) => {
	const rpcResult = await rpcHandler.handle(req, res, {
		prefix: "/rpc",
{{#if (eq auth "better-auth")}}
		context: await createContext({ req }),
{{else}}
		context: {},
{{/if}}
	});
	if (rpcResult.matched) return;

	const apiResult = await apiHandler.handle(req, res, {
		prefix: "/api-reference",
{{#if (eq auth "better-auth")}}
		context: await createContext({ req }),
{{else}}
		context: {},
{{/if}}
	});
	if (apiResult.matched) return;

	next();
});
{{/if}}

app.use(express.json());

{{#if (includes examples "ai")}}
app.post("/ai", async (req, res) => {
	const { messages = [] } = (req.body || {}) as { messages: UIMessage[] };
	const model = wrapLanguageModel({
		model: google("gemini-2.5-flash"),
		middleware: devToolsMiddleware(),
	});
	const result = streamText({
		model,
		messages: await convertToModelMessages(messages),
	});
	result.pipeUIMessageStreamToResponse(res);
});
{{/if}}

app.get("/", (_req, res) => {
	res.status(200).send("OK");
});

app.listen(3000, () => {
	console.log("Server is running on http://localhost:3000");
});
`],
  ["backend/server/adonisjs/start/routes.ts.hbs", `import { env } from "@{{projectName}}/env/server";
{{#if (eq api "trpc")}}
import { createExpressMiddleware } from "@trpc/server/adapters/express";
import { createContext } from "@{{projectName}}/api/context";
import { appRouter } from "@{{projectName}}/api/routers/index";
{{/if}}
{{#if (eq api "orpc")}}
import { OpenAPIHandler } from "@orpc/openapi/node";
import { OpenAPIReferencePlugin } from "@orpc/openapi/plugins";
import { ZodToJsonSchemaConverter } from "@orpc/zod/zod4";
import { RPCHandler } from "@orpc/server/node";
import { onError } from "@orpc/server";
import { appRouter } from "@{{projectName}}/api/routers/index";
{{#if (eq auth "better-auth")}}
import { createContext } from "@{{projectName}}/api/context";
{{/if}}
{{/if}}
{{#if (includes examples "ai")}}
import { streamText, type UIMessage, convertToModelMessages, wrapLanguageModel } from "ai";
import { google } from "@ai-sdk/google";
import { devToolsMiddleware } from "@ai-sdk/devtools";
{{/if}}
{{#if (eq auth "better-auth")}}
import { auth } from "@{{projectName}}/auth";
import { toNodeHandler } from "better-auth/node";
{{/if}}
import router from "@adonisjs/core/services/router";

// CORS headers helper
const setCorsHeaders = (response: any) => {
	const origin = env.CORS_ORIGIN;
	response.header("Access-Control-Allow-Origin", origin);
	response.header("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS");
{{#if (eq auth "better-auth")}}
	response.header("Access-Control-Allow-Headers", "Content-Type, Authorization");
	response.header("Access-Control-Allow-Credentials", "true");
{{else}}
	response.header("Access-Control-Allow-Headers", "Content-Type");
{{/if}}
};

// CORS preflight handler
router.options("*", ({ response }) => {
	setCorsHeaders(response);
	return response.status(204);
});

// Health check endpoint
router.get("/", ({ response }) => {
	setCorsHeaders(response);
	return response.send("OK");
});

{{#if (eq auth "better-auth")}}
// Better Auth handler
const authHandler = toNodeHandler(auth);
router.any("/api/auth/*", async ({ request, response }) => {
	setCorsHeaders(response);
	return new Promise<void>((resolve) => {
		authHandler(request.request as any, response.response as any, () => {
			resolve();
		});
	});
});
{{/if}}

{{#if (eq api "trpc")}}
// tRPC middleware adapter for AdonisJS
const trpcMiddleware = createExpressMiddleware({
	router: appRouter,
	createContext,
});

router.any("/trpc/*", async ({ request, response }) => {
	setCorsHeaders(response);
	return new Promise<void>((resolve) => {
		trpcMiddleware(request.request as any, response.response as any, () => {
			resolve();
		});
	});
});
{{/if}}

{{#if (eq api "orpc")}}
const rpcHandler = new RPCHandler(appRouter, {
	interceptors: [
		onError((error) => {
			console.error(error);
		}),
	],
});
const apiHandler = new OpenAPIHandler(appRouter, {
	plugins: [
		new OpenAPIReferencePlugin({
			schemaConverters: [new ZodToJsonSchemaConverter()],
		}),
	],
	interceptors: [
		onError((error) => {
			console.error(error);
		}),
	],
});

router.any("/rpc/*", async ({ request, response }) => {
	setCorsHeaders(response);
	const result = await rpcHandler.handle(request.request as any, response.response as any, {
		prefix: "/rpc",
{{#if (eq auth "better-auth")}}
		context: await createContext({ req: request.request as any }),
{{else}}
		context: {},
{{/if}}
	});
	if (!result.matched) {
		return response.status(404).send("Not Found");
	}
});

router.any("/api-reference/*", async ({ request, response }) => {
	setCorsHeaders(response);
	const result = await apiHandler.handle(request.request as any, response.response as any, {
		prefix: "/api-reference",
{{#if (eq auth "better-auth")}}
		context: await createContext({ req: request.request as any }),
{{else}}
		context: {},
{{/if}}
	});
	if (!result.matched) {
		return response.status(404).send("Not Found");
	}
});
{{/if}}

{{#if (includes examples "ai")}}
router.post("/ai", async ({ request, response }) => {
	setCorsHeaders(response);
	const body = request.body() as { messages?: UIMessage[] };
	const messages = body.messages || [];
	const model = wrapLanguageModel({
		model: google("gemini-2.5-flash"),
		middleware: devToolsMiddleware(),
	});
	const result = streamText({
		model,
		messages: await convertToModelMessages(messages),
	});
	result.pipeUIMessageStreamToResponse(response.response as any);
});
{{/if}}
`],
  ["backend/server/adonisjs/config/app.ts.hbs", `import { defineConfig } from "@adonisjs/core/http";

export default defineConfig({
	generateRequestId: true,
	useAsyncLocalStorage: true,
	qs: {
		parse: {},
	},
});
`],
  ["backend/server/fastify/src/index.ts.hbs", `import { env } from "@{{projectName}}/env/server";
import Fastify from "fastify";
import fastifyCors from "@fastify/cors";

{{#if (eq api "trpc")}}
import { fastifyTRPCPlugin, type FastifyTRPCPluginOptions } from "@trpc/server/adapters/fastify";
import { createContext } from "@{{projectName}}/api/context";
import { appRouter, type AppRouter } from "@{{projectName}}/api/routers/index";
{{/if}}

{{#if (eq api "orpc")}}
import { OpenAPIHandler } from "@orpc/openapi/node";
import { OpenAPIReferencePlugin } from "@orpc/openapi/plugins";
import { ZodToJsonSchemaConverter } from "@orpc/zod/zod4";
import { RPCHandler } from "@orpc/server/node";
import { CORSPlugin } from "@orpc/server/plugins";
import { onError } from "@orpc/server";
import { appRouter } from "@{{projectName}}/api/routers/index";
import { createServer } from "node:http";
{{#if (eq auth "better-auth")}}
import { createContext } from "@{{projectName}}/api/context";
{{/if}}
{{/if}}

{{#if (includes examples "ai")}}
import { streamText, type UIMessage, convertToModelMessages, wrapLanguageModel } from "ai";
import { google } from "@ai-sdk/google";
import { devToolsMiddleware } from "@ai-sdk/devtools";
{{/if}}

{{#if (eq auth "better-auth")}}
import { auth } from "@{{projectName}}/auth";
{{/if}}

const baseCorsConfig = {
	origin: env.CORS_ORIGIN,
	methods: ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
	allowedHeaders: [
		"Content-Type",
		"Authorization",
		"X-Requested-With"
	],
	credentials: true,
	maxAge: 86400,
};

{{#if (eq api "orpc")}}
const rpcHandler = new RPCHandler(appRouter, {
	plugins: [
		new CORSPlugin({
			origin: env.CORS_ORIGIN,
			credentials: true,
			allowHeaders: ["Content-Type", "Authorization"],
		}),
	],
	interceptors: [
		onError((error) => {
			console.error(error);
		}),
	],
});

const apiHandler = new OpenAPIHandler(appRouter, {
	plugins: [
		new OpenAPIReferencePlugin({
			schemaConverters: [new ZodToJsonSchemaConverter()],
		}),
	],
	interceptors: [
		onError((error) => {
			console.error(error);
		}),
	],
});

const fastify = Fastify({
	logger: true,
	serverFactory: (fastifyHandler) => {
		const server = createServer(async (req, res) => {
			const { matched } = await rpcHandler.handle(req, res, {
				context: await createContext(req.headers),
				prefix: "/rpc",
			});

			if (matched) {
				return;
			}

			const apiResult = await apiHandler.handle(req, res, {
				context: await createContext(req.headers),
				prefix: "/api-reference",
			});

			if (apiResult.matched) {
				return;
			}

			fastifyHandler(req, res);
		});

		return server;
	},
});
{{else}}
const fastify = Fastify({
	logger: true,
});
{{/if}}

fastify.register(fastifyCors, baseCorsConfig);

{{#if (eq auth "better-auth")}}
fastify.route({
	method: ["GET", "POST"],
	url: "/api/auth/*",
	async handler(request, reply) {
		try {
			const url = new URL(request.url, \`http://\${request.headers.host}\`);
			const headers = new Headers();
			Object.entries(request.headers).forEach(([key, value]) => {
				if (value) headers.append(key, value.toString());
			});
			const req = new Request(url.toString(), {
				method: request.method,
				headers,
				body: request.body ? JSON.stringify(request.body) : undefined,
			});
			const response = await auth.handler(req);
			reply.status(response.status);
			response.headers.forEach((value, key) => reply.header(key, value));
			reply.send(response.body ? await response.text() : null);
		} catch (error) {
			fastify.log.error({ err: error }, "Authentication Error:");
			reply.status(500).send({
				error: "Internal authentication error",
				code: "AUTH_FAILURE"
			});
		}
	}
});
{{/if}}

{{#if (eq api "trpc")}}
fastify.register(fastifyTRPCPlugin, {
	prefix: "/trpc",
	trpcOptions: {
		router: appRouter,
		createContext,
		onError({ path, error }) {
			console.error(\`Error in tRPC handler on path '\${path}':\`, error);
		},
	} satisfies FastifyTRPCPluginOptions<AppRouter>["trpcOptions"],
});
{{/if}}

{{#if (includes examples "ai")}}
interface AiRequestBody {
	id?: string;
	messages: UIMessage[];
}

fastify.post('/ai', async function (request) {
	const { messages } = request.body as AiRequestBody;
	const model = wrapLanguageModel({
		model: google('gemini-2.5-flash'),
		middleware: devToolsMiddleware(),
	});
	const result = streamText({
		model,
		messages: await convertToModelMessages(messages),
	});

	return result.toUIMessageStreamResponse();
});
{{/if}}

fastify.get('/', async () => {
	return 'OK';
});

fastify.listen({ port: 3000 }, (err) => {
	if (err) {
		fastify.log.error(err);
		process.exit(1);
	}
	console.log("Server running on port 3000");
});
`],
  ["backend/server/hono/src/index.ts.hbs", `import { env } from "@{{projectName}}/env/server";
{{#if (eq api "orpc")}}
import { OpenAPIHandler } from "@orpc/openapi/fetch";
import { OpenAPIReferencePlugin } from "@orpc/openapi/plugins";
import { ZodToJsonSchemaConverter } from "@orpc/zod/zod4";
import { RPCHandler } from "@orpc/server/fetch";
import { onError } from "@orpc/server";
import { createContext } from "@{{projectName}}/api/context";
import { appRouter } from "@{{projectName}}/api/routers/index";
{{/if}}
{{#if (eq api "trpc")}}
import { trpcServer } from "@hono/trpc-server";
import { createContext } from "@{{projectName}}/api/context";
import { appRouter } from "@{{projectName}}/api/routers/index";
{{/if}}
{{#if (eq auth "better-auth")}}
import { auth } from "@{{projectName}}/auth";
{{/if}}
import { Hono } from "hono";
import { cors } from "hono/cors";
import { logger } from "hono/logger";
{{#if (and (includes examples "ai") (or (eq runtime "bun") (eq runtime "node")))}}
import { streamText, convertToModelMessages, wrapLanguageModel } from "ai";
import { google } from "@ai-sdk/google";
import { devToolsMiddleware } from "@ai-sdk/devtools";
{{/if}}
{{#if (and (includes examples "ai") (eq runtime "workers"))}}
import { streamText, convertToModelMessages, wrapLanguageModel } from "ai";
import { createGoogleGenerativeAI } from "@ai-sdk/google";
import { devToolsMiddleware } from "@ai-sdk/devtools";
{{/if}}

const app = new Hono();

app.use(logger());
app.use(
	"/*",
	cors({
		origin: env.CORS_ORIGIN,
		allowMethods: ["GET", "POST", "OPTIONS"],
{{#if (eq auth "better-auth")}}
		allowHeaders: ["Content-Type", "Authorization"],
		credentials: true,
{{/if}}
	})
);

{{#if (eq auth "better-auth")}}
app.on(["POST", "GET"], "/api/auth/*", (c) => auth.handler(c.req.raw));
{{/if}}

{{#if (eq api "orpc")}}
export const apiHandler = new OpenAPIHandler(appRouter, {
	plugins: [
		new OpenAPIReferencePlugin({
			schemaConverters: [new ZodToJsonSchemaConverter()],
		}),
	],
	interceptors: [
		onError((error) => {
			console.error(error);
		}),
	],
});

export const rpcHandler = new RPCHandler(appRouter, {
	interceptors: [
		onError((error) => {
			console.error(error);
		}),
	],
});

app.use("/*", async (c, next) => {
	const context = await createContext({ context: c });

	const rpcResult = await rpcHandler.handle(c.req.raw, {
		prefix: "/rpc",
		context: context,
	});

	if (rpcResult.matched) {
		return c.newResponse(rpcResult.response.body, rpcResult.response);
	}

	const apiResult = await apiHandler.handle(c.req.raw, {
		prefix: "/api-reference",
		context: context,
	});

	if (apiResult.matched) {
		return c.newResponse(apiResult.response.body, apiResult.response);
	}

	await next();
});
{{/if}}

{{#if (eq api "trpc")}}
app.use(
	"/trpc/*",
	trpcServer({
		router: appRouter,
		createContext: (_opts, context) => {
			return createContext({ context });
		},
	})
);
{{/if}}

{{#if (and (includes examples "ai") (or (eq runtime "bun") (eq runtime "node")))}}
app.post("/ai", async (c) => {
	const body = await c.req.json();
	const uiMessages = body.messages || [];
	const model = wrapLanguageModel({
		model: google("gemini-2.5-flash"),
		middleware: devToolsMiddleware(),
	});
	const result = streamText({
		model,
		messages: await convertToModelMessages(uiMessages),
	});

	return result.toUIMessageStreamResponse();
});
{{/if}}

{{#if (and (includes examples "ai") (eq runtime "workers"))}}
app.post("/ai", async (c) => {
	const body = await c.req.json();
	const uiMessages = body.messages || [];
	const google = createGoogleGenerativeAI({
		apiKey: env.GOOGLE_GENERATIVE_AI_API_KEY,
	});
	const model = wrapLanguageModel({
		model: google("gemini-2.5-flash"),
		middleware: devToolsMiddleware(),
	});
	const result = streamText({
		model,
		messages: await convertToModelMessages(uiMessages),
	});

	return result.toUIMessageStreamResponse();
});
{{/if}}

app.get("/", (c) => {
	return c.text("OK");
});

{{#if (eq runtime "node")}}
import { serve } from "@hono/node-server";

serve(
	{
		fetch: app.fetch,
		port: 3000,
	},
	(info) => {
		console.log(\`Server is running on http://localhost:\${info.port}\`);
	}
);
{{else}}
{{#if (eq runtime "bun")}}
export default app;
{{/if}}
{{#if (eq runtime "workers")}}
export default app;
{{/if}}
{{/if}}
`],
  ["backend/server/elysia/src/index.ts.hbs", `import { env } from "@{{projectName}}/env/server";
{{#if (eq runtime "node")}}
import { node } from "@elysiajs/node";
{{/if}}
import { Elysia } from "elysia";
import { cors } from "@elysiajs/cors";
{{#if (includes examples "ai")}}
import { google } from "@ai-sdk/google";
import { convertToModelMessages, streamText, wrapLanguageModel } from "ai";
import { devToolsMiddleware } from "@ai-sdk/devtools";
{{/if}}
{{#if (eq api "trpc")}}
import { createContext } from "@{{projectName}}/api/context";
import { appRouter } from "@{{projectName}}/api/routers/index";
import { fetchRequestHandler } from "@trpc/server/adapters/fetch";
{{/if}}
{{#if (eq api "orpc")}}
import { OpenAPIHandler } from "@orpc/openapi/fetch";
import { OpenAPIReferencePlugin } from "@orpc/openapi/plugins";
import { ZodToJsonSchemaConverter } from "@orpc/zod/zod4";
import { RPCHandler } from "@orpc/server/fetch";
import { onError } from "@orpc/server";
import { appRouter } from "@{{projectName}}/api/routers/index";
import { createContext } from "@{{projectName}}/api/context";
{{/if}}
{{#if (eq auth "better-auth")}}
import { auth } from "@{{projectName}}/auth";
{{/if}}

{{#if (eq api "orpc")}}
const rpcHandler = new RPCHandler(appRouter, {
	interceptors: [
		onError((error) => {
			console.error(error);
		}),
	],
});
const apiHandler = new OpenAPIHandler(appRouter, {
	plugins: [
		new OpenAPIReferencePlugin({
			schemaConverters: [new ZodToJsonSchemaConverter()],
		}),
	],
	interceptors: [
		onError((error) => {
			console.error(error);
		}),
	],
});
{{/if}}

{{#if (eq runtime "node")}}
const app = new Elysia({ adapter: node() })
{{else}}
const app = new Elysia()
{{/if}}
	.use(
		cors({
			origin: env.CORS_ORIGIN,
			methods: ["GET", "POST", "OPTIONS"],
{{#if (eq auth "better-auth")}}
			allowedHeaders: ["Content-Type", "Authorization"],
			credentials: true,
{{/if}}
		}),
	)
{{#if (eq auth "better-auth")}}
	.all("/api/auth/*", async (context) => {
		const { request, status } = context;
		if (["POST", "GET"].includes(request.method)) {
			return auth.handler(request);
		}
		return status(405)
	})
{{/if}}
{{#if (eq api "orpc")}}
	.all('/rpc*', async (context) => {
		const { response } = await rpcHandler.handle(context.request, {
			prefix: '/rpc',
			context: await createContext({ context })
		})
		return response ?? new Response('Not Found', { status: 404 })
	})
	.all('/api*', async (context) => {
		const { response } = await apiHandler.handle(context.request, {
			prefix: '/api-reference',
			context: await createContext({ context })
		})
		return response ?? new Response('Not Found', { status: 404 })
	})
{{/if}}
{{#if (eq api "trpc")}}
	.all("/trpc/*", async (context) => {
		const res = await fetchRequestHandler({
			endpoint: "/trpc",
			router: appRouter,
			req: context.request,
			createContext: () => createContext({ context }),
		});
		return res;
	})
{{/if}}
{{#if (includes examples "ai")}}
	.post("/ai", async (context) => {
		const body = await context.request.json();
		const uiMessages = body.messages || [];
		const model = wrapLanguageModel({
			model: google("gemini-2.5-flash"),
			middleware: devToolsMiddleware(),
		});
		const result = streamText({
			model,
			messages: await convertToModelMessages(uiMessages)
		});

		return result.toUIMessageStreamResponse();
	})
{{/if}}
	.get("/", () => "OK")
	.listen(3000, () => {
		console.log("Server is running on http://localhost:3000");
	});
`],
  ["backend/server/nitro/routes/ai.post.ts.hbs", `{{#if (includes examples "ai")}}
import { streamText, type UIMessage, convertToModelMessages, wrapLanguageModel } from "ai";
{{#if (or (eq runtime "bun") (eq runtime "node"))}}
import { google } from "@ai-sdk/google";
{{else}}
import { createGoogleGenerativeAI } from "@ai-sdk/google";
import { env } from "@{{projectName}}/env/server";
{{/if}}
import { devToolsMiddleware } from "@ai-sdk/devtools";

export default defineEventHandler(async (event) => {
	const body = await readBody<{ messages?: UIMessage[] }>(event);
	const messages = body.messages || [];

{{#if (eq runtime "workers")}}
	const google = createGoogleGenerativeAI({
		apiKey: env.GOOGLE_GENERATIVE_AI_API_KEY,
	});
{{/if}}
	const model = wrapLanguageModel({
		model: google("gemini-2.5-flash"),
		middleware: devToolsMiddleware(),
	});

	const result = streamText({
		model,
		messages: await convertToModelMessages(messages),
	});

	return result.toUIMessageStreamResponse();
});
{{else}}
// AI placeholder - AI example not included
export default defineEventHandler(() => {
	return { error: "AI not configured" };
});
{{/if}}
`],
  ["backend/server/nitro/routes/index.ts.hbs", `// Health check endpoint
export default defineEventHandler(() => {
	return "OK";
});
`],
  ["backend/server/adonisjs/bin/server.ts.hbs", `import "reflect-metadata";
import { Ignitor, prettyPrintError } from "@adonisjs/core";

const APP_ROOT = new URL("../", import.meta.url);

const ignitor = new Ignitor(APP_ROOT);

ignitor
	.tap((app) => {
		app.booting(async () => {
			await import("#start/routes");
		});
	})
	.httpServer()
	.start()
	.catch((error) => {
		process.exitCode = 1;
		prettyPrintError(error);
	});
`],
  ["backend/server/nestjs/src/app.module.ts.hbs", `import { Module } from "@nestjs/common";
import { AppController } from "./app.controller";
import { AppService } from "./app.service";
{{#if (eq api "trpc")}}
import { TrpcModule } from "./trpc/trpc.module";
{{/if}}
{{#if (eq api "orpc")}}
import { OrpcModule } from "./orpc/orpc.module";
{{/if}}
{{#if (includes examples "ai")}}
import { AiModule } from "./ai/ai.module";
{{/if}}

@Module({
	imports: [
{{#if (eq api "trpc")}}
		TrpcModule,
{{/if}}
{{#if (eq api "orpc")}}
		OrpcModule,
{{/if}}
{{#if (includes examples "ai")}}
		AiModule,
{{/if}}
	],
	controllers: [AppController],
	providers: [AppService],
})
export class AppModule {}
`],
  ["backend/server/nestjs/src/app.controller.ts.hbs", `import { Controller, Get } from "@nestjs/common";
import { AppService } from "./app.service";

@Controller()
export class AppController {
	constructor(private readonly appService: AppService) {}

	@Get()
	getHello(): string {
		return this.appService.getHello();
	}
}
`],
  ["backend/server/nestjs/src/index.ts.hbs", `import "reflect-metadata";
import { env } from "@{{projectName}}/env/server";
import { NestFactory } from "@nestjs/core";
import { AppModule } from "./app.module";
{{#if (eq auth "better-auth")}}
import { auth } from "@{{projectName}}/auth";
{{/if}}

async function bootstrap() {
	const app = await NestFactory.create(AppModule);

	app.enableCors({
		origin: env.CORS_ORIGIN,
		methods: ["GET", "POST", "OPTIONS"],
{{#if (eq auth "better-auth")}}
		allowedHeaders: ["Content-Type", "Authorization"],
		credentials: true,
{{/if}}
	});

{{#if (eq auth "better-auth")}}
	const expressApp = app.getHttpAdapter().getInstance();
	expressApp.all("/api/auth/*path", async (req: any, res: any) => {
		return auth.handler(req);
	});
{{/if}}

	await app.listen(3000);
	console.log("Server is running on http://localhost:3000");
}

bootstrap();
`],
  ["backend/server/nestjs/src/app.service.ts.hbs", `import { Injectable } from "@nestjs/common";

@Injectable()
export class AppService {
	getHello(): string {
		return "OK";
	}
}
`],
  ["api/garph/server/src/context.ts.hbs", `{{#if (eq backend "hono")}}
import type { Context as HonoContext } from "hono";
{{#if (eq auth "better-auth")}}
import type { Session, User } from "better-auth";
{{/if}}

export type Context = {
  honoContext: HonoContext;
{{#if (eq auth "better-auth")}}
  session: { user: User; session: Session } | null;
{{/if}}
};

export function createContext(c: HonoContext{{#if (eq auth "better-auth")}}, session: { user: User; session: Session } | null{{/if}}): Context {
  return {
    honoContext: c,
{{#if (eq auth "better-auth")}}
    session,
{{/if}}
  };
}
{{else if (eq backend "elysia")}}
{{#if (eq auth "better-auth")}}
import type { Session, User } from "better-auth";
{{/if}}

export type Context = {
{{#if (eq auth "better-auth")}}
  session: { user: User; session: Session } | null;
{{/if}}
};

export function createContext({{#if (eq auth "better-auth")}}session: { user: User; session: Session } | null{{/if}}): Context {
  return {
{{#if (eq auth "better-auth")}}
    session,
{{/if}}
  };
}
{{else if (eq backend "express")}}
import type { Request } from "express";
{{#if (eq auth "better-auth")}}
import type { Session, User } from "better-auth";
{{/if}}

export type Context = {
  req: Request;
{{#if (eq auth "better-auth")}}
  session: { user: User; session: Session } | null;
{{/if}}
};

export function createContext(req: Request{{#if (eq auth "better-auth")}}, session: { user: User; session: Session } | null{{/if}}): Context {
  return {
    req,
{{#if (eq auth "better-auth")}}
    session,
{{/if}}
  };
}
{{else if (eq backend "fastify")}}
import type { FastifyRequest } from "fastify";
{{#if (eq auth "better-auth")}}
import type { Session, User } from "better-auth";
{{/if}}

export type Context = {
  req: FastifyRequest;
{{#if (eq auth "better-auth")}}
  session: { user: User; session: Session } | null;
{{/if}}
};

export function createContext(req: FastifyRequest{{#if (eq auth "better-auth")}}, session: { user: User; session: Session } | null{{/if}}): Context {
  return {
    req,
{{#if (eq auth "better-auth")}}
    session,
{{/if}}
  };
}
{{else if (eq backend "self")}}
{{#if (includes frontend "next")}}
import type { NextRequest } from "next/server";
{{#if (eq auth "better-auth")}}
import type { Session, User } from "better-auth";
{{/if}}

export type Context = {
  req: NextRequest;
{{#if (eq auth "better-auth")}}
  session: { user: User; session: Session } | null;
{{/if}}
};

export function createContext(req: NextRequest{{#if (eq auth "better-auth")}}, session: { user: User; session: Session } | null{{/if}}): Context {
  return {
    req,
{{#if (eq auth "better-auth")}}
    session,
{{/if}}
  };
}
{{else if (includes frontend "tanstack-start")}}
{{#if (eq auth "better-auth")}}
import type { Session, User } from "better-auth";
{{/if}}

export type Context = {
  request: Request;
{{#if (eq auth "better-auth")}}
  session: { user: User; session: Session } | null;
{{/if}}
};

export function createContext(request: Request{{#if (eq auth "better-auth")}}, session: { user: User; session: Session } | null{{/if}}): Context {
  return {
    request,
{{#if (eq auth "better-auth")}}
    session,
{{/if}}
  };
}
{{else if (includes frontend "astro")}}
import type { APIContext } from "astro";
{{#if (eq auth "better-auth")}}
import type { Session, User } from "better-auth";
{{/if}}

export type Context = {
  astroContext: APIContext;
{{#if (eq auth "better-auth")}}
  session: { user: User; session: Session } | null;
{{/if}}
};

export function createContext(astroContext: APIContext{{#if (eq auth "better-auth")}}, session: { user: User; session: Session } | null{{/if}}): Context {
  return {
    astroContext,
{{#if (eq auth "better-auth")}}
    session,
{{/if}}
  };
}
{{/if}}
{{/if}}
`],
  ["api/garph/server/src/index.ts.hbs", `import { g, buildSchema, InferResolvers } from "garph";

// Define GraphQL types using Garph's type-safe builder
{{#if (includes examples "todo")}}
export const todoType = g.type("Todo", {
  id: g.int(),
  content: g.string(),
  completed: g.boolean(),
  createdAt: g.string(),
});
{{/if}}

{{#if (eq auth "better-auth")}}
export const userType = g.type("User", {
  id: g.string(),
  email: g.string(),
  name: g.string().nullable(),
});

export const privateDataType = g.type("PrivateData", {
  message: g.string(),
  user: g.ref(userType),
});
{{/if}}

export const queryType = g.type("Query", {
  health: g.string().description("Health check endpoint"),
{{#if (eq auth "better-auth")}}
  privateData: g.ref(privateDataType).nullable().description("Get private data (requires authentication)"),
{{/if}}
{{#if (includes examples "todo")}}
  todos: g.ref(todoType).list().description("Get all todos"),
  todo: g
    .ref(todoType)
    .nullable()
    .args({ id: g.int() })
    .description("Get a single todo by ID"),
{{/if}}
});

export const mutationType = g.type("Mutation", {
{{#if (includes examples "todo")}}
  createTodo: g
    .ref(todoType)
    .args({ content: g.string() })
    .description("Create a new todo"),
  toggleTodo: g
    .ref(todoType)
    .nullable()
    .args({ id: g.int() })
    .description("Toggle a todo's completed status"),
  deleteTodo: g
    .boolean()
    .args({ id: g.int() })
    .description("Delete a todo"),
{{/if}}
  _empty: g.string().nullable().description("Placeholder mutation"),
});

// Export types for resolver type inference
export type QueryType = typeof queryType;
export type MutationType = typeof mutationType;
{{#if (includes examples "todo")}}
export type TodoType = typeof todoType;
{{/if}}

// Re-export Garph utilities for use in resolvers
export { g, buildSchema, type InferResolvers };
`],
  ["api/orpc/server/src/context.ts.hbs", `{{#if (and (eq backend 'self') (includes frontend "next"))}}
import type { NextRequest } from "next/server";
{{#if (eq auth "better-auth")}}
import { auth } from "@{{projectName}}/auth";
{{/if}}

export async function createContext(req: NextRequest) {
{{#if (eq auth "better-auth")}}
  const session = await auth.api.getSession({
    headers: req.headers,
  });
  return {
    session,
  };
{{else}}
  return {}
{{/if}}
}

{{else if (and (eq backend 'self') (includes frontend "tanstack-start"))}}
{{#if (eq auth "better-auth")}}
import { auth } from "@{{projectName}}/auth";
{{/if}}

export async function createContext({ req }: { req: Request }) {
{{#if (eq auth "better-auth")}}
	const session = await auth.api.getSession({
		headers: req.headers,
	});
	return {
		session,
	};
{{else}}
	return {};
{{/if}}
}

{{else if (eq backend 'hono')}}
import type { Context as HonoContext } from "hono";
{{#if (eq auth "better-auth")}}
import { auth } from "@{{projectName}}/auth";
{{/if}}

export type CreateContextOptions = {
  context: HonoContext;
};

export async function createContext({ context }: CreateContextOptions) {
{{#if (eq auth "better-auth")}}
  const session = await auth.api.getSession({
    headers: context.req.raw.headers,
  });
  return {
    session,
  };
{{else}}
  // No auth configured
  return {
    session: null,
  };
{{/if}}
}

{{else if (eq backend 'elysia')}}
import type { Context as ElysiaContext } from "elysia";
{{#if (eq auth "better-auth")}}
import { auth } from "@{{projectName}}/auth";
{{/if}}

export type CreateContextOptions = {
  context: ElysiaContext;
};

export async function createContext({ context }: CreateContextOptions) {
{{#if (eq auth "better-auth")}}
  const session = await auth.api.getSession({
    headers: context.request.headers,
  });
  return {
    session,
  };
{{else}}
  // No auth configured
  return {
    session: null,
  };
{{/if}}
}

{{else if (eq backend 'express')}}
import type { Request } from "express";
{{#if (eq auth "better-auth")}}
import { fromNodeHeaders } from "better-auth/node";
import { auth } from "@{{projectName}}/auth";
{{/if}}

interface CreateContextOptions {
	req: Request;
}

export async function createContext(opts: CreateContextOptions) {
{{#if (eq auth "better-auth")}}
	const session = await auth.api.getSession({
		headers: fromNodeHeaders(opts.req.headers),
	});
	return {
		session,
	};
{{else}}
  // No auth configured
	return {
		session: null,
	};
{{/if}}
}

{{else if (eq backend 'fastify')}}
import type { IncomingHttpHeaders } from "node:http";
{{#if (eq auth "better-auth")}}
import { fromNodeHeaders } from "better-auth/node";
import { auth } from "@{{projectName}}/auth";
{{/if}}

export async function createContext(req: IncomingHttpHeaders) {
{{#if (eq auth "better-auth")}}
  const session = await auth.api.getSession({
    headers: fromNodeHeaders(req),
  });
  return {
    session,
  };
{{else}}
  // No auth configured
  return {
    session: null,
  };
{{/if}}
}

{{else}}
export async function createContext() {
  return {
    session: null,
  };
}
{{/if}}

export type Context = Awaited<ReturnType<typeof createContext>>;
`],
  ["api/orpc/server/src/index.ts.hbs", `import { ORPCError, os } from "@orpc/server";
import type { Context } from "./context";

export const o = os.$context<Context>();

export const publicProcedure = o;

{{#if (eq auth "better-auth")}}
const requireAuth = o.middleware(async ({ context, next }) => {
  if (!context.session?.user) {
    throw new ORPCError("UNAUTHORIZED");
  }
  return next({
    context: {
      session: context.session,
    },
  });
});

export const protectedProcedure = publicProcedure.use(requireAuth);
{{/if}}
`],
  ["api/orpc/native/utils/orpc.ts.hbs", `import { createORPCClient } from "@orpc/client";
import { RPCLink } from "@orpc/client/fetch";
import { createTanstackQueryUtils } from "@orpc/tanstack-query";
import { QueryCache, QueryClient } from "@tanstack/react-query";
import type { AppRouterClient } from "@{{projectName}}/api/routers/index";
import { env } from "@{{projectName}}/env/native";
{{#if (eq auth "better-auth")}}
import { authClient } from "@/lib/auth-client";
{{/if}}

export const queryClient = new QueryClient({
	queryCache: new QueryCache({
		onError: (error) => {
			console.log(error)
		},
	}),
});

export const link = new RPCLink({
{{#if (eq backend "self")}}
	url: \`\${env.EXPO_PUBLIC_SERVER_URL}/api/rpc\`,
{{else}}
	url: \`\${env.EXPO_PUBLIC_SERVER_URL}/rpc\`,
{{/if}}
{{#if (eq auth "better-auth")}}
	headers() {
		const headers = new Map<string, string>();
		const cookies = authClient.getCookie();
		if (cookies) {
			headers.set("Cookie", cookies);
		}
		return Object.fromEntries(headers);
	},
{{/if}}
});

export const client: AppRouterClient = createORPCClient(link);

export const orpc = createTanstackQueryUtils(client);
`],
  ["api/garph/native/utils/garph.ts.hbs", `import { QueryClient } from "@tanstack/react-query";
import { createClient, type InferClient } from "@garph/gqty";
import {
  createGeneratedSchema,
  createScalarsEnumsHash,
} from "@garph/gqty/dist/utils";
import {
  g,
  queryType,
  mutationType,
{{#if (includes examples "todo")}}
  todoType,
{{/if}}
} from "@{{projectName}}/api/index";
import { API_URL } from "@/lib/api";

// Create QueryClient for React Query integration
export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      retry: 2,
      staleTime: 1000 * 60,
    },
  },
});

// Generate schema and scalars for GQty client
const generatedSchema = createGeneratedSchema(g);
const scalarsEnumsHash = createScalarsEnumsHash(g);

// Create type-safe GraphQL client
export const client = createClient<{
  query: InferClient<typeof queryType>;
  mutation: InferClient<typeof mutationType>;
}>({
  generatedSchema,
  scalarsEnumsHash,
  url: \`\${API_URL}/graphql\`,
{{#if (eq auth "better-auth")}}
  credentials: "include",
{{/if}}
});

// Export typed query and mutation functions
export const { query, mutation, resolved } = client;

// Helper for React Query integration
export async function graphqlFetcher<T>(
  fn: () => T | Promise<T>
): Promise<T> {
  return resolved(fn);
}
`],
  ["api/ts-rest/native/utils/ts-rest.ts.hbs", `import { QueryClient } from "@tanstack/react-query";
import { initClient, tsRestFetchApi } from "@ts-rest/core";
import { initTsrReactQuery } from "@ts-rest/react-query";
import { contract } from "@{{projectName}}/api/index";
import { env } from "@{{projectName}}/env/native";

export const queryClient = new QueryClient({
	defaultOptions: {
		queries: {
			retry: 2,
			staleTime: 1000 * 60,
		},
	},
});

const client = initClient(contract, {
	baseUrl: \`\${env.EXPO_PUBLIC_SERVER_URL}/rest\`,
	baseHeaders: {},
{{#if (eq auth "better-auth")}}
	credentials: "include",
{{/if}}
	api: tsRestFetchApi,
});

export const tsr = initTsrReactQuery(contract, client);
`],
  ["api/trpc/native/utils/trpc.ts.hbs", `{{#if (eq auth "better-auth")}}
import { authClient } from "@/lib/auth-client";
{{/if}}
import { QueryClient } from "@tanstack/react-query";
import { createTRPCClient, httpBatchLink } from "@trpc/client";
import { createTRPCOptionsProxy } from "@trpc/tanstack-react-query";
import type { AppRouter } from "@{{projectName}}/api/routers/index";
import { env } from "@{{projectName}}/env/native";

export const queryClient = new QueryClient();

const trpcClient = createTRPCClient<AppRouter>({
	links: [
		httpBatchLink({
{{#if (eq backend "self")}}
			url: \`\${env.EXPO_PUBLIC_SERVER_URL}/api/trpc\`,
{{else}}
			url: \`\${env.EXPO_PUBLIC_SERVER_URL}/trpc\`,
{{/if}}
{{#if (eq auth "better-auth")}}
			headers() {
				const headers = new Map<string, string>();
				const cookies = authClient.getCookie();
				if (cookies) {
					headers.set("Cookie", cookies);
				}
				return Object.fromEntries(headers);
			},
{{/if}}
		}),
	],
});

export const trpc = createTRPCOptionsProxy<AppRouter>({
	client: trpcClient,
	queryClient,
});
`],
  ["api/ts-rest/server/src/context.ts.hbs", `{{#if (eq backend "hono")}}
import type { Context as HonoContext } from "hono";
{{#if (eq auth "better-auth")}}
import type { Session, User } from "better-auth";
{{/if}}

export type Context = {
  honoContext: HonoContext;
{{#if (eq auth "better-auth")}}
  session: { user: User; session: Session } | null;
{{/if}}
};

export function createContext(c: HonoContext{{#if (eq auth "better-auth")}}, session: { user: User; session: Session } | null{{/if}}): Context {
  return {
    honoContext: c,
{{#if (eq auth "better-auth")}}
    session,
{{/if}}
  };
}
{{else if (eq backend "elysia")}}
{{#if (eq auth "better-auth")}}
import type { Session, User } from "better-auth";
{{/if}}

export type Context = {
{{#if (eq auth "better-auth")}}
  session: { user: User; session: Session } | null;
{{/if}}
};

export function createContext({{#if (eq auth "better-auth")}}session: { user: User; session: Session } | null{{/if}}): Context {
  return {
{{#if (eq auth "better-auth")}}
    session,
{{/if}}
  };
}
{{else if (eq backend "express")}}
import type { Request } from "express";
{{#if (eq auth "better-auth")}}
import type { Session, User } from "better-auth";
{{/if}}

export type Context = {
  req: Request;
{{#if (eq auth "better-auth")}}
  session: { user: User; session: Session } | null;
{{/if}}
};

export function createContext(req: Request{{#if (eq auth "better-auth")}}, session: { user: User; session: Session } | null{{/if}}): Context {
  return {
    req,
{{#if (eq auth "better-auth")}}
    session,
{{/if}}
  };
}
{{else if (eq backend "fastify")}}
import type { FastifyRequest } from "fastify";
{{#if (eq auth "better-auth")}}
import type { Session, User } from "better-auth";
{{/if}}

export type Context = {
  req: FastifyRequest;
{{#if (eq auth "better-auth")}}
  session: { user: User; session: Session } | null;
{{/if}}
};

export function createContext(req: FastifyRequest{{#if (eq auth "better-auth")}}, session: { user: User; session: Session } | null{{/if}}): Context {
  return {
    req,
{{#if (eq auth "better-auth")}}
    session,
{{/if}}
  };
}
{{else if (eq backend "self")}}
{{#if (includes frontend "next")}}
import type { NextRequest } from "next/server";
{{#if (eq auth "better-auth")}}
import type { Session, User } from "better-auth";
{{/if}}

export type Context = {
  req: NextRequest;
{{#if (eq auth "better-auth")}}
  session: { user: User; session: Session } | null;
{{/if}}
};

export function createContext(req: NextRequest{{#if (eq auth "better-auth")}}, session: { user: User; session: Session } | null{{/if}}): Context {
  return {
    req,
{{#if (eq auth "better-auth")}}
    session,
{{/if}}
  };
}
{{else if (includes frontend "tanstack-start")}}
{{#if (eq auth "better-auth")}}
import type { Session, User } from "better-auth";
{{/if}}

export type Context = {
  request: Request;
{{#if (eq auth "better-auth")}}
  session: { user: User; session: Session } | null;
{{/if}}
};

export function createContext(request: Request{{#if (eq auth "better-auth")}}, session: { user: User; session: Session } | null{{/if}}): Context {
  return {
    request,
{{#if (eq auth "better-auth")}}
    session,
{{/if}}
  };
}
{{else if (includes frontend "astro")}}
import type { APIContext } from "astro";
{{#if (eq auth "better-auth")}}
import type { Session, User } from "better-auth";
{{/if}}

export type Context = {
  astroContext: APIContext;
{{#if (eq auth "better-auth")}}
  session: { user: User; session: Session } | null;
{{/if}}
};

export function createContext(astroContext: APIContext{{#if (eq auth "better-auth")}}, session: { user: User; session: Session } | null{{/if}}): Context {
  return {
    astroContext,
{{#if (eq auth "better-auth")}}
    session,
{{/if}}
  };
}
{{/if}}
{{/if}}
`],
  ["api/ts-rest/server/src/index.ts.hbs", `import { initContract } from "@ts-rest/core";
import { z } from "zod";

const c = initContract();

export const contract = c.router({
  healthCheck: {
    method: "GET",
    path: "/health",
    responses: {
      200: z.literal("OK"),
    },
  },
{{#if (eq auth "better-auth")}}
  privateData: {
    method: "GET",
    path: "/private",
    responses: {
      200: z.object({
        message: z.string(),
        user: z.object({
          id: z.string(),
          email: z.string(),
          name: z.string().nullable(),
        }),
      }),
      401: z.object({
        message: z.string(),
      }),
    },
  },
{{/if}}
{{#if (includes examples "todo")}}
  todos: {
    getAll: {
      method: "GET",
      path: "/todos",
      responses: {
        200: z.array(
          z.object({
            id: z.number(),
            content: z.string(),
            completed: z.boolean(),
            createdAt: z.string(),
          })
        ),
      },
    },
    create: {
      method: "POST",
      path: "/todos",
      body: z.object({
        content: z.string().min(1),
      }),
      responses: {
        201: z.object({
          id: z.number(),
          content: z.string(),
          completed: z.boolean(),
          createdAt: z.string(),
        }),
      },
    },
    toggle: {
      method: "PATCH",
      path: "/todos/:id/toggle",
      pathParams: z.object({
        id: z.coerce.number(),
      }),
      body: z.object({}),
      responses: {
        200: z.object({
          id: z.number(),
          content: z.string(),
          completed: z.boolean(),
          createdAt: z.string(),
        }),
        404: z.object({
          message: z.string(),
        }),
      },
    },
    delete: {
      method: "DELETE",
      path: "/todos/:id",
      pathParams: z.object({
        id: z.coerce.number(),
      }),
      body: z.object({}),
      responses: {
        200: z.object({
          success: z.boolean(),
        }),
        404: z.object({
          message: z.string(),
        }),
      },
    },
  },
{{/if}}
});

export type AppContract = typeof contract;
`],
  ["api/trpc/server/src/context.ts.hbs", `{{#if (and (eq backend 'self') (includes frontend "next"))}}
import type { NextRequest } from "next/server";
{{#if (eq auth "better-auth")}}
import { auth } from "@{{projectName}}/auth";
{{/if}}

export async function createContext(req: NextRequest) {
{{#if (eq auth "better-auth")}}
  const session = await auth.api.getSession({
    headers: req.headers,
  });
  return {
    session,
  };
{{else}}
  // No auth configured
  return {
    session: null,
  };
{{/if}}
}

{{else if (and (eq backend 'self') (includes frontend "tanstack-start"))}}
{{#if (eq auth "better-auth")}}
import { auth } from "@{{projectName}}/auth";
{{/if}}

export async function createContext({ req }: { req: Request }) {
{{#if (eq auth "better-auth")}}
	const session = await auth.api.getSession({
		headers: req.headers,
	});
	return {
		session,
	};
{{else}}
	// No auth configured
	return {
		session: null,
	};
{{/if}}
}

{{else if (eq backend 'hono')}}
import type { Context as HonoContext } from "hono";
{{#if (eq auth "better-auth")}}
import { auth } from "@{{projectName}}/auth";
{{/if}}

export type CreateContextOptions = {
  context: HonoContext;
};

export async function createContext({ context }: CreateContextOptions) {
{{#if (eq auth "better-auth")}}
  const session = await auth.api.getSession({
    headers: context.req.raw.headers,
  });
  return {
    session,
  };
{{else}}
  // No auth configured
  return {
    session: null,
  };
{{/if}}
}

{{else if (eq backend 'elysia')}}
import type { Context as ElysiaContext } from "elysia";
{{#if (eq auth "better-auth")}}
import { auth } from "@{{projectName}}/auth";
{{/if}}

export type CreateContextOptions = {
  context: ElysiaContext;
};

export async function createContext({ context }: CreateContextOptions) {
{{#if (eq auth "better-auth")}}
  const session = await auth.api.getSession({
    headers: context.request.headers,
  });
  return {
    session,
  };
{{else}}
  // No auth configured
  return {
    session: null,
  };
{{/if}}
}

{{else if (eq backend 'express')}}
import type { CreateExpressContextOptions } from "@trpc/server/adapters/express";
{{#if (eq auth "better-auth")}}
import { fromNodeHeaders } from "better-auth/node";
import { auth } from "@{{projectName}}/auth";
{{/if}}

export async function createContext(opts: CreateExpressContextOptions) {
{{#if (eq auth "better-auth")}}
	const session = await auth.api.getSession({
		headers: fromNodeHeaders(opts.req.headers),
	});
	return {
		session,
	};
{{else}}
  // No auth configured
	return {
		session: null,
	};
{{/if}}
}

{{else if (eq backend 'fastify')}}
import type { CreateFastifyContextOptions } from "@trpc/server/adapters/fastify";
{{#if (eq auth "better-auth")}}
import { fromNodeHeaders } from "better-auth/node";
import { auth } from "@{{projectName}}/auth";
{{/if}}

export async function createContext({ req, res }: CreateFastifyContextOptions) {
{{#if (eq auth "better-auth")}}
  const session = await auth.api.getSession({
    headers: fromNodeHeaders(req.headers),
  });
  return { session };
{{else}}
  // No auth configured
	return {
		session: null,
	};
{{/if}}
}

{{else}}
export async function createContext() {
  return {
    session: null,
  };
}
{{/if}}

export type Context = Awaited<ReturnType<typeof createContext>>;
`],
  ["api/trpc/server/src/index.ts.hbs", `import { initTRPC, TRPCError } from "@trpc/server";
import type { Context } from "./context";

export const t = initTRPC.context<Context>().create();

export const router = t.router;

export const publicProcedure = t.procedure;

{{#if (eq auth "better-auth")}}
export const protectedProcedure = t.procedure.use(({ ctx, next }) => {
  if (!ctx.session) {
    throw new TRPCError({
      code: "UNAUTHORIZED",
      message: "Authentication required",
      cause: "No session",
    });
  }
  return next({
    ctx: {
      ...ctx,
      session: ctx.session,
    },
  });
});
{{/if}}
`],
  ["db/mongoose/mongodb/src/index.ts.hbs", `import mongoose from "mongoose";
import { env } from "@{{projectName}}/env/server";

await mongoose.connect(env.DATABASE_URL).catch((error) => {
	console.log("Error connecting to database:", error);
});

const client = mongoose.connection.getClient().db("myDB");

export { client };
`],
  ["db/sequelize/postgres/src/index.ts.hbs", `import { Sequelize } from "sequelize-typescript";
import { env } from "@{{projectName}}/env/server";

export const sequelize = new Sequelize(env.DATABASE_URL, {
	dialect: "postgres",
	logging: false,
	models: [__dirname + "/models/**/*.ts"],
{{#if (eq dbSetup "neon")}}
	dialectOptions: {
		ssl: {
			require: true,
			rejectUnauthorized: false,
		},
	},
{{/if}}
});

export const initializeDatabase = async () => {
	await sequelize.authenticate();
	await sequelize.sync();
	return sequelize;
};

export const db = sequelize;
`],
  ["db/mikroorm/postgres/src/index.ts.hbs", `import { MikroORM, type Options } from "@mikro-orm/core";
import { PostgreSqlDriver } from "@mikro-orm/postgresql";
import { env } from "@{{projectName}}/env/server";

const config: Options<PostgreSqlDriver> = {
	driver: PostgreSqlDriver,
	clientUrl: env.DATABASE_URL,
	entities: ["./src/entities"],
	entitiesTs: ["./src/entities"],
	debug: process.env.NODE_ENV !== "production",
{{#if (eq dbSetup "neon")}}
	driverOptions: {
		connection: {
			ssl: {
				rejectUnauthorized: false,
			},
		},
	},
{{/if}}
};

let orm: MikroORM<PostgreSqlDriver> | null = null;

export const initializeDatabase = async () => {
	if (!orm) {
		orm = await MikroORM.init(config);
	}
	return orm;
};

export const getEntityManager = async () => {
	const db = await initializeDatabase();
	return db.em.fork();
};

export const db = {
	getORM: initializeDatabase,
	getEM: getEntityManager,
};
`],
  ["db/mikroorm/sqlite/src/index.ts.hbs", `import { MikroORM, type Options } from "@mikro-orm/core";
import { BetterSqliteDriver } from "@mikro-orm/better-sqlite";
import { env } from "@{{projectName}}/env/server";

const config: Options<BetterSqliteDriver> = {
	driver: BetterSqliteDriver,
	dbName: env.DATABASE_URL.replace("file:", ""),
	entities: ["./src/entities"],
	entitiesTs: ["./src/entities"],
	debug: process.env.NODE_ENV !== "production",
};

let orm: MikroORM<BetterSqliteDriver> | null = null;

export const initializeDatabase = async () => {
	if (!orm) {
		orm = await MikroORM.init(config);
	}
	return orm;
};

export const getEntityManager = async () => {
	const db = await initializeDatabase();
	return db.em.fork();
};

export const db = {
	getORM: initializeDatabase,
	getEM: getEntityManager,
};
`],
  ["db/sequelize/sqlite/src/index.ts.hbs", `import { Sequelize } from "sequelize-typescript";
import { env } from "@{{projectName}}/env/server";

const dbPath = env.DATABASE_URL.replace("file:", "");

export const sequelize = new Sequelize({
	dialect: "sqlite",
	storage: dbPath,
	logging: false,
	models: [__dirname + "/models/**/*.ts"],
});

export const initializeDatabase = async () => {
	await sequelize.authenticate();
	await sequelize.sync();
	return sequelize;
};

export const db = sequelize;
`],
  ["db/kysely/mysql/src/index.ts.hbs", `import { env } from "@{{projectName}}/env/server";
import { Kysely, MysqlDialect } from "kysely";
import { createPool } from "mysql2";
import type { Database as DB } from "./schema";

{{#if (eq dbSetup "planetscale")}}
const dialect = new MysqlDialect({
	pool: createPool({
		host: env.DATABASE_HOST,
		user: env.DATABASE_USERNAME,
		password: env.DATABASE_PASSWORD,
		database: env.DATABASE_NAME,
		ssl: {
			rejectUnauthorized: true,
		},
	}),
});
{{else}}
const dialect = new MysqlDialect({
	pool: createPool(env.DATABASE_URL),
});
{{/if}}

export const db = new Kysely<DB>({
	dialect,
});
`],
  ["db/sequelize/mysql/src/index.ts.hbs", `import { Sequelize } from "sequelize-typescript";
import { env } from "@{{projectName}}/env/server";

export const sequelize = new Sequelize(env.DATABASE_URL, {
	dialect: "mysql",
	logging: false,
	models: [__dirname + "/models/**/*.ts"],
{{#if (eq dbSetup "planetscale")}}
	dialectOptions: {
		ssl: {
			rejectUnauthorized: false,
		},
	},
{{/if}}
});

export const initializeDatabase = async () => {
	await sequelize.authenticate();
	await sequelize.sync();
	return sequelize;
};

export const db = sequelize;
`],
  ["db/kysely/postgres/src/index.ts.hbs", `import { env } from "@{{projectName}}/env/server";
import { Kysely, PostgresDialect } from "kysely";
import { Pool } from "pg";
import type { Database as DB } from "./schema";

const dialect = new PostgresDialect({
	pool: new Pool({
		connectionString: env.DATABASE_URL,
{{#if (eq dbSetup "neon")}}
		ssl: {
			rejectUnauthorized: false,
		},
{{/if}}
	}),
});

export const db = new Kysely<DB>({
	dialect,
});
`],
  ["db/mikroorm/mysql/src/index.ts.hbs", `import { MikroORM, type Options } from "@mikro-orm/core";
import { MySqlDriver } from "@mikro-orm/mysql";
import { env } from "@{{projectName}}/env/server";

const config: Options<MySqlDriver> = {
	driver: MySqlDriver,
	clientUrl: env.DATABASE_URL,
	entities: ["./src/entities"],
	entitiesTs: ["./src/entities"],
	debug: process.env.NODE_ENV !== "production",
{{#if (eq dbSetup "planetscale")}}
	driverOptions: {
		connection: {
			ssl: {
				rejectUnauthorized: false,
			},
		},
	},
{{/if}}
};

let orm: MikroORM<MySqlDriver> | null = null;

export const initializeDatabase = async () => {
	if (!orm) {
		orm = await MikroORM.init(config);
	}
	return orm;
};

export const getEntityManager = async () => {
	const db = await initializeDatabase();
	return db.em.fork();
};

export const db = {
	getORM: initializeDatabase,
	getEM: getEntityManager,
};
`],
  ["db/kysely/sqlite/src/index.ts.hbs", `import { env } from "@{{projectName}}/env/server";
import { Kysely, SqliteDialect } from "kysely";
import Database from "better-sqlite3";
import type { Database as DB } from "./schema";

const dialect = new SqliteDialect({
	database: new Database(env.DATABASE_URL.replace("file:", "")),
});

export const db = new Kysely<DB>({
	dialect,
});
`],
  ["db/prisma/postgres/src/index.ts.hbs", `{{#if (eq runtime "workers")}}
import { PrismaClient } from "../prisma/generated/client";
import { env } from "@{{projectName}}/env/server";
{{#if (eq dbSetup "neon")}}
import { PrismaNeon } from "@prisma/adapter-neon";
import { neonConfig } from "@neondatabase/serverless";

neonConfig.poolQueryViaFetch = true;

const prisma = new PrismaClient({
	adapter: new PrismaNeon({
		connectionString: env.DATABASE_URL,
	}),
});

{{else if (eq dbSetup "prisma-postgres")}}
import { PrismaPg } from "@prisma/adapter-pg";

const adapter = new PrismaPg({
	connectionString: env.DATABASE_URL,
});

const prisma = new PrismaClient({ adapter });

{{else}}
import { PrismaPg } from "@prisma/adapter-pg";

const adapter = new PrismaPg({ connectionString: env.DATABASE_URL });
const prisma = new PrismaClient({ adapter });

{{/if}}

export default prisma;
{{else}}
import { PrismaClient } from "../prisma/generated/client";
import { env } from "@{{projectName}}/env/server";
{{#if (eq dbSetup "neon")}}
import { PrismaNeon } from "@prisma/adapter-neon";
import { neonConfig } from "@neondatabase/serverless";
import ws from "ws";

neonConfig.webSocketConstructor = ws;
neonConfig.poolQueryViaFetch = true;

const adapter = new PrismaNeon({
	connectionString: env.DATABASE_URL,
});

const prisma = new PrismaClient({ adapter });

{{else if (eq dbSetup "prisma-postgres")}}
import { PrismaPg } from "@prisma/adapter-pg";

const adapter = new PrismaPg({
	connectionString: env.DATABASE_URL,
});

const prisma = new PrismaClient({ adapter });

{{else}}
import { PrismaPg } from "@prisma/adapter-pg";

const adapter = new PrismaPg({ connectionString: env.DATABASE_URL });
const prisma = new PrismaClient({ adapter });

{{/if}}

export default prisma;
{{/if}}`],
  ["db/prisma/mysql/src/index.ts.hbs", `{{#if (eq runtime "workers")}}
import { PrismaClient } from "../prisma/generated/client";
import { env } from "@{{projectName}}/env/server";

{{#if (eq dbSetup "planetscale")}}
import { PrismaPlanetScale } from "@prisma/adapter-planetscale";

const adapter = new PrismaPlanetScale({ url: env.DATABASE_URL });
const prisma = new PrismaClient({ adapter });
{{else}}
import { PrismaMariaDb } from "@prisma/adapter-mariadb";

const databaseUrl: string = env.DATABASE_URL;
const url: URL = new URL(databaseUrl);
const connectionConfig = {
	host: url.hostname,
	port: parseInt(url.port || "3306"),
	user: url.username,
	password: url.password,
	database: url.pathname.slice(1),
};

const adapter = new PrismaMariaDb(connectionConfig);
const prisma = new PrismaClient({ adapter });
{{/if}}

export default prisma;
{{else}}
import { PrismaClient } from "../prisma/generated/client";
import { env } from "@{{projectName}}/env/server";

{{#if (eq dbSetup "planetscale")}}
import { PrismaPlanetScale } from "@prisma/adapter-planetscale";

const adapter = new PrismaPlanetScale({ url: env.DATABASE_URL });
const prisma = new PrismaClient({ adapter });
{{else}}
import { PrismaMariaDb } from "@prisma/adapter-mariadb";

const databaseUrl: string = env.DATABASE_URL;
const url: URL = new URL(databaseUrl);
const connectionConfig = {
	host: url.hostname,
	port: parseInt(url.port || "3306"),
	user: url.username,
	password: url.password,
	database: url.pathname.slice(1),
};

const adapter = new PrismaMariaDb(connectionConfig);
const prisma = new PrismaClient({ adapter });
{{/if}}

export default prisma;
{{/if}}`],
  ["db/prisma/sqlite/src/index.ts.hbs", `import { PrismaClient } from "../prisma/generated/client";

{{#if (eq dbSetup "d1")}}
import { PrismaD1 } from "@prisma/adapter-d1";
import { env } from "@{{projectName}}/env/server";

const adapter = new PrismaD1(env.DB);
const prisma = new PrismaClient({ adapter });

export default prisma;
{{else}}
import { PrismaLibSql } from "@prisma/adapter-libsql";
import { env } from "@{{projectName}}/env/server";

const adapter = new PrismaLibSql({
	url: env.DATABASE_URL,
{{#if (eq dbSetup "turso")}}
	authToken: env.DATABASE_AUTH_TOKEN || "",
{{/if}}
});

const prisma = new PrismaClient({ adapter });

export default prisma;
{{/if}}`],
  ["db/prisma/mongodb/src/index.ts.hbs", `import { PrismaClient } from "../prisma/generated/client";

const prisma = new PrismaClient();

export default prisma;
`],
  ["db/typeorm/mysql/src/index.ts.hbs", `import "reflect-metadata";
import { DataSource } from "typeorm";
import { env } from "@{{projectName}}/env/server";

export const AppDataSource = new DataSource({
	type: "mysql",
	url: env.DATABASE_URL,
	synchronize: true,
	logging: false,
	entities: ["src/entities/**/*.ts"],
	migrations: ["src/migrations/**/*.ts"],
	subscribers: ["src/subscribers/**/*.ts"],
{{#if (eq dbSetup "planetscale")}}
	ssl: {
		rejectUnauthorized: false,
	},
{{/if}}
});

export const initializeDatabase = async () => {
	if (!AppDataSource.isInitialized) {
		await AppDataSource.initialize();
	}
	return AppDataSource;
};

export const db = AppDataSource;
`],
  ["db/drizzle/sqlite/src/index.ts.hbs", `{{#if (or (eq runtime "bun") (eq runtime "node") (eq runtime "none"))}}
import { env } from "@{{projectName}}/env/server";
import * as schema from "./schema";
import { drizzle } from "drizzle-orm/libsql";
import { createClient } from "@libsql/client";

const client = createClient({
	url: env.DATABASE_URL,
{{#if (eq dbSetup "turso")}}
	authToken: env.DATABASE_AUTH_TOKEN,
{{/if}}
});

export const db = drizzle({ client, schema });
{{/if}}

{{#if (eq runtime "workers")}}
import * as schema from "./schema";

{{#if (eq dbSetup "d1")}}
import { drizzle } from "drizzle-orm/d1";
import { env } from "@{{projectName}}/env/server";

export const db = drizzle(env.DB, { schema });
{{else}}
import { drizzle } from "drizzle-orm/libsql";
import { env } from "@{{projectName}}/env/server";
import { createClient } from "@libsql/client";

const client = createClient({
	url: env.DATABASE_URL || "",
{{#if (eq dbSetup "turso")}}
	authToken: env.DATABASE_AUTH_TOKEN,
{{/if}}
});

export const db = drizzle({ client, schema });
{{/if}}
{{/if}}
`],
  ["db/typeorm/postgres/src/index.ts.hbs", `import "reflect-metadata";
import { DataSource } from "typeorm";
import { env } from "@{{projectName}}/env/server";

export const AppDataSource = new DataSource({
	type: "postgres",
	url: env.DATABASE_URL,
	synchronize: true,
	logging: false,
	entities: ["src/entities/**/*.ts"],
	migrations: ["src/migrations/**/*.ts"],
	subscribers: ["src/subscribers/**/*.ts"],
{{#if (eq dbSetup "neon")}}
	ssl: {
		rejectUnauthorized: false,
	},
{{/if}}
});

export const initializeDatabase = async () => {
	if (!AppDataSource.isInitialized) {
		await AppDataSource.initialize();
	}
	return AppDataSource;
};

export const db = AppDataSource;
`],
  ["db/typeorm/sqlite/src/index.ts.hbs", `import "reflect-metadata";
import { DataSource } from "typeorm";
import { env } from "@{{projectName}}/env/server";

export const AppDataSource = new DataSource({
	type: "better-sqlite3",
	database: env.DATABASE_URL.replace("file:", ""),
	synchronize: true,
	logging: false,
	entities: ["src/entities/**/*.ts"],
	migrations: ["src/migrations/**/*.ts"],
	subscribers: ["src/subscribers/**/*.ts"],
});

export const initializeDatabase = async () => {
	if (!AppDataSource.isInitialized) {
		await AppDataSource.initialize();
	}
	return AppDataSource;
};

export const db = AppDataSource;
`],
  ["db/drizzle/mysql/src/index.ts.hbs", `{{#if (or (eq runtime "bun") (eq runtime "node") (eq runtime "none"))}}
import { env } from "@{{projectName}}/env/server";
import * as schema from "./schema";

{{#if (eq dbSetup "planetscale")}}
import { drizzle } from "drizzle-orm/planetscale-serverless";

export const db = drizzle({
	connection: {
		host: env.DATABASE_HOST,
		username: env.DATABASE_USERNAME,
		password: env.DATABASE_PASSWORD,
	},
	schema,
});
{{else}}
import { drizzle } from "drizzle-orm/mysql2";

export const db = drizzle({
	connection: {
		uri: env.DATABASE_URL,
	},
	schema,
});
{{/if}}
{{/if}}

{{#if (eq runtime "workers")}}
import * as schema from "./schema";

{{#if (eq dbSetup "planetscale")}}
import { drizzle } from "drizzle-orm/planetscale-serverless";
import { env } from "@{{projectName}}/env/server";

export const db = drizzle({
	connection: {
		host: env.DATABASE_HOST,
		username: env.DATABASE_USERNAME,
		password: env.DATABASE_PASSWORD,
	},
	schema,
});
{{else}}
import { drizzle } from "drizzle-orm/mysql2";
import { env } from "@{{projectName}}/env/server";

export const db = drizzle({
	connection: {
		uri: env.DATABASE_URL,
	},
	schema,
});
{{/if}}
{{/if}}
`],
  ["db/drizzle/postgres/src/index.ts.hbs", `{{#if (or (eq runtime "bun") (eq runtime "node") (eq runtime "none"))}}
import { env } from "@{{projectName}}/env/server";
import * as schema from "./schema";

{{#if (eq dbSetup "neon")}}
import { neon, neonConfig } from '@neondatabase/serverless';
import { drizzle } from 'drizzle-orm/neon-http';
import ws from "ws";

neonConfig.webSocketConstructor = ws;

// To work in edge environments (Cloudflare Workers, Vercel Edge, etc.), enable querying over fetch
// neonConfig.poolQueryViaFetch = true

const sql = neon(env.DATABASE_URL);
export const db = drizzle(sql, { schema });
{{else}}
import { drizzle } from "drizzle-orm/node-postgres";

export const db = drizzle(env.DATABASE_URL, { schema });
{{/if}}
{{/if}}

{{#if (eq runtime "workers")}}
import * as schema from "./schema";

{{#if (eq dbSetup "neon")}}
import { neon, neonConfig } from '@neondatabase/serverless';
import { drizzle } from 'drizzle-orm/neon-http';
import { env } from "@{{projectName}}/env/server";
import ws from "ws";

neonConfig.webSocketConstructor = ws;
neonConfig.poolQueryViaFetch = true;

const sql = neon(env.DATABASE_URL || "");
export const db = drizzle(sql, { schema });
{{else}}
import { drizzle } from "drizzle-orm/node-postgres";
import { env } from "@{{projectName}}/env/server";

export const db = drizzle(env.DATABASE_URL || "", { schema });
{{/if}}
{{/if}}`],
  ["cms/payload/web/next/src/payload.config.ts.hbs", `import { buildConfig } from "payload";
import { lexicalEditor } from "@payloadcms/richtext-lexical";
{{#if (eq database "postgres")}}
import { postgresAdapter } from "@payloadcms/db-postgres";
{{else if (eq database "mongodb")}}
import { mongooseAdapter } from "@payloadcms/db-mongodb";
{{else}}
import { sqliteAdapter } from "@payloadcms/db-sqlite";
{{/if}}

import { Users } from "./payload/collections/Users";
import { Media } from "./payload/collections/Media";
import { Pages } from "./payload/collections/Pages";

export default buildConfig({
  // Rich text editor
  editor: lexicalEditor(),

  // Collections
  collections: [Users, Media, Pages],

  // Secret for encryption (should be a complex and secure string)
  secret: process.env.PAYLOAD_SECRET || "",

  // Database adapter
{{#if (eq database "postgres")}}
  db: postgresAdapter({
    pool: {
      connectionString: process.env.DATABASE_URL || "",
    },
  }),
{{else if (eq database "mongodb")}}
  db: mongooseAdapter({
    url: process.env.DATABASE_URL || "",
  }),
{{else}}
  db: sqliteAdapter({
    client: {
      url: process.env.DATABASE_URL || "file:./payload.db",
    },
  }),
{{/if}}

  // Admin panel configuration
  admin: {
    // Customize admin panel
    meta: {
      titleSuffix: "- {{projectName}}",
    },
  },

  // TypeScript configuration
  typescript: {
    outputFile: "./src/payload-types.ts",
  },
});
`],
  ["rust-base/crates/proto/src/generated/greeter.rs.hbs", `// This file is @generated by prost-build.
/// The request message containing the user's name.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HelloRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The response message containing the greeting.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HelloReply {
    #[prost(string, tag = "1")]
    pub message: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod greeter_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The greeting service definition.
    #[derive(Debug, Clone)]
    pub struct GreeterClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl GreeterClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> GreeterClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> GreeterClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            GreeterClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: \`4MB\`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: \`usize::MAX\`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Sends a greeting
        pub async fn say_hello(
            &mut self,
            request: impl tonic::IntoRequest<super::HelloRequest>,
        ) -> std::result::Result<tonic::Response<super::HelloReply>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/greeter.Greeter/SayHello");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("greeter.Greeter", "SayHello"));
            self.inner.unary(req, path, codec).await
        }
        /// Sends a streaming greeting
        pub async fn say_hello_stream(
            &mut self,
            request: impl tonic::IntoRequest<super::HelloRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::HelloReply>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/greeter.Greeter/SayHelloStream",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("greeter.Greeter", "SayHelloStream"));
            self.inner.server_streaming(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod greeter_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with GreeterServer.
    #[async_trait]
    pub trait Greeter: std::marker::Send + std::marker::Sync + 'static {
        /// Sends a greeting
        async fn say_hello(
            &self,
            request: tonic::Request<super::HelloRequest>,
        ) -> std::result::Result<tonic::Response<super::HelloReply>, tonic::Status>;
        /// Server streaming response type for the SayHelloStream method.
        type SayHelloStreamStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::HelloReply, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        /// Sends a streaming greeting
        async fn say_hello_stream(
            &self,
            request: tonic::Request<super::HelloRequest>,
        ) -> std::result::Result<tonic::Response<Self::SayHelloStreamStream>, tonic::Status>;
    }
    /// The greeting service definition.
    #[derive(Debug)]
    pub struct GreeterServer<T: Greeter> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T: Greeter> GreeterServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: \`4MB\`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: \`usize::MAX\`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for GreeterServer<T>
    where
        T: Greeter,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/greeter.Greeter/SayHello" => {
                    #[allow(non_camel_case_types)]
                    struct SayHelloSvc<T: Greeter>(pub Arc<T>);
                    impl<T: Greeter> tonic::server::UnaryService<super::HelloRequest>
                    for SayHelloSvc<T> {
                        type Response = super::HelloReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::HelloRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Greeter>::say_hello(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SayHelloSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/greeter.Greeter/SayHelloStream" => {
                    #[allow(non_camel_case_types)]
                    struct SayHelloStreamSvc<T: Greeter>(pub Arc<T>);
                    impl<
                        T: Greeter,
                    > tonic::server::ServerStreamingService<super::HelloRequest>
                    for SayHelloStreamSvc<T> {
                        type Response = super::HelloReply;
                        type ResponseStream = T::SayHelloStreamStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::HelloRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Greeter>::say_hello_stream(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SayHelloStreamSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T: Greeter> Clone for GreeterServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "greeter.Greeter";
    impl<T: Greeter> tonic::server::NamedService for GreeterServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
`],
  ["auth/clerk/convex/backend/convex/auth.config.ts.hbs", `export default {
	providers: [
		{
			// Replace with your own Clerk Issuer URL from your "convex" JWT template
			// or with \`process.env.CLERK_JWT_ISSUER_DOMAIN\`
			// and configure CLERK_JWT_ISSUER_DOMAIN on the Convex Dashboard
			// See https://docs.convex.dev/auth/clerk#configuring-dev-and-prod-instances
			domain: process.env.CLERK_JWT_ISSUER_DOMAIN,
			applicationID: "convex",
		},
	],
};
`],
  ["auth/clerk/convex/backend/convex/privateData.ts.hbs", `import { query } from "./_generated/server";

export const get = query({
	args: {},
	handler: async (ctx) => {
		const identity = await ctx.auth.getUserIdentity();
		if (identity === null) {
			return {
				message: "Not authenticated",
			};
		}
		return {
			message: "This is private",
		};
	},
});
`],
  ["auth/better-auth/convex/backend/convex/auth.ts.hbs", `import { createClient, type GenericCtx } from "@convex-dev/better-auth";
{{#if (or (includes frontend "native-bare") (includes frontend "native-uniwind") (includes frontend "native-unistyles"))}}
import { convex } from "@convex-dev/better-auth/plugins";
import { expo } from "@better-auth/expo";
{{else if (or (includes frontend "tanstack-router") (includes frontend "react-router") (includes frontend "nuxt") (includes frontend "svelte") (includes frontend "solid"))}}
import { convex, crossDomain } from "@convex-dev/better-auth/plugins";
{{else}}
import { convex } from "@convex-dev/better-auth/plugins";
{{/if}}
import { components } from "./_generated/api";
import type { DataModel } from "./_generated/dataModel";
import { query } from "./_generated/server";
import { betterAuth } from "better-auth";
import authConfig from "./auth.config";

{{#if (or (includes frontend "tanstack-start") (includes frontend "next"))}}
const siteUrl = process.env.SITE_URL!;
{{else if (or (includes frontend "tanstack-router") (includes frontend "react-router") (includes frontend "nuxt") (includes frontend "svelte") (includes frontend "solid"))}}
const siteUrl = process.env.SITE_URL!;
{{/if}}
{{#if (or (includes frontend "native-bare") (includes frontend "native-uniwind") (includes frontend "native-unistyles"))}}
const nativeAppUrl = process.env.NATIVE_APP_URL || "mybettertapp://";
{{/if}}

export const authComponent = createClient<DataModel>(components.betterAuth);

function createAuth(ctx: GenericCtx<DataModel>) {
  return betterAuth({
    {{#if (and (or (includes frontend "native-bare") (includes frontend "native-uniwind") (includes frontend "native-unistyles")) (or (includes frontend "tanstack-start") (includes frontend "next")))}}
    baseURL: siteUrl,
    trustedOrigins: [siteUrl, nativeAppUrl],
    {{else if (and (or (includes frontend "native-bare") (includes frontend "native-uniwind") (includes frontend "native-unistyles")) (or (includes frontend "tanstack-router") (includes frontend "react-router") (includes frontend "nuxt") (includes frontend "svelte") (includes frontend "solid")))}}
    trustedOrigins: [siteUrl, nativeAppUrl],
    {{else if (or (includes frontend "native-bare") (includes frontend "native-uniwind") (includes frontend "native-unistyles"))}}
    trustedOrigins: [nativeAppUrl],
    {{else if (or (includes frontend "tanstack-start") (includes frontend "next"))}}
    baseURL: siteUrl,
    trustedOrigins: [siteUrl],
    {{else if (or (includes frontend "tanstack-router") (includes frontend "react-router") (includes frontend "nuxt") (includes frontend "svelte") (includes frontend "solid"))}}
    trustedOrigins: [siteUrl],
    {{/if}}
    database: authComponent.adapter(ctx),
    emailAndPassword: {
      enabled: true,
      requireEmailVerification: false,
    },
    plugins: [
      {{#if (or (includes frontend "native-bare") (includes frontend "native-uniwind") (includes frontend "native-unistyles"))}}
      expo(),
      {{else if (or (includes frontend "tanstack-router") (includes frontend "react-router") (includes frontend "nuxt") (includes frontend "svelte") (includes frontend "solid"))}}
      crossDomain({ siteUrl }),
      {{/if}}
      convex({
        authConfig,
        jwksRotateOnTokenGenerationError: true,
      }),
    ],
  });
}

export { createAuth };

export const getCurrentUser = query({
  args: {},
  handler: async (ctx) => {
    return await authComponent.safeGetAuthUser(ctx);
  },
});
`],
  ["auth/better-auth/convex/backend/convex/http.ts.hbs", `import { httpRouter } from "convex/server";
import { authComponent, createAuth } from "./auth";

const http = httpRouter();

{{#if (or (includes frontend "tanstack-router") (includes frontend "react-router") (includes frontend "nuxt") (includes frontend "svelte") (includes frontend "solid"))}}
authComponent.registerRoutes(http, createAuth, { cors: true });
{{else}}
authComponent.registerRoutes(http, createAuth);
{{/if}}

export default http;
`],
  ["auth/better-auth/convex/backend/convex/auth.config.ts.hbs", `import { getAuthConfigProvider } from "@convex-dev/better-auth/auth-config";
import type { AuthConfig } from "convex/server";

export default {
  providers: [getAuthConfigProvider()],
} satisfies AuthConfig;
`],
  ["auth/better-auth/convex/backend/convex/privateData.ts.hbs", `import { query } from "./_generated/server";
import { authComponent } from "./auth";

export const get = query({
  args: {},
  handler: async (ctx) => {
    const authUser = await authComponent.safeGetAuthUser(ctx);
    if (!authUser) {
      return {
        message: "Not authenticated",
      };
    }
    return {
      message: "This is private",
    };
  },
});
`],
  ["auth/better-auth/native/uniwind/components/sign-up.tsx.hbs", `import { authClient } from "@/lib/auth-client";
{{#if (eq api "trpc")}}
import { queryClient } from "@/utils/trpc";
{{/if}}
{{#if (eq api "orpc")}}
import { queryClient } from "@/utils/orpc";
{{/if}}
import { useState } from "react";
import { Text, View } from "react-native";
import { Button, ErrorView, Spinner, Surface, TextField } from "heroui-native";

function signUpHandler({
name,
email,
password,
setError,
setIsLoading,
setName,
setEmail,
setPassword,
}: {
  name: string;
  email: string;
  password: string;
  setError: (error: string | null) => void;
  setIsLoading: (loading: boolean) => void;
  setName: (name: string) => void;
  setEmail: (email: string) => void;
  setPassword: (password: string) => void;
}) {
setIsLoading(true);
setError(null);

authClient.signUp.email(
{
name,
email,
password,
},
{
onError(error) {
setError(error.error?.message || "Failed to sign up");
setIsLoading(false);
},
onSuccess() {
setName("");
setEmail("");
setPassword("");
{{#if (eq api "orpc")}}
queryClient.refetchQueries();
{{/if}}
{{#if (eq api "trpc")}}
queryClient.refetchQueries();
{{/if}}
},
onFinished() {
setIsLoading(false);
},
}
);
}

export function SignUp() {
const [name, setName] = useState("");
const [email, setEmail] = useState("");
const [password, setPassword] = useState("");
const [isLoading, setIsLoading] = useState(false);
const [error, setError] = useState<string | null>(null);

  function handlePress() {
  signUpHandler({
  name,
  email,
  password,
  setError,
  setIsLoading,
  setName,
  setEmail,
  setPassword,
  });
  }

  return (
  <Surface variant="secondary" className="p-4 rounded-lg">
    <Text className="text-foreground font-medium mb-4">Create Account</Text>

    <ErrorView isInvalid={!!error} className="mb-3">
      {error}
    </ErrorView>

    <View className="gap-3">
      <TextField>
        <TextField.Label>Name</TextField.Label>
        <TextField.Input value={name} onChangeText={setName} placeholder="John Doe" />
      </TextField>

      <TextField>
        <TextField.Label>Email</TextField.Label>
        <TextField.Input
          value={email}
          onChangeText={setEmail}
          placeholder="email@example.com"
          keyboardType="email-address"
          autoCapitalize="none"
        />
      </TextField>

      <TextField>
        <TextField.Label>Password</TextField.Label>
        <TextField.Input
          value={password}
          onChangeText={setPassword}
          placeholder=""
          secureTextEntry
        />
      </TextField>

      <Button onPress={handlePress} isDisabled={isLoading} className="mt-1">
        {isLoading ? (
          <Spinner size="sm" color="default" />
        ) : (
          <Button.Label>Create Account</Button.Label>
        )}
      </Button>
    </View>
  </Surface>
  );
  }`],
  ["auth/better-auth/native/uniwind/components/sign-in.tsx.hbs", `import { authClient } from "@/lib/auth-client";
{{#if (eq api "trpc")}}
import { queryClient } from "@/utils/trpc";
{{/if}}
{{#if (eq api "orpc")}}
import { queryClient } from "@/utils/orpc";
{{/if}}
import { useState } from "react";
import { Text, View } from "react-native";
import { Button, ErrorView, Spinner, Surface, TextField } from "heroui-native";

function SignIn() {
const [email, setEmail] = useState("");
const [password, setPassword] = useState("");
const [isLoading, setIsLoading] = useState(false);
const [error, setError] = useState<string | null>(null);

  async function handleLogin() {
  setIsLoading(true);
  setError(null);

  await authClient.signIn.email(
  {
  email,
  password,
  },
  {
  onError(error) {
  setError(error.error?.message || "Failed to sign in");
  setIsLoading(false);
  },
  onSuccess() {
  setEmail("");
  setPassword("");
  {{#if (eq api "orpc")}}
  queryClient.refetchQueries();
  {{/if}}
  {{#if (eq api "trpc")}}
  queryClient.refetchQueries();
  {{/if}}
  },
  onFinished() {
  setIsLoading(false);
  },
  }
  );
  }

  return (
  <Surface variant="secondary" className="p-4 rounded-lg">
    <Text className="text-foreground font-medium mb-4">Sign In</Text>

    <ErrorView isInvalid={!!error} className="mb-3">
      {error}
    </ErrorView>

    <View className="gap-3">
      <TextField>
        <TextField.Label>Email</TextField.Label>
        <TextField.Input
          value={email}
          onChangeText={setEmail}
          placeholder="email@example.com"
          keyboardType="email-address"
          autoCapitalize="none"
        />
      </TextField>

      <TextField>
        <TextField.Label>Password</TextField.Label>
        <TextField.Input
          value={password}
          onChangeText={setPassword}
          placeholder=""
          secureTextEntry
        />
      </TextField>

      <Button onPress={handleLogin} isDisabled={isLoading} className="mt-1">
        {isLoading ? <Spinner size="sm" color="default" /> : <Button.Label>Sign In</Button.Label>}
      </Button>
    </View>
  </Surface>
  );
  }

  export { SignIn };`],
  ["auth/better-auth/native/base/lib/auth-client.ts.hbs", `import { expoClient } from "@better-auth/expo/client";
import { createAuthClient } from "better-auth/react";
import * as SecureStore from "expo-secure-store";
import Constants from "expo-constants";
import { env } from "@{{projectName}}/env/native";

export const authClient = createAuthClient({
	baseURL: env.EXPO_PUBLIC_SERVER_URL,
	plugins: [
		expoClient({
			scheme: Constants.expoConfig?.scheme as string,
			storagePrefix: Constants.expoConfig?.scheme as string,
			storage: SecureStore,
		}),
	],
});
`],
  ["auth/better-auth/native/bare/components/sign-up.tsx.hbs", `import { authClient } from "@/lib/auth-client";
{{#if (eq api "trpc")}}
import { queryClient } from "@/utils/trpc";
{{/if}}
{{#if (eq api "orpc")}}
import { queryClient } from "@/utils/orpc";
{{/if}}
import { useState } from "react";
import {
  ActivityIndicator,
  Text,
  TextInput,
  TouchableOpacity,
  View,
  StyleSheet,
} from "react-native";
import { useColorScheme } from "@/lib/use-color-scheme";
import { NAV_THEME } from "@/lib/constants";

function SignUp() {
  const { colorScheme } = useColorScheme();
  const theme = colorScheme === "dark" ? NAV_THEME.dark : NAV_THEME.light;
  const [name, setName] = useState("");
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  async function handleSignUp() {
    setIsLoading(true);
    setError(null);

    await authClient.signUp.email(
      {
        name,
        email,
        password,
      },
      {
        onError(error) {
          setError(error.error?.message || "Failed to sign up");
          setIsLoading(false);
        },
        onSuccess() {
          setName("");
          setEmail("");
          setPassword("");
          {{#if (eq api "orpc")}}
          queryClient.refetchQueries();
          {{/if}}
          {{#if (eq api "trpc")}}
          queryClient.refetchQueries();
          {{/if}}
        },
        onFinished() {
          setIsLoading(false);
        },
      }
    );
  }

  return (
    <View style={[styles.card, { backgroundColor: theme.card, borderColor: theme.border }]}>
      <Text style={[styles.title, { color: theme.text }]}>Create Account</Text>

      {error ? (
        <View style={[styles.errorContainer, { backgroundColor: theme.notification + "20" }]}>
          <Text style={[styles.errorText, { color: theme.notification }]}>{error}</Text>
        </View>
      ) : null}

      <TextInput
        style={[styles.input, { color: theme.text, borderColor: theme.border, backgroundColor: theme.background }]}
        placeholder="Name"
        placeholderTextColor={theme.text}
        value={name}
        onChangeText={setName}
      />

      <TextInput
        style={[styles.input, { color: theme.text, borderColor: theme.border, backgroundColor: theme.background }]}
        placeholder="Email"
        placeholderTextColor={theme.text}
        value={email}
        onChangeText={setEmail}
        keyboardType="email-address"
        autoCapitalize="none"
      />

      <TextInput
        style={[styles.input, { color: theme.text, borderColor: theme.border, backgroundColor: theme.background }]}
        placeholder="Password"
        placeholderTextColor={theme.text}
        value={password}
        onChangeText={setPassword}
        secureTextEntry
      />

      <TouchableOpacity
        onPress={handleSignUp}
        disabled={isLoading}
        style={[styles.button, { backgroundColor: theme.primary, opacity: isLoading ? 0.5 : 1 }]}
      >
        {isLoading ? (
          <ActivityIndicator size="small" color="#ffffff" />
        ) : (
          <Text style={styles.buttonText}>Sign Up</Text>
        )}
      </TouchableOpacity>
    </View>
  );
}

const styles = StyleSheet.create({
  card: {
    marginTop: 16,
    padding: 16,
    borderWidth: 1,
  },
  title: {
    fontSize: 18,
    fontWeight: "bold",
    marginBottom: 12,
  },
  errorContainer: {
    marginBottom: 12,
    padding: 8,
  },
  errorText: {
    fontSize: 14,
  },
  input: {
    borderWidth: 1,
    padding: 12,
    fontSize: 16,
    marginBottom: 12,
  },
  button: {
    padding: 12,
    alignItems: "center",
    justifyContent: "center",
  },
  buttonText: {
    color: "#ffffff",
    fontSize: 16,
  },
});

export { SignUp };

`],
  ["auth/better-auth/native/bare/components/sign-in.tsx.hbs", `import { authClient } from "@/lib/auth-client";
{{#if (eq api "trpc")}}
import { queryClient } from "@/utils/trpc";
{{/if}}
{{#if (eq api "orpc")}}
import { queryClient } from "@/utils/orpc";
{{/if}}
import { useState } from "react";
import {
ActivityIndicator,
Text,
TextInput,
TouchableOpacity,
View,
StyleSheet,
} from "react-native";
import { useColorScheme } from "@/lib/use-color-scheme";
import { NAV_THEME } from "@/lib/constants";

function SignIn() {
const { colorScheme } = useColorScheme();
const theme = colorScheme === "dark" ? NAV_THEME.dark : NAV_THEME.light;
const [form, setForm] = useState({ email: "", password: "" });
const [isLoading, setIsLoading] = useState(false);
const [error, setError] = useState<string | null>(null);

    function handleFormChange(field: "email" | "password", value: string) {
    setForm(prev => ({ ...prev, [field]: value }));
    }

    async function handleLogin() {
    setIsLoading(true);
    setError(null);

    await authClient.signIn.email(
    {
    email: form.email,
    password: form.password,
    },
    {
    onError(error) {
    setError(error.error?.message || "Failed to sign in");
    setIsLoading(false);
    },
    onSuccess() {
    setForm({ email: "", password: "" });
    {{#if (eq api "orpc")}}
    queryClient.refetchQueries();
    {{/if}}
    {{#if (eq api "trpc")}}
    queryClient.refetchQueries();
    {{/if}}
    },
    onFinished() {
    setIsLoading(false);
    },
    }
    );
    }

    return (
    <View style={[styles.card, { backgroundColor: theme.card, borderColor: theme.border }]}>
        <Text style={[styles.title, { color: theme.text }]}>Sign In</Text>

        {error ? (
        <View style={[styles.errorContainer, { backgroundColor: theme.notification + "20" }]}>
            <Text style={[styles.errorText, { color: theme.notification }]}>{error}</Text>
        </View>
        ) : null}

        <TextInput style={[ styles.input, { color: theme.text, borderColor: theme.border, backgroundColor:
            theme.background }, ]} placeholder="Email" placeholderTextColor={theme.text} value={form.email}
            onChangeText={value=> handleFormChange("email", value)}
            keyboardType="email-address"
            autoCapitalize="none"
            />

            <TextInput style={[ styles.input, { color: theme.text, borderColor: theme.border, backgroundColor:
                theme.background }, ]} placeholder="Password" placeholderTextColor={theme.text} value={form.password}
                onChangeText={value=> handleFormChange("password", value)}
                secureTextEntry
                />

                <TouchableOpacity onPress={handleLogin} disabled={isLoading} style={[ styles.button, { backgroundColor:
                    theme.primary, opacity: isLoading ? 0.5 : 1 }, ]}>
                    {isLoading ? (
                    <ActivityIndicator size="small" color="#ffffff" />
                    ) : (
                    <Text style={styles.buttonText}>Sign In</Text>
                    )}
                </TouchableOpacity>
    </View>
    );
    }

    const styles = StyleSheet.create({
    card: {
    marginTop: 16,
    padding: 16,
    borderWidth: 1,
    },
    title: {
    fontSize: 18,
    fontWeight: "bold",
    marginBottom: 12,
    },
    errorContainer: {
    marginBottom: 12,
    padding: 8,
    },
    errorText: {
    fontSize: 14,
    },
    input: {
    borderWidth: 1,
    padding: 12,
    fontSize: 16,
    marginBottom: 12,
    },
    button: {
    padding: 12,
    alignItems: "center",
    justifyContent: "center",
    },
    buttonText: {
    color: "#ffffff",
    fontSize: 16,
    },
    });

    export { SignIn };`],
  ["auth/better-auth/native/unistyles/components/sign-up.tsx.hbs", `import { authClient } from "@/lib/auth-client";
{{#if (eq api "trpc")}}
import { queryClient } from "@/utils/trpc";
{{/if}}
{{#if (eq api "orpc")}}
import { queryClient } from "@/utils/orpc";
{{/if}}
import { useState } from "react";
import {
  ActivityIndicator,
  Text,
  TextInput,
  TouchableOpacity,
  View,
} from "react-native";
import { StyleSheet } from "react-native-unistyles";

export function SignUp() {
  const [name, setName] = useState("");
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const handleSignUp = async () => {
    setIsLoading(true);
    setError(null);

    await authClient.signUp.email(
      {
        name,
        email,
        password,
      },
      {
        onError: (error) => {
          setError(error.error?.message || "Failed to sign up");
          setIsLoading(false);
        },
        onSuccess: () => {
          setName("");
          setEmail("");
          setPassword("");
          {{#if (eq api "orpc")}}
          queryClient.refetchQueries();
          {{/if}}
          {{#if (eq api "trpc")}}
          queryClient.refetchQueries();
          {{/if}}
        },
        onFinished: () => {
          setIsLoading(false);
        },
      },
    );
  };

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Create Account</Text>

      {error && (
        <View style={styles.errorContainer}>
          <Text style={styles.errorText}>{error}</Text>
        </View>
      )}

      <TextInput
        style={styles.input}
        placeholder="Name"
        value={name}
        onChangeText={setName}
      />

      <TextInput
        style={styles.input}
        placeholder="Email"
        value={email}
        onChangeText={setEmail}
        keyboardType="email-address"
        autoCapitalize="none"
      />

      <TextInput
        style={styles.inputLast}
        placeholder="Password"
        value={password}
        onChangeText={setPassword}
        secureTextEntry
      />

      <TouchableOpacity
        onPress={handleSignUp}
        disabled={isLoading}
        style={styles.button}
      >
        {isLoading ? (
          <ActivityIndicator size="small" color="#fff" />
        ) : (
          <Text style={styles.buttonText}>Sign Up</Text>
        )}
      </TouchableOpacity>
    </View>
  );
}

const styles = StyleSheet.create((theme) => ({
  container: {
    marginTop: 24,
    padding: 16,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: theme.colors.border,
  },
  title: {
    fontSize: 18,
    fontWeight: "600",
    color: theme.colors.typography,
    marginBottom: 16,
  },
  errorContainer: {
    marginBottom: 16,
    padding: 12,
    borderRadius: 6,
  },
  errorText: {
    color: theme.colors.destructive,
    fontSize: 14,
  },
  input: {
    marginBottom: 12,
    padding: 16,
    borderRadius: 6,
    color: theme.colors.typography,
    borderWidth: 1,
    borderColor: theme.colors.border,
  },
  inputLast: {
    marginBottom: 16,
    padding: 16,
    borderRadius: 6,
    color: theme.colors.typography,
    borderWidth: 1,
    borderColor: theme.colors.border,
  },
  button: {
    backgroundColor: theme.colors.primary,
    padding: 16,
    borderRadius: 6,
    flexDirection: "row",
    justifyContent: "center",
    alignItems: "center",
  },
  buttonText: {
    fontWeight: "500",
  },
}));
`],
  ["auth/better-auth/native/unistyles/components/sign-in.tsx.hbs", `import { authClient } from "@/lib/auth-client";
{{#if (eq api "trpc")}}
import { queryClient } from "@/utils/trpc";
{{/if}}
{{#if (eq api "orpc")}}
import { queryClient } from "@/utils/orpc";
{{/if}}
import { useState } from "react";
import {
  ActivityIndicator,
  Text,
  TextInput,
  TouchableOpacity,
  View,
} from "react-native";
import { StyleSheet } from "react-native-unistyles";

export function SignIn() {
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const handleLogin = async () => {
    setIsLoading(true);
    setError(null);

    await authClient.signIn.email(
      {
        email,
        password,
      },
      {
        onError: (error) => {
          setError(error.error?.message || "Failed to sign in");
          setIsLoading(false);
        },
        onSuccess: () => {
          setEmail("");
          setPassword("");
          {{#if (eq api "orpc")}}
          queryClient.refetchQueries();
          {{/if}}
          {{#if (eq api "trpc")}}
          queryClient.refetchQueries();
          {{/if}}
        },
        onFinished: () => {
          setIsLoading(false);
        },
      },
    );
  };

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Sign In</Text>

      {error && (
        <View style={styles.errorContainer}>
          <Text style={styles.errorText}>{error}</Text>
        </View>
      )}

      <TextInput
        style={styles.input}
        placeholder="Email"
        value={email}
        onChangeText={setEmail}
        keyboardType="email-address"
        autoCapitalize="none"
      />

      <TextInput
        style={styles.input}
        placeholder="Password"
        value={password}
        onChangeText={setPassword}
        secureTextEntry
      />

      <TouchableOpacity
        onPress={handleLogin}
        disabled={isLoading}
        style={styles.button}
      >
        {isLoading ? (
          <ActivityIndicator size="small" color="#fff" />
        ) : (
          <Text style={styles.buttonText}>Sign In</Text>
        )}
      </TouchableOpacity>
    </View>
  );
}

const styles = StyleSheet.create((theme) => ({
  container: {
    marginTop: 24,
    padding: 16,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: theme.colors.border,
  },
  title: {
    fontSize: 18,
    fontWeight: "600",
    color: theme.colors.typography,
    marginBottom: 16,
  },
  errorContainer: {
    marginBottom: 16,
    padding: 12,
    borderRadius: 6,
  },
  errorText: {
    color: theme.colors.destructive,
    fontSize: 14,
  },
  input: {
    marginBottom: 12,
    padding: 16,
    borderRadius: 6,
    color: theme.colors.typography,
    borderWidth: 1,
    borderColor: theme.colors.border,
  },
  button: {
    backgroundColor: theme.colors.primary,
    padding: 16,
    borderRadius: 6,
    flexDirection: "row",
    justifyContent: "center",
    alignItems: "center",
  },
  buttonText: {
    fontWeight: "500",
  },
}));
`],
  ["auth/nextauth/fullstack/next/src/middleware.ts.hbs", `export { auth as middleware } from "@/lib/auth";

export const config = {
  matcher: [
    // Skip Next.js internals and all static files
    "/((?!_next|[^?]*\\\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)",
    // Always run for API routes
    "/(api|trpc)(.*)",
  ],
};
`],
  ["auth/better-auth/server/base/src/index.ts.hbs", `{{#if (eq orm "prisma")}}
import { betterAuth } from "better-auth";
import { prismaAdapter } from "better-auth/adapters/prisma";
import { env } from "@{{projectName}}/env/server";
{{#if (eq payments "polar")}}
import { polar, checkout, portal } from "@polar-sh/better-auth";
import { polarClient } from "./lib/payments";
{{/if}}
import prisma from "@{{projectName}}/db";

export const auth = betterAuth({
	database: prismaAdapter(prisma, {
{{#if (eq database "postgres")}}provider: "postgresql",{{/if}}
{{#if (eq database "sqlite")}}provider: "sqlite",{{/if}}
{{#if (eq database "mysql")}}provider: "mysql",{{/if}}
{{#if (eq database "mongodb")}}provider: "mongodb",{{/if}}
	}),

	trustedOrigins: [
		env.CORS_ORIGIN,
{{#if (or (includes frontend "native-bare") (includes frontend "native-uniwind") (includes frontend "native-unistyles"))}}
		"mybettertapp://", "exp://"
{{/if}}
	],
	emailAndPassword: {
		enabled: true,
	},
{{#if (ne backend "self")}}
	advanced: {
		defaultCookieAttributes: {
			sameSite: "none",
			secure: true,
			httpOnly: true,
		},
	},
{{/if}}
	plugins: [
{{#if (or (includes frontend "native-bare") (includes frontend "native-uniwind") (includes frontend "native-unistyles"))}}
        expo(),
{{/if}}
{{#if (and (eq backend "self") (includes frontend "tanstack-start"))}}
        tanstackStartCookies(),
{{/if}}
{{#if (and (eq backend "self") (includes frontend "next"))}}
        nextCookies(),
{{/if}}
{{#if (eq payments "polar")}}
		polar({
			client: polarClient,
			createCustomerOnSignUp: true,
			enableCustomerPortal: true,
			use: [
				checkout({
					products: [
						{
							productId: "your-product-id",
							slug: "pro",
						},
					],
					successUrl: env.POLAR_SUCCESS_URL,
					authenticatedUsersOnly: true,
				}),
				portal(),
			],
		}),
{{/if}}
	],
});
{{/if}}

{{#if (eq orm "drizzle")}}
{{#if (or (eq runtime "bun") (eq runtime "node") (eq runtime "none"))}}
import { betterAuth } from "better-auth";
import { drizzleAdapter } from "better-auth/adapters/drizzle";
import { env } from "@{{projectName}}/env/server";
{{#if (eq payments "polar")}}
import { polar, checkout, portal } from "@polar-sh/better-auth";
import { polarClient } from "./lib/payments";
{{/if}}
import { db } from "@{{projectName}}/db";
import * as schema from "@{{projectName}}/db/schema/auth";
{{#if (or (includes frontend "native-bare") (includes frontend "native-uniwind") (includes frontend "native-unistyles"))}}
import { expo } from "@better-auth/expo";
{{/if}}
{{#if (and (eq backend "self") (includes frontend "tanstack-start"))}}
import { tanstackStartCookies } from "better-auth/tanstack-start";
{{/if}}
{{#if (and (eq backend "self") (includes frontend "next"))}}
import { nextCookies } from "better-auth/next-js";
{{/if}}

export const auth = betterAuth({
	database: drizzleAdapter(db, {
{{#if (eq database "postgres")}}provider: "pg",{{/if}}
{{#if (eq database "sqlite")}}provider: "sqlite",{{/if}}
{{#if (eq database "mysql")}}provider: "mysql",{{/if}}
		schema: schema,
	}),
	trustedOrigins: [
		env.CORS_ORIGIN,
{{#if (or (includes frontend "native-bare") (includes frontend "native-uniwind") (includes frontend "native-unistyles"))}}
		"mybettertapp://", "exp://"
{{/if}}
	],
	emailAndPassword: {
		enabled: true,
	},
{{#if (ne backend "self")}}
	advanced: {
		defaultCookieAttributes: {
			sameSite: "none",
			secure: true,
			httpOnly: true,
		},
	},
{{/if}}
	plugins: [
{{#if (eq payments "polar")}}
		polar({
			client: polarClient,
			createCustomerOnSignUp: true,
			enableCustomerPortal: true,
			use: [
				checkout({
					products: [
						{
							productId: "your-product-id",
							slug: "pro",
						},
					],
					successUrl: env.POLAR_SUCCESS_URL,
					authenticatedUsersOnly: true,
				}),
				portal(),
			],
		}),
{{/if}}
	],
});
{{/if}}

{{#if (eq runtime "workers")}}
import { betterAuth } from "better-auth";
import { drizzleAdapter } from "better-auth/adapters/drizzle";
import { env } from "@{{projectName}}/env/server";
{{#if (eq payments "polar")}}
import { polar, checkout, portal } from "@polar-sh/better-auth";
import { polarClient } from "./lib/payments";
{{/if}}
import { db } from "@{{projectName}}/db";
import * as schema from "@{{projectName}}/db/schema/auth";


export const auth = betterAuth({
	database: drizzleAdapter(db, {
{{#if (eq database "postgres")}}provider: "pg",{{/if}}
{{#if (eq database "sqlite")}}provider: "sqlite",{{/if}}
{{#if (eq database "mysql")}}provider: "mysql",{{/if}}
		schema: schema,
	}),
	trustedOrigins: [
		env.CORS_ORIGIN,
{{#if (or (includes frontend "native-bare") (includes frontend "native-uniwind") (includes frontend "native-unistyles"))}}
		"mybettertapp://", "exp://"
{{/if}}
	],
	emailAndPassword: {
		enabled: true,
	},
	// uncomment cookieCache setting when ready to deploy to Cloudflare using *.workers.dev domains
	// session: {
	//   cookieCache: {
	//     enabled: true,
	//     maxAge: 60,
	//   },
	// },
	secret: env.BETTER_AUTH_SECRET,
	baseURL: env.BETTER_AUTH_URL,
	advanced: {
		defaultCookieAttributes: {
			sameSite: "none",
			secure: true,
			httpOnly: true,
		},
		// uncomment crossSubDomainCookies setting when ready to deploy and replace <your-workers-subdomain> with your actual workers subdomain
		// https://developers.cloudflare.com/workers/wrangler/configuration/#workersdev
		// crossSubDomainCookies: {
		//   enabled: true,
		//   domain: "<your-workers-subdomain>",
		// },
	},
{{#if (eq payments "polar")}}
	plugins: [
		polar({
			client: polarClient,
			createCustomerOnSignUp: true,
			enableCustomerPortal: true,
			use: [
				checkout({
					products: [
						{
							productId: "your-product-id",
							slug: "pro",
						},
					],
					successUrl: env.POLAR_SUCCESS_URL,
					authenticatedUsersOnly: true,
				}),
				portal(),
			],
		}),
	],
{{/if}}
});
{{/if}}
{{/if}}

{{#if (eq orm "mongoose")}}
import { betterAuth } from "better-auth";
import { mongodbAdapter } from "better-auth/adapters/mongodb";
import { env } from "@{{projectName}}/env/server";
{{#if (eq payments "polar")}}
import { polar, checkout, portal } from "@polar-sh/better-auth";
import { polarClient } from "./lib/payments";
{{/if}}
import { client } from "@{{projectName}}/db";

export const auth = betterAuth({
	database: mongodbAdapter(client),
	trustedOrigins: [
		env.CORS_ORIGIN,
{{#if (or (includes frontend "native-bare") (includes frontend "native-uniwind") (includes frontend "native-unistyles"))}}
		"mybettertapp://", "exp://"
{{/if}}
	],
	emailAndPassword: {
		enabled: true,
	},
{{#if (ne backend "self")}}
	advanced: {
		defaultCookieAttributes: {
			sameSite: "none",
			secure: true,
			httpOnly: true,
		},
	},
{{/if}}
{{#if (eq payments "polar")}}
	plugins: [
		polar({
			client: polarClient,
			createCustomerOnSignUp: true,
			enableCustomerPortal: true,
			use: [
				checkout({
					products: [
						{
							productId: "your-product-id",
							slug: "pro",
						},
					],
					successUrl: env.POLAR_SUCCESS_URL,
					authenticatedUsersOnly: true,
				}),
				portal(),
			],
		}),
	],
{{/if}}
});
{{/if}}

{{#if (eq orm "none")}}
import { betterAuth } from "better-auth";
import { env } from "@{{projectName}}/env/server";
{{#if (eq payments "polar")}}
import { polar, checkout, portal } from "@polar-sh/better-auth";
import { polarClient } from "./lib/payments";
{{/if}}


export const auth = betterAuth({
	database: "", // Invalid configuration
	trustedOrigins: [
		env.CORS_ORIGIN,
{{#if (or (includes frontend "native-bare") (includes frontend "native-uniwind") (includes frontend "native-unistyles"))}}
		"mybettertapp://", "exp://"
{{/if}}
	],
	emailAndPassword: {
		enabled: true,
	},
{{#if (ne backend "self")}}
	advanced: {
		defaultCookieAttributes: {
			sameSite: "none",
			secure: true,
			httpOnly: true,
		},
	},
{{/if}}
{{#if (eq payments "polar")}}
	plugins: [
		polar({
			client: polarClient,
			createCustomerOnSignUp: true,
			enableCustomerPortal: true,
			use: [
				checkout({
					products: [
						{
							productId: "your-product-id",
							slug: "pro",
						},
					],
					successUrl: env.POLAR_SUCCESS_URL,
					authenticatedUsersOnly: true,
				}),
				portal(),
			],
		}),
	],
{{/if}}
});
{{/if}}`],
  ["email/react-email/components/src/emails/welcome.tsx.hbs", `import {
  Body,
  Button,
  Container,
  Head,
  Heading,
  Html,
  Link,
  Preview,
  Section,
  Text,
} from "@react-email/components";

interface WelcomeEmailProps {
  username?: string;
  loginUrl?: string;
}

export function WelcomeEmail({
  username = "there",
  loginUrl = "{{#if (includes frontend 'next')}}http://localhost:3000{{else}}http://localhost:5173{{/if}}",
}: WelcomeEmailProps) {
  return (
    <Html>
      <Head />
      <Preview>Welcome to {{projectName}}!</Preview>
      <Body style={main}>
        <Container style={container}>
          <Heading style={h1}>Welcome to {{projectName}}!</Heading>
          <Text style={text}>Hi {username},</Text>
          <Text style={text}>
            Thanks for signing up! We're excited to have you on board.
          </Text>
          <Section style={buttonContainer}>
            <Button style={button} href={loginUrl}>
              Get Started
            </Button>
          </Section>
          <Text style={footer}>
            If you didn't create an account, you can safely ignore this email.
          </Text>
        </Container>
      </Body>
    </Html>
  );
}

export default WelcomeEmail;

const main = {
  backgroundColor: "#f6f9fc",
  fontFamily:
    '-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Ubuntu,sans-serif',
};

const container = {
  backgroundColor: "#ffffff",
  margin: "0 auto",
  padding: "20px 0 48px",
  marginBottom: "64px",
  borderRadius: "5px",
  maxWidth: "600px",
};

const h1 = {
  color: "#333",
  fontSize: "24px",
  fontWeight: "bold",
  margin: "40px 0",
  padding: "0",
  textAlign: "center" as const,
};

const text = {
  color: "#333",
  fontSize: "16px",
  lineHeight: "26px",
  padding: "0 48px",
};

const buttonContainer = {
  padding: "27px 0 27px",
  textAlign: "center" as const,
};

const button = {
  backgroundColor: "#000",
  borderRadius: "5px",
  color: "#fff",
  fontSize: "16px",
  fontWeight: "bold",
  textDecoration: "none",
  textAlign: "center" as const,
  display: "inline-block",
  padding: "12px 30px",
};

const footer = {
  color: "#898989",
  fontSize: "12px",
  lineHeight: "22px",
  padding: "0 48px",
  marginTop: "20px",
};
`],
  ["email/react-email/components/src/emails/index.ts.hbs", `export { WelcomeEmail } from "./welcome";
`],
  ["email/resend/components/src/emails/welcome.tsx.hbs", `import {
  Body,
  Button,
  Container,
  Head,
  Heading,
  Html,
  Link,
  Preview,
  Section,
  Text,
} from "@react-email/components";

interface WelcomeEmailProps {
  username?: string;
  loginUrl?: string;
}

export function WelcomeEmail({
  username = "there",
  loginUrl = "{{#if (includes frontend 'next')}}http://localhost:3000{{else}}http://localhost:5173{{/if}}",
}: WelcomeEmailProps) {
  return (
    <Html>
      <Head />
      <Preview>Welcome to {{projectName}}!</Preview>
      <Body style={main}>
        <Container style={container}>
          <Heading style={h1}>Welcome to {{projectName}}!</Heading>
          <Text style={text}>Hi {username},</Text>
          <Text style={text}>
            Thanks for signing up! We're excited to have you on board.
          </Text>
          <Section style={buttonContainer}>
            <Button style={button} href={loginUrl}>
              Get Started
            </Button>
          </Section>
          <Text style={footer}>
            If you didn't create an account, you can safely ignore this email.
          </Text>
        </Container>
      </Body>
    </Html>
  );
}

export default WelcomeEmail;

const main = {
  backgroundColor: "#f6f9fc",
  fontFamily:
    '-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Ubuntu,sans-serif',
};

const container = {
  backgroundColor: "#ffffff",
  margin: "0 auto",
  padding: "20px 0 48px",
  marginBottom: "64px",
  borderRadius: "5px",
  maxWidth: "600px",
};

const h1 = {
  color: "#333",
  fontSize: "24px",
  fontWeight: "bold",
  margin: "40px 0",
  padding: "0",
  textAlign: "center" as const,
};

const text = {
  color: "#333",
  fontSize: "16px",
  lineHeight: "26px",
  padding: "0 48px",
};

const buttonContainer = {
  padding: "27px 0 27px",
  textAlign: "center" as const,
};

const button = {
  backgroundColor: "#000",
  borderRadius: "5px",
  color: "#fff",
  fontSize: "16px",
  fontWeight: "bold",
  textDecoration: "none",
  textAlign: "center" as const,
  display: "inline-block",
  padding: "12px 30px",
};

const footer = {
  color: "#898989",
  fontSize: "12px",
  lineHeight: "22px",
  padding: "0 48px",
  marginTop: "20px",
};
`],
  ["email/resend/components/src/emails/index.ts.hbs", `export { WelcomeEmail } from "./welcome";
`],
  ["frontend/qwik/src/components/router-head/router-head.tsx", `import { component$ } from "@builder.io/qwik";
import { useDocumentHead, useLocation } from "@builder.io/qwik-city";

export const RouterHead = component$(() => {
  const head = useDocumentHead();
  const loc = useLocation();

  return (
    <>
      <title>{head.title}</title>

      <link rel="canonical" href={loc.url.href} />
      <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="icon" type="image/svg+xml" href="/favicon.svg" />

      {head.meta.map((m) => (
        <meta key={m.key} {...m} />
      ))}

      {head.links.map((l) => (
        <link key={l.key} {...l} />
      ))}

      {head.styles.map((s) => (
        <style
          key={s.key}
          {...s.props}
          {...(s.props?.dangerouslySetInnerHTML ? {} : { dangerouslySetInnerHTML: s.style })}
        />
      ))}

      {head.scripts.map((s) => (
        <script
          key={s.key}
          {...s.props}
          {...(s.props?.dangerouslySetInnerHTML ? {} : { dangerouslySetInnerHTML: s.script })}
        />
      ))}
    </>
  );
});
`],
  ["frontend/redwood/api/src/functions/graphql.ts", `import { createGraphQLHandler } from "@redwoodjs/graphql-server";
import directives from "src/directives/**/*.{js,ts}";
import sdls from "src/graphql/**/*.sdl.{js,ts}";
import { db } from "src/lib/db";
import { logger } from "src/lib/logger";
import services from "src/services/**/*.{js,ts}";

export const handler = createGraphQLHandler({
  loggerConfig: { logger, options: {} },
  directives,
  sdls,
  services,
  onException: () => {
    // Disconnect from your database with an unhandled exception.
    db.$disconnect();
  },
});
`],
  ["frontend/redwood/api/src/graphql/posts.sdl.ts", `export const schema = gql\`
  type Post {
    id: Int!
    title: String!
    body: String!
    createdAt: DateTime!
  }

  type Query {
    posts: [Post!]! @skipAuth
    post(id: Int!): Post @skipAuth
  }

  input CreatePostInput {
    title: String!
    body: String!
  }

  input UpdatePostInput {
    title: String
    body: String
  }

  type Mutation {
    createPost(input: CreatePostInput!): Post! @requireAuth
    updatePost(id: Int!, input: UpdatePostInput!): Post! @requireAuth
    deletePost(id: Int!): Post! @requireAuth
  }
\`;
`],
  ["frontend/redwood/api/src/lib/auth.ts", `/**
 * Once you have your authentication type defined (e.g. Cookie, OAuth, etc.),
 * you can add auth to your API functions by importing this file
 * and calling \`isAuthenticated()\` and \`hasRole()\` in your handler functions.
 *
 * @see https://redwoodjs.com/docs/authentication
 */
import type { Decoded } from "@redwoodjs/api";

/**
 * Represents the user attributes returned by the decoding the
 * Authentication provider's JWT token together with any additional
 * attributes that you wish to add to the user's context.
 */
export interface CurrentUser {
  id: string;
  email?: string;
  roles?: string[];
}

/**
 * The session object sent in as the first argument to getCurrentUser() will
 * have a single key \`id\` containing the unique ID of the logged in user
 * (whatever field you set as \`authFields.id\` in your auth function config).
 */
export const getCurrentUser = async (
  decoded: Decoded,
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  { _token, _type }: { _token: string; _type: string },
): Promise<CurrentUser | null> => {
  if (!decoded) {
    return null;
  }

  // Add your custom user lookup logic here
  return {
    id: decoded.sub || decoded.id || "user",
    email: decoded.email,
    roles: decoded.roles || [],
  };
};

/**
 * The user is authenticated if there is a currentUser in the context
 */
export const isAuthenticated = (): boolean => {
  return !!context.currentUser;
};

/**
 * When checking role membership, roles can be a single value, a list, or none.
 * You can use Prisma enum types if you have defined them.
 */
export const hasRole = (roles: string | string[]): boolean => {
  if (!isAuthenticated()) {
    return false;
  }

  const currentUserRoles = context.currentUser?.roles;

  if (typeof roles === "string") {
    if (typeof currentUserRoles === "string") {
      return currentUserRoles === roles;
    } else if (Array.isArray(currentUserRoles)) {
      return currentUserRoles?.some((allowedRole) => roles === allowedRole);
    }
  }

  if (Array.isArray(roles)) {
    if (Array.isArray(currentUserRoles)) {
      return currentUserRoles?.some((allowedRole) => roles.includes(allowedRole));
    } else if (typeof currentUserRoles === "string") {
      return roles.some((allowedRole) => currentUserRoles === allowedRole);
    }
  }

  return false;
};

/**
 * Use requireAuth in your services to check that a user is logged in
 *
 * @example
 *
 * export const createPost = ({ input }: { input: CreatePostInput }) => {
 *   requireAuth({ roles: ['admin'] })
 *
 *   return db.post.create({ data: input })
 * }
 *
 */
export const requireAuth = ({ roles }: { roles?: string | string[] } = {}) => {
  if (!isAuthenticated()) {
    throw new Error("You must be logged in to access this");
  }

  if (roles && !hasRole(roles)) {
    throw new Error("You do not have permission to access this");
  }
};
`],
  ["frontend/redwood/api/src/lib/db.ts", `// See https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/constructor
// for options.

import { PrismaClient } from "@prisma/client";
import { emitLogLevels, handlePrismaLogging } from "@redwoodjs/api/logger";

import { logger } from "./logger";

/*
 * Instance of the Prisma Client
 */
export const db = new PrismaClient({
  log: emitLogLevels(["info", "warn", "error"]),
});

handlePrismaLogging({
  db,
  logger,
  logLevels: ["info", "warn", "error"],
});
`],
  ["frontend/redwood/api/src/lib/logger.ts", `import { createLogger } from "@redwoodjs/api/logger";

/**
 * Creates a logger with RedwoodLoggerOptions
 *
 * These extend and adhere to options defined in https://github.com/pinojs/pino/blob/master/docs/api.md
 *
 * @param RedwoodLoggerOptions
 *
 * @returns Logger
 */
export const logger = createLogger({});
`],
  ["frontend/astro/integrations/vue/components/Counter.vue.hbs", `<script setup lang="ts">
import { ref } from 'vue';

const count = ref(0);
</script>

<template>
	<div class="flex items-center gap-4">
		<button
			@click="count--"
			class="rounded-md bg-secondary px-4 py-2 text-secondary-foreground transition-colors hover:bg-secondary/80"
		>
			-
		</button>
		<span class="min-w-[3rem] text-center text-2xl font-bold">{{ count }}</span>
		<button
			@click="count++"
			class="rounded-md bg-primary px-4 py-2 text-primary-foreground transition-colors hover:bg-primary/80"
		>
			+
		</button>
	</div>
</template>
`],
  ["frontend/astro/integrations/solid/components/Counter.tsx.hbs", `import { createSignal } from 'solid-js';

export default function Counter() {
	const [count, setCount] = createSignal(0);

	return (
		<div class="flex items-center gap-4">
			<button
				onClick={() => setCount(count() - 1)}
				class="rounded-md bg-secondary px-4 py-2 text-secondary-foreground transition-colors hover:bg-secondary/80"
			>
				-
			</button>
			<span class="min-w-[3rem] text-center text-2xl font-bold">{count()}</span>
			<button
				onClick={() => setCount(count() + 1)}
				class="rounded-md bg-primary px-4 py-2 text-primary-foreground transition-colors hover:bg-primary/80"
			>
				+
			</button>
		</div>
	);
}
`],
  ["frontend/astro/integrations/svelte/components/Counter.svelte.hbs", `<script lang="ts">
	let count = $state(0);
</script>

<div class="flex items-center gap-4">
	<button
		onclick={() => count--}
		class="rounded-md bg-secondary px-4 py-2 text-secondary-foreground transition-colors hover:bg-secondary/80"
	>
		-
	</button>
	<span class="min-w-[3rem] text-center text-2xl font-bold">{count}</span>
	<button
		onclick={() => count++}
		class="rounded-md bg-primary px-4 py-2 text-primary-foreground transition-colors hover:bg-primary/80"
	>
		+
	</button>
</div>
`],
  ["frontend/astro/integrations/react/components/ModeToggle.tsx.hbs", `import { useEffect, useState } from 'react';

export default function ModeToggle() {
	const [isDark, setIsDark] = useState(true);

	useEffect(() => {
		setIsDark(document.documentElement.classList.contains('dark'));
	}, []);

	const toggleTheme = () => {
		document.documentElement.classList.toggle('dark');
		setIsDark(!isDark);
	};

	return (
		<button
			onClick={toggleTheme}
			className="rounded-md p-2 hover:bg-accent"
			aria-label="Toggle theme"
		>
			{isDark ? (
				<svg className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
					<path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />
				</svg>
			) : (
				<svg className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
					<path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" />
				</svg>
			)}
		</button>
	);
}
`],
  ["frontend/astro/integrations/react/components/Counter.tsx.hbs", `import { useState } from 'react';

export default function Counter() {
	const [count, setCount] = useState(0);

	return (
		<div className="flex items-center gap-4">
			<button
				onClick={() => setCount(count - 1)}
				className="rounded-md bg-secondary px-4 py-2 text-secondary-foreground transition-colors hover:bg-secondary/80"
			>
				-
			</button>
			<span className="min-w-[3rem] text-center text-2xl font-bold">{count}</span>
			<button
				onClick={() => setCount(count + 1)}
				className="rounded-md bg-primary px-4 py-2 text-primary-foreground transition-colors hover:bg-primary/80"
			>
				+
			</button>
		</div>
	);
}
`],
  ["frontend/native/unistyles/app/(drawer)/_layout.tsx.hbs", `import { Ionicons, MaterialIcons } from "@expo/vector-icons";
import { Link } from "expo-router";
import { Drawer } from "expo-router/drawer";
import { useUnistyles } from "react-native-unistyles";

import { HeaderButton } from "../../components/header-button";

const DrawerLayout = () => {
  const { theme } = useUnistyles();

  return (
    <Drawer
      screenOptions=\\{{
        headerStyle: {
          backgroundColor: theme.colors.background,
        },
        headerTitleStyle: {
          color: theme.colors.foreground,
        },
        headerTintColor: theme.colors.foreground,
        drawerStyle: {
          backgroundColor: theme.colors.background,
        },
        drawerLabelStyle: {
          color: theme.colors.foreground,
        },
        drawerInactiveTintColor: theme.colors.mutedForeground,
      }}
    >
      <Drawer.Screen
        name="index"
        options=\\{{
          headerTitle: "Home",
          drawerLabel: "Home",
          drawerIcon: ({ size, color }) => (
            <Ionicons name="home-outline" size={size} color={color} />
          ),
        }}
      />
      <Drawer.Screen
        name="(tabs)"
        options=\\{{
          headerTitle: "Tabs",
          drawerLabel: "Tabs",
          drawerIcon: ({ size, color }) => (
            <MaterialIcons name="border-bottom" size={size} color={color} />
          ),
          headerRight: () => (
            <Link href="/modal" asChild>
              <HeaderButton />
            </Link>
          ),
        }}
      />
      {{#if (includes examples "todo")}}
      <Drawer.Screen
        name="todos"
        options=\\{{
          headerTitle: "Todos",
          drawerLabel: "Todos",
          drawerIcon: ({ size, color }) => (
            <Ionicons name="checkbox-outline" size={size} color={color} />
          ),
        }}
      />
      {{/if}}
      {{#if (includes examples "ai")}}
      <Drawer.Screen
        name="ai"
        options=\\{{
          headerTitle: "AI",
          drawerLabel: "AI",
          drawerIcon: ({ size, color }) => (
            <Ionicons
              name="chatbubble-ellipses-outline"
              size={size}
              color={color}
            />
          ),
        }}
      />
      {{/if}}
    </Drawer>
  );
};

export default DrawerLayout;
`],
  ["frontend/native/unistyles/app/(drawer)/index.tsx.hbs", `import { ScrollView, Text, View, TouchableOpacity } from "react-native";
import { StyleSheet } from "react-native-unistyles";
import { Container } from "@/components/container";

{{#if (eq api "orpc")}}
import { useQuery } from "@tanstack/react-query";
import { orpc } from "@/utils/orpc";
{{/if}}
{{#if (eq api "trpc")}}
import { useQuery } from "@tanstack/react-query";
import { trpc } from "@/utils/trpc";
{{/if}}
{{#if (and (eq backend "convex") (eq auth "clerk"))}}
import { Link } from "expo-router";
import { Authenticated, AuthLoading, Unauthenticated, useQuery } from "convex/react";
import { api } from "@{{ projectName }}/backend/convex/_generated/api";
import { useUser } from "@clerk/clerk-expo";
import { SignOutButton } from "@/components/sign-out-button";
{{else if (and (eq backend "convex") (eq auth "better-auth"))}}
import { useConvexAuth, useQuery } from "convex/react";
import { api } from "@{{ projectName }}/backend/convex/_generated/api";
import { authClient } from "@/lib/auth-client";
import { SignIn } from "@/components/sign-in";
import { SignUp } from "@/components/sign-up";
{{else if (eq backend "convex")}}
import { useQuery } from "convex/react";
import { api } from "@{{ projectName }}/backend/convex/_generated/api";
{{/if}}

export default function Home() {
  {{#if (eq api "orpc")}}
  const healthCheck = useQuery(orpc.healthCheck.queryOptions());
  {{/if}}
  {{#if (eq api "trpc")}}
  const healthCheck = useQuery(trpc.healthCheck.queryOptions());
  {{/if}}
  {{#if (and (eq backend "convex") (eq auth "clerk"))}}
  const { user } = useUser();
  const healthCheck = useQuery(api.healthCheck.get);
  const privateData = useQuery(api.privateData.get);
  {{else if (and (eq backend "convex") (eq auth "better-auth"))}}
  const healthCheck = useQuery(api.healthCheck.get);
  const { isAuthenticated } = useConvexAuth();
  const user = useQuery(api.auth.getCurrentUser, isAuthenticated ? {} : "skip");
  {{else if (eq backend "convex")}}
  const healthCheck = useQuery(api.healthCheck.get);
  {{/if}}

  return (
    <Container>
      <ScrollView
        contentContainerStyle={styles.container}
        showsVerticalScrollIndicator={false}
      >
        <Text style={styles.heroTitle}>
          BETTER T STACK
        </Text>

        {{#unless (and (eq backend "convex") (eq auth "better-auth"))}}
        <View style={styles.statusCard}>
          <View style={styles.statusHeader}>
            <Text style={styles.statusTitle}>System Status</Text>
            <View style={styles.statusBadge}>
              <Text style={styles.statusBadgeText}>LIVE</Text>
            </View>
          </View>
          {{#if (eq backend "convex")}}
            {{#unless (eq auth "better-auth")}}
            <View style={styles.statusRow}>
              <View
                style={[
                  styles.statusDot,
                  healthCheck === "OK"
                    ? styles.statusDotSuccess
                    : styles.statusDotWarning,
                ]}
              />
              <View style={styles.statusContent}>
                <Text style={styles.statusLabel}>Convex</Text>
                <Text style={styles.statusDescription}>
                  {healthCheck === undefined
                    ? "Checking connection..."
                    : healthCheck === "OK"
                    ? "Connected to API"
                    : "API Disconnected"}
                </Text>
              </View>
            </View>
            {{/unless}}
          {{else}}
            {{#unless (eq api "none")}}
            <View style={styles.statusRow}>
              <View
                style={[
                  styles.statusDot,
                  healthCheck.data
                    ? styles.statusDotSuccess
                    : styles.statusDotWarning,
                ]}
              />
              <View style={styles.statusContent}>
                <Text style={styles.statusLabel}>
                  {{#if (eq api "orpc")}}ORPC{{/if}}
                  {{#if (eq api "trpc")}}TRPC{{/if}}
                </Text>
                <Text style={styles.statusDescription}>
                  {healthCheck.isLoading
                    ? "Checking connection..."
                    : healthCheck.data
                    ? "Connected to API"
                    : "API Disconnected"}
                </Text>
              </View>
            </View>
            {{/unless}}
          {{/if}}
        </View>
        {{/unless}}

        {{#if (and (eq backend "convex") (eq auth "clerk"))}}
        <Authenticated>
          <Text>
            Hello {user?.emailAddresses[0].emailAddress}
          </Text>
          <Text>
            Private Data: {privateData?.message}
          </Text>
          <SignOutButton />
        </Authenticated>
        <Unauthenticated>
          <Link href="/(auth)/sign-in">
            <Text>Sign in</Text>
          </Link>
          <Link href="/(auth)/sign-up">
            <Text>Sign up</Text>
          </Link>
        </Unauthenticated>
        <AuthLoading>
          <Text>Loading...</Text>
        </AuthLoading>
        {{/if}}

        {{#if (and (eq backend "convex") (eq auth "better-auth"))}}
        {user ? (
          <View style={styles.userCard}>
            <View style={styles.userHeader}>
              <Text style={styles.userWelcome}>
                Welcome,{" "}
                <Text style={styles.userName}>{user.name}</Text>
              </Text>
            </View>
            <Text style={styles.userEmail}>{user.email}</Text>
            <TouchableOpacity
              style={styles.signOutButton}
              onPress={() => {
                authClient.signOut();
              }}
            >
              <Text style={styles.signOutText}>Sign Out</Text>
            </TouchableOpacity>
          </View>
        ) : null}
        <View style={styles.apiStatusCard}>
          <Text style={styles.apiStatusTitle}>API Status</Text>
          <View style={styles.apiStatusRow}>
            <View
              style={[
                styles.statusDot,
                healthCheck === "OK"
                  ? styles.statusDotSuccess
                  : styles.statusDotWarning,
              ]}
            />
            <Text style={styles.apiStatusText}>
              {healthCheck === undefined
                ? "Checking..."
                : healthCheck === "OK"
                ? "Connected to API"
                : "API Disconnected"}
            </Text>
          </View>
        </View>
        {!user && (
          <>
            <SignIn />
            <SignUp />
          </>
        )}
        {{/if}}
      </ScrollView>
    </Container>
  );
}

const styles = StyleSheet.create((theme) => ({
  container: {
    paddingHorizontal: theme.spacing.md,
  },
  heroSection: {
    paddingVertical: theme.spacing.xl,
  },
  heroTitle: {
    fontSize: theme.fontSize["4xl"],
    fontWeight: "bold",
    color: theme.colors.foreground,
    marginBottom: theme.spacing.sm,
  },
  heroSubtitle: {
    fontSize: theme.fontSize.lg,
    color: theme.colors.mutedForeground,
    lineHeight: 28,
  },
  statusCard: {
    backgroundColor: theme.colors.card,
    borderWidth: 1,
    borderColor: theme.colors.border,
    borderRadius: theme.borderRadius.xl,
    padding: theme.spacing.lg,
    marginBottom: theme.spacing.lg,
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.05,
    shadowRadius: 3,
    elevation: 2,
  },
  statusHeader: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    marginBottom: theme.spacing.md,
  },
  statusTitle: {
    fontSize: theme.fontSize.lg,
    fontWeight: "600",
    color: theme.colors.cardForeground,
  },
  statusBadge: {
    backgroundColor: theme.colors.secondary,
    paddingHorizontal: theme.spacing.sm + 4,
    paddingVertical: theme.spacing.xs,
    borderRadius: 9999,
  },
  statusBadgeText: {
    fontSize: theme.fontSize.xs,
    fontWeight: "500",
    color: theme.colors.secondaryForeground,
  },
  statusRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: theme.spacing.sm + 4,
  },
  statusDot: {
    height: 12,
    width: 12,
    borderRadius: 6,
  },
  statusDotSuccess: {
    backgroundColor: theme.colors.success,
  },
  statusDotWarning: {
    backgroundColor: "#F59E0B",
  },
  statusContent: {
    flex: 1,
  },
  statusLabel: {
    fontSize: theme.fontSize.sm,
    fontWeight: "500",
    color: theme.colors.cardForeground,
  },
  statusDescription: {
    fontSize: theme.fontSize.xs,
    color: theme.colors.mutedForeground,
  },
  userCard: {
    backgroundColor: theme.colors.card,
    borderWidth: 1,
    borderColor: theme.colors.border,
    borderRadius: theme.borderRadius.lg,
    padding: theme.spacing.md,
    marginBottom: theme.spacing.md,
  },
  userHeader: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    marginBottom: theme.spacing.xs,
  },
  userWelcome: {
    fontSize: theme.fontSize.base,
    color: theme.colors.foreground,
  },
  userName: {
    fontWeight: "500",
  },
  userEmail: {
    fontSize: theme.fontSize.sm,
    color: theme.colors.mutedForeground,
    marginBottom: theme.spacing.md,
  },
  signOutButton: {
    backgroundColor: theme.colors.destructive,
    paddingVertical: theme.spacing.sm,
    paddingHorizontal: theme.spacing.md,
    borderRadius: theme.borderRadius.md,
    alignSelf: "flex-start",
  },
  signOutText: {
    color: theme.colors.destructiveForeground,
    fontWeight: "500",
  },
  apiStatusCard: {
    marginBottom: theme.spacing.md,
    borderRadius: theme.borderRadius.lg,
    borderWidth: 1,
    borderColor: theme.colors.border,
    padding: theme.spacing.md,
  },
  apiStatusTitle: {
    marginBottom: theme.spacing.sm,
    fontWeight: "500",
    color: theme.colors.foreground,
  },
  apiStatusRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: theme.spacing.xs,
  },
  apiStatusText: {
    color: theme.colors.mutedForeground,
  },
}));`],
  ["frontend/angular/src/app/components/header.component.ts.hbs", `import { Component } from '@angular/core';

@Component({
  selector: 'app-header',
  standalone: true,
  template: \`
    {{#if (eq cssFramework "tailwind")}}
    <header class="flex items-center justify-between border-b border-gray-200 dark:border-gray-800 px-4 py-3">
      <div class="flex items-center gap-2">
        <span class="font-semibold">Better Fullstack</span>
      </div>
      <nav class="flex items-center gap-4">
        <a href="https://github.com/Marve10s/Better-Fullstack"
           target="_blank"
           rel="noopener noreferrer"
           class="text-sm text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-gray-100 transition-colors">
          GitHub
        </a>
        <a href="https://better-fullstack-web.vercel.app"
           target="_blank"
           rel="noopener noreferrer"
           class="text-sm text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-gray-100 transition-colors">
          Docs
        </a>
      </nav>
    </header>
    {{else}}
    <header [style.display]="'flex'"
            [style.alignItems]="'center'"
            [style.justifyContent]="'space-between'"
            [style.borderBottom]="'1px solid var(--border-color)'"
            [style.padding]="'0.75rem 1rem'">
      <div [style.display]="'flex'" [style.alignItems]="'center'" [style.gap]="'0.5rem'">
        <span [style.fontWeight]="600">Better Fullstack</span>
      </div>
      <nav [style.display]="'flex'" [style.alignItems]="'center'" [style.gap]="'1rem'">
        <a href="https://github.com/Marve10s/Better-Fullstack"
           target="_blank"
           rel="noopener noreferrer"
           [style.fontSize]="'0.875rem'"
           [style.color]="'var(--muted-color)'">
          GitHub
        </a>
        <a href="https://better-fullstack-web.vercel.app"
           target="_blank"
           rel="noopener noreferrer"
           [style.fontSize]="'0.875rem'"
           [style.color]="'var(--muted-color)'">
          Docs
        </a>
      </nav>
    </header>
    {{/if}}
  \`,
})
export class HeaderComponent {}
`],
  ["frontend/native/uniwind/app/(drawer)/_layout.tsx.hbs", `import React, { useCallback } from "react";
import { Ionicons, MaterialIcons } from "@expo/vector-icons";
import { Link } from "expo-router";
import { Drawer } from "expo-router/drawer";
import { useThemeColor } from "heroui-native";
import { Pressable, Text } from "react-native";
import { ThemeToggle } from "@/components/theme-toggle";

function DrawerLayout() {
  const themeColorForeground = useThemeColor("foreground");
  const themeColorBackground = useThemeColor("background");

  const renderThemeToggle = useCallback(() => <ThemeToggle />, []);

  return (
    <Drawer
      screenOptions=\\{{
        headerTintColor: themeColorForeground,
        headerStyle: { backgroundColor: themeColorBackground },
        headerTitleStyle: {
          fontWeight: "600",
          color: themeColorForeground,
        },
        headerRight: renderThemeToggle,
        drawerStyle: { backgroundColor: themeColorBackground },
      }}
    >
      <Drawer.Screen
        name="index"
        options=\\{{
          headerTitle: "Home",
          drawerLabel: ({ color, focused }) => (
            <Text style=\\{{ color: focused ? color : themeColorForeground }}>Home</Text>
          ),
          drawerIcon: ({ size, color, focused }) => (
            <Ionicons name="home-outline" size={size} color={focused ? color : themeColorForeground} />
          ),
        }}
      />
      <Drawer.Screen
        name="(tabs)"
        options=\\{{
          headerTitle: "Tabs",
          drawerLabel: ({ color, focused }) => (
            <Text style=\\{{ color: focused ? color : themeColorForeground }}>Tabs</Text>
          ),
          drawerIcon: ({ size, color, focused }) => (
            <MaterialIcons name="border-bottom" size={size} color={focused ? color : themeColorForeground} />
          ),
          headerRight: () => (
            <Link href="/modal" asChild>
              <Pressable className="mr-4">
                <Ionicons name="add-outline" size={24} color={themeColorForeground} />
              </Pressable>
            </Link>
          ),
        }}
      />
      {{#if (includes examples "todo")}}
      <Drawer.Screen
        name="todos"
        options=\\{{
          headerTitle: "Todos",
          drawerLabel: ({ color, focused }) => (
            <Text style=\\{{ color: focused ? color : themeColorForeground }}>Todos</Text>
          ),
          drawerIcon: ({ size, color, focused }) => (
            <Ionicons name="checkbox-outline" size={size} color={focused ? color : themeColorForeground} />
          ),
        }}
      />
      {{/if}}
      {{#if (includes examples "ai")}}
      <Drawer.Screen
        name="ai"
        options=\\{{
          headerTitle: "AI",
          drawerLabel: ({ color, focused }) => (
            <Text style=\\{{ color: focused ? color : themeColorForeground }}>AI</Text>
          ),
          drawerIcon: ({ size, color, focused }) => (
            <Ionicons name="chatbubble-ellipses-outline" size={size} color={focused ? color : themeColorForeground} />
          ),
        }}
      />
      {{/if}}
    </Drawer>
  );
}

export default DrawerLayout;`],
  ["frontend/native/uniwind/app/(drawer)/index.tsx.hbs", `import { Text, View } from "react-native";
import { Container } from "@/components/container";
{{#if (eq api "orpc")}}
import { useQuery } from "@tanstack/react-query";
import { orpc } from "@/utils/orpc";
{{/if}}
{{#if (eq api "trpc")}}
import { useQuery } from "@tanstack/react-query";
import { trpc } from "@/utils/trpc";
{{/if}}
{{#if (and (eq backend "convex") (eq auth "clerk"))}}
import { Link } from "expo-router";
import { Authenticated, AuthLoading, Unauthenticated, useQuery } from "convex/react";
import { api } from "@{{projectName}}/backend/convex/_generated/api";
import { useUser } from "@clerk/clerk-expo";
import { SignOutButton } from "@/components/sign-out-button";
{{else if (and (eq backend "convex") (eq auth "better-auth"))}}
import { useConvexAuth, useQuery } from "convex/react";
import { api } from "@{{projectName}}/backend/convex/_generated/api";
import { authClient } from "@/lib/auth-client";
import { SignIn } from "@/components/sign-in";
import { SignUp } from "@/components/sign-up";
{{else if (eq backend "convex")}}
import { useQuery } from "convex/react";
import { api } from "@{{projectName}}/backend/convex/_generated/api";
{{/if}}
{{#unless (or (eq backend "none") (and (eq backend "convex") (eq auth "better-auth")))}}
import { Ionicons } from "@expo/vector-icons";
{{/unless}}
import { Button, Chip, Divider, Spinner, Surface, useThemeColor } from "heroui-native";

export default function Home() {
{{#if (eq api "orpc")}}
const healthCheck = useQuery(orpc.healthCheck.queryOptions());
{{/if}}
{{#if (eq api "trpc")}}
const healthCheck = useQuery(trpc.healthCheck.queryOptions());
{{/if}}
{{#if (and (eq backend "convex") (eq auth "clerk"))}}
const { user } = useUser();
const healthCheck = useQuery(api.healthCheck.get);
const privateData = useQuery(api.privateData.get);
{{else if (and (eq backend "convex") (eq auth "better-auth"))}}
const healthCheck = useQuery(api.healthCheck.get);
const { isAuthenticated } = useConvexAuth();
const user = useQuery(api.auth.getCurrentUser, isAuthenticated ? {} : "skip");
{{else if (eq backend "convex")}}
const healthCheck = useQuery(api.healthCheck.get);
{{/if}}
{{#unless (eq backend "none")}}
const successColor = useThemeColor("success");
const dangerColor = useThemeColor("danger");

{{#if (eq backend "convex")}}
const isConnected = healthCheck === "OK";
const isLoading = healthCheck === undefined;
{{else}}
{{#unless (eq api "none")}}
const isConnected = healthCheck?.data === "OK";
const isLoading = healthCheck?.isLoading;
{{/unless}}
{{/if}}
{{/unless}}

return (
<Container className="p-4">
  <View className="py-6 mb-4">
    <Text className="text-3xl font-semibold text-foreground tracking-tight">
      Better T Stack
    </Text>
    <Text className="text-muted text-sm mt-1">Full-stack TypeScript starter</Text>
  </View>

  {{#unless (or (eq backend "none") (and (eq backend "convex") (eq auth "better-auth")))}}
  <Surface variant="secondary" className="p-4 rounded-lg">
    <View className="flex-row items-center justify-between mb-3">
      <Text className="text-foreground font-medium">System Status</Text>
      <Chip variant="secondary" color={isConnected ? "success" : "danger" } size="sm">
        <Chip.Label>
          {isConnected ? "LIVE" : "OFFLINE"}
        </Chip.Label>
      </Chip>
    </View>

    <Divider className="mb-3" />

    <Surface variant="tertiary" className="p-3 rounded-md">
      <View className="flex-row items-center">
        <View className={\`w-2 h-2 rounded-full mr-3 \${ isConnected ? "bg-success" : "bg-muted" }\`} />
        <View className="flex-1">
          <Text className="text-foreground text-sm font-medium">
            {{#if (eq backend "convex")}}
            Convex Backend
            {{else}}
            {{#unless (eq api "none")}}
            {{#if (eq api "orpc")}}ORPC{{else}}TRPC{{/if}} Backend
            {{/unless}}
            {{/if}}
          </Text>
          <Text className="text-muted text-xs mt-0.5">
            {isLoading
            ? "Checking connection..."
            : isConnected
            ? "Connected to API"
            : "API Disconnected"}
          </Text>
        </View>
        {isLoading && <Spinner size="sm" />}
        {!isLoading && isConnected && (
        <Ionicons name="checkmark-circle" size={18} color={successColor} />
        )}
        {!isLoading && !isConnected && (
        <Ionicons name="close-circle" size={18} color={dangerColor} />
        )}
      </View>
    </Surface>
  </Surface>
  {{/unless}}

  {{#if (and (eq backend "convex") (eq auth "clerk"))}}
  <Authenticated>
    <Surface variant="secondary" className="mt-4 p-4 rounded-lg">
      <View className="flex-row items-center justify-between">
        <View className="flex-1">
          <Text className="text-foreground font-medium">{user?.emailAddresses[0].emailAddress}</Text>
          <Text className="text-muted text-xs mt-0.5">Private: {privateData?.message}</Text>
        </View>
        <SignOutButton />
      </View>
    </Surface>
  </Authenticated>
  <Unauthenticated>
    <View className="mt-4 gap-3">
      <Link href="/(auth)/sign-in" asChild>
        <Button variant="secondary"><Button.Label>Sign In</Button.Label></Button>
      </Link>
      <Link href="/(auth)/sign-up" asChild>
        <Button variant="ghost"><Button.Label>Sign Up</Button.Label></Button>
      </Link>
    </View>
  </Unauthenticated>
  <AuthLoading>
    <View className="mt-4 items-center">
      <Spinner size="sm" />
    </View>
  </AuthLoading>
  {{/if}}

  {{#if (and (eq backend "convex") (eq auth "better-auth"))}}
  {user ? (
  <Surface variant="secondary" className="mb-4 p-4 rounded-lg">
    <View className="flex-row items-center justify-between">
      <View className="flex-1">
        <Text className="text-foreground font-medium">{user.name}</Text>
        <Text className="text-muted text-xs mt-0.5">{user.email}</Text>
      </View>
      <Button
        variant="destructive"
        size="sm"
        onPress={() => {
          authClient.signOut();
        }}
      >
        Sign Out
      </Button>
    </View>
  </Surface>
  ) : null}
  <Surface variant="secondary" className="p-4 rounded-lg">
    <Text className="text-foreground font-medium mb-2">API Status</Text>
    <View className="flex-row items-center gap-2">
      <View className={\`w-2 h-2 rounded-full \${healthCheck==="OK" ? "bg-success" : "bg-danger" }\`} />
      <Text className="text-muted text-xs">
        {healthCheck === undefined
        ? "Checking..."
        : healthCheck === "OK"
        ? "Connected to API"
        : "API Disconnected"}
      </Text>
    </View>
  </Surface>
  {!user && (
  <View className="mt-4 gap-4">
    <SignIn />
    <SignUp />
  </View>
  )}
  {{/if}}
</Container>
);
}`],
  ["frontend/native/base/assets/images/partial-react-logo.png", `[Binary file]`],
  ["frontend/native/base/assets/images/react-logo.png", `[Binary file]`],
  ["frontend/native/base/assets/images/react-logo@2x.png", `[Binary file]`],
  ["frontend/native/base/assets/images/android-icon-monochrome.png", `[Binary file]`],
  ["frontend/native/base/assets/images/splash-icon.png", `[Binary file]`],
  ["frontend/native/base/assets/images/react-logo@3x.png", `[Binary file]`],
  ["frontend/native/base/assets/images/icon.png", `[Binary file]`],
  ["frontend/native/base/assets/images/android-icon-foreground.png", `[Binary file]`],
  ["frontend/native/base/assets/images/favicon.png", `[Binary file]`],
  ["frontend/native/base/assets/images/android-icon-background.png", `[Binary file]`],
  ["frontend/nuxt/app/assets/css/main.css", `@import "tailwindcss";
@import "@nuxt/ui";
`],
  ["frontend/native/bare/app/(drawer)/_layout.tsx.hbs", `import { Ionicons, MaterialIcons } from "@expo/vector-icons";
import { Link } from "expo-router";
import { Drawer } from "expo-router/drawer";
import { useColorScheme } from "@/lib/use-color-scheme";
import { NAV_THEME } from "@/lib/constants";

import { HeaderButton } from "@/components/header-button";

const DrawerLayout = () => {
  const { colorScheme } = useColorScheme();
  const theme = colorScheme === "dark" ? NAV_THEME.dark : NAV_THEME.light;

  return (
    <Drawer
      screenOptions=\\{{
        headerStyle: {
          backgroundColor: theme.background,
        },
        headerTitleStyle: {
          color: theme.text,
        },
        headerTintColor: theme.text,
        drawerStyle: {
          backgroundColor: theme.background,
        },
        drawerLabelStyle: {
          color: theme.text,
        },
        drawerInactiveTintColor: theme.text,
      }}
    >
      <Drawer.Screen
        name="index"
        options=\\{{
          headerTitle: "Home",
          drawerLabel: "Home",
          drawerIcon: ({ size, color }) => (
            <Ionicons name="home-outline" size={size} color={color} />
          ),
        }}
      />
      <Drawer.Screen
        name="(tabs)"
        options=\\{{
          headerTitle: "Tabs",
          drawerLabel: "Tabs",
          drawerIcon: ({ size, color }) => (
            <MaterialIcons name="border-bottom" size={size} color={color} />
          ),
          headerRight: () => (
            <Link href="/modal" asChild>
              <HeaderButton />
            </Link>
          ),
        }}
      />
      {{#if (includes examples "todo")}}
      <Drawer.Screen
        name="todos"
        options=\\{{
          headerTitle: "Todos",
          drawerLabel: "Todos",
          drawerIcon: ({ size, color }) => (
            <Ionicons name="checkbox-outline" size={size} color={color} />
          ),
        }}
      />
      {{/if}}
      {{#if (includes examples "ai")}}
      <Drawer.Screen
        name="ai"
        options=\\{{
          headerTitle: "AI",
          drawerLabel: "AI",
          drawerIcon: ({ size, color }) => (
            <Ionicons
              name="chatbubble-ellipses-outline"
              size={size}
              color={color}
            />
          ),
        }}
      />
      {{/if}}
    </Drawer>
  );
};

export default DrawerLayout;

`],
  ["frontend/native/bare/app/(drawer)/index.tsx.hbs", `import { View, Text, ScrollView, TouchableOpacity, StyleSheet } from "react-native";
import { Container } from "@/components/container";
import { useColorScheme } from "@/lib/use-color-scheme";
import { NAV_THEME } from "@/lib/constants";
{{#if (eq api "orpc")}}
import { useQuery } from "@tanstack/react-query";
import { orpc } from "@/utils/orpc";
{{/if}}
{{#if (eq api "trpc")}}
import { useQuery } from "@tanstack/react-query";
import { trpc } from "@/utils/trpc";
{{/if}}
{{#if (and (eq backend "convex") (eq auth "clerk"))}}
import { Link } from "expo-router";
import { Authenticated, AuthLoading, Unauthenticated, useQuery } from "convex/react";
import { api } from "@{{ projectName }}/backend/convex/_generated/api";
import { useUser } from "@clerk/clerk-expo";
import { SignOutButton } from "@/components/sign-out-button";
{{else if (and (eq backend "convex") (eq auth "better-auth"))}}
import { useConvexAuth, useQuery } from "convex/react";
import { api } from "@{{ projectName }}/backend/convex/_generated/api";
import { authClient } from "@/lib/auth-client";
import { SignIn } from "@/components/sign-in";
import { SignUp } from "@/components/sign-up";
{{else if (eq backend "convex")}}
import { useQuery } from "convex/react";
import { api } from "@{{ projectName }}/backend/convex/_generated/api";
{{/if}}

export default function Home() {
const { colorScheme } = useColorScheme();
const theme = colorScheme === "dark" ? NAV_THEME.dark : NAV_THEME.light;
{{#if (eq api "orpc")}}
const healthCheck = useQuery(orpc.healthCheck.queryOptions());
{{/if}}
{{#if (eq api "trpc")}}
const healthCheck = useQuery(trpc.healthCheck.queryOptions());
{{/if}}
{{#if (and (eq backend "convex") (eq auth "clerk"))}}
const { user } = useUser();
const healthCheck = useQuery(api.healthCheck.get);
const privateData = useQuery(api.privateData.get);
{{else if (and (eq backend "convex") (eq auth "better-auth"))}}
const healthCheck = useQuery(api.healthCheck.get);
const { isAuthenticated } = useConvexAuth();
const user = useQuery(api.auth.getCurrentUser, isAuthenticated ? {} : "skip");
{{else if (eq backend "convex")}}
const healthCheck = useQuery(api.healthCheck.get);
{{/if}}

return (
<Container>
  <ScrollView style={styles.scrollView}>
    <View style={styles.content}>
      <Text style={[styles.title, { color: theme.text }]}>
        BETTER T STACK
      </Text>

      {{#unless (and (eq backend "convex") (eq auth "better-auth"))}}
      <View style={[styles.card, { backgroundColor: theme.card, borderColor: theme.border }]}>
        {{#if (eq backend "convex")}}
        <View style={styles.statusRow}>
          <View style={[styles.statusIndicator, { backgroundColor: healthCheck ? "#10b981" : "#f59e0b" }]} />
          <View style={styles.statusContent}>
            <Text style={[styles.statusTitle, { color: theme.text }]}>
              Convex
            </Text>
            <Text style={[styles.statusText, { color: theme.text, opacity: 0.7 }]}>
              {healthCheck === undefined
              ? "Checking..."
              : healthCheck === "OK"
              ? "Connected to API"
              : "API Disconnected"}
            </Text>
          </View>
        </View>
        {{else}}
        {{#unless (eq api "none")}}
        <View style={styles.statusRow}>
          <View style={[styles.statusIndicator, { backgroundColor: healthCheck.data ? "#10b981" : "#f59e0b" }]} />
          <View style={styles.statusContent}>
            <Text style={[styles.statusTitle, { color: theme.text }]}>
              {{#if (eq api "orpc")}}ORPC{{else}}TRPC{{/if}}
            </Text>
            <Text style={[styles.statusText, { color: theme.text, opacity: 0.7 }]}>
              {healthCheck.isLoading
              ? "Checking connection..."
              : healthCheck.data
              ? "All systems operational"
              : "Service unavailable"}
            </Text>
          </View>
        </View>
        {{/unless}}
        {{/if}}
      </View>
      {{/unless}}

      {{#if (and (eq backend "convex") (eq auth "clerk"))}}
      <Authenticated>
        <Text style=\\{{ color: theme.text }}>Hello {user?.emailAddresses[0].emailAddress}</Text>
        <Text style=\\{{ color: theme.text }}>Private Data: {privateData?.message}</Text>
        <SignOutButton />
      </Authenticated>
      <Unauthenticated>
        <Link href="/(auth)/sign-in">
        <Text style=\\{{ color: theme.primary }}>Sign in</Text>
        </Link>
        <Link href="/(auth)/sign-up">
        <Text style=\\{{ color: theme.primary }}>Sign up</Text>
        </Link>
      </Unauthenticated>
      <AuthLoading>
        <Text style=\\{{ color: theme.text }}>Loading...</Text>
      </AuthLoading>
      {{/if}}

      {{#if (and (eq backend "convex") (eq auth "better-auth"))}}
      {user ? (
      <View style={[styles.userCard, { backgroundColor: theme.card, borderColor: theme.border }]}>
        <View style={styles.userHeader}>
          <Text style={[styles.userText, { color: theme.text }]}>
            Welcome, <Text style={styles.userName}>{user.name}</Text>
          </Text>
        </View>
        <Text style={[styles.userEmail, { color: theme.text, opacity: 0.7 }]}>
          {user.email}
        </Text>
        <TouchableOpacity style={[styles.signOutButton, { backgroundColor: theme.notification }]} onPress={()=> {
          authClient.signOut();
          }}
          >
          <Text style={styles.signOutText}>Sign Out</Text>
        </TouchableOpacity>
      </View>
      ) : null}
      <View style={[styles.statusCard, { backgroundColor: theme.card, borderColor: theme.border }]}>
        <Text style={[styles.statusCardTitle, { color: theme.text }]}>
          API Status
        </Text>
        <View style={styles.statusRow}>
          <View style={[styles.statusIndicator, { backgroundColor: healthCheck ? "#10b981" : "#ef4444" }]} />
          <Text style={[styles.statusText, { color: theme.text, opacity: 0.7 }]}>
            {healthCheck === undefined
            ? "Checking..."
            : healthCheck === "OK"
            ? "Connected to API"
            : "API Disconnected"}
          </Text>
        </View>
      </View>
      {!user && (
      <>
        <SignIn />
        <SignUp />
      </>
      )}
      {{/if}}
    </View>
  </ScrollView>
</Container>
);
}

const styles = StyleSheet.create({
scrollView: {
flex: 1,
},
content: {
padding: 16,
},
title: {
fontSize: 24,
fontWeight: "bold",
marginBottom: 16,
},
card: {
padding: 16,
marginBottom: 16,
borderWidth: 1,
},
statusRow: {
flexDirection: "row",
alignItems: "center",
gap: 8,
},
statusIndicator: {
height: 8,
width: 8,
},
statusContent: {
flex: 1,
},
statusTitle: {
fontSize: 14,
fontWeight: "bold",
},
statusText: {
fontSize: 12,
},
userCard: {
marginBottom: 16,
padding: 16,
borderWidth: 1,
},
userHeader: {
marginBottom: 8,
},
userText: {
fontSize: 16,
},
userName: {
fontWeight: "bold",
},
userEmail: {
fontSize: 14,
marginBottom: 12,
},
signOutButton: {
padding: 12,
},
signOutText: {
color: "#ffffff",
},
statusCard: {
marginBottom: 16,
padding: 16,
borderWidth: 1,
},
statusCardTitle: {
marginBottom: 8,
fontWeight: "bold",
},
});`],
  ["frontend/react/react-router/src/routes/_index.tsx.hbs", `import type { Route } from "./+types/_index";
{{#if (eq backend "convex")}}
import { useQuery } from "convex/react";
import { api } from "@{{projectName}}/backend/convex/_generated/api";
{{else if (or (eq api "orpc") (eq api "trpc"))}}
import { useQuery } from "@tanstack/react-query";
  {{#if (eq api "orpc")}}
  import { orpc } from "@/utils/orpc";
  {{/if}}
  {{#if (eq api "trpc")}}
  import { trpc } from "@/utils/trpc";
  {{/if}}
{{/if}}

const TITLE_TEXT = \`
  
 
                 
                 
               
                

          
      
                      
                      
                     
                      
 \`;

export function meta({}: Route.MetaArgs) {
  return [{ title: "{{projectName}}" }, { name: "description", content: "{{projectName}} is a web application" }];
}

export default function Home() {
  {{#if (eq backend "convex")}}
  const healthCheck = useQuery(api.healthCheck.get);
  {{else if (eq api "orpc")}}
  const healthCheck = useQuery(orpc.healthCheck.queryOptions());
  {{else if (eq api "trpc")}}
  const healthCheck = useQuery(trpc.healthCheck.queryOptions());
  {{/if}}

  return (
    <div className="container mx-auto max-w-3xl px-4 py-2">
      <pre className="overflow-x-auto font-mono text-sm">{TITLE_TEXT}</pre>
      <div className="grid gap-6">
        <section className="rounded-lg border p-4">
          <h2 className="mb-2 font-medium">API Status</h2>
          {{#if (eq backend "convex")}}
          <div className="flex items-center gap-2">
            <div
              className={\`h-2 w-2 rounded-full \${healthCheck === "OK" ? "bg-green-500" : healthCheck === undefined ? "bg-orange-400" : "bg-red-500"}\`}
            />
            <span className="text-sm text-muted-foreground">
              {healthCheck === undefined
                ? "Checking..."
                : healthCheck === "OK"
                  ? "Connected"
                  : "Error"}
            </span>
          </div>
          {{else}}
            {{#unless (eq api "none")}}
            <div className="flex items-center gap-2">
              <div
                className={\`h-2 w-2 rounded-full \${
                  healthCheck.data ? "bg-green-500" : "bg-red-500"
                }\`}
              />
              <span className="text-sm text-muted-foreground">
                {healthCheck.isLoading
                  ? "Checking..."
                  : healthCheck.data
                  ? "Connected"
                  : "Disconnected"}
              </span>
            </div>
            {{/unless}}
          {{/if}}
        </section>
      </div>
    </div>
  );
}
`],
  ["frontend/react/react-router/src/components/theme-provider.tsx.hbs", `import * as React from "react";
import { ThemeProvider as NextThemesProvider } from "next-themes";

export function ThemeProvider({
  children,
  ...props
}: React.ComponentProps<typeof NextThemesProvider>) {
  return <NextThemesProvider {...props}>{children}</NextThemesProvider>;
}

export { useTheme } from "next-themes";
`],
  ["frontend/react/react-router/src/components/mode-toggle.tsx.hbs", `import { Moon, Sun } from "lucide-react";

import { Button } from "@/components/ui/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { useTheme } from "@/components/theme-provider";

export function ModeToggle() {
  const { setTheme } = useTheme();

  return (
    <DropdownMenu>
      <DropdownMenuTrigger render={<Button variant="outline" size="icon" />}>
        <Sun className="h-[1.2rem] w-[1.2rem] scale-100 rotate-0 transition-all dark:scale-0 dark:-rotate-90" />
        <Moon className="absolute h-[1.2rem] w-[1.2rem] scale-0 rotate-90 transition-all dark:scale-100 dark:rotate-0" />
        <span className="sr-only">Toggle theme</span>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end">
        <DropdownMenuItem onClick={() => setTheme("light")}>Light</DropdownMenuItem>
        <DropdownMenuItem onClick={() => setTheme("dark")}>Dark</DropdownMenuItem>
        <DropdownMenuItem onClick={() => setTheme("system")}>System</DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}
`],
  ["backend/convex/packages/backend/convex/convex.config.ts.hbs", `import { defineApp } from "convex/server";
{{#if (eq auth "better-auth")}}
import betterAuth from "@convex-dev/better-auth/convex.config";
{{/if}}
{{#if (includes examples "ai")}}
import agent from "@convex-dev/agent/convex.config";
{{/if}}

const app = defineApp();
{{#if (eq auth "better-auth")}}
app.use(betterAuth);
{{/if}}
{{#if (includes examples "ai")}}
app.use(agent);
{{/if}}

export default app;
`],
  ["backend/convex/packages/backend/convex/schema.ts.hbs", `import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";

export default defineSchema({
{{#if (includes examples "todo")}}
  todos: defineTable({
    text: v.string(),
    completed: v.boolean(),
  }),
{{/if}}
});
`],
  ["backend/convex/packages/backend/convex/healthCheck.ts.hbs", `import { query } from "./_generated/server";

export const get = query({
  handler: async () => {
    return "OK";
  },
});
`],
  ["backend/convex/packages/backend/convex/tsconfig.json.hbs", `{
  /* This TypeScript project config describes the environment that
   * Convex functions run in and is used to typecheck them.
   * You can modify it, but some settings are required to use Convex.
   */
  "compilerOptions": {
    /* These settings are not required by Convex and can be modified. */
    "allowJs": true,
    "strict": true,
    "moduleResolution": "Bundler",
    "jsx": "react-jsx",
    "skipLibCheck": true,
    "allowSyntheticDefaultImports": true,

    /* These compiler options are required by Convex */
    "target": "ESNext",
    "lib": ["ES2021", "dom"],
    "forceConsistentCasingInFileNames": true,
    "module": "ESNext",
    "isolatedModules": true,
    "noEmit": true
  },
  "include": ["./**/*"],
  "exclude": ["./_generated"]
}
`],
  ["backend/convex/packages/backend/convex/README.md", `# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

\`\`\`ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
\`\`\`

Using this query function in a React component looks like:

\`\`\`ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
\`\`\`

A mutation function looks like:

\`\`\`ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get("messages", id);
  },
});
\`\`\`

Using this mutation function in a React component looks like:

\`\`\`ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
\`\`\`

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running \`npx convex -h\` in your project root
directory. To learn more, launch the docs with \`npx convex docs\`.
`],
  ["frontend/react/tanstack-router/src/routes/__root.tsx.hbs", `import Header from "@/components/header";
import { ThemeProvider } from "@/components/theme-provider";
import { Toaster } from "@/components/ui/sonner";
{{#if (eq api "orpc")}}
import { link, orpc } from "@/utils/orpc";
import type { QueryClient } from "@tanstack/react-query";
import { ReactQueryDevtools } from "@tanstack/react-query-devtools";
import { useState } from "react";
import { createTanstackQueryUtils } from "@orpc/tanstack-query";
import type { AppRouterClient } from "@{{projectName}}/api/routers/index";
import { createORPCClient } from "@orpc/client";
{{/if}}
{{#if (eq api "trpc")}}
import type { trpc } from "@/utils/trpc";
import type { QueryClient } from "@tanstack/react-query";
import { ReactQueryDevtools } from "@tanstack/react-query-devtools";
{{/if}}
import {
  HeadContent,
  Outlet,
  createRootRouteWithContext,
} from "@tanstack/react-router";
import { TanStackRouterDevtools } from "@tanstack/react-router-devtools";
import "../index.css";

{{#if (eq api "orpc")}}
export interface RouterAppContext {
  orpc: typeof orpc;
  queryClient: QueryClient;
}
{{else if (eq api "trpc")}}
export interface RouterAppContext {
  trpc: typeof trpc;
  queryClient: QueryClient;
}
{{else}}
export interface RouterAppContext {}
{{/if}}

export const Route = createRootRouteWithContext<RouterAppContext>()({
  component: RootComponent,
  head: () => ({
    meta: [
      {
        title: "{{projectName}}",
      },
      {
        name: "description",
        content: "{{projectName}} is a web application",
      },
    ],
    links: [
      {
        rel: "icon",
        href: "/favicon.ico",
      },
    ],
  }),
});

function RootComponent() {
  {{#if (eq api "orpc")}}
  const [client] = useState<AppRouterClient>(() => createORPCClient(link));
  const [orpcUtils] = useState(() => createTanstackQueryUtils(client));
  {{/if}}

  return (
    <>
      <HeadContent />
      {{#if (eq api "orpc")}}
        <ThemeProvider
          attribute="class"
          defaultTheme="dark"
          disableTransitionOnChange
          storageKey="vite-ui-theme"
        >
          <div className="grid grid-rows-[auto_1fr] h-svh">
            <Header />
            <Outlet />
          </div>
          <Toaster richColors />
        </ThemeProvider>
      {{else}}
      <ThemeProvider
        attribute="class"
        defaultTheme="dark"
        disableTransitionOnChange
        storageKey="vite-ui-theme"
      >
        <div className="grid grid-rows-[auto_1fr] h-svh">
          <Header />
          <Outlet />
        </div>
        <Toaster richColors />
      </ThemeProvider>
      {{/if}}
      <TanStackRouterDevtools position="bottom-left" />
      {{#if (or (eq api "orpc") (eq api "trpc"))}}
      <ReactQueryDevtools position="bottom" buttonPosition="bottom-right" />
      {{/if}}
    </>
  );
}
`],
  ["frontend/react/tanstack-router/src/routes/index.tsx.hbs", `import { createFileRoute } from "@tanstack/react-router";
{{#if (eq api "orpc")}}
import { orpc } from "@/utils/orpc";
import { useQuery } from "@tanstack/react-query";
{{/if}}
{{#if (eq api "trpc")}}
import { trpc } from "@/utils/trpc";
import { useQuery } from "@tanstack/react-query";
{{/if}}
{{#if (eq backend "convex")}}
import { useQuery } from "convex/react";
import { api } from "@{{ projectName }}/backend/convex/_generated/api";
{{/if}}

export const Route = createFileRoute("/")({
  component: HomeComponent,
});

const TITLE_TEXT = \`
  
 
                 
                 
               
                

          
      
                      
                      
                     
                      
 \`;

function HomeComponent() {
  {{#if (eq api "orpc")}}
  const healthCheck = useQuery(orpc.healthCheck.queryOptions());
  {{/if}}
  {{#if (eq api "trpc")}}
  const healthCheck = useQuery(trpc.healthCheck.queryOptions());
  {{/if}}
  {{#if (eq backend "convex")}}
  const healthCheck = useQuery(api.healthCheck.get);
  {{/if}}

  return (
    <div className="container mx-auto max-w-3xl px-4 py-2">
      <pre className="overflow-x-auto font-mono text-sm">{TITLE_TEXT}</pre>
      <div className="grid gap-6">
        <section className="rounded-lg border p-4">
          <h2 className="mb-2 font-medium">API Status</h2>
          {{#if (eq backend "convex")}}
          <div className="flex items-center gap-2">
            <div
              className={\`h-2 w-2 rounded-full \${healthCheck === "OK" ? "bg-green-500" : healthCheck === undefined ? "bg-orange-400" : "bg-red-500"}\`}
            />
            <span className="text-sm text-muted-foreground">
              {healthCheck === undefined
                ? "Checking..."
                : healthCheck === "OK"
                  ? "Connected"
                  : "Error"}
            </span>
          </div>
          {{else}}
            {{#unless (eq api "none")}}
            <div className="flex items-center gap-2">
              <div
                className={\`h-2 w-2 rounded-full \${healthCheck.data ? "bg-green-500" : "bg-red-500"}\`}
              />
              <span className="text-sm text-muted-foreground">
                {healthCheck.isLoading
                  ? "Checking..."
                  : healthCheck.data
                    ? "Connected"
                    : "Disconnected"}
              </span>
            </div>
            {{/unless}}
          {{/if}}
        </section>
      </div>
    </div>
  );
}
`],
  ["frontend/react/tanstack-router/src/components/theme-provider.tsx.hbs", `import * as React from "react";
import { ThemeProvider as NextThemesProvider } from "next-themes";

export function ThemeProvider({
  children,
  ...props
}: React.ComponentProps<typeof NextThemesProvider>) {
  return <NextThemesProvider {...props}>{children}</NextThemesProvider>;
}

export { useTheme } from "next-themes";
`],
  ["frontend/react/tanstack-router/src/components/mode-toggle.tsx.hbs", `import { Moon, Sun } from "lucide-react";

import { Button } from "@/components/ui/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { useTheme } from "@/components/theme-provider";

export function ModeToggle() {
  const { setTheme } = useTheme();

  return (
    <DropdownMenu>
      <DropdownMenuTrigger render={<Button variant="outline" size="icon" />}>
        <Sun className="h-[1.2rem] w-[1.2rem] scale-100 rotate-0 transition-all dark:scale-0 dark:-rotate-90" />
        <Moon className="absolute h-[1.2rem] w-[1.2rem] scale-0 rotate-90 transition-all dark:scale-100 dark:rotate-0" />
        <span className="sr-only">Toggle theme</span>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end">
        <DropdownMenuItem onClick={() => setTheme("light")}>Light</DropdownMenuItem>
        <DropdownMenuItem onClick={() => setTheme("dark")}>Dark</DropdownMenuItem>
        <DropdownMenuItem onClick={() => setTheme("system")}>System</DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}
`],
  ["frontend/react/next/src/app/favicon.ico", `[Binary file]`],
  ["frontend/react/next/src/app/page.tsx.hbs", `"use client"
{{#if (eq backend "convex")}}
import { useQuery } from "convex/react";
import { api } from "@{{projectName}}/backend/convex/_generated/api";
{{else if (or (eq api "orpc") (eq api "trpc"))}}
import { useQuery } from "@tanstack/react-query";
  {{#if (eq api "orpc")}}
import { orpc } from "@/utils/orpc";
  {{/if}}
  {{#if (eq api "trpc")}}
import { trpc } from "@/utils/trpc";
  {{/if}}
{{/if}}

const TITLE_TEXT = \`
  
 
                 
                 
               
                

          
      
                      
                      
                     
                      
 \`;

export default function Home() {
  {{#if (eq backend "convex")}}
  const healthCheck = useQuery(api.healthCheck.get);
  {{else if (eq api "orpc")}}
  const healthCheck = useQuery(orpc.healthCheck.queryOptions());
  {{else if (eq api "trpc")}}
  const healthCheck = useQuery(trpc.healthCheck.queryOptions());
  {{/if}}

  return (
    <div className="container mx-auto max-w-3xl px-4 py-2">
      <pre className="overflow-x-auto font-mono text-sm">{TITLE_TEXT}</pre>
      <div className="grid gap-6">
        <section className="rounded-lg border p-4">
          <h2 className="mb-2 font-medium">API Status</h2>
          {{#if (eq backend "convex")}}
          <div className="flex items-center gap-2">
            <div
              className={\`h-2 w-2 rounded-full \${healthCheck === "OK" ? "bg-green-500" : healthCheck === undefined ? "bg-orange-400" : "bg-red-500"}\`}
            />
            <span className="text-sm text-muted-foreground">
              {healthCheck === undefined
                ? "Checking..."
                : healthCheck === "OK"
                  ? "Connected"
                  : "Error"}
            </span>
          </div>
          {{else}}
            {{#unless (eq api "none")}}
            <div className="flex items-center gap-2">
              <div
                className={\`h-2 w-2 rounded-full \${healthCheck.data ? "bg-green-500" : "bg-red-500"}\`}
              />
              <span className="text-sm text-muted-foreground">
                {healthCheck.isLoading
                  ? "Checking..."
                  : healthCheck.data
                    ? "Connected"
                    : "Disconnected"}
              </span>
            </div>
            {{/unless}}
          {{/if}}
        </section>
      </div>
    </div>
  );
}
`],
  ["frontend/react/next/src/app/layout.tsx.hbs", `import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "../index.css";
{{#if (eq auth "clerk")}}{{#if (eq backend "convex")}}import { ClerkProvider } from "@clerk/nextjs";
{{/if}}{{/if}}{{#if (and (eq backend "convex") (eq auth "better-auth"))}}
import { getToken } from "@/lib/auth-server";
{{/if}}
import Providers from "@/components/providers";
import Header from "@/components/header";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "{{projectName}}",
  description: "{{projectName}}",
};

{{#if (and (eq backend "convex") (eq auth "better-auth"))}}
export default async function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  const token = await getToken();
  return (
    <html lang="en" suppressHydrationWarning>
      <body
        className={\`\${geistSans.variable} \${geistMono.variable} antialiased\`}
      >
        <Providers initialToken={token}>
          <div className="grid grid-rows-[auto_1fr] h-svh">
            <Header />
            {children}
          </div>
        </Providers>
      </body>
    </html>
  );
}
{{else}}
export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  	return (
		<html lang="en" suppressHydrationWarning>
			<body
				className={\`\${geistSans.variable} \${geistMono.variable} antialiased\`}
			>
				{{#if (and (eq auth "clerk") (eq backend "convex"))}}<ClerkProvider>
					<Providers>
						<div className="grid grid-rows-[auto_1fr] h-svh">
							<Header />
							{children}
						</div>
					</Providers>
				</ClerkProvider>{{else}}<Providers>
					<div className="grid grid-rows-[auto_1fr] h-svh">
						<Header />
						{children}
					</div>
				</Providers>{{/if}}
			</body>
		</html>
	);
}
{{/if}}
`],
  ["frontend/react/next/src/components/theme-provider.tsx.hbs", `"use client"

import * as React from "react"
import { ThemeProvider as NextThemesProvider } from "next-themes"

export function ThemeProvider({
  children,
  ...props
}: React.ComponentProps<typeof NextThemesProvider>) {
  return <NextThemesProvider {...props}>{children}</NextThemesProvider>
}
`],
  ["frontend/react/next/src/components/mode-toggle.tsx.hbs", `"use client"

import * as React from "react"
import { Moon, Sun } from "lucide-react"
import { useTheme } from "next-themes"
import { Button } from "@/components/ui/button"
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu"

export function ModeToggle() {
  const { setTheme } = useTheme()

  return (
    <DropdownMenu>
      <DropdownMenuTrigger render={<Button variant="outline" size="icon" />}>
        <Sun className="h-[1.2rem] w-[1.2rem] rotate-0 scale-100 transition-all dark:-rotate-90 dark:scale-0" />
        <Moon className="absolute h-[1.2rem] w-[1.2rem] rotate-90 scale-0 transition-all dark:rotate-0 dark:scale-100" />
        <span className="sr-only">Toggle theme</span>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end">
        <DropdownMenuItem onClick={() => setTheme("light")}>
          Light
        </DropdownMenuItem>
        <DropdownMenuItem onClick={() => setTheme("dark")}>
          Dark
        </DropdownMenuItem>
        <DropdownMenuItem onClick={() => setTheme("system")}>
          System
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  )
}
`],
  ["frontend/react/next/src/components/providers.tsx.hbs", `"use client";

{{#if (eq backend "convex")}}
{{#if (eq auth "clerk")}}
import { useAuth } from "@clerk/nextjs";
import { ConvexReactClient } from "convex/react";
import { ConvexProviderWithClerk } from "convex/react-clerk";
import { env } from "@{{projectName}}/env/web";
{{else if (eq auth "better-auth")}}
import { ConvexReactClient } from "convex/react";
import { ConvexBetterAuthProvider } from "@convex-dev/better-auth/react";
import { authClient } from "@/lib/auth-client";
import { env } from "@{{projectName}}/env/web";
{{else}}
import { ConvexProvider, ConvexReactClient } from "convex/react";
import { env } from "@{{projectName}}/env/web";
{{/if}}
{{else}}
{{#unless (eq api "none")}}
import { QueryClientProvider } from "@tanstack/react-query";
import { ReactQueryDevtools } from "@tanstack/react-query-devtools";
{{#if (eq api "orpc")}}
import { queryClient } from "@/utils/orpc";
{{/if}}
{{#if (eq api "trpc")}}
import { queryClient } from "@/utils/trpc";
{{/if}}
{{/unless}}
{{/if}}
import { ThemeProvider } from "./theme-provider";
import { Toaster } from "./ui/sonner";

{{#if (eq backend "convex")}}
const convex = new ConvexReactClient(env.NEXT_PUBLIC_CONVEX_URL);
{{/if}}

export default function Providers({
  children,
{{#if (and (eq backend "convex") (eq auth "better-auth"))}}
  initialToken,
{{/if}}
}: {
  children: React.ReactNode;
{{#if (and (eq backend "convex") (eq auth "better-auth"))}}
  initialToken?: string | null;
{{/if}}
}) {
  return (
    <ThemeProvider
      attribute="class"
      defaultTheme="system"
      enableSystem
      disableTransitionOnChange
    >
      {{#if (eq backend "convex")}}
      {{#if (eq auth "clerk")}}
      <ConvexProviderWithClerk client={convex} useAuth={useAuth}>
        {children}
      </ConvexProviderWithClerk>
      {{else if (eq auth "better-auth")}}
      <ConvexBetterAuthProvider
        client={convex}
        authClient={authClient}
        initialToken={initialToken}
      >
        {children}
      </ConvexBetterAuthProvider>
      {{else}}
      <ConvexProvider client={convex}>{children}</ConvexProvider>
      {{/if}}
      {{else}}
      {{#unless (eq api "none")}}
      <QueryClientProvider client={queryClient}>
        {{#if (eq api "orpc")}}
        {children}
        {{/if}}
        {{#if (eq api "trpc")}}
        {children}
        {{/if}}
        <ReactQueryDevtools />
      </QueryClientProvider>
      {{else}}
      {children}
      {{/unless}}
      {{/if}}
      <Toaster richColors />
    </ThemeProvider>
  );
}
`],
  ["frontend/react/web-base/src/components/loader.tsx.hbs", `import { Loader2 } from "lucide-react";

export default function Loader() {
  return (
    <div className="flex h-full items-center justify-center pt-8">
      <Loader2 className="animate-spin" />
    </div>
  );
}
`],
  ["frontend/react/web-base/src/components/header.tsx.hbs", `{{#if (includes frontend "next")}}
"use client";
import Link from "next/link";
{{else if (includes frontend "react-router")}}
import { NavLink } from "react-router";
{{else if (or (includes frontend "tanstack-router") (includes frontend "tanstack-start"))}}
import { Link } from "@tanstack/react-router";
{{/if}}
{{#unless (includes frontend "tanstack-start")}}
import { ModeToggle } from "./mode-toggle";
{{/unless}}
{{#if (and (eq auth "better-auth") (ne backend "convex"))}}
import UserMenu from "./user-menu";
{{/if}}

export default function Header() {
  const links = [
    { to: "/", label: "Home" },
    {{#if (or (eq auth "better-auth") (eq auth "clerk"))}}
      { to: "/dashboard", label: "Dashboard" },
    {{/if}}
    {{#if (includes examples "todo")}}
    { to: "/todos", label: "Todos" },
    {{/if}}
    {{#if (includes examples "ai")}}
    { to: "/ai", label: "AI Chat" },
    {{/if}}
  ] as const;

  return (
    <div>
      <div className="flex flex-row items-center justify-between px-2 py-1">
        <nav className="flex gap-4 text-lg">
          {links.map(({ to, label }) => {
            {{#if (includes frontend "next")}}
            return (
              <Link key={to} href={to}>
                {label}
              </Link>
            );
            {{else if (includes frontend "react-router")}}
            return (
              <NavLink
                key={to}
                to={to}
                className={({ isActive }) => isActive ? "font-bold" : ""}
                end
              >
                {label}
              </NavLink>
            );
            {{else if (or (includes frontend "tanstack-router") (includes frontend "tanstack-start"))}}
            return (
              <Link
                key={to}
                to={to}
              >
                {label}
              </Link>
            );
            {{else}}
            return null;
            {{/if}}
          })}
        </nav>
        <div className="flex items-center gap-2">
          {{#unless (includes frontend "tanstack-start")}}
          <ModeToggle />
          {{/unless}}
          {{#if (and (eq auth "better-auth") (ne backend "convex"))}}
          <UserMenu />
          {{/if}}
        </div>
      </div>
      <hr />
    </div>
  );
}
`],
  ["frontend/react/web-base/src/lib/utils.ts.hbs", `import { clsx, type ClassValue } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}
`],
  ["frontend/react/tanstack-start/src/routes/__root.tsx.hbs", `import { Toaster } from "@/components/ui/sonner";
{{#unless (eq backend "convex")}} {{#unless (eq api "none")}}
import { ReactQueryDevtools } from "@tanstack/react-query-devtools";
{{/unless}} {{/unless}}
import {
  HeadContent,
  Outlet,
  Scripts,
  createRootRouteWithContext,
{{#if (and (eq backend "convex") (or (eq auth "clerk") (eq auth "better-auth")))}}
  useRouteContext,
{{/if}}
} from "@tanstack/react-router";
import { TanStackRouterDevtools } from "@tanstack/react-router-devtools";
import Header from "../components/header";
import appCss from "../index.css?url";
{{#if (eq backend "convex")}}
import type { QueryClient } from "@tanstack/react-query";
import type { ConvexQueryClient } from "@convex-dev/react-query";
{{else}}
{{#if (or (eq api "trpc") (eq api "orpc"))}}
import type { QueryClient } from "@tanstack/react-query";
{{/if}}
{{/if}}

{{#if (and (eq backend "convex") (eq auth "clerk"))}}
import { ClerkProvider, useAuth } from "@clerk/tanstack-react-start";
import { auth } from "@clerk/tanstack-react-start/server";
import { createServerFn } from "@tanstack/react-start";
import { ConvexProviderWithClerk } from "convex/react-clerk";

const fetchClerkAuth = createServerFn({ method: "GET" }).handler(async () => {
  const clerkAuth = await auth();
  const token = await clerkAuth.getToken({ template: "convex" });
  return { userId: clerkAuth.userId, token };
});
{{else if (and (eq backend "convex") (eq auth "better-auth"))}}
import { createServerFn } from "@tanstack/react-start";
import { ConvexBetterAuthProvider } from "@convex-dev/better-auth/react";
import { authClient } from "@/lib/auth-client";
import { getToken } from "@/lib/auth-server";

const getAuth = createServerFn({ method: "GET" }).handler(async () => {
  return await getToken();
});
{{else if (eq backend "convex")}}
import { ConvexProvider } from "convex/react";
{{/if}}

{{#if (eq backend "convex")}}
export interface RouterAppContext {
  queryClient: QueryClient;
  convexQueryClient: ConvexQueryClient;
}
{{else}}
  {{#if (eq api "trpc")}}
import type { TRPCOptionsProxy } from "@trpc/tanstack-react-query";
import type { AppRouter } from "@{{projectName}}/api/routers/index";
export interface RouterAppContext {
  trpc: TRPCOptionsProxy<AppRouter>;
  queryClient: QueryClient;
}
  {{else if (eq api "orpc")}}
import type { orpc } from "@/utils/orpc";
export interface RouterAppContext {
  orpc: typeof orpc;
  queryClient: QueryClient;
}
  {{else}}
export interface RouterAppContext {
}
  {{/if}}
{{/if}}

export const Route = createRootRouteWithContext<RouterAppContext>()({
  head: () => ({
    meta: [
      {
        charSet: "utf-8",
      },
      {
        name: "viewport",
        content: "width=device-width, initial-scale=1",
      },
      {
        title: "My App",
      },
    ],
    links: [
      {
        rel: "stylesheet",
        href: appCss,
      },
    ],
  }),

  component: RootDocument,
  {{#if (and (eq backend "convex") (eq auth "clerk"))}}
  beforeLoad: async (ctx) => {
    const { userId, token } = await fetchClerkAuth();
    if (token) {
      ctx.context.convexQueryClient.serverHttpClient?.setAuth(token);
    }
    return { userId, token };
  },
  {{else if (and (eq backend "convex") (eq auth "better-auth"))}}
  beforeLoad: async (ctx) => {
    const token = await getAuth();
    if (token) {
      ctx.context.convexQueryClient.serverHttpClient?.setAuth(token);
    }
    return {
      isAuthenticated: !!token,
      token,
    };
  },
  {{/if}}
});

function RootDocument() {
  {{#if (and (eq backend "convex") (eq auth "clerk"))}}
  const context = useRouteContext({ from: Route.id });
  return (
    <ClerkProvider>
      <ConvexProviderWithClerk client={context.convexQueryClient.convexClient} useAuth={useAuth}>
        <html lang="en" className="dark">
          <head>
            <HeadContent />
          </head>
          <body>
            <div className="grid h-svh grid-rows-[auto_1fr]">
              <Header />
              <Outlet />
            </div>
            <Toaster richColors />
            <TanStackRouterDevtools position="bottom-left" />
            <Scripts />
          </body>
        </html>
      </ConvexProviderWithClerk>
    </ClerkProvider>
  );
  {{else if (and (eq backend "convex") (eq auth "better-auth"))}}
  const context = useRouteContext({ from: Route.id });
  return (
    <ConvexBetterAuthProvider
      client={context.convexQueryClient.convexClient}
      authClient={authClient}
      initialToken={context.token}
    >
      <html lang="en" className="dark">
        <head>
          <HeadContent />
        </head>
        <body>
          <div className="grid h-svh grid-rows-[auto_1fr]">
            <Header />
            <Outlet />
          </div>
          <Toaster richColors />
          <TanStackRouterDevtools position="bottom-left" />
          <Scripts />
        </body>
      </html>
    </ConvexBetterAuthProvider>
  );
  {{else if (eq backend "convex")}}
  const { convexQueryClient } = Route.useRouteContext();
  return (
    <ConvexProvider client={convexQueryClient.convexClient}>
      <html lang="en" className="dark">
        <head>
          <HeadContent />
        </head>
        <body>
          <div className="grid h-svh grid-rows-[auto_1fr]">
            <Header />
            <Outlet />
          </div>
          <Toaster richColors />
          <TanStackRouterDevtools position="bottom-left" />
          <Scripts />
        </body>
      </html>
    </ConvexProvider>
  );
  {{else}}
  return (
    <html lang="en" className="dark">
      <head>
        <HeadContent />
      </head>
      <body>
        <div className="grid h-svh grid-rows-[auto_1fr]">
          <Header />
          <Outlet />
        </div>
        <Toaster richColors />
        <TanStackRouterDevtools position="bottom-left" />
        {{#unless (eq api "none")}}
        <ReactQueryDevtools position="bottom" buttonPosition="bottom-right" />
        {{/unless}}
        <Scripts />
      </body>
    </html>
  );
  {{/if}}
}
`],
  ["frontend/react/tanstack-start/src/routes/index.tsx.hbs", `import { createFileRoute } from "@tanstack/react-router";
{{#if (eq backend "convex")}}
import { convexQuery } from "@convex-dev/react-query";
import { useQuery } from "@tanstack/react-query";
import { api } from "@{{projectName}}/backend/convex/_generated/api";
{{else if (or (eq api "trpc") (eq api "orpc"))}}
import { useQuery } from "@tanstack/react-query";
  {{#if (eq api "trpc")}}
import { useTRPC } from "@/utils/trpc";
  {{/if}}
  {{#if (eq api "orpc")}}
import { orpc } from "@/utils/orpc";
  {{/if}}
{{/if}}

export const Route = createFileRoute("/")({
  component: HomeComponent,
});

const TITLE_TEXT = \`
  
 
                 
                 
               
                

          
      
                      
                      
                     
                      
 \`;

function HomeComponent() {
  {{#if (eq backend "convex")}}
  const healthCheck = useQuery(convexQuery(api.healthCheck.get, {}));
  {{else if (eq api "trpc")}}
  const trpc = useTRPC();
  const healthCheck = useQuery(trpc.healthCheck.queryOptions());
  {{else if (eq api "orpc")}}
  const healthCheck = useQuery(orpc.healthCheck.queryOptions());
  {{/if}}

  return (
    <div className="container mx-auto max-w-3xl px-4 py-2">
      <pre className="overflow-x-auto font-mono text-sm">{TITLE_TEXT}</pre>
      <div className="grid gap-6">
        <section className="rounded-lg border p-4">
          <h2 className="mb-2 font-medium">API Status</h2>
          {{#if (eq backend "convex")}}
          <div className="flex items-center gap-2">
            <div
              className={\`h-2 w-2 rounded-full \${healthCheck.data === "OK" ? "bg-green-500" : healthCheck.isLoading ? "bg-orange-400" : "bg-red-500"}\`}
            />
            <span className="text-muted-foreground text-sm">
              {healthCheck.isLoading
                ? "Checking..."
                : healthCheck.data === "OK"
                  ? "Connected"
                  : "Error"}
            </span>
          </div>
          {{else}}
            {{#unless (eq api "none")}}
            <div className="flex items-center gap-2">
              <div
                className={\`h-2 w-2 rounded-full \${healthCheck.data ? "bg-green-500" : "bg-red-500"}\`}
              />
              <span className="text-muted-foreground text-sm">
                {healthCheck.isLoading
                  ? "Checking..."
                  : healthCheck.data
                    ? "Connected"
                    : "Disconnected"}
              </span>
            </div>
            {{/unless}}
          {{/if}}
        </section>
      </div>
    </div>
  );
}
`],
  ["backend/server/nitro/routes/api-reference/[...path].ts.hbs", `{{#if (eq api "orpc")}}
import { OpenAPIHandler } from "@orpc/openapi/node";
import { OpenAPIReferencePlugin } from "@orpc/openapi/plugins";
import { ZodToJsonSchemaConverter } from "@orpc/zod/zod4";
import { onError } from "@orpc/server";
import { appRouter } from "@{{projectName}}/api/routers/index";
{{#if (eq auth "better-auth")}}
import { createContext } from "@{{projectName}}/api/context";
{{/if}}

const apiHandler = new OpenAPIHandler(appRouter, {
	plugins: [
		new OpenAPIReferencePlugin({
			schemaConverters: [new ZodToJsonSchemaConverter()],
		}),
	],
	interceptors: [
		onError((error) => {
			console.error(error);
		}),
	],
});

export default defineEventHandler(async (event) => {
	const { req, res } = event.node;
	const result = await apiHandler.handle(req, res, {
		prefix: "/api-reference",
{{#if (eq auth "better-auth")}}
		context: await createContext({ req }),
{{else}}
		context: {},
{{/if}}
	});
	if (!result.matched) {
		setResponseStatus(event, 404);
		return "Not Found";
	}
});
{{else}}
// OpenAPI reference placeholder - oRPC not configured
export default defineEventHandler(() => {
	return { error: "OpenAPI reference not configured" };
});
{{/if}}
`],
  ["backend/server/nitro/routes/rpc/[...path].ts.hbs", `{{#if (eq api "orpc")}}
import { RPCHandler } from "@orpc/server/node";
import { onError } from "@orpc/server";
import { appRouter } from "@{{projectName}}/api/routers/index";
{{#if (eq auth "better-auth")}}
import { createContext } from "@{{projectName}}/api/context";
{{/if}}

const rpcHandler = new RPCHandler(appRouter, {
	interceptors: [
		onError((error) => {
			console.error(error);
		}),
	],
});

export default defineEventHandler(async (event) => {
	const { req, res } = event.node;
	const result = await rpcHandler.handle(req, res, {
		prefix: "/rpc",
{{#if (eq auth "better-auth")}}
		context: await createContext({ req }),
{{else}}
		context: {},
{{/if}}
	});
	if (!result.matched) {
		setResponseStatus(event, 404);
		return "Not Found";
	}
});
{{else}}
// oRPC placeholder - not configured
export default defineEventHandler(() => {
	return { error: "oRPC not configured" };
});
{{/if}}
`],
  ["backend/server/nitro/routes/trpc/[...path].ts.hbs", `{{#if (eq api "trpc")}}
import { fetchRequestHandler } from "@trpc/server/adapters/fetch";
import { createContext } from "@{{projectName}}/api/context";
import { appRouter } from "@{{projectName}}/api/routers/index";

export default defineEventHandler(async (event) => {
	const response = await fetchRequestHandler({
		endpoint: "/trpc",
		req: event.node.req as unknown as Request,
		router: appRouter,
		createContext: ({ req }) => createContext({ req }),
	});
	return response;
});
{{else}}
// tRPC placeholder - not configured
export default defineEventHandler(() => {
	return { error: "tRPC not configured" };
});
{{/if}}
`],
  ["backend/server/nestjs/src/trpc/trpc.module.ts.hbs", `import { Module, type MiddlewareConsumer, type NestModule } from "@nestjs/common";
import { TrpcMiddleware } from "./trpc.middleware";

@Module({})
export class TrpcModule implements NestModule {
	configure(consumer: MiddlewareConsumer) {
		consumer.apply(TrpcMiddleware).forRoutes("trpc/*path");
	}
}
`],
  ["backend/server/nestjs/src/trpc/trpc.middleware.ts.hbs", `import { Injectable, type NestMiddleware } from "@nestjs/common";
import { createExpressMiddleware } from "@trpc/server/adapters/express";
import { createContext } from "@{{projectName}}/api/context";
import { appRouter } from "@{{projectName}}/api/routers/index";
import type { Request, Response, NextFunction } from "express";

@Injectable()
export class TrpcMiddleware implements NestMiddleware {
	private trpcMiddleware = createExpressMiddleware({
		router: appRouter,
		createContext,
	});

	use(req: Request, res: Response, next: NextFunction) {
		this.trpcMiddleware(req, res, next);
	}
}
`],
  ["backend/server/nestjs/src/ai/ai.service.ts.hbs", `import { Injectable } from "@nestjs/common";
import { streamText, type UIMessage, convertToModelMessages, wrapLanguageModel } from "ai";
import { google } from "@ai-sdk/google";
import { devToolsMiddleware } from "@ai-sdk/devtools";
import type { Request, Response } from "express";

@Injectable()
export class AiService {
	async streamChat(req: Request, res: Response) {
		const { messages = [] } = (req.body || {}) as { messages: UIMessage[] };
		const model = wrapLanguageModel({
			model: google("gemini-2.5-flash"),
			middleware: devToolsMiddleware(),
		});
		const result = streamText({
			model,
			messages: await convertToModelMessages(messages),
		});
		result.pipeUIMessageStreamToResponse(res);
	}
}
`],
  ["backend/server/nestjs/src/ai/ai.controller.ts.hbs", `import { Controller, Post, Req, Res } from "@nestjs/common";
import { AiService } from "./ai.service";
import type { Request, Response } from "express";

@Controller("ai")
export class AiController {
	constructor(private readonly aiService: AiService) {}

	@Post()
	async chat(@Req() req: Request, @Res() res: Response) {
		return this.aiService.streamChat(req, res);
	}
}
`],
  ["backend/server/nestjs/src/ai/ai.module.ts.hbs", `import { Module } from "@nestjs/common";
import { AiController } from "./ai.controller";
import { AiService } from "./ai.service";

@Module({
	controllers: [AiController],
	providers: [AiService],
})
export class AiModule {}
`],
  ["backend/server/nestjs/src/orpc/orpc.module.ts.hbs", `import { Module, type MiddlewareConsumer, type NestModule } from "@nestjs/common";
import { OrpcMiddleware } from "./orpc.middleware";

@Module({})
export class OrpcModule implements NestModule {
	configure(consumer: MiddlewareConsumer) {
		consumer.apply(OrpcMiddleware).forRoutes("rpc/*path", "api-reference/*path");
	}
}
`],
  ["backend/server/nestjs/src/orpc/orpc.middleware.ts.hbs", `import { Injectable, type NestMiddleware } from "@nestjs/common";
import { OpenAPIHandler } from "@orpc/openapi/node";
import { OpenAPIReferencePlugin } from "@orpc/openapi/plugins";
import { ZodToJsonSchemaConverter } from "@orpc/zod/zod4";
import { RPCHandler } from "@orpc/server/node";
import { onError } from "@orpc/server";
import { appRouter } from "@{{projectName}}/api/routers/index";
{{#if (eq auth "better-auth")}}
import { createContext } from "@{{projectName}}/api/context";
{{/if}}
import type { Request, Response, NextFunction } from "express";

@Injectable()
export class OrpcMiddleware implements NestMiddleware {
	private rpcHandler = new RPCHandler(appRouter, {
		interceptors: [
			onError((error) => {
				console.error(error);
			}),
		],
	});

	private apiHandler = new OpenAPIHandler(appRouter, {
		plugins: [
			new OpenAPIReferencePlugin({
				schemaConverters: [new ZodToJsonSchemaConverter()],
			}),
		],
		interceptors: [
			onError((error) => {
				console.error(error);
			}),
		],
	});

	async use(req: Request, res: Response, next: NextFunction) {
		const rpcResult = await this.rpcHandler.handle(req, res, {
			prefix: "/rpc",
{{#if (eq auth "better-auth")}}
			context: await createContext({ req }),
{{else}}
			context: {},
{{/if}}
		});
		if (rpcResult.matched) return;

		const apiResult = await this.apiHandler.handle(req, res, {
			prefix: "/api-reference",
{{#if (eq auth "better-auth")}}
			context: await createContext({ req }),
{{else}}
			context: {},
{{/if}}
		});
		if (apiResult.matched) return;

		next();
	}
}
`],
  ["api/garph/server/src/routers/index.ts.hbs", `import { g, buildSchema, type InferResolvers, queryType, mutationType } from "../index";
import type { Context } from "../context";
{{#if (includes examples "todo")}}
import { todoResolvers } from "./todo";
{{/if}}

export function createResolvers(ctx: Context): InferResolvers<{ Query: typeof queryType; Mutation: typeof mutationType }, { context: Context }> {
{{#if (includes examples "todo")}}
  const todos = todoResolvers(ctx);
{{/if}}

  return {
    Query: {
      health: () => "OK",
{{#if (eq auth "better-auth")}}
      privateData: () => {
        if (!ctx.session) {
          return null;
        }
        return {
          message: "This is private data",
          user: ctx.session.user,
        };
      },
{{/if}}
{{#if (includes examples "todo")}}
      todos: todos.getAll,
      todo: todos.getOne,
{{/if}}
    },
    Mutation: {
{{#if (includes examples "todo")}}
      createTodo: todos.create,
      toggleTodo: todos.toggle,
      deleteTodo: todos.delete,
{{/if}}
      _empty: () => null,
    },
  };
}

export function createSchema(ctx: Context) {
  const resolvers = createResolvers(ctx);
  return buildSchema({ g, resolvers });
}
`],
  ["api/garph/server/src/routers/todo.ts.hbs", `{{#if (includes examples "todo")}}
import type { Context } from "../context";
import { db } from "@{{projectName}}/db";
import { todos } from "@{{projectName}}/db/schema";
import { eq } from "drizzle-orm";

export function todoResolvers(ctx: Context) {
  return {
    getAll: async () => {
      const allTodos = await db.select().from(todos).orderBy(todos.createdAt);
      return allTodos.map((t) => ({
        ...t,
        createdAt: t.createdAt.toISOString(),
      }));
    },
    getOne: async (_: unknown, args: { id: number }) => {
      const [todo] = await db.select().from(todos).where(eq(todos.id, args.id));
      if (!todo) return null;
      return {
        ...todo,
        createdAt: todo.createdAt.toISOString(),
      };
    },
    create: async (_: unknown, args: { content: string }) => {
      const [newTodo] = await db
        .insert(todos)
        .values({ content: args.content })
        .returning();
      return {
        ...newTodo,
        createdAt: newTodo.createdAt.toISOString(),
      };
    },
    toggle: async (_: unknown, args: { id: number }) => {
      const [existing] = await db
        .select()
        .from(todos)
        .where(eq(todos.id, args.id));
      if (!existing) return null;
      const [updated] = await db
        .update(todos)
        .set({ completed: !existing.completed })
        .where(eq(todos.id, args.id))
        .returning();
      return {
        ...updated,
        createdAt: updated.createdAt.toISOString(),
      };
    },
    delete: async (_: unknown, args: { id: number }) => {
      const [existing] = await db
        .select()
        .from(todos)
        .where(eq(todos.id, args.id));
      if (!existing) return false;
      await db.delete(todos).where(eq(todos.id, args.id));
      return true;
    },
  };
}
{{/if}}
`],
  ["api/ts-rest/server/src/routers/index.ts.hbs", `import { contract } from "../index";
import type { Context } from "../context";
{{#if (includes examples "todo")}}
import { todoHandlers } from "./todo";
{{/if}}

export function createRouter(ctx: Context) {
  return {
    healthCheck: async () => {
      return {
        status: 200 as const,
        body: "OK" as const,
      };
    },
{{#if (eq auth "better-auth")}}
    privateData: async () => {
      if (!ctx.session) {
        return {
          status: 401 as const,
          body: {
            message: "Authentication required",
          },
        };
      }
      return {
        status: 200 as const,
        body: {
          message: "This is private",
          user: ctx.session.user,
        },
      };
    },
{{/if}}
{{#if (includes examples "todo")}}
    todos: todoHandlers(ctx),
{{/if}}
  };
}

export type AppRouter = ReturnType<typeof createRouter>;
`],
  ["api/ts-rest/server/src/routers/todo.ts.hbs", `{{#if (includes examples "todo")}}
import type { Context } from "../context";
import { db } from "@{{projectName}}/db";
import { todos } from "@{{projectName}}/db/schema";
import { eq } from "drizzle-orm";

export function todoHandlers(ctx: Context) {
  return {
    getAll: async () => {
      const allTodos = await db.select().from(todos).orderBy(todos.createdAt);
      return {
        status: 200 as const,
        body: allTodos.map((t) => ({
          ...t,
          createdAt: t.createdAt.toISOString(),
        })),
      };
    },
    create: async ({ body }: { body: { content: string } }) => {
      const [newTodo] = await db
        .insert(todos)
        .values({ content: body.content })
        .returning();
      return {
        status: 201 as const,
        body: {
          ...newTodo,
          createdAt: newTodo.createdAt.toISOString(),
        },
      };
    },
    toggle: async ({ params }: { params: { id: number } }) => {
      const [existing] = await db
        .select()
        .from(todos)
        .where(eq(todos.id, params.id));
      if (!existing) {
        return {
          status: 404 as const,
          body: { message: "Todo not found" },
        };
      }
      const [updated] = await db
        .update(todos)
        .set({ completed: !existing.completed })
        .where(eq(todos.id, params.id))
        .returning();
      return {
        status: 200 as const,
        body: {
          ...updated,
          createdAt: updated.createdAt.toISOString(),
        },
      };
    },
    delete: async ({ params }: { params: { id: number } }) => {
      const [existing] = await db
        .select()
        .from(todos)
        .where(eq(todos.id, params.id));
      if (!existing) {
        return {
          status: 404 as const,
          body: { message: "Todo not found" },
        };
      }
      await db.delete(todos).where(eq(todos.id, params.id));
      return {
        status: 200 as const,
        body: { success: true },
      };
    },
  };
}
{{/if}}
`],
  ["api/trpc/server/src/routers/index.ts.hbs", `{{#if (eq api "orpc")}}
import { {{#if (eq auth "better-auth")}}protectedProcedure, {{/if}}publicProcedure } from "../index";
import type { RouterClient } from "@orpc/server";
{{#if (includes examples "todo")}}
import { todoRouter } from "./todo";
{{/if}}

export const appRouter = {
  healthCheck: publicProcedure.handler(() => {
    return "OK";
  }),
  {{#if (eq auth "better-auth")}}
  privateData: protectedProcedure.handler(({ context }) => {
    return {
      message: "This is private",
      user: context.session?.user,
    };
  }),
  {{/if}}
  {{#if (includes examples "todo")}}
  todo: todoRouter,
  {{/if}}
};
export type AppRouter = typeof appRouter;
export type AppRouterClient = RouterClient<typeof appRouter>;
{{else if (eq api "trpc")}}
import {
  {{#if (eq auth "better-auth")}}protectedProcedure, {{/if}}publicProcedure,
  router,
} from "../index";
{{#if (includes examples "todo")}}
import { todoRouter } from "./todo";
{{/if}}

export const appRouter = router({
  healthCheck: publicProcedure.query(() => {
    return "OK";
  }),
  {{#if (eq auth "better-auth")}}
  privateData: protectedProcedure.query(({ ctx }) => {
    return {
      message: "This is private",
      user: ctx.session.user,
    };
  }),
  {{/if}}
  {{#if (includes examples "todo")}}
  todo: todoRouter,
  {{/if}}
});
export type AppRouter = typeof appRouter;
{{else}}
export const appRouter = {};
export type AppRouter = typeof appRouter;
{{/if}}
`],
  ["api/orpc/server/src/routers/index.ts.hbs", `{{#if (eq api "orpc")}}
import { {{#if (eq auth "better-auth")}}protectedProcedure, {{/if}}publicProcedure } from "../index";
import type { RouterClient } from "@orpc/server";
{{#if (includes examples "todo")}}
import { todoRouter } from "./todo";
{{/if}}

export const appRouter = {
  healthCheck: publicProcedure.handler(() => {
    return "OK";
  }),
  {{#if (eq auth "better-auth")}}
  privateData: protectedProcedure.handler(({ context }) => {
    return {
      message: "This is private",
      user: context.session?.user,
    };
  }),
  {{/if}}
  {{#if (includes examples "todo")}}
  todo: todoRouter,
  {{/if}}
};
export type AppRouter = typeof appRouter;
export type AppRouterClient = RouterClient<typeof appRouter>;
{{else if (eq api "trpc")}}
import {
  {{#if (eq auth "better-auth")}}protectedProcedure, {{/if}}publicProcedure,
  router,
} from "../index";
{{#if (includes examples "todo")}}
import { todoRouter } from "./todo";
{{/if}}

export const appRouter = router({
  healthCheck: publicProcedure.query(() => {
    return "OK";
  }),
  {{#if (eq auth "better-auth")}}
  privateData: protectedProcedure.query(({ ctx }) => {
    return {
      message: "This is private",
      user: ctx.session.user,
    };
  }),
  {{/if}}
  {{#if (includes examples "todo")}}
  todo: todoRouter,
  {{/if}}
});
export type AppRouter = typeof appRouter;
{{else}}
export const appRouter = {};
export type AppRouter = typeof appRouter;
{{/if}}
`],
  ["db/sequelize/base/src/models/index.ts.hbs", `{{#if (eq auth "better-auth")}}
export * from "./user";
export * from "./session";
export * from "./account";
export * from "./verification";
{{/if}}
{{#if (includes examples "todo")}}
export * from "./todo";
{{/if}}
export {};
`],
  ["db/kysely/base/src/schema/index.ts.hbs", `import type { Generated, ColumnType } from "kysely";

{{#if (eq auth "better-auth")}}
// Auth tables
export interface UserTable {
	id: string;
	name: string;
	email: string;
	emailVerified: number;
	image: string | null;
	createdAt: ColumnType<Date, string | undefined, never>;
	updatedAt: ColumnType<Date, string | undefined, never>;
}

export interface SessionTable {
	id: string;
	expiresAt: ColumnType<Date, string, string>;
	token: string;
	createdAt: ColumnType<Date, string | undefined, never>;
	updatedAt: ColumnType<Date, string | undefined, never>;
	ipAddress: string | null;
	userAgent: string | null;
	userId: string;
}

export interface AccountTable {
	id: string;
	accountId: string;
	providerId: string;
	userId: string;
	accessToken: string | null;
	refreshToken: string | null;
	idToken: string | null;
	accessTokenExpiresAt: ColumnType<Date, string | null, string | null>;
	refreshTokenExpiresAt: ColumnType<Date, string | null, string | null>;
	scope: string | null;
	password: string | null;
	createdAt: ColumnType<Date, string | undefined, never>;
	updatedAt: ColumnType<Date, string | undefined, never>;
}

export interface VerificationTable {
	id: string;
	identifier: string;
	value: string;
	expiresAt: ColumnType<Date, string, string>;
	createdAt: ColumnType<Date, string | undefined, never>;
	updatedAt: ColumnType<Date, string | undefined, never>;
}
{{/if}}

{{#if (includes examples "todo")}}
// Todo table
export interface TodoTable {
	id: Generated<number>;
	text: string;
	completed: number;
	createdAt: ColumnType<Date, string | undefined, never>;
}
{{/if}}

// Database interface - lists all tables
export interface Database {
{{#if (eq auth "better-auth")}}
	user: UserTable;
	session: SessionTable;
	account: AccountTable;
	verification: VerificationTable;
{{/if}}
{{#if (includes examples "todo")}}
	todo: TodoTable;
{{/if}}
}
`],
  ["db/prisma/mysql/prisma/schema/schema.prisma.hbs", `generator client {
  provider      = "prisma-client"
  output        = "../generated"
  moduleFormat  = "esm"
  {{#if (eq runtime "bun")}}
  runtime       = "bun"
  {{/if}}
  {{#if (eq runtime "node")}}
  runtime       = "nodejs"
  {{/if}}
  {{#if (or (eq runtime "workers") (and (eq backend "self") (eq webDeploy "cloudflare")))}}
  runtime       = "workerd"
  {{/if}}
}

datasource db {
  provider = "mysql"
  {{#if (eq dbSetup "planetscale")}}
  relationMode = "prisma"
  {{/if}}
}`],
  ["db/prisma/sqlite/prisma/schema/schema.prisma.hbs", `generator client {
  provider = "prisma-client"
  output   = "../generated"
  moduleFormat = "esm"
  {{#if (eq runtime "bun")}}
  runtime = "bun"
  {{/if}}
  {{#if (eq runtime "node")}}
  runtime = "nodejs"
  {{/if}}
  {{#if (or (eq runtime "workers") (and (eq backend "self") (eq webDeploy "cloudflare")))}}
  runtime = "workerd"
  {{/if}}
}

datasource db {
  provider = "sqlite"
}
`],
  ["db/mikroorm/base/src/entities/index.ts.hbs", `{{#if (eq auth "better-auth")}}
export * from "./user";
export * from "./session";
export * from "./account";
export * from "./verification";
{{/if}}
{{#if (includes examples "todo")}}
export * from "./todo";
{{/if}}
export {};
`],
  ["addons/pwa/apps/web/vite/pwa-assets.config.ts.hbs", `import {
  defineConfig,
  minimal2023Preset as preset,
} from "@vite-pwa/assets-generator/config";

export default defineConfig({
  headLinkOptions: {
    preset: "2023",
  },
  preset,
  images: ["public/logo.png"],
});
`],
  ["observability/opentelemetry/server/base/src/lib/tracing.ts.hbs", `import { NodeSDK } from "@opentelemetry/sdk-node";
import { getNodeAutoInstrumentations } from "@opentelemetry/auto-instrumentations-node";
import { OTLPTraceExporter } from "@opentelemetry/exporter-trace-otlp-http";
import { OTLPMetricExporter } from "@opentelemetry/exporter-metrics-otlp-http";
import { Resource } from "@opentelemetry/resources";
import {
  ATTR_SERVICE_NAME,
  ATTR_SERVICE_VERSION,
  ATTR_DEPLOYMENT_ENVIRONMENT_NAME,
} from "@opentelemetry/semantic-conventions";
import { PeriodicExportingMetricReader } from "@opentelemetry/sdk-metrics";

// Service configuration from environment variables
const serviceName = process.env.OTEL_SERVICE_NAME || "{{projectName}}-server";
const serviceVersion = process.env.OTEL_SERVICE_VERSION || "1.0.0";
const environment = process.env.NODE_ENV || "development";

// OTLP endpoint configuration
// Default to localhost:4318 for local development with Jaeger or OTEL Collector
const otlpEndpoint = process.env.OTEL_EXPORTER_OTLP_ENDPOINT || "http://localhost:4318";

// Create resource with service information
const resource = new Resource({
  [ATTR_SERVICE_NAME]: serviceName,
  [ATTR_SERVICE_VERSION]: serviceVersion,
  [ATTR_DEPLOYMENT_ENVIRONMENT_NAME]: environment,
});

// Configure trace exporter
const traceExporter = new OTLPTraceExporter({
  url: \`\${otlpEndpoint}/v1/traces\`,
});

// Configure metric exporter
const metricExporter = new OTLPMetricExporter({
  url: \`\${otlpEndpoint}/v1/metrics\`,
});

// Initialize OpenTelemetry SDK
const sdk = new NodeSDK({
  resource,
  traceExporter,
  metricReader: new PeriodicExportingMetricReader({
    exporter: metricExporter,
    // Export metrics every 30 seconds
    exportIntervalMillis: 30000,
  }),
  instrumentations: [
    getNodeAutoInstrumentations({
      // Disable fs instrumentation to reduce noise
      "@opentelemetry/instrumentation-fs": {
        enabled: false,
      },
      // Configure HTTP instrumentation
      "@opentelemetry/instrumentation-http": {
        enabled: true,
      },
    }),
  ],
});

/**
 * Start the OpenTelemetry SDK
 * Call this at the very beginning of your application, before any other imports
 *
 * @example
 * // At the top of your main entry file (e.g., index.ts)
 * import { startTracing } from './lib/tracing';
 * startTracing();
 *
 * // Then import and start your application
 * import { app } from './app';
 */
export function startTracing(): void {
  sdk.start();
  console.log(\`[OpenTelemetry] Tracing started for service: \${serviceName}\`);
  console.log(\`[OpenTelemetry] Exporting to: \${otlpEndpoint}\`);
}

/**
 * Gracefully shutdown the SDK
 * Call this before your application exits to ensure all spans are flushed
 *
 * @example
 * process.on('SIGTERM', async () => {
 *   await shutdownTracing();
 *   process.exit(0);
 * });
 */
export async function shutdownTracing(): Promise<void> {
  try {
    await sdk.shutdown();
    console.log("[OpenTelemetry] Tracing shutdown complete");
  } catch (error) {
    console.error("[OpenTelemetry] Error shutting down tracing:", error);
  }
}

/**
 * Get the OpenTelemetry API for manual instrumentation
 * Use this when you need to create custom spans or add attributes
 *
 * @example
 * import { trace } from '@opentelemetry/api';
 *
 * const tracer = trace.getTracer('my-component');
 * const span = tracer.startSpan('my-operation');
 * try {
 *   // ... do work
 *   span.setAttribute('result', 'success');
 * } catch (error) {
 *   span.recordException(error);
 *   span.setStatus({ code: SpanStatusCode.ERROR });
 * } finally {
 *   span.end();
 * }
 */
export { trace, context, SpanStatusCode } from "@opentelemetry/api";

/**
 * Environment Variables:
 *
 * OTEL_SERVICE_NAME - Service name for tracing (default: {{projectName}}-server)
 * OTEL_SERVICE_VERSION - Service version (default: 1.0.0)
 * OTEL_EXPORTER_OTLP_ENDPOINT - OTLP collector endpoint (default: http://localhost:4318)
 *
 * Common OTLP backends:
 * - Jaeger: http://localhost:4318 (with OTLP enabled)
 * - OTEL Collector: http://localhost:4318
 * - Grafana Tempo: Your Tempo endpoint
 * - Honeycomb: https://api.honeycomb.io (requires API key header)
 * - Datadog: https://trace.agent.datadoghq.com
 *
 * For production, configure OTEL_EXPORTER_OTLP_HEADERS for authentication:
 * OTEL_EXPORTER_OTLP_HEADERS="x-honeycomb-team=your-api-key"
 */
`],
  ["payments/lemon-squeezy/server/base/src/lib/lemonsqueezy.ts.hbs", `import {
	lemonSqueezySetup,
	createCheckout,
	getCheckout,
	listProducts,
	getProduct,
	listVariants,
	getVariant,
	listSubscriptions,
	getSubscription,
	cancelSubscription,
	type Checkout,
	type Product,
	type Variant,
	type Subscription,
} from "@lemonsqueezy/lemonsqueezy.js";
import { env } from "@{{projectName}}/env/server";

// Initialize Lemon Squeezy with your API key
lemonSqueezySetup({
	apiKey: env.LEMONSQUEEZY_API_KEY,
	onError: (error) => console.error("Lemon Squeezy Error:", error),
});

export async function createCheckoutSession(params: {
	variantId: number;
	customData?: Record<string, string | number | boolean>;
	checkoutOptions?: {
		embed?: boolean;
		media?: boolean;
		logo?: boolean;
		desc?: boolean;
		discount?: boolean;
		dark?: boolean;
		subscriptionPreview?: boolean;
		buttonColor?: string;
	};
	productOptions?: {
		name?: string;
		description?: string;
		redirectUrl?: string;
		receiptButtonText?: string;
		receiptLinkUrl?: string;
		receiptThankYouNote?: string;
		enabledVariants?: number[];
	};
	checkoutData?: {
		email?: string;
		name?: string;
		billingAddress?: {
			country: string;
			zip?: string;
		};
		taxNumber?: string;
		discountCode?: string;
	};
	expiresAt?: string;
	preview?: boolean;
	testMode?: boolean;
}) {
	const { data, error } = await createCheckout(env.LEMONSQUEEZY_STORE_ID, params.variantId, {
		customData: params.customData,
		checkoutOptions: params.checkoutOptions,
		productOptions: params.productOptions,
		checkoutData: params.checkoutData,
		expiresAt: params.expiresAt,
		preview: params.preview,
		testMode: params.testMode,
	});

	if (error) {
		throw new Error(\`Failed to create checkout: \${error.message}\`);
	}

	return data;
}

export async function getCheckoutById(checkoutId: string): Promise<Checkout | null> {
	const { data, error } = await getCheckout(checkoutId);

	if (error) {
		throw new Error(\`Failed to get checkout: \${error.message}\`);
	}

	return data;
}

export async function getProducts(): Promise<Product[]> {
	const { data, error } = await listProducts({
		filter: { storeId: env.LEMONSQUEEZY_STORE_ID },
	});

	if (error) {
		throw new Error(\`Failed to list products: \${error.message}\`);
	}

	return data?.data ?? [];
}

export async function getProductById(productId: string): Promise<Product | null> {
	const { data, error } = await getProduct(productId);

	if (error) {
		throw new Error(\`Failed to get product: \${error.message}\`);
	}

	return data;
}

export async function getVariants(productId?: string): Promise<Variant[]> {
	const { data, error } = await listVariants({
		filter: productId ? { productId } : undefined,
	});

	if (error) {
		throw new Error(\`Failed to list variants: \${error.message}\`);
	}

	return data?.data ?? [];
}

export async function getVariantById(variantId: string): Promise<Variant | null> {
	const { data, error } = await getVariant(variantId);

	if (error) {
		throw new Error(\`Failed to get variant: \${error.message}\`);
	}

	return data;
}

export async function getUserSubscriptions(customerId?: string): Promise<Subscription[]> {
	const { data, error } = await listSubscriptions({
		filter: customerId ? { customerId } : undefined,
	});

	if (error) {
		throw new Error(\`Failed to list subscriptions: \${error.message}\`);
	}

	return data?.data ?? [];
}

export async function getSubscriptionById(subscriptionId: string): Promise<Subscription | null> {
	const { data, error } = await getSubscription(subscriptionId);

	if (error) {
		throw new Error(\`Failed to get subscription: \${error.message}\`);
	}

	return data;
}

export async function cancelUserSubscription(subscriptionId: string): Promise<Subscription | null> {
	const { data, error } = await cancelSubscription(subscriptionId);

	if (error) {
		throw new Error(\`Failed to cancel subscription: \${error.message}\`);
	}

	return data;
}

export function verifyWebhookSignature(
	payload: string,
	signature: string,
): boolean {
	// Lemon Squeezy uses HMAC-SHA256 for webhook signatures
	const crypto = require("crypto");
	const hmac = crypto.createHmac("sha256", env.LEMONSQUEEZY_WEBHOOK_SECRET);
	const digest = hmac.update(payload).digest("hex");
	return crypto.timingSafeEqual(Buffer.from(signature), Buffer.from(digest));
}

export type WebhookEvent =
	| "order_created"
	| "order_refunded"
	| "subscription_created"
	| "subscription_updated"
	| "subscription_cancelled"
	| "subscription_resumed"
	| "subscription_expired"
	| "subscription_paused"
	| "subscription_unpaused"
	| "subscription_payment_success"
	| "subscription_payment_failed"
	| "subscription_payment_recovered"
	| "license_key_created"
	| "license_key_updated";

export interface WebhookPayload {
	meta: {
		event_name: WebhookEvent;
		custom_data?: Record<string, string | number | boolean>;
		webhook_id: string;
	};
	data: {
		type: string;
		id: string;
		attributes: Record<string, unknown>;
		relationships?: Record<string, unknown>;
	};
}
`],
  ["db/prisma/postgres/prisma/schema/schema.prisma.hbs", `generator client {
  provider = "prisma-client"
  output   = "../generated"
  moduleFormat = "esm"
  {{#if (eq runtime "bun")}}
  runtime = "bun"
  {{/if}}
  {{#if (eq runtime "node")}}
  runtime = "nodejs"
  {{/if}}
  {{#if (or (eq runtime "workers") (and (eq backend "self") (eq webDeploy "cloudflare")))}}
  runtime = "workerd"
  {{/if}}
}

datasource db {
  provider = "postgresql"
  {{#if (eq dbSetup "planetscale")}}
  relationMode = "prisma"
  {{/if}}
}
`],
  ["db/typeorm/base/src/entities/index.ts.hbs", `{{#if (eq auth "better-auth")}}
export * from "./user";
export * from "./session";
export * from "./account";
export * from "./verification";
{{/if}}
{{#if (includes examples "todo")}}
export * from "./todo";
{{/if}}
export {};
`],
  ["db/prisma/mongodb/prisma/schema/schema.prisma.hbs", `generator client {
  provider = "prisma-client"
  output   = "../generated"
  moduleFormat = "esm"
  {{#if (eq runtime "bun")}}
  runtime = "bun"
  {{/if}}
  {{#if (eq runtime "node")}}
  runtime = "nodejs"
  {{/if}}
  {{#if (or (eq runtime "workers") (and (eq backend "self") (eq webDeploy "cloudflare")))}}
  runtime = "workerd"
  {{/if}}
}

datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}
`],
  ["payments/paddle/web/solid/src/routes/success.tsx.hbs", `import { useSearchParams } from "@solidjs/router";

export default function SuccessPage() {
	const [searchParams] = useSearchParams();
	const transactionId = () => searchParams.transaction_id;

	return (
		<div class="container mx-auto px-4 py-8">
			<h1 class="text-2xl font-bold mb-4">Payment Successful!</h1>
			<p class="text-gray-600 mb-4">
				Thank you for your purchase. Your payment has been processed successfully.
			</p>
			{transactionId() && (
				<p class="text-sm text-gray-500">Transaction ID: {transactionId()}</p>
			)}
		</div>
	);
}
`],
  ["payments/paddle/server/base/src/lib/paddle.ts.hbs", `import {
	Paddle,
	Environment,
	type Product,
	type Price,
	type Subscription,
	type Customer,
	type Transaction,
	type EventEntity,
} from "@paddle/paddle-node-sdk";
import { env } from "@{{projectName}}/env/server";

// Initialize Paddle with your API key
const paddle = new Paddle(env.PADDLE_API_KEY, {
	environment: env.PADDLE_ENVIRONMENT === "production" ? Environment.production : Environment.sandbox,
});

export { paddle };

// Products
export async function listProducts(): Promise<Product[]> {
	const products: Product[] = [];
	const productCollection = paddle.products.list();

	for await (const product of productCollection) {
		products.push(product);
	}

	return products;
}

export async function getProduct(productId: string): Promise<Product> {
	return paddle.products.get(productId);
}

// Prices
export async function listPrices(productId?: string): Promise<Price[]> {
	const prices: Price[] = [];
	const priceCollection = paddle.prices.list(productId ? { productId: [productId] } : undefined);

	for await (const price of priceCollection) {
		prices.push(price);
	}

	return prices;
}

export async function getPrice(priceId: string): Promise<Price> {
	return paddle.prices.get(priceId);
}

// Customers
export async function listCustomers(email?: string): Promise<Customer[]> {
	const customers: Customer[] = [];
	const customerCollection = paddle.customers.list(email ? { email: [email] } : undefined);

	for await (const customer of customerCollection) {
		customers.push(customer);
	}

	return customers;
}

export async function getCustomer(customerId: string): Promise<Customer> {
	return paddle.customers.get(customerId);
}

export async function createCustomer(params: {
	email: string;
	name?: string;
	locale?: string;
}): Promise<Customer> {
	return paddle.customers.create(params);
}

// Subscriptions
export async function listSubscriptions(customerId?: string): Promise<Subscription[]> {
	const subscriptions: Subscription[] = [];
	const subscriptionCollection = paddle.subscriptions.list(
		customerId ? { customerId: [customerId] } : undefined
	);

	for await (const subscription of subscriptionCollection) {
		subscriptions.push(subscription);
	}

	return subscriptions;
}

export async function getSubscription(subscriptionId: string): Promise<Subscription> {
	return paddle.subscriptions.get(subscriptionId);
}

export async function cancelSubscription(
	subscriptionId: string,
	effectiveFrom?: "immediately" | "next_billing_period"
): Promise<Subscription> {
	return paddle.subscriptions.cancel(subscriptionId, {
		effectiveFrom: effectiveFrom ?? "next_billing_period",
	});
}

export async function pauseSubscription(subscriptionId: string): Promise<Subscription> {
	return paddle.subscriptions.pause(subscriptionId, {});
}

export async function resumeSubscription(subscriptionId: string): Promise<Subscription> {
	return paddle.subscriptions.resume(subscriptionId, {
		effectiveFrom: "immediately",
	});
}

// Transactions
export async function listTransactions(customerId?: string): Promise<Transaction[]> {
	const transactions: Transaction[] = [];
	const transactionCollection = paddle.transactions.list(
		customerId ? { customerId: [customerId] } : undefined
	);

	for await (const transaction of transactionCollection) {
		transactions.push(transaction);
	}

	return transactions;
}

export async function getTransaction(transactionId: string): Promise<Transaction> {
	return paddle.transactions.get(transactionId);
}

// Webhook verification
export function verifyWebhookSignature(
	requestBody: string,
	signature: string
): EventEntity | null {
	try {
		// Paddle SDK handles webhook verification internally
		const event = paddle.webhooks.unmarshal(requestBody, env.PADDLE_WEBHOOK_SECRET, signature);
		return event;
	} catch (error) {
		console.error("Webhook verification failed:", error);
		return null;
	}
}

// Webhook event types
export type WebhookEventType =
	| "transaction.billed"
	| "transaction.canceled"
	| "transaction.completed"
	| "transaction.created"
	| "transaction.paid"
	| "transaction.past_due"
	| "transaction.payment_failed"
	| "transaction.ready"
	| "transaction.updated"
	| "subscription.activated"
	| "subscription.canceled"
	| "subscription.created"
	| "subscription.imported"
	| "subscription.past_due"
	| "subscription.paused"
	| "subscription.resumed"
	| "subscription.trialing"
	| "subscription.updated"
	| "customer.created"
	| "customer.imported"
	| "customer.updated"
	| "product.created"
	| "product.imported"
	| "product.updated"
	| "price.created"
	| "price.imported"
	| "price.updated";
`],
  ["addons/storybook/apps/web/.storybook/main.ts.hbs", `import type { StorybookConfig } from "{{#if (eq frontend "next")}}@storybook/nextjs{{else if (or (eq frontend "tanstack-router") (eq frontend "react-router") (eq frontend "solid"))}}@storybook/react-vite{{else if (eq frontend "nuxt")}}@storybook/vue3-vite{{else if (eq frontend "svelte")}}@storybook/svelte-vite{{else}}@storybook/react-vite{{/if}}";

const config: StorybookConfig = {
  stories: ["../src/**/*.mdx", "../src/**/*.stories.@(js|jsx|mjs|ts|tsx)"],
  addons: [
    "@storybook/addon-essentials",
    "@storybook/addon-interactions",
  ],
  framework: {
    name: "{{#if (eq frontend "next")}}@storybook/nextjs{{else if (or (eq frontend "tanstack-router") (eq frontend "react-router") (eq frontend "solid"))}}@storybook/react-vite{{else if (eq frontend "nuxt")}}@storybook/vue3-vite{{else if (eq frontend "svelte")}}@storybook/svelte-vite{{else}}@storybook/react-vite{{/if}}",
    options: {},
  },
};

export default config;
`],
  ["addons/storybook/apps/web/.storybook/preview.ts.hbs", `{{#if (eq frontend "next")}}
import type { Preview } from "@storybook/nextjs";
{{else if (or (eq frontend "tanstack-router") (eq frontend "react-router") (eq frontend "solid"))}}
import type { Preview } from "@storybook/react-vite";
{{else if (eq frontend "nuxt")}}
import type { Preview } from "@storybook/vue3-vite";
{{else if (eq frontend "svelte")}}
import type { Preview } from "@storybook/svelte-vite";
{{else}}
import type { Preview } from "@storybook/react-vite";
{{/if}}
{{#if (eq cssFramework "tailwind")}}
import "../src/index.css";
{{/if}}

const preview: Preview = {
  parameters: {
    controls: {
      matchers: {
        color: /(background|color)$/i,
        date: /Date$/i,
      },
    },
  },
};

export default preview;
`],
  ["db/drizzle/base/src/schema/index.ts.hbs", `{{#if (eq auth "better-auth")}}
export * from "./auth";
{{/if}}
{{#if (includes examples "todo")}}
export * from "./todo";
{{/if}}
export {};`],
  ["payments/paddle/web/nuxt/app/pages/success.vue.hbs", `<script setup lang="ts">
const route = useRoute();
const transactionId = route.query.transaction_id as string | undefined;
</script>

<template>
	<div class="container mx-auto px-4 py-8">
		<h1 class="text-2xl font-bold mb-4">Payment Successful!</h1>
		<p class="text-gray-600 mb-4">
			Thank you for your purchase. Your payment has been processed successfully.
		</p>
		<p v-if="transactionId" class="text-sm text-gray-500">
			Transaction ID: {{ transactionId }}
		</p>
	</div>
</template>
`],
  ["cms/strapi/web/next/src/strapi/env.ts.hbs", `// Strapi environment configuration
export const strapiUrl = process.env.NEXT_PUBLIC_STRAPI_URL || "http://localhost:1337";
export const strapiApiUrl = \`\${strapiUrl}/api\`;

// API token for server-side authenticated requests
export const strapiApiToken = process.env.STRAPI_API_TOKEN;
`],
  ["cms/strapi/web/next/src/strapi/index.ts.hbs", `// Strapi client and utilities
export { strapiClient, strapiServerClient, strapiFetch, strapiFetchSingle } from "./lib/client";
export { buildCollectionQuery, stringifyQuery, populateConfigs, filterBuilders } from "./lib/queries";
export { getStrapiMediaUrl, getStrapiMediaFormat, getStrapiMediaDimensions, getStrapiSrcSet } from "./lib/media";
export { strapiUrl, strapiApiUrl, strapiApiToken } from "./env";

// Types
export type {
  StrapiPagination,
  StrapiCollectionResponse,
  StrapiSingleResponse,
  StrapiBaseDocument,
  StrapiMedia,
  StrapiMediaFormat,
  StrapiSEO,
  Article,
  Author,
  Category,
  Page,
  Homepage,
} from "./lib/types";
`],
  ["payments/stripe/web/solid/src/routes/success.tsx.hbs", `import { createFileRoute } from "@tanstack/solid-router";
import { Show } from "solid-js";

export const Route = createFileRoute("/success")({
	component: SuccessPage,
	validateSearch: (search) => ({
		session_id: search.session_id as string,
	}),
});

function SuccessPage() {
	const searchParams = Route.useSearch();
	const session_id = searchParams().session_id;

	return (
		<div class="container mx-auto px-4 py-8">
			<h1 class="text-2xl font-bold mb-4">Payment Successful!</h1>
			<p class="text-gray-600 mb-4">
				Thank you for your purchase. Your payment has been processed successfully.
			</p>
			<Show when={session_id}>
				<p class="text-sm text-gray-500">Session ID: {session_id}</p>
			</Show>
		</div>
	);
}
`],
  ["payments/lemon-squeezy/web/solid/src/routes/success.tsx.hbs", `import { useSearchParams } from "@solidjs/router";

export default function SuccessPage() {
	const [searchParams] = useSearchParams();

	return (
		<div class="container mx-auto px-4 py-8">
			<h1 class="text-2xl font-bold mb-4">Payment Successful!</h1>
			<p class="text-gray-600 mb-4">
				Thank you for your purchase. Your payment has been processed successfully.
			</p>
			{searchParams.checkout_id && (
				<p class="text-sm text-gray-500">Checkout ID: {searchParams.checkout_id}</p>
			)}
		</div>
	);
}
`],
  ["payments/lemon-squeezy/web/nuxt/app/pages/success.vue.hbs", `<script setup lang="ts">
const route = useRoute();
const checkoutId = computed(() => route.query.checkout_id as string | undefined);
</script>

<template>
	<div class="container mx-auto px-4 py-8">
		<h1 class="text-2xl font-bold mb-4">Payment Successful!</h1>
		<p class="text-gray-600 mb-4">
			Thank you for your purchase. Your payment has been processed successfully.
		</p>
		<p v-if="checkoutId" class="text-sm text-gray-500">
			Checkout ID: {{ checkoutId }}
		</p>
	</div>
</template>
`],
  ["payments/polar/web/solid/src/routes/success.tsx.hbs", `import { createFileRoute } from "@tanstack/solid-router";
import { Show } from "solid-js";

export const Route = createFileRoute("/success")({
	component: SuccessPage,
	validateSearch: (search) => ({
		checkout_id: search.checkout_id as string,
	}),
});

function SuccessPage() {
	const searchParams = Route.useSearch();
	const checkout_id = searchParams().checkout_id;

	return (
		<div class="container mx-auto px-4 py-8">
			<h1>Payment Successful!</h1>
			<Show when={checkout_id}>
				<p>Checkout ID: {checkout_id}</p>
			</Show>
		</div>
	);
}
`],
  ["payments/stripe/web/nuxt/app/pages/success.vue.hbs", `<script setup lang="ts">
const route = useRoute()
const session_id = route.query.session_id as string
</script>

<template>
  <div class="container mx-auto px-4 py-8">
    <h1 class="text-2xl font-bold mb-4">Payment Successful!</h1>
    <p class="text-gray-600 mb-4">
      Thank you for your purchase. Your payment has been processed successfully.
    </p>
    <p v-if="session_id" class="text-sm text-gray-500">
      Session ID: \\{{ session_id }}
    </p>
  </div>
</template>
`],
  ["cms/sanity/web/next/src/sanity/env.ts.hbs", `export const projectId = process.env.NEXT_PUBLIC_SANITY_PROJECT_ID!;
export const dataset = process.env.NEXT_PUBLIC_SANITY_DATASET!;
export const apiVersion =
  process.env.NEXT_PUBLIC_SANITY_API_VERSION || "2024-07-11";

// Used for server-side fetching
export const token = process.env.SANITY_API_READ_TOKEN;
`],
  ["payments/stripe/server/base/src/lib/stripe.ts.hbs", `import Stripe from "stripe";
import { env } from "@{{projectName}}/env/server";

export const stripe = new Stripe(env.STRIPE_SECRET_KEY, {
	apiVersion: "2024-12-18",
});

export async function createCheckoutSession(params: {
	priceId: string;
	successUrl: string;
	cancelUrl: string;
	customerId?: string;
	metadata?: Record<string, string>;
}) {
	const session = await stripe.checkout.sessions.create({
		mode: "payment",
		payment_method_types: ["card"],
		line_items: [
			{
				price: params.priceId,
				quantity: 1,
			},
		],
		success_url: params.successUrl,
		cancel_url: params.cancelUrl,
		customer: params.customerId,
		metadata: params.metadata,
	});

	return session;
}

export async function createSubscriptionCheckout(params: {
	priceId: string;
	successUrl: string;
	cancelUrl: string;
	customerId?: string;
	metadata?: Record<string, string>;
}) {
	const session = await stripe.checkout.sessions.create({
		mode: "subscription",
		payment_method_types: ["card"],
		line_items: [
			{
				price: params.priceId,
				quantity: 1,
			},
		],
		success_url: params.successUrl,
		cancel_url: params.cancelUrl,
		customer: params.customerId,
		metadata: params.metadata,
	});

	return session;
}

export async function constructWebhookEvent(
	payload: string | Buffer,
	signature: string,
) {
	return stripe.webhooks.constructEvent(
		payload,
		signature,
		env.STRIPE_WEBHOOK_SECRET,
	);
}
`],
  ["payments/polar/server/base/src/lib/payments.ts.hbs", `import { Polar } from "@polar-sh/sdk";
import { env } from "@{{projectName}}/env/server";

export const polarClient = new Polar({
	accessToken: env.POLAR_ACCESS_TOKEN,
	server: "sandbox",
});
`],
  ["payments/polar/web/nuxt/app/pages/success.vue.hbs", `<script setup lang="ts">
const route = useRoute()
const checkout_id = route.query.checkout_id as string
</script>

<template>
  <div class="container mx-auto px-4 py-8">
    <h1 class="text-2xl font-bold mb-4">Payment Successful!</h1>
    <p v-if="checkout_id">Checkout ID: \\{{ checkout_id }}</p>
  </div>
</template>
`],
  ["examples/ai/web/nuxt/app/pages/ai.vue.hbs", `<script setup lang="ts">
import { Chat } from '@ai-sdk/vue'
import type { UIMessage } from 'ai'
import { getTextFromMessage } from '@nuxt/ui/utils/ai'
import { DefaultChatTransport } from 'ai'
import { ref } from 'vue'

const config = useRuntimeConfig()
const messages: UIMessage[] = []
const input = ref('')

const chat = new Chat({
  messages,
  transport: new DefaultChatTransport({
    api: \`\${config.public.serverUrl}/ai\`,
  }),
  onError(error) {
    console.error('Chat error:', error)
  }
})

async function handleSubmit(e: Event) {
  e.preventDefault()
  const userInput = input.value
  input.value = ''

  if (!userInput.trim()) return

  chat.sendMessage({ text: userInput })
}
</script>

<template>
  <UContainer class="h-full flex flex-col overflow-hidden py-4">
    <div class="flex-1 min-h-0 overflow-y-auto">
      <UChatMessages :messages="chat.messages" :status="chat.status">
        <template #content="{ message }">
          <div class="whitespace-pre-wrap">\\{{ getTextFromMessage(message) }}</div>
        </template>
      </UChatMessages>
    </div>

    <div class="shrink-0 pt-4 border-t border-gray-200 dark:border-gray-800">
      <UChatPrompt
        v-model="input"
        :error="chat.error"
        @submit="handleSubmit"
        placeholder="Type your message..."
      >
        <UChatPromptSubmit :status="chat.status" @stop="() => chat.stop()" @reload="() => chat.regenerate()" />
      </UChatPrompt>
    </div>
  </UContainer>
</template>`],
  ["examples/ai/native/unistyles/app/(drawer)/ai.tsx.hbs", `{{#if (eq backend "convex")}}
import { Ionicons } from "@expo/vector-icons";
import {
  useUIMessages,
  useSmoothText,
  type UIMessage,
} from "@convex-dev/agent/react";
import { api } from "@{{projectName}}/backend/convex/_generated/api";
import { useMutation } from "convex/react";
import React, { useRef, useEffect, useState } from "react";
import {
  View,
  Text,
  TextInput,
  TouchableOpacity,
  ScrollView,
  KeyboardAvoidingView,
  Platform,
  ActivityIndicator,
} from "react-native";
import { StyleSheet, useUnistyles } from "react-native-unistyles";

import { Container } from "@/components/container";

function MessageContent({
  text,
  isStreaming,
  style,
}: {
  text: string;
  isStreaming: boolean;
  style: object;
}) {
  const [visibleText] = useSmoothText(text, {
    startStreaming: isStreaming,
  });
  return <Text style={style}>{visibleText}</Text>;
}

export default function AIScreen() {
  const { theme } = useUnistyles();
  const [input, setInput] = useState("");
  const [threadId, setThreadId] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const scrollViewRef = useRef<ScrollView>(null);

  const createThread = useMutation(api.chat.createNewThread);
  const sendMessage = useMutation(api.chat.sendMessage);

  const { results: messages } = useUIMessages(
    api.chat.listMessages,
    threadId ? { threadId } : "skip",
    { initialNumItems: 50, stream: true },
  );

  const hasStreamingMessage = messages?.some(
    (m: UIMessage) => m.status === "streaming",
  );

  useEffect(() => {
    scrollViewRef.current?.scrollToEnd({ animated: true });
  }, [messages]);

  const onSubmit = async () => {
    const value = input.trim();
    if (!value || isLoading) return;

    setIsLoading(true);
    setInput("");

    try {
      let currentThreadId = threadId;
      if (!currentThreadId) {
        currentThreadId = await createThread();
        setThreadId(currentThreadId);
      }

      await sendMessage({ threadId: currentThreadId, prompt: value });
    } catch (error) {
      console.error("Failed to send message:", error);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <Container>
      <KeyboardAvoidingView
        style={styles.container}
        behavior={Platform.OS === "ios" ? "padding" : "height"}
      >
        <View style={styles.content}>
          <View style={styles.header}>
            <Text style={styles.headerTitle}>AI Chat</Text>
            <Text style={styles.headerSubtitle}>
              Chat with our AI assistant
            </Text>
          </View>

          <ScrollView
            ref={scrollViewRef}
            style={styles.messagesContainer}
            showsVerticalScrollIndicator={false}
          >
            {!messages || messages.length === 0 ? (
              <View style={styles.emptyContainer}>
                <Text style={styles.emptyText}>
                  Ask me anything to get started!
                </Text>
              </View>
            ) : (
              <View style={styles.messagesWrapper}>
                {messages.map((message: UIMessage) => (
                  <View
                    key={message.key}
                    style={[
                      styles.messageContainer,
                      message.role === "user"
                        ? styles.userMessage
                        : styles.assistantMessage,
                    ]}
                  >
                    <Text style={styles.messageRole}>
                      {message.role === "user" ? "You" : "AI Assistant"}
                    </Text>
                    <MessageContent
                      text={message.text ?? ""}
                      isStreaming={message.status === "streaming"}
                      style={styles.messageContent}
                    />
                  </View>
                ))}
                {isLoading && !hasStreamingMessage && (
                  <View style={[styles.messageContainer, styles.assistantMessage]}>
                    <Text style={styles.messageRole}>AI Assistant</Text>
                    <View style={styles.loadingContainer}>
                      <ActivityIndicator size="small" color={theme.colors.primary} />
                      <Text style={styles.loadingText}>Thinking...</Text>
                    </View>
                  </View>
                )}
              </View>
            )}
          </ScrollView>

          <View style={styles.inputSection}>
            <View style={styles.inputContainer}>
              <TextInput
                value={input}
                onChangeText={setInput}
                placeholder="Type your message..."
                placeholderTextColor={theme.colors.border}
                style={styles.textInput}
                onSubmitEditing={(e) => {
                  e.preventDefault();
                  onSubmit();
                }}
                editable={!isLoading}
                autoFocus={true}
              />
              <TouchableOpacity
                onPress={onSubmit}
                disabled={!input.trim() || isLoading}
                style={[
                  styles.sendButton,
                  (!input.trim() || isLoading) && styles.sendButtonDisabled,
                ]}
              >
                <Ionicons
                  name="send"
                  size={20}
                  color={
                    input.trim() && !isLoading
                      ? theme.colors.background
                      : theme.colors.border
                  }
                />
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </KeyboardAvoidingView>
    </Container>
  );
}

const styles = StyleSheet.create((theme) => ({
  container: {
    flex: 1,
  },
  content: {
    flex: 1,
    paddingHorizontal: theme.spacing.md,
    paddingVertical: theme.spacing.lg,
  },
  header: {
    marginBottom: theme.spacing.lg,
  },
  headerTitle: {
    fontSize: 28,
    fontWeight: "bold",
    color: theme.colors.typography,
    marginBottom: theme.spacing.sm,
  },
  headerSubtitle: {
    fontSize: 16,
    color: theme.colors.typography,
  },
  messagesContainer: {
    flex: 1,
    marginBottom: theme.spacing.md,
  },
  emptyContainer: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
  },
  emptyText: {
    textAlign: "center",
    color: theme.colors.typography,
    fontSize: 18,
  },
  messagesWrapper: {
    gap: theme.spacing.md,
  },
  messageContainer: {
    padding: theme.spacing.md,
    borderRadius: 8,
  },
  userMessage: {
    backgroundColor: theme.colors.primary + "20",
    marginLeft: theme.spacing.xl,
    alignSelf: "flex-end",
  },
  assistantMessage: {
    backgroundColor: theme.colors.background,
    marginRight: theme.spacing.xl,
    borderWidth: 1,
    borderColor: theme.colors.border,
  },
  messageRole: {
    fontSize: 14,
    fontWeight: "600",
    marginBottom: theme.spacing.sm,
    color: theme.colors.typography,
  },
  messageContent: {
    color: theme.colors.typography,
    lineHeight: 20,
  },
  loadingContainer: {
    flexDirection: "row",
    alignItems: "center",
    gap: theme.spacing.sm,
  },
  loadingText: {
    color: theme.colors.typography,
    opacity: 0.7,
  },
  inputSection: {
    borderTopWidth: 1,
    borderTopColor: theme.colors.border,
    paddingTop: theme.spacing.md,
  },
  inputContainer: {
    flexDirection: "row",
    alignItems: "flex-end",
    gap: theme.spacing.sm,
  },
  textInput: {
    flex: 1,
    borderWidth: 1,
    borderColor: theme.colors.border,
    borderRadius: 8,
    paddingHorizontal: theme.spacing.md,
    paddingVertical: theme.spacing.sm,
    color: theme.colors.typography,
    backgroundColor: theme.colors.background,
    fontSize: 16,
    minHeight: 40,
    maxHeight: 120,
  },
  sendButton: {
    backgroundColor: theme.colors.primary,
    padding: theme.spacing.sm,
    borderRadius: 8,
    justifyContent: "center",
    alignItems: "center",
  },
  sendButtonDisabled: {
    backgroundColor: theme.colors.border,
  },
}));
{{else}}
import React, { useRef, useEffect, useState } from "react";
import {
  View,
  Text,
  TextInput,
  TouchableOpacity,
  ScrollView,
  KeyboardAvoidingView,
  Platform,
} from "react-native";
import { useChat } from "@ai-sdk/react";
import { DefaultChatTransport } from "ai";
import { fetch as expoFetch } from "expo/fetch";
import { Ionicons } from "@expo/vector-icons";
import { StyleSheet, useUnistyles } from "react-native-unistyles";
import { Container } from "@/components/container";
import { env } from "@{{projectName}}/env/native";

const generateAPIUrl = (relativePath: string) => {
  const serverUrl = env.EXPO_PUBLIC_SERVER_URL;
  if (!serverUrl) {
    throw new Error(
      "EXPO_PUBLIC_SERVER_URL environment variable is not defined"
    );
  }
  const path = relativePath.startsWith("/") ? relativePath : \`/\${relativePath}\`;
  return serverUrl.concat(path);
};

export default function AIScreen() {
  const { theme } = useUnistyles();
  const [input, setInput] = useState("");
  const { messages, error, sendMessage } = useChat({
    transport: new DefaultChatTransport({
      fetch: expoFetch as unknown as typeof globalThis.fetch,
      api: generateAPIUrl("/ai"),
    }),
    onError: (error) => console.error(error, "AI Chat Error"),
  });

  const scrollViewRef = useRef<ScrollView>(null);

  useEffect(() => {
    scrollViewRef.current?.scrollToEnd({ animated: true });
  }, [messages]);

  const onSubmit = () => {
    const value = input.trim();
    if (value) {
      sendMessage({ text: value });
      setInput("");
    }
  };

  if (error) {
    return (
      <Container>
        <View style={styles.errorContainer}>
          <Text style={styles.errorText}>Error: {error.message}</Text>
          <Text style={styles.errorSubtext}>
            Please check your connection and try again.
          </Text>
        </View>
      </Container>
    );
  }

  return (
    <Container>
      <KeyboardAvoidingView
        style={styles.container}
        behavior={Platform.OS === "ios" ? "padding" : "height"}
      >
        <View style={styles.content}>
          <View style={styles.header}>
            <Text style={styles.headerTitle}>AI Chat</Text>
            <Text style={styles.headerSubtitle}>
              Chat with our AI assistant
            </Text>
          </View>

          <ScrollView
            ref={scrollViewRef}
            style={styles.messagesContainer}
            showsVerticalScrollIndicator={false}
          >
            {messages.length === 0 ? (
              <View style={styles.emptyContainer}>
                <Text style={styles.emptyText}>
                  Ask me anything to get started!
                </Text>
              </View>
            ) : (
              <View style={styles.messagesWrapper}>
                {messages.map((message) => (
                  <View
                    key={message.id}
                    style={[
                      styles.messageContainer,
                      message.role === "user"
                        ? styles.userMessage
                        : styles.assistantMessage,
                    ]}
                  >
                    <Text style={styles.messageRole}>
                      {message.role === "user" ? "You" : "AI Assistant"}
                    </Text>
                    <View style={styles.messageContentWrapper}>
                      {message.parts.map((part, i) => {
                        if (part.type === "text") {
                          return (
                            <Text
                              key={\`\${message.id}-\${i}\`}
                              style={styles.messageContent}
                            >
                              {part.text}
                            </Text>
                          );
                        }
                        return (
                          <Text
                            key={\`\${message.id}-\${i}\`}
                            style={styles.messageContent}
                          >
                            {JSON.stringify(part)}
                          </Text>
                        );
                      })}
                    </View>
                  </View>
                ))}
              </View>
            )}
          </ScrollView>

          <View style={styles.inputSection}>
            <View style={styles.inputContainer}>
              <TextInput
                value={input}
                onChangeText={setInput}
                placeholder="Type your message..."
                placeholderTextColor={theme.colors.border}
                style={styles.textInput}
                onSubmitEditing={(e) => {
                  e.preventDefault();
                  onSubmit();
                }}
                autoFocus={true}
              />
              <TouchableOpacity
                onPress={onSubmit}
                disabled={!input.trim()}
                style={[
                  styles.sendButton,
                  !input.trim() && styles.sendButtonDisabled,
                ]}
              >
                <Ionicons
                  name="send"
                  size={20}
                  color={
                    input.trim()
                      ? theme.colors.background
                      : theme.colors.border
                  }
                />
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </KeyboardAvoidingView>
    </Container>
  );
}

const styles = StyleSheet.create((theme) => ({
  container: {
    flex: 1,
  },
  content: {
    flex: 1,
    paddingHorizontal: theme.spacing.md,
    paddingVertical: theme.spacing.lg,
  },
  errorContainer: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    paddingHorizontal: theme.spacing.md,
  },
  errorText: {
    color: theme.colors.destructive,
    textAlign: "center",
    fontSize: 18,
    marginBottom: theme.spacing.md,
  },
  errorSubtext: {
    color: theme.colors.typography,
    textAlign: "center",
    fontSize: 16,
  },
  header: {
    marginBottom: theme.spacing.lg,
  },
  headerTitle: {
    fontSize: 28,
    fontWeight: "bold",
    color: theme.colors.typography,
    marginBottom: theme.spacing.sm,
  },
  headerSubtitle: {
    fontSize: 16,
    color: theme.colors.typography,
  },
  messagesContainer: {
    flex: 1,
    marginBottom: theme.spacing.md,
  },
  emptyContainer: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
  },
  emptyText: {
    textAlign: "center",
    color: theme.colors.typography,
    fontSize: 18,
  },
  messagesWrapper: {
    gap: theme.spacing.md,
  },
  messageContainer: {
    padding: theme.spacing.md,
    borderRadius: 8,
  },
  userMessage: {
    backgroundColor: theme.colors.primary + "20",
    marginLeft: theme.spacing.xl,
    alignSelf: "flex-end",
  },
  assistantMessage: {
    backgroundColor: theme.colors.background,
    marginRight: theme.spacing.xl,
    borderWidth: 1,
    borderColor: theme.colors.border,
  },
  messageRole: {
    fontSize: 14,
    fontWeight: "600",
    marginBottom: theme.spacing.sm,
    color: theme.colors.typography,
  },
  messageContentWrapper: {
    gap: theme.spacing.xs,
  },
  messageContent: {
    color: theme.colors.typography,
    lineHeight: 20,
  },
  inputSection: {
    borderTopWidth: 1,
    borderTopColor: theme.colors.border,
    paddingTop: theme.spacing.md,
  },
  inputContainer: {
    flexDirection: "row",
    alignItems: "flex-end",
    gap: theme.spacing.sm,
  },
  textInput: {
    flex: 1,
    borderWidth: 1,
    borderColor: theme.colors.border,
    borderRadius: 8,
    paddingHorizontal: theme.spacing.md,
    paddingVertical: theme.spacing.sm,
    color: theme.colors.typography,
    backgroundColor: theme.colors.background,
    fontSize: 16,
    minHeight: 40,
    maxHeight: 120,
  },
  sendButton: {
    backgroundColor: theme.colors.primary,
    padding: theme.spacing.sm,
    borderRadius: 8,
    justifyContent: "center",
    alignItems: "center",
  },
  sendButtonDisabled: {
    backgroundColor: theme.colors.border,
  },
}));
{{/if}}
`],
  ["examples/ai/native/bare/app/(drawer)/ai.tsx.hbs", `{{#if (eq backend "convex")}}
import { Ionicons } from "@expo/vector-icons";
import {
  useUIMessages,
  useSmoothText,
  type UIMessage,
} from "@convex-dev/agent/react";
import { api } from "@{{projectName}}/backend/convex/_generated/api";
import { useMutation } from "convex/react";
import { useRef, useEffect, useState } from "react";
import {
  View,
  Text,
  TextInput,
  TouchableOpacity,
  ScrollView,
  KeyboardAvoidingView,
  Platform,
  StyleSheet,
  ActivityIndicator,
} from "react-native";

import { Container } from "@/components/container";
import { useColorScheme } from "@/lib/use-color-scheme";
import { NAV_THEME } from "@/lib/constants";

function MessageContent({
  text,
  isStreaming,
  textColor,
}: {
  text: string;
  isStreaming: boolean;
  textColor: string;
}) {
  const [visibleText] = useSmoothText(text, {
    startStreaming: isStreaming,
  });
  return <Text style={[styles.messageText, { color: textColor }]}>{visibleText}</Text>;
}

export default function AIScreen() {
  const { colorScheme } = useColorScheme();
  const theme = colorScheme === "dark" ? NAV_THEME.dark : NAV_THEME.light;
  const [input, setInput] = useState("");
  const [threadId, setThreadId] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const scrollViewRef = useRef<ScrollView>(null);

  const createThread = useMutation(api.chat.createNewThread);
  const sendMessage = useMutation(api.chat.sendMessage);

  const { results: messages } = useUIMessages(
    api.chat.listMessages,
    threadId ? { threadId } : "skip",
    { initialNumItems: 50, stream: true },
  );

  const hasStreamingMessage = messages?.some(
    (m: UIMessage) => m.status === "streaming",
  );

  useEffect(() => {
    scrollViewRef.current?.scrollToEnd({ animated: true });
  }, [messages]);

  async function onSubmit() {
    const value = input.trim();
    if (!value || isLoading) return;

    setIsLoading(true);
    setInput("");

    try {
      let currentThreadId = threadId;
      if (!currentThreadId) {
        currentThreadId = await createThread();
        setThreadId(currentThreadId);
      }

      await sendMessage({ threadId: currentThreadId, prompt: value });
    } catch (error) {
      console.error("Failed to send message:", error);
    } finally {
      setIsLoading(false);
    }
  }

  return (
    <Container>
      <KeyboardAvoidingView
        style={styles.container}
        behavior={Platform.OS === "ios" ? "padding" : "height"}
      >
        <View style={styles.content}>
          <View style={styles.header}>
            <Text style={[styles.headerTitle, { color: theme.text }]}>
              AI Chat
            </Text>
            <Text style={[styles.headerSubtitle, { color: theme.text, opacity: 0.7 }]}>
              Chat with our AI assistant
            </Text>
          </View>
          <ScrollView
            ref={scrollViewRef}
            style={styles.scrollView}
            showsVerticalScrollIndicator={false}
          >
            {!messages || messages.length === 0 ? (
              <View style={styles.emptyContainer}>
                <Text style={[styles.emptyText, { color: theme.text, opacity: 0.7 }]}>
                  Ask me anything to get started!
                </Text>
              </View>
            ) : (
              <View style={styles.messagesList}>
                {messages.map((message: UIMessage) => (
                  <View
                    key={message.key}
                    style={[
                      styles.messageCard,
                      {
                        backgroundColor: message.role === "user"
                          ? theme.primary + "20"
                          : theme.card,
                        borderColor: theme.border,
                        alignSelf: message.role === "user" ? "flex-end" : "flex-start",
                        marginLeft: message.role === "user" ? 32 : 0,
                        marginRight: message.role === "user" ? 0 : 32,
                      },
                    ]}
                  >
                    <Text style={[styles.messageRole, { color: theme.text }]}>
                      {message.role === "user" ? "You" : "AI Assistant"}
                    </Text>
                    <MessageContent
                      text={message.text ?? ""}
                      isStreaming={message.status === "streaming"}
                      textColor={theme.text}
                    />
                  </View>
                ))}
                {isLoading && !hasStreamingMessage && (
                  <View
                    style={[
                      styles.messageCard,
                      {
                        backgroundColor: theme.card,
                        borderColor: theme.border,
                        alignSelf: "flex-start",
                        marginRight: 32,
                      },
                    ]}
                  >
                    <Text style={[styles.messageRole, { color: theme.text }]}>
                      AI Assistant
                    </Text>
                    <View style={styles.loadingContainer}>
                      <ActivityIndicator size="small" color={theme.primary} />
                      <Text style={[styles.loadingText, { color: theme.text, opacity: 0.7 }]}>
                        Thinking...
                      </Text>
                    </View>
                  </View>
                )}
              </View>
            )}
          </ScrollView>
          <View style={[styles.inputContainer, { borderTopColor: theme.border }]}>
            <View style={styles.inputRow}>
              <TextInput
                value={input}
                onChangeText={setInput}
                placeholder="Type your message..."
                placeholderTextColor={theme.text}
                style={[
                  styles.input,
                  {
                    color: theme.text,
                    borderColor: theme.border,
                    backgroundColor: theme.background,
                  },
                ]}
                onSubmitEditing={(e) => {
                  e.preventDefault();
                  onSubmit();
                }}
                editable={!isLoading}
                autoFocus={true}
                multiline
              />
              <TouchableOpacity
                onPress={onSubmit}
                disabled={!input.trim() || isLoading}
                style={[
                  styles.sendButton,
                  {
                    backgroundColor: input.trim() && !isLoading ? theme.primary : theme.border,
                    opacity: input.trim() && !isLoading ? 1 : 0.5,
                  },
                ]}
              >
                <Ionicons
                  name="send"
                  size={20}
                  color="#ffffff"
                />
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </KeyboardAvoidingView>
    </Container>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  content: {
    flex: 1,
    padding: 16,
  },
  header: {
    marginBottom: 16,
  },
  headerTitle: {
    fontSize: 20,
    fontWeight: "bold",
    marginBottom: 4,
  },
  headerSubtitle: {
    fontSize: 14,
  },
  scrollView: {
    flex: 1,
    marginBottom: 16,
  },
  emptyContainer: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
  },
  emptyText: {
    fontSize: 16,
    textAlign: "center",
  },
  messagesList: {
    gap: 8,
    paddingBottom: 16,
  },
  messageCard: {
    borderWidth: 1,
    padding: 12,
    maxWidth: "80%",
  },
  messageRole: {
    fontSize: 12,
    fontWeight: "bold",
    marginBottom: 4,
  },
  messageText: {
    fontSize: 14,
    lineHeight: 20,
  },
  loadingContainer: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
  },
  loadingText: {
    fontSize: 14,
  },
  inputContainer: {
    borderTopWidth: 1,
    paddingTop: 12,
  },
  inputRow: {
    flexDirection: "row",
    alignItems: "flex-end",
    gap: 8,
  },
  input: {
    flex: 1,
    borderWidth: 1,
    padding: 8,
    fontSize: 14,
    minHeight: 36,
    maxHeight: 100,
  },
  sendButton: {
    padding: 8,
    justifyContent: "center",
    alignItems: "center",
  },
});
{{else}}
import { useRef, useEffect, useState } from "react";
import {
  View,
  Text,
  TextInput,
  TouchableOpacity,
  ScrollView,
  KeyboardAvoidingView,
  Platform,
  StyleSheet,
} from "react-native";
import { useChat } from "@ai-sdk/react";
import { DefaultChatTransport } from "ai";
import { fetch as expoFetch } from "expo/fetch";
import { Ionicons } from "@expo/vector-icons";
import { Container } from "@/components/container";
import { useColorScheme } from "@/lib/use-color-scheme";
import { NAV_THEME } from "@/lib/constants";
import { env } from "@{{projectName}}/env/native";

const generateAPIUrl = (relativePath: string) => {
  const serverUrl = env.EXPO_PUBLIC_SERVER_URL;
  if (!serverUrl) {
    throw new Error(
      "EXPO_PUBLIC_SERVER_URL environment variable is not defined"
    );
  }
  const path = relativePath.startsWith("/") ? relativePath : \`/\${relativePath}\`;
  return serverUrl.concat(path);
};

export default function AIScreen() {
  const { colorScheme } = useColorScheme();
  const theme = colorScheme === "dark" ? NAV_THEME.dark : NAV_THEME.light;
  const [input, setInput] = useState("");
  const { messages, error, sendMessage } = useChat({
    transport: new DefaultChatTransport({
      fetch: expoFetch as unknown as typeof globalThis.fetch,
      api: generateAPIUrl("/ai"),
    }),
    onError: (error) => console.error(error, "AI Chat Error"),
  });
  const scrollViewRef = useRef<ScrollView>(null);

  useEffect(() => {
    scrollViewRef.current?.scrollToEnd({ animated: true });
  }, [messages]);

  function onSubmit() {
    const value = input.trim();
    if (value) {
      sendMessage({ text: value });
      setInput("");
    }
  }

  if (error) {
    return (
      <Container>
        <View style={styles.errorContainer}>
          <View style={[styles.errorCard, { backgroundColor: theme.notification + "20", borderColor: theme.notification }]}>
            <Text style={[styles.errorTitle, { color: theme.notification }]}>
              Error: {error.message}
            </Text>
            <Text style={[styles.errorText, { color: theme.text, opacity: 0.7 }]}>
              Please check your connection and try again.
            </Text>
          </View>
        </View>
      </Container>
    );
  }

  return (
    <Container>
      <KeyboardAvoidingView
        style={styles.container}
        behavior={Platform.OS === "ios" ? "padding" : "height"}
      >
        <View style={styles.content}>
          <View style={styles.header}>
            <Text style={[styles.headerTitle, { color: theme.text }]}>
              AI Chat
            </Text>
            <Text style={[styles.headerSubtitle, { color: theme.text, opacity: 0.7 }]}>
              Chat with our AI assistant
            </Text>
          </View>
          <ScrollView
            ref={scrollViewRef}
            style={styles.scrollView}
            showsVerticalScrollIndicator={false}
          >
            {messages.length === 0 ? (
              <View style={styles.emptyContainer}>
                <Text style={[styles.emptyText, { color: theme.text, opacity: 0.7 }]}>
                  Ask me anything to get started!
                </Text>
              </View>
            ) : (
              <View style={styles.messagesList}>
                {messages.map((message) => (
                  <View
                    key={message.id}
                    style={[
                      styles.messageCard,
                      {
                        backgroundColor: message.role === "user"
                          ? theme.primary + "20"
                          : theme.card,
                        borderColor: theme.border,
                        alignSelf: message.role === "user" ? "flex-end" : "flex-start",
                        marginLeft: message.role === "user" ? 32 : 0,
                        marginRight: message.role === "user" ? 0 : 32,
                      },
                    ]}
                  >
                    <Text style={[styles.messageRole, { color: theme.text }]}>
                      {message.role === "user" ? "You" : "AI Assistant"}
                    </Text>
                    <View style={styles.messageParts}>
                      {message.parts.map((part, i) =>
                        part.type === "text" ? (
                          <Text
                            key={\`\${message.id}-\${i}\`}
                            style={[styles.messageText, { color: theme.text }]}
                          >
                            {part.text}
                          </Text>
                        ) : (
                          <Text
                            key={\`\${message.id}-\${i}\`}
                            style={[styles.messageText, { color: theme.text }]}
                          >
                            {JSON.stringify(part)}
                          </Text>
                        )
                      )}
                    </View>
                  </View>
                ))}
              </View>
            )}
          </ScrollView>
          <View style={[styles.inputContainer, { borderTopColor: theme.border }]}>
            <View style={styles.inputRow}>
              <TextInput
                value={input}
                onChangeText={setInput}
                placeholder="Type your message..."
                placeholderTextColor={theme.text}
                style={[
                  styles.input,
                  {
                    color: theme.text,
                    borderColor: theme.border,
                    backgroundColor: theme.background,
                  },
                ]}
                onSubmitEditing={(e) => {
                  e.preventDefault();
                  onSubmit();
                }}
                autoFocus={true}
                multiline
              />
              <TouchableOpacity
                onPress={onSubmit}
                disabled={!input.trim()}
                style={[
                  styles.sendButton,
                  {
                    backgroundColor: input.trim() ? theme.primary : theme.border,
                    opacity: input.trim() ? 1 : 0.5,
                  },
                ]}
              >
                <Ionicons
                  name="send"
                  size={20}
                  color="#ffffff"
                />
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </KeyboardAvoidingView>
    </Container>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  content: {
    flex: 1,
    padding: 16,
  },
  header: {
    marginBottom: 16,
  },
  headerTitle: {
    fontSize: 20,
    fontWeight: "bold",
    marginBottom: 4,
  },
  headerSubtitle: {
    fontSize: 14,
  },
  scrollView: {
    flex: 1,
    marginBottom: 16,
  },
  emptyContainer: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
  },
  emptyText: {
    fontSize: 16,
    textAlign: "center",
  },
  messagesList: {
    gap: 8,
    paddingBottom: 16,
  },
  messageCard: {
    borderWidth: 1,
    padding: 12,
    maxWidth: "80%",
  },
  messageRole: {
    fontSize: 12,
    fontWeight: "bold",
    marginBottom: 4,
  },
  messageParts: {
    gap: 4,
  },
  messageText: {
    fontSize: 14,
    lineHeight: 20,
  },
  inputContainer: {
    borderTopWidth: 1,
    paddingTop: 12,
  },
  inputRow: {
    flexDirection: "row",
    alignItems: "flex-end",
    gap: 8,
  },
  input: {
    flex: 1,
    borderWidth: 1,
    padding: 8,
    fontSize: 14,
    minHeight: 36,
    maxHeight: 100,
  },
  sendButton: {
    padding: 8,
    justifyContent: "center",
    alignItems: "center",
  },
  errorContainer: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    padding: 16,
  },
  errorCard: {
    borderWidth: 1,
    padding: 16,
  },
  errorTitle: {
    fontSize: 16,
    fontWeight: "bold",
    marginBottom: 8,
    textAlign: "center",
  },
  errorText: {
    fontSize: 14,
    textAlign: "center",
  },
});
{{/if}}
`],
  ["examples/ai/native/uniwind/app/(drawer)/ai.tsx.hbs", `{{#if (eq backend "convex")}}
import { Ionicons } from "@expo/vector-icons";
import {
  useUIMessages,
  useSmoothText,
  type UIMessage,
} from "@convex-dev/agent/react";
import { api } from "@{{projectName}}/backend/convex/_generated/api";
import { useMutation } from "convex/react";
import { Button, Divider, Spinner, Surface, TextField, useThemeColor } from "heroui-native";
import { useRef, useEffect, useState } from "react";
import {
  View,
  Text,
  ScrollView,
  KeyboardAvoidingView,
  Platform,
} from "react-native";

import { Container } from "@/components/container";

function MessageContent({
  text,
  isStreaming,
}: {
  text: string;
  isStreaming: boolean;
}) {
  const [visibleText] = useSmoothText(text, {
    startStreaming: isStreaming,
  });
  return <Text className="text-foreground text-sm leading-relaxed">{visibleText}</Text>;
}

export default function AIScreen() {
  const [input, setInput] = useState("");
  const [threadId, setThreadId] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const scrollViewRef = useRef<ScrollView>(null);
  const mutedColor = useThemeColor("muted");
  const foregroundColor = useThemeColor("foreground");

  const createThread = useMutation(api.chat.createNewThread);
  const sendMessage = useMutation(api.chat.sendMessage);

  const { results: messages } = useUIMessages(
    api.chat.listMessages,
    threadId ? { threadId } : "skip",
    { initialNumItems: 50, stream: true },
  );

  const hasStreamingMessage = messages?.some(
    (m: UIMessage) => m.status === "streaming",
  );

  useEffect(() => {
    scrollViewRef.current?.scrollToEnd({ animated: true });
  }, [messages]);

  const onSubmit = async () => {
    const value = input.trim();
    if (!value || isLoading) return;

    setIsLoading(true);
    setInput("");

    try {
      let currentThreadId = threadId;
      if (!currentThreadId) {
        currentThreadId = await createThread();
        setThreadId(currentThreadId);
      }

      await sendMessage({ threadId: currentThreadId, prompt: value });
    } catch (error) {
      console.error("Failed to send message:", error);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <Container>
      <KeyboardAvoidingView
        className="flex-1"
        behavior={Platform.OS === "ios" ? "padding" : "height"}
      >
        <View className="flex-1 px-4 py-4">
          <View className="py-4 mb-4">
            <Text className="text-2xl font-semibold text-foreground tracking-tight">AI Chat</Text>
            <Text className="text-muted text-sm mt-1">Chat with our AI assistant</Text>
          </View>

          <ScrollView
            ref={scrollViewRef}
            className="flex-1 mb-4"
            showsVerticalScrollIndicator={false}
          >
            {!messages || messages.length === 0 ? (
              <View className="flex-1 justify-center items-center py-10">
                <Ionicons name="chatbubble-ellipses-outline" size={32} color={mutedColor} />
                <Text className="text-muted text-sm mt-3">Ask me anything to get started</Text>
              </View>
            ) : (
              <View className="gap-2">
                {messages.map((message: UIMessage) => (
                  <Surface
                    key={message.key}
                    variant={message.role === "user" ? "tertiary" : "secondary"}
                    className={\`p-3 rounded-lg \${message.role === "user" ? "ml-10" : "mr-10"}\`}
                  >
                    <Text className="text-xs font-medium mb-1 text-muted">
                      {message.role === "user" ? "You" : "AI"}
                    </Text>
                    <MessageContent
                      text={message.text ?? ""}
                      isStreaming={message.status === "streaming"}
                    />
                  </Surface>
                ))}
                {isLoading && !hasStreamingMessage && (
                  <Surface variant="secondary" className="p-3 mr-10 rounded-lg">
                    <Text className="text-xs font-medium mb-1 text-muted">AI</Text>
                    <View className="flex-row items-center gap-2">
                      <Spinner size="sm" />
                      <Text className="text-muted text-sm">Thinking...</Text>
                    </View>
                  </Surface>
                )}
              </View>
            )}
          </ScrollView>

          <Divider className="mb-3" />

          <View className="flex-row items-center gap-2">
            <View className="flex-1">
              <TextField>
                <TextField.Input
                  value={input}
                  onChangeText={setInput}
                  placeholder="Type a message..."
                  onSubmitEditing={onSubmit}
                  editable={!isLoading}
                  autoFocus
                />
              </TextField>
            </View>
            <Button
              isIconOnly
              variant={input.trim() && !isLoading ? "primary" : "secondary"}
              onPress={onSubmit}
              isDisabled={!input.trim() || isLoading}
              size="sm"
            >
              <Ionicons
                name="arrow-up"
                size={18}
                color={input.trim() && !isLoading ? foregroundColor : mutedColor}
              />
            </Button>
          </View>
        </View>
      </KeyboardAvoidingView>
    </Container>
  );
}
{{else}}
import { useRef, useEffect, useState } from "react";
import {
  View,
  Text,
  ScrollView,
  KeyboardAvoidingView,
  Platform,
} from "react-native";
import { useChat } from "@ai-sdk/react";
import { DefaultChatTransport } from "ai";
import { fetch as expoFetch } from "expo/fetch";
import { Ionicons } from "@expo/vector-icons";
import { Container } from "@/components/container";
import { Button, Divider, ErrorView, Spinner, Surface, TextField, useThemeColor } from "heroui-native";
import { env } from "@{{projectName}}/env/native";

const generateAPIUrl = (relativePath: string) => {
  const serverUrl = env.EXPO_PUBLIC_SERVER_URL;
  if (!serverUrl) {
    throw new Error(
      "EXPO_PUBLIC_SERVER_URL environment variable is not defined"
    );
  }
  const path = relativePath.startsWith("/") ? relativePath : \`/\${relativePath}\`;
  return serverUrl.concat(path);
};

export default function AIScreen() {
  const [input, setInput] = useState("");
  const { messages, error, sendMessage } = useChat({
    transport: new DefaultChatTransport({
      fetch: expoFetch as unknown as typeof globalThis.fetch,
      api: generateAPIUrl("/ai"),
    }),
    onError: (error) => console.error(error, "AI Chat Error"),
  });
  const scrollViewRef = useRef<ScrollView>(null);
  const foregroundColor = useThemeColor("foreground");
  const mutedColor = useThemeColor("muted");

  useEffect(() => {
    scrollViewRef.current?.scrollToEnd({ animated: true });
  }, [messages]);

  const onSubmit = () => {
    const value = input.trim();
    if (value) {
      sendMessage({ text: value });
      setInput("");
    }
  };

  if (error) {
    return (
      <Container>
        <View className="flex-1 justify-center items-center px-4">
          <Surface variant="secondary" className="p-4 rounded-lg">
            <ErrorView isInvalid>
              <Text className="text-danger text-center font-medium mb-1">
                {error.message}
              </Text>
              <Text className="text-muted text-center text-xs">
                Please check your connection and try again.
              </Text>
            </ErrorView>
          </Surface>
        </View>
      </Container>
    );
  }

  return (
    <Container>
      <KeyboardAvoidingView
        className="flex-1"
        behavior={Platform.OS === "ios" ? "padding" : "height"}
      >
        <View className="flex-1 px-4 py-4">
          <View className="py-4 mb-4">
            <Text className="text-2xl font-semibold text-foreground tracking-tight">AI Chat</Text>
            <Text className="text-muted text-sm mt-1">Chat with our AI assistant</Text>
          </View>

          <ScrollView
            ref={scrollViewRef}
            className="flex-1 mb-4"
            showsVerticalScrollIndicator={false}
          >
            {messages.length === 0 ? (
              <View className="flex-1 justify-center items-center py-10">
                <Ionicons name="chatbubble-ellipses-outline" size={32} color={mutedColor} />
                <Text className="text-muted text-sm mt-3">Ask me anything to get started</Text>
              </View>
            ) : (
              <View className="gap-2">
                {messages.map((message) => (
                  <Surface
                    key={message.id}
                    variant={message.role === "user" ? "tertiary" : "secondary"}
                    className={\`p-3 rounded-lg \${message.role === "user" ? "ml-10" : "mr-10"}\`}
                  >
                    <Text className="text-xs font-medium mb-1 text-muted">
                      {message.role === "user" ? "You" : "AI"}
                    </Text>
                    <View className="gap-1">
                      {message.parts.map((part, i) =>
                        part.type === "text" ? (
                          <Text
                            key={\`\${message.id}-\${i}\`}
                            className="text-foreground text-sm leading-relaxed"
                          >
                            {part.text}
                          </Text>
                        ) : (
                          <Text
                            key={\`\${message.id}-\${i}\`}
                            className="text-foreground text-sm leading-relaxed"
                          >
                            {JSON.stringify(part)}
                          </Text>
                        )
                      )}
                    </View>
                  </Surface>
                ))}
              </View>
            )}
          </ScrollView>

          <Divider className="mb-3" />

          <View className="flex-row items-center gap-2">
            <View className="flex-1">
              <TextField>
                <TextField.Input
                  value={input}
                  onChangeText={setInput}
                  placeholder="Type a message..."
                  onSubmitEditing={onSubmit}
                  autoFocus
                />
              </TextField>
            </View>
            <Button
              isIconOnly
              variant={input.trim() ? "primary" : "secondary"}
              onPress={onSubmit}
              isDisabled={!input.trim()}
              size="sm"
            >
              <Ionicons
                name="arrow-up"
                size={18}
                color={input.trim() ? foregroundColor : mutedColor}
              />
            </Button>
          </View>
        </View>
      </KeyboardAvoidingView>
    </Container>
  );
}
{{/if}}
`],
  ["examples/todo/native/unistyles/app/(drawer)/todos.tsx.hbs", `import { useState } from "react";
import {
  View,
  Text,
  TextInput,
  TouchableOpacity,
  ScrollView,
  ActivityIndicator,
  Alert,
} from "react-native";
import { Ionicons } from "@expo/vector-icons";
import { StyleSheet, useUnistyles } from "react-native-unistyles";

{{#if (eq backend "convex")}}
import { useMutation, useQuery } from "convex/react";
import { api } from "@{{projectName}}/backend/convex/_generated/api";
import type { Id } from "@{{projectName}}/backend/convex/_generated/dataModel";
{{else}}
import { useMutation, useQuery } from "@tanstack/react-query";
{{/if}}

import { Container } from "@/components/container";
{{#unless (eq backend "convex")}}
{{#if (eq api "orpc")}}
import { orpc } from "@/utils/orpc";
{{/if}}
{{#if (eq api "trpc")}}
import { trpc } from "@/utils/trpc";
{{/if}}
{{/unless}}

export default function TodosScreen() {
  const [newTodoText, setNewTodoText] = useState("");
  const { theme } = useUnistyles();

  {{#if (eq backend "convex")}}
  const todos = useQuery(api.todos.getAll);
  const createTodoMutation = useMutation(api.todos.create);
  const toggleTodoMutation = useMutation(api.todos.toggle);
  const deleteTodoMutation = useMutation(api.todos.deleteTodo);

  const handleAddTodo = async () => {
    const text = newTodoText.trim();
    if (!text) return;
    await createTodoMutation({ text });
    setNewTodoText("");
  };

  const handleToggleTodo = (id: Id<"todos">, currentCompleted: boolean) => {
    toggleTodoMutation({ id, completed: !currentCompleted });
  };

  const handleDeleteTodo = (id: Id<"todos">) => {
    Alert.alert("Delete Todo", "Are you sure you want to delete this todo?", [
      { text: "Cancel", style: "cancel" },
      {
        text: "Delete",
        style: "destructive",
        onPress: () => deleteTodoMutation({ id }),
      },
    ]);
  };
  {{else}}
    {{#if (eq api "orpc")}}
    const todos = useQuery(orpc.todo.getAll.queryOptions());
    const createMutation = useMutation(
      orpc.todo.create.mutationOptions({
        onSuccess: () => {
          todos.refetch();
          setNewTodoText("");
        },
      })
    );
    const toggleMutation = useMutation(
      orpc.todo.toggle.mutationOptions({
        onSuccess: () => { todos.refetch() },
      })
    );
    const deleteMutation = useMutation(
      orpc.todo.delete.mutationOptions({
        onSuccess: () => { todos.refetch() },
      })
    );
    {{/if}}
    {{#if (eq api "trpc")}}
    const todos = useQuery(trpc.todo.getAll.queryOptions());
    const createMutation = useMutation(
      trpc.todo.create.mutationOptions({
        onSuccess: () => {
          todos.refetch();
          setNewTodoText("");
        },
      })
    );
    const toggleMutation = useMutation(
      trpc.todo.toggle.mutationOptions({
        onSuccess: () => { todos.refetch() },
      })
    );
    const deleteMutation = useMutation(
      trpc.todo.delete.mutationOptions({
        onSuccess: () => { todos.refetch() },
      })
    );
    {{/if}}

  const handleAddTodo = () => {
    if (newTodoText.trim()) {
      createMutation.mutate({ text: newTodoText });
    }
  };

  const handleToggleTodo = (id: number, completed: boolean) => {
    toggleMutation.mutate({ id, completed: !completed });
  };

  const handleDeleteTodo = (id: number) => {
    Alert.alert("Delete Todo", "Are you sure you want to delete this todo?", [
      { text: "Cancel", style: "cancel" },
      {
        text: "Delete",
        style: "destructive",
        onPress: () => deleteMutation.mutate({ id }),
      },
    ]);
  };
  {{/if}}

  const isLoading = {{#if (eq backend "convex")}}!todos{{else}}todos.isLoading{{/if}};
  const isCreating = {{#if (eq backend "convex")}}false{{else}}createMutation.isPending{{/if}};
  const primaryButtonTextColor = theme.colors.background;

  return (
    <Container>
      <ScrollView style={styles.scrollView}>
        <View style={styles.headerContainer}>
          <Text style={styles.headerTitle}>Todo List</Text>
          <Text style={styles.headerSubtitle}>
            Manage your tasks efficiently
          </Text>

          <View style={styles.inputContainer}>
            <TextInput
              value={newTodoText}
              onChangeText={setNewTodoText}
              placeholder="Add a new task..."
              placeholderTextColor={theme.colors.border}
              editable={!isCreating}
              style={styles.textInput}
              onSubmitEditing={handleAddTodo}
              returnKeyType="done"
            />
            <TouchableOpacity
              onPress={handleAddTodo}
              disabled={isCreating || !newTodoText.trim()}
              style={[
                styles.addButton,
                (isCreating || !newTodoText.trim()) && styles.addButtonDisabled,
              ]}
            >
              {isCreating ? (
                <ActivityIndicator size="small" color={primaryButtonTextColor} />
              ) : (
                <Ionicons
                  name="add"
                  size={24}
                  color={primaryButtonTextColor}
                />
              )}
            </TouchableOpacity>
          </View>
        </View>

        {isLoading && (
          <View style={styles.loadingContainer}>
            <ActivityIndicator size="large" color={theme.colors.primary} />
            <Text style={styles.loadingText}>Loading todos...</Text>
          </View>
        )}

        {{#if (eq backend "convex")}}
          {todos && todos.length === 0 && !isLoading && (
            <Text style={styles.emptyText}>No todos yet. Add one!</Text>
          )}
          {todos?.map((todo) => (
            <View key={todo._id} style={styles.todoItem}>
              <TouchableOpacity
                onPress={() => handleToggleTodo(todo._id, todo.completed)}
                style={styles.todoContent}
              >
                <Ionicons
                  name={todo.completed ? "checkbox" : "square-outline"}
                  size={24}
                  color={todo.completed ? theme.colors.primary : theme.colors.typography}
                  style={styles.checkbox}
                />
                <Text
                  style={[
                    styles.todoText,
                    todo.completed && styles.todoTextCompleted,
                  ]}
                >
                  {todo.text}
                </Text>
              </TouchableOpacity>
              <TouchableOpacity onPress={() => handleDeleteTodo(todo._id)}>
                <Ionicons name="trash-outline" size={24} color={theme.colors.destructive} />
              </TouchableOpacity>
            </View>
          ))}
        {{else}}
          {todos.data && todos.data.length === 0 && !isLoading && (
             <Text style={styles.emptyText}>No todos yet. Add one!</Text>
          )}
          {todos.data?.map((todo: { id: number; text: string; completed: boolean }) => (
            <View key={todo.id} style={styles.todoItem}>
              <TouchableOpacity
                onPress={() => handleToggleTodo(todo.id, todo.completed)}
                style={styles.todoContent}
              >
                <Ionicons
                  name={todo.completed ? "checkbox" : "square-outline"}
                  size={24}
                  color={todo.completed ? theme.colors.primary : theme.colors.typography}
                  style={styles.checkbox}
                />
                <Text
                  style={[
                    styles.todoText,
                    todo.completed && styles.todoTextCompleted,
                  ]}
                >
                  {todo.text}
                </Text>
              </TouchableOpacity>
              <TouchableOpacity onPress={() => handleDeleteTodo(todo.id)}>
                <Ionicons name="trash-outline" size={24} color={theme.colors.destructive} />
              </TouchableOpacity>
            </View>
          ))}
        {{/if}}
      </ScrollView>
    </Container>
  );
}

const styles = StyleSheet.create((theme) => ({
  scrollView: {
    flex: 1,
  },
  headerContainer: {
    paddingHorizontal: theme.spacing.md,
    paddingVertical: theme.spacing.lg,
    borderBottomWidth: 1,
    borderBottomColor: theme.colors.border,
    backgroundColor: theme.colors.background,
  },
  headerTitle: {
    fontSize: 28,
    fontWeight: "bold",
    color: theme.colors.typography,
    marginBottom: theme.spacing.sm,
  },
  headerSubtitle: {
    fontSize: 16,
    color: theme.colors.typography,
    marginBottom: theme.spacing.md,
  },
  inputContainer: {
    flexDirection: "row",
    alignItems: "center",
    marginBottom: theme.spacing.md,
  },
  textInput: {
    flex: 1,
    borderWidth: 1,
    borderColor: theme.colors.border,
    borderRadius: 8,
    paddingHorizontal: theme.spacing.md,
    paddingVertical: theme.spacing.sm,
    color: theme.colors.typography,
    backgroundColor: theme.colors.background,
    marginRight: theme.spacing.sm,
    fontSize: 16,
  },
  addButton: {
    backgroundColor: theme.colors.primary,
    padding: theme.spacing.sm,
    borderRadius: 8,
    justifyContent: "center",
    alignItems: "center",
  },
  addButtonDisabled: {
    backgroundColor: theme.colors.border,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    padding: theme.spacing.lg,
  },
  loadingText: {
    marginTop: theme.spacing.sm,
    fontSize: 16,
    color: theme.colors.typography,
  },
  emptyText: {
    textAlign: "center",
    marginTop: theme.spacing.xl,
    fontSize: 16,
    color: theme.colors.typography,
  },
  todoItem: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    paddingVertical: theme.spacing.md,
    paddingHorizontal: theme.spacing.md,
    borderBottomWidth: 1,
    borderBottomColor: theme.colors.border,
    backgroundColor: theme.colors.background,
  },
  todoContent: {
    flexDirection: "row",
    alignItems: "center",
    flex: 1,
  },
  checkbox: {
    marginRight: theme.spacing.md,
  },
  todoText: {
    fontSize: 16,
    color: theme.colors.typography,
    flex: 1,
  },
  todoTextCompleted: {
    textDecorationLine: "line-through",
    color: theme.colors.border,
  },
}));
`],
  ["examples/todo/convex/packages/backend/convex/todos.ts.hbs", `import { query, mutation } from "./_generated/server";
import { v } from "convex/values";

export const getAll = query({
    handler: async (ctx) => {
        return await ctx.db.query("todos").collect();
    },
});

export const create = mutation({
    args: {
        text: v.string(),
    },
    handler: async (ctx, args) => {
        const newTodoId = await ctx.db.insert("todos", {
            text: args.text,
            completed: false,
        });
        return await ctx.db.get("todos", newTodoId);
    },
});

export const toggle = mutation({
    args: {
        id: v.id("todos"),
        completed: v.boolean(),
    },
    handler: async (ctx, args) => {
        await ctx.db.patch("todos", args.id, { completed: args.completed });
        return { success: true };
    },
});

export const deleteTodo = mutation({
    args: {
        id: v.id("todos"),
    },
    handler: async (ctx, args) => {
        await ctx.db.delete("todos", args.id);
        return { success: true };
    },
});`],
  ["examples/ai/convex/packages/backend/convex/chat.ts.hbs", `import {
  createThread,
  listUIMessages,
  saveMessage,
  syncStreams,
  vStreamArgs,
} from "@convex-dev/agent";
import { paginationOptsValidator } from "convex/server";
import { v } from "convex/values";

import { components, internal } from "./_generated/api";
import { internalAction, mutation, query } from "./_generated/server";
import { chatAgent } from "./agent";

export const createNewThread = mutation({
  args: {},
  handler: async (ctx) => {
    const threadId = await createThread(ctx, components.agent, {});
    return threadId;
  },
});

export const listMessages = query({
  args: {
    threadId: v.string(),
    paginationOpts: paginationOptsValidator,
    streamArgs: vStreamArgs,
  },
  handler: async (ctx, args) => {
    const paginated = await listUIMessages(ctx, components.agent, args);
    const streams = await syncStreams(ctx, components.agent, args);
    return { ...paginated, streams };
  },
});

export const sendMessage = mutation({
  args: {
    threadId: v.string(),
    prompt: v.string(),
  },
  handler: async (ctx, { threadId, prompt }) => {
    const { messageId } = await saveMessage(ctx, components.agent, {
      threadId,
      prompt,
    });
    await ctx.scheduler.runAfter(0, internal.chat.generateResponseAsync, {
      threadId,
      promptMessageId: messageId,
    });
    return messageId;
  },
});

export const generateResponseAsync = internalAction({
  args: {
    threadId: v.string(),
    promptMessageId: v.string(),
  },
  handler: async (ctx, { threadId, promptMessageId }) => {
    await chatAgent.streamText(
      ctx,
      { threadId },
      { promptMessageId },
      { saveStreamDeltas: true },
    );
  },
});
`],
  ["examples/ai/convex/packages/backend/convex/agent.ts.hbs", `import { Agent } from "@convex-dev/agent";
import { google } from "@ai-sdk/google";
import { components } from "./_generated/api";

export const chatAgent = new Agent(components.agent, {
  name: "Chat Agent",
  languageModel: google("gemini-2.5-flash"),
  instructions: "You are a helpful AI assistant. Be concise and friendly in your responses.",
});
`],
  ["examples/todo/native/uniwind/app/(drawer)/todos.tsx.hbs", `import { useState } from "react";
import { View, Text, ScrollView, Alert } from "react-native";
import { Ionicons } from "@expo/vector-icons";
{{#if (eq backend "convex")}}
import { useMutation, useQuery } from "convex/react";
import { api } from "@{{projectName}}/backend/convex/_generated/api";
import type { Id } from "@{{projectName}}/backend/convex/_generated/dataModel";
{{else}}
import { useMutation, useQuery } from "@tanstack/react-query";
{{/if}}
import { Container } from "@/components/container";
{{#unless (eq backend "convex")}}
  {{#if (eq api "orpc")}}
    import { orpc } from "@/utils/orpc";
  {{/if}}
  {{#if (eq api "trpc")}}
    import { trpc } from "@/utils/trpc";
  {{/if}}
{{/unless}}
import { Button, Checkbox, Chip, Spinner, Surface, TextField, useThemeColor } from "heroui-native";

export default function TodosScreen() {
  const [newTodoText, setNewTodoText] = useState("");
  {{#if (eq backend "convex")}}
    const todos = useQuery(api.todos.getAll);
    const createTodoMutation = useMutation(api.todos.create);
    const toggleTodoMutation = useMutation(api.todos.toggle);
    const deleteTodoMutation = useMutation(api.todos.deleteTodo);
  {{else}}
    {{#if (eq api "orpc")}}
      const todos = useQuery(orpc.todo.getAll.queryOptions());
      const createMutation = useMutation(orpc.todo.create.mutationOptions({
        onSuccess: () => {
          todos.refetch();
          setNewTodoText("");
        },
      }));
      const toggleMutation = useMutation(orpc.todo.toggle.mutationOptions({
        onSuccess: () => {
          todos.refetch();
        },
      }));
      const deleteMutation = useMutation(orpc.todo.delete.mutationOptions({
        onSuccess: () => {
          todos.refetch();
        },
      }));
    {{/if}}
    {{#if (eq api "trpc")}}
      const todos = useQuery(trpc.todo.getAll.queryOptions());
      const createMutation = useMutation(trpc.todo.create.mutationOptions({
        onSuccess: () => {
          todos.refetch();
          setNewTodoText("");
        },
      }));
      const toggleMutation = useMutation(trpc.todo.toggle.mutationOptions({
        onSuccess: () => {
          todos.refetch();
        },
      }));
      const deleteMutation = useMutation(trpc.todo.delete.mutationOptions({
        onSuccess: () => {
          todos.refetch();
        },
      }));
    {{/if}}
  {{/if}}

  const mutedColor = useThemeColor("muted");
  const dangerColor = useThemeColor("danger");
  const foregroundColor = useThemeColor("foreground");

  {{#if (eq backend "convex")}}
    const handleAddTodo = async () => {
      const text = newTodoText.trim();
      if (!text) return;
      await createTodoMutation({ text });
      setNewTodoText("");
    };

    const handleToggleTodo = (id: Id<"todos">, currentCompleted: boolean) => {
      toggleTodoMutation({ id, completed: !currentCompleted });
    };

    const handleDeleteTodo = (id: Id<"todos">) => {
      Alert.alert("Delete Todo", "Are you sure you want to delete this todo?", [
        { text: "Cancel", style: "cancel" },
        {
          text: "Delete",
          style: "destructive",
          onPress: () => deleteTodoMutation({ id }),
        },
      ]);
    };

    const isLoading = !todos;
    const completedCount = todos?.filter((t) => t.completed).length || 0;
    const totalCount = todos?.length || 0;
  {{else}}
    const handleAddTodo = () => {
      if (newTodoText.trim()) {
        createMutation.mutate({ text: newTodoText });
      }
    };

    const handleToggleTodo = (id: number, completed: boolean) => {
      toggleMutation.mutate({ id, completed: !completed });
    };

    const handleDeleteTodo = (id: number) => {
      Alert.alert("Delete Todo", "Are you sure you want to delete this todo?", [
        { text: "Cancel", style: "cancel" },
        {
          text: "Delete",
          style: "destructive",
          onPress: () => deleteMutation.mutate({ id }),
        },
      ]);
    };

    const isLoading = todos?.isLoading;
    const completedCount = todos?.data?.filter((t) => t.completed).length || 0;
    const totalCount = todos?.data?.length || 0;
  {{/if}}

  return (
    <Container>
      <ScrollView className="flex-1" contentContainerClassName="p-4">
        <View className="py-4 mb-4">
          <View className="flex-row items-center justify-between">
            <Text className="text-2xl font-semibold text-foreground tracking-tight">Tasks</Text>
            {totalCount > 0 && (
              <Chip variant="secondary" color="accent" size="sm">
                <Chip.Label>
                  {completedCount}/{totalCount}
                </Chip.Label>
              </Chip>
            )}
          </View>
        </View>

        <Surface variant="secondary" className="mb-4 p-3 rounded-lg">
          <View className="flex-row items-center gap-2">
            <View className="flex-1">
              <TextField>
                <TextField.Input
                  value={newTodoText}
                  onChangeText={setNewTodoText}
                  placeholder="Add a new task..."
                  {{#unless (eq backend "convex")}}
                    editable={!createMutation.isPending}
                  {{/unless}}
                  onSubmitEditing={handleAddTodo}
                  returnKeyType="done"
                />
              </TextField>
            </View>
            <Button
              isIconOnly
              {{#if (eq backend "convex")}}
                variant={!newTodoText.trim() ? "secondary" : "primary"}
                isDisabled={!newTodoText.trim()}
              {{else}}
                variant={createMutation.isPending || !newTodoText.trim() ? "secondary" : "primary"}
                isDisabled={createMutation.isPending || !newTodoText.trim()}
              {{/if}}
              onPress={handleAddTodo}
              size="sm"
            >
              {{#if (eq backend "convex")}}
                <Ionicons
                  name="add"
                  size={20}
                  color={newTodoText.trim() ? foregroundColor : mutedColor}
                />
              {{else}}
                {createMutation.isPending ? (
                  <Spinner size="sm" color="default" />
                ) : (
                  <Ionicons
                    name="add"
                    size={20}
                    color={(createMutation.isPending || !newTodoText.trim()) ? mutedColor : foregroundColor}
                  />
                )}
              {{/if}}
            </Button>
          </View>
        </Surface>

        {{#if (eq backend "convex")}}
          {isLoading && (
            <View className="items-center justify-center py-12">
              <Spinner size="lg" />
              <Text className="text-muted text-sm mt-3">Loading tasks...</Text>
            </View>
          )}

          {todos && todos.length === 0 && !isLoading && (
            <Surface variant="secondary" className="items-center justify-center py-10 rounded-lg">
              <Ionicons name="checkbox-outline" size={40} color={mutedColor} />
              <Text className="text-foreground font-medium mt-3">No tasks yet</Text>
              <Text className="text-muted text-xs mt-1">Add your first task to get started</Text>
            </Surface>
          )}

          {todos && todos.length > 0 && (
            <View className="gap-2">
              {todos.map((todo) => (
                <Surface key={todo._id} variant="secondary" className="p-3 rounded-lg">
                  <View className="flex-row items-center gap-3">
                    <Checkbox
                      isSelected={todo.completed}
                      onSelectedChange={() => handleToggleTodo(todo._id, todo.completed)}
                    />
                    <View className="flex-1">
                      <Text className={\`text-sm \${todo.completed ? "text-muted line-through" : "text-foreground"}\`}>
                        {todo.text}
                      </Text>
                    </View>
                    <Button
                      isIconOnly
                      variant="ghost"
                      onPress={() => handleDeleteTodo(todo._id)}
                      size="sm"
                    >
                      <Ionicons name="trash-outline" size={16} color={dangerColor} />
                    </Button>
                  </View>
                </Surface>
              ))}
            </View>
          )}
        {{else}}
          {isLoading && (
            <View className="items-center justify-center py-12">
              <Spinner size="lg" />
              <Text className="text-muted text-sm mt-3">Loading tasks...</Text>
            </View>
          )}

          {todos?.data && todos.data.length === 0 && !isLoading && (
            <Surface variant="secondary" className="items-center justify-center py-10 rounded-lg">
              <Ionicons name="checkbox-outline" size={40} color={mutedColor} />
              <Text className="text-foreground font-medium mt-3">No tasks yet</Text>
              <Text className="text-muted text-xs mt-1">Add your first task to get started</Text>
            </Surface>
          )}

          {todos?.data && todos.data.length > 0 && (
            <View className="gap-2">
              {todos.data.map((todo) => (
                <Surface key={todo.id} variant="secondary" className="p-3 rounded-lg">
                  <View className="flex-row items-center gap-3">
                    <Checkbox
                      isSelected={todo.completed}
                      onSelectedChange={() => handleToggleTodo(todo.id, todo.completed)}
                    />
                    <View className="flex-1">
                      <Text className={\`text-sm \${todo.completed ? "text-muted line-through" : "text-foreground"}\`}>
                        {todo.text}
                      </Text>
                    </View>
                    <Button
                      isIconOnly
                      variant="ghost"
                      onPress={() => handleDeleteTodo(todo.id)}
                      size="sm"
                    >
                      <Ionicons name="trash-outline" size={16} color={dangerColor} />
                    </Button>
                  </View>
                </Surface>
              ))}
            </View>
          )}
        {{/if}}
      </ScrollView>
    </Container>
  );
}`],
  ["examples/todo/web/solid/src/routes/todos.tsx.hbs", `import { createFileRoute } from "@tanstack/solid-router";
import { Loader2, Trash2 } from "lucide-solid";
import { createSignal, For, Show } from "solid-js";
import { orpc } from "@/utils/orpc";
import { useQuery, useMutation } from "@tanstack/solid-query";

export const Route = createFileRoute("/todos")({
  component: TodosRoute,
});

function TodosRoute() {
  const [newTodoText, setNewTodoText] = createSignal("");

  const todos = useQuery(() => orpc.todo.getAll.queryOptions());

  const createMutation = useMutation(() =>
    orpc.todo.create.mutationOptions({
      onSuccess: () => {
        todos.refetch();
        setNewTodoText("");
      },
    }),
  );

  const toggleMutation = useMutation(() =>
    orpc.todo.toggle.mutationOptions({
      onSuccess: () => { todos.refetch() },
    }),
  );

  const deleteMutation = useMutation(() =>
    orpc.todo.delete.mutationOptions({
      onSuccess: () => { todos.refetch() },
    }),
  );

  const handleAddTodo = (e: Event) => {
    e.preventDefault();
    if (newTodoText().trim()) {
      createMutation.mutate({ text: newTodoText() });
    }
  };

  const handleToggleTodo = (id: number, completed: boolean) => {
    toggleMutation.mutate({ id, completed: !completed });
  };

  const handleDeleteTodo = (id: number) => {
    deleteMutation.mutate({ id });
  };

  return (
    <div class="mx-auto w-full max-w-md py-10">
      <div class="rounded-lg border p-6 shadow-sm">
        <div class="mb-4">
          <h2 class="text-xl font-semibold">Todo List</h2>
          <p class="text-sm">Manage your tasks efficiently</p>
        </div>
        <div>
          <form
            onSubmit={handleAddTodo}
            class="mb-6 flex items-center space-x-2"
          >
            <input
              type="text"
              value={newTodoText()}
              onInput={(e) => setNewTodoText(e.currentTarget.value)}
              placeholder="Add a new task..."
              disabled={createMutation.isPending}
              class="w-full rounded-md border p-2 text-sm"
            />
            <button
              type="submit"
              disabled={createMutation.isPending || !newTodoText().trim()}
              class="rounded-md bg-blue-600 px-4 py-2 text-sm text-white disabled:opacity-50"
            >
              <Show when={createMutation.isPending} fallback="Add">
                <Loader2 class="h-4 w-4 animate-spin" />
              </Show>
            </button>
          </form>

          <Show when={todos.isLoading}>
            <div class="flex justify-center py-4">
              <Loader2 class="h-6 w-6 animate-spin" />
            </div>
          </Show>

          <Show when={!todos.isLoading && todos.data?.length === 0}>
            <p class="py-4 text-center">No todos yet. Add one above!</p>
          </Show>

          <Show when={!todos.isLoading}>
            <ul class="space-y-2">
              <For each={todos.data}>
                {(todo) => (
                  <li class="flex items-center justify-between rounded-md border p-2">
                    <div class="flex items-center space-x-2">
                      <input
                        type="checkbox"
                        checked={todo.completed}
                        onChange={() =>
                          handleToggleTodo(todo.id, todo.completed)
                        }
                        id={\`todo-\${todo.id}\`}
                        class="h-4 w-4"
                      />
                      <label
                        for={\`todo-\${todo.id}\`}
                        class={todo.completed ? "line-through" : ""}
                      >
                        {todo.text}
                      </label>
                    </div>
                    <button
                      type="button"
                      onClick={() => handleDeleteTodo(todo.id)}
                      aria-label="Delete todo"
                      class="ml-2 rounded-md p-1"
                    >
                      <Trash2 class="h-4 w-4" />
                    </button>
                  </li>
                )}
              </For>
            </ul>
          </Show>
        </div>
      </div>
    </div>
  );
}
`],
  ["examples/todo/web/nuxt/app/pages/todos.vue.hbs", `<script setup lang="ts">
import { ref } from 'vue'
{{#if (eq backend "convex")}}
import { api } from "@{{ projectName }}/backend/convex/_generated/api";
import type { Id } from "@{{ projectName }}/backend/convex/_generated/dataModel";
import { useConvexMutation, useConvexQuery } from "convex-vue";

const { data, error, isPending } = useConvexQuery(api.todos.getAll, {});

const newTodoText = ref("");
const { mutate: createTodo, isPending: isCreatePending } = useConvexMutation(api.todos.create);

const { mutate: toggleTodo } = useConvexMutation(api.todos.toggle);
const { mutate: deleteTodo, error: deleteError } = useConvexMutation(
  api.todos.deleteTodo,
);

function handleAddTodo() {
  const text = newTodoText.value.trim();
  if (!text) return;

  createTodo({ text });
  newTodoText.value = "";
}

function handleToggleTodo(id: Id<"todos">, completed: boolean) {
  toggleTodo({ id, completed: !completed });
}

function handleDeleteTodo(id: Id<"todos">) {
  deleteTodo({ id });
}
{{else}}
import { useQuery, useMutation, useQueryClient } from '@tanstack/vue-query'

const { $orpc } = useNuxtApp()

const newTodoText = ref('')
const queryClient = useQueryClient()

const todos = useQuery($orpc.todo.getAll.queryOptions())

const createMutation = useMutation($orpc.todo.create.mutationOptions({
  onSuccess: () => {
    queryClient.invalidateQueries()
    newTodoText.value = ''
  }
}))

const toggleMutation = useMutation($orpc.todo.toggle.mutationOptions({
  onSuccess: () => queryClient.invalidateQueries()
}))

const deleteMutation = useMutation($orpc.todo.delete.mutationOptions({
  onSuccess: () => queryClient.invalidateQueries()
}))

function handleAddTodo() {
  if (newTodoText.value.trim()) {
    createMutation.mutate({ text: newTodoText.value })
  }
}

function handleToggleTodo(id: number, completed: boolean) {
  toggleMutation.mutate({ id, completed: !completed })
}

function handleDeleteTodo(id: number) {
  deleteMutation.mutate({ id })
}
{{/if}}
</script>

<template>
  <UContainer class="py-8 max-w-md">
    <UCard>
      <template #header>
        <div>
          <div class="text-xl font-bold">Todo List</div>
          <div class="text-muted text-sm">Manage your tasks efficiently</div>
        </div>
      </template>

      <form @submit.prevent="handleAddTodo" class="mb-6 flex items-center gap-2">
        <UInput
          v-model="newTodoText"
          placeholder="Add a new task..."
          autocomplete="off"
          class="flex-1"
          {{#if (eq backend "convex")}}
          :disabled="isCreatePending"
          {{/if}}
        />
        <UButton
          type="submit"
          {{#if (eq backend "convex")}}
          :loading="isCreatePending"
          :disabled="!newTodoText.trim()"
          {{else}}
          :loading="createMutation.isPending.value"
          {{/if}}
        >
          Add
        </UButton>
      </form>

      {{#if (eq backend "convex")}}
      <!-- Loading State -->
      <div v-if="isPending" class="space-y-2">
        <USkeleton v-for="i in 3" :key="i" class="h-12 w-full" />
      </div>

      <!-- Error State -->
      <UAlert
        v-else-if="error || deleteError"
        color="error"
        icon="i-lucide-alert-circle"
        title="Error"
        :description="error?.message || deleteError?.message"
      />

      <!-- Empty State -->
      <UEmpty
        v-else-if="data?.length === 0"
        icon="i-lucide-clipboard-list"
        title="No todos yet"
        description="Add your first task above!"
      />

      <!-- Todo List -->
      <ul v-else-if="data" class="space-y-2">
        <li
          v-for="todo in data"
          :key="todo._id"
          class="flex items-center justify-between rounded-md border p-3"
        >
          <div class="flex items-center gap-3">
            <UCheckbox
              :model-value="todo.completed"
              @update:model-value="() => handleToggleTodo(todo._id, todo.completed)"
              :id="\`todo-\${todo._id}\`"
            />
            <label
              :for="\`todo-\${todo._id}\`"
              :class="{ 'line-through text-muted': todo.completed }"
              class="cursor-pointer"
            >
              \\{{ todo.text }}
            </label>
          </div>
          <UButton
            color="error"
            variant="ghost"
            size="sm"
            square
            @click="handleDeleteTodo(todo._id)"
            aria-label="Delete todo"
            icon="i-lucide-trash-2"
          />
        </li>
      </ul>
      {{else}}
      <!-- Loading State -->
      <div v-if="todos.status.value === 'pending'" class="space-y-2">
        <USkeleton v-for="i in 3" :key="i" class="h-12 w-full" />
      </div>

      <!-- Error State -->
      <UAlert
        v-else-if="todos.status.value === 'error'"
        color="error"
        icon="i-lucide-alert-circle"
        title="Failed to load todos"
        :description="todos.error.value?.message"
      />

      <!-- Empty State -->
      <UEmpty
        v-else-if="todos.data.value?.length === 0"
        icon="i-lucide-clipboard-list"
        title="No todos yet"
        description="Add your first task above!"
      />

      <!-- Todo List -->
      <ul v-else class="space-y-2">
        <li
          v-for="todo in todos.data.value"
          :key="todo.id"
          class="flex items-center justify-between rounded-md border p-3"
        >
          <div class="flex items-center gap-3">
            <UCheckbox
              :model-value="todo.completed"
              @update:model-value="() => handleToggleTodo(todo.id, todo.completed)"
              :id="\`todo-\${todo.id}\`"
            />
            <label
              :for="\`todo-\${todo.id}\`"
              :class="{ 'line-through text-muted': todo.completed }"
              class="cursor-pointer"
            >
              \\{{ todo.text }}
            </label>
          </div>
          <UButton
            color="error"
            variant="ghost"
            size="sm"
            square
            @click="handleDeleteTodo(todo.id)"
            aria-label="Delete todo"
            icon="i-lucide-trash-2"
          />
        </li>
      </ul>
      {{/if}}
    </UCard>
  </UContainer>
</template>
`],
  ["auth/better-auth/convex/native/bare/components/sign-up.tsx.hbs", `import { authClient } from "@/lib/auth-client";
import { useState } from "react";
import {
  ActivityIndicator,
  Text,
  TextInput,
  TouchableOpacity,
  View,
  StyleSheet,
} from "react-native";
import { useColorScheme } from "@/lib/use-color-scheme";
import { NAV_THEME } from "@/lib/constants";

function SignUp() {
  const { colorScheme } = useColorScheme();
  const theme = colorScheme === "dark" ? NAV_THEME.dark : NAV_THEME.light;
  const [name, setName] = useState("");
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  async function handleSignUp() {
    setIsLoading(true);
    setError(null);

    await authClient.signUp.email(
      {
        name,
        email,
        password,
      },
      {
        onError(error) {
          setError(error.error?.message || "Failed to sign up");
          setIsLoading(false);
        },
        onSuccess() {
          setName("");
          setEmail("");
          setPassword("");
        },
        onFinished() {
          setIsLoading(false);
        },
      }
    );
  }

  return (
    <View style={[styles.card, { backgroundColor: theme.card, borderColor: theme.border }]}>
      <Text style={[styles.title, { color: theme.text }]}>Create Account</Text>

      {error ? (
        <View style={[styles.errorContainer, { backgroundColor: theme.notification + "20" }]}>
          <Text style={[styles.errorText, { color: theme.notification }]}>{error}</Text>
        </View>
      ) : null}

      <TextInput
        style={[styles.input, { color: theme.text, borderColor: theme.border, backgroundColor: theme.background }]}
        placeholder="Name"
        placeholderTextColor={theme.text}
        value={name}
        onChangeText={setName}
      />

      <TextInput
        style={[styles.input, { color: theme.text, borderColor: theme.border, backgroundColor: theme.background }]}
        placeholder="Email"
        placeholderTextColor={theme.text}
        value={email}
        onChangeText={setEmail}
        keyboardType="email-address"
        autoCapitalize="none"
      />

      <TextInput
        style={[styles.input, { color: theme.text, borderColor: theme.border, backgroundColor: theme.background }]}
        placeholder="Password"
        placeholderTextColor={theme.text}
        value={password}
        onChangeText={setPassword}
        secureTextEntry
      />

      <TouchableOpacity
        onPress={handleSignUp}
        disabled={isLoading}
        style={[styles.button, { backgroundColor: theme.primary, opacity: isLoading ? 0.5 : 1 }]}
      >
        {isLoading ? (
          <ActivityIndicator size="small" color="#ffffff" />
        ) : (
          <Text style={styles.buttonText}>Sign Up</Text>
        )}
      </TouchableOpacity>
    </View>
  );
}

const styles = StyleSheet.create({
  card: {
    marginTop: 16,
    padding: 16,
    borderWidth: 1,
  },
  title: {
    fontSize: 18,
    fontWeight: "bold",
    marginBottom: 12,
  },
  errorContainer: {
    marginBottom: 12,
    padding: 8,
  },
  errorText: {
    fontSize: 14,
  },
  input: {
    borderWidth: 1,
    padding: 12,
    fontSize: 16,
    marginBottom: 12,
  },
  button: {
    padding: 12,
    alignItems: "center",
    justifyContent: "center",
  },
  buttonText: {
    color: "#ffffff",
    fontSize: 16,
  },
});

export { SignUp };

`],
  ["auth/better-auth/convex/native/bare/components/sign-in.tsx.hbs", `import { authClient } from "@/lib/auth-client";
import { useState } from "react";
import {
  ActivityIndicator,
  Text,
  TextInput,
  TouchableOpacity,
  View,
  StyleSheet,
} from "react-native";
import { useColorScheme } from "@/lib/use-color-scheme";
import { NAV_THEME } from "@/lib/constants";

function SignIn() {
  const { colorScheme } = useColorScheme();
  const theme = colorScheme === "dark" ? NAV_THEME.dark : NAV_THEME.light;
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  async function handleLogin() {
    setIsLoading(true);
    setError(null);

    await authClient.signIn.email(
      {
        email,
        password,
      },
      {
        onError(error) {
          setError(error.error?.message || "Failed to sign in");
          setIsLoading(false);
        },
        onSuccess() {
          setEmail("");
          setPassword("");
        },
        onFinished() {
          setIsLoading(false);
        },
      }
    );
  }

  return (
    <View style={[styles.card, { backgroundColor: theme.card, borderColor: theme.border }]}>
      <Text style={[styles.title, { color: theme.text }]}>Sign In</Text>

      {error ? (
        <View style={[styles.errorContainer, { backgroundColor: theme.notification + "20" }]}>
          <Text style={[styles.errorText, { color: theme.notification }]}>{error}</Text>
        </View>
      ) : null}

      <TextInput
        style={[styles.input, { color: theme.text, borderColor: theme.border, backgroundColor: theme.background }]}
        placeholder="Email"
        placeholderTextColor={theme.text}
        value={email}
        onChangeText={setEmail}
        keyboardType="email-address"
        autoCapitalize="none"
      />

      <TextInput
        style={[styles.input, { color: theme.text, borderColor: theme.border, backgroundColor: theme.background }]}
        placeholder="Password"
        placeholderTextColor={theme.text}
        value={password}
        onChangeText={setPassword}
        secureTextEntry
      />

      <TouchableOpacity
        onPress={handleLogin}
        disabled={isLoading}
        style={[styles.button, { backgroundColor: theme.primary, opacity: isLoading ? 0.5 : 1 }]}
      >
        {isLoading ? (
          <ActivityIndicator size="small" color="#ffffff" />
        ) : (
          <Text style={styles.buttonText}>Sign In</Text>
        )}
      </TouchableOpacity>
    </View>
  );
}

const styles = StyleSheet.create({
  card: {
    marginTop: 16,
    padding: 16,
    borderWidth: 1,
  },
  title: {
    fontSize: 18,
    fontWeight: "bold",
    marginBottom: 12,
  },
  errorContainer: {
    marginBottom: 12,
    padding: 8,
  },
  errorText: {
    fontSize: 14,
  },
  input: {
    borderWidth: 1,
    padding: 12,
    fontSize: 16,
    marginBottom: 12,
  },
  button: {
    padding: 12,
    alignItems: "center",
    justifyContent: "center",
  },
  buttonText: {
    color: "#ffffff",
    fontSize: 16,
  },
});

export { SignIn };

`],
  ["auth/better-auth/convex/native/unistyles/components/sign-up.tsx.hbs", `import { authClient } from "@/lib/auth-client";
import { useState } from "react";
import {
  ActivityIndicator,
  Text,
  TextInput,
  TouchableOpacity,
  View,
} from "react-native";
import { StyleSheet } from "react-native-unistyles";

export function SignUp() {
  const [name, setName] = useState("");
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const handleSignUp = async () => {
    setIsLoading(true);
    setError(null);

    await authClient.signUp.email(
      {
        name,
        email,
        password,
      },
      {
        onError: (error) => {
          setError(error.error?.message || "Failed to sign up");
          setIsLoading(false);
        },
        onSuccess: () => {
          setName("");
          setEmail("");
          setPassword("");
        },
        onFinished: () => {
          setIsLoading(false);
        },
      },
    );
  };

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Create Account</Text>

      {error && (
        <View style={styles.errorContainer}>
          <Text style={styles.errorText}>{error}</Text>
        </View>
      )}

      <TextInput
        style={styles.input}
        placeholder="Name"
        value={name}
        onChangeText={setName}
      />

      <TextInput
        style={styles.input}
        placeholder="Email"
        value={email}
        onChangeText={setEmail}
        keyboardType="email-address"
        autoCapitalize="none"
      />

      <TextInput
        style={styles.inputLast}
        placeholder="Password"
        value={password}
        onChangeText={setPassword}
        secureTextEntry
      />

      <TouchableOpacity
        onPress={handleSignUp}
        disabled={isLoading}
        style={styles.button}
      >
        {isLoading ? (
          <ActivityIndicator size="small" color="#fff" />
        ) : (
          <Text style={styles.buttonText}>Sign Up</Text>
        )}
      </TouchableOpacity>
    </View>
  );
}

const styles = StyleSheet.create((theme) => ({
  container: {
    marginTop: 24,
    padding: 16,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: theme.colors.border,
  },
  title: {
    fontSize: 18,
    fontWeight: "600",
    color: theme.colors.typography,
    marginBottom: 16,
  },
  errorContainer: {
    marginBottom: 16,
    padding: 12,
    borderRadius: 6,
  },
  errorText: {
    color: theme.colors.destructive,
    fontSize: 14,
  },
  input: {
    marginBottom: 12,
    padding: 16,
    borderRadius: 6,
    color: theme.colors.typography,
    borderWidth: 1,
    borderColor: theme.colors.border,
  },
  inputLast: {
    marginBottom: 16,
    padding: 16,
    borderRadius: 6,
    color: theme.colors.typography,
    borderWidth: 1,
    borderColor: theme.colors.border,
  },
  button: {
    backgroundColor: theme.colors.primary,
    padding: 16,
    borderRadius: 6,
    flexDirection: "row",
    justifyContent: "center",
    alignItems: "center",
  },
  buttonText: {
    fontWeight: "500",
  },
}));
`],
  ["auth/better-auth/convex/native/unistyles/components/sign-in.tsx.hbs", `import { authClient } from "@/lib/auth-client";
import { useState } from "react";
import {
  ActivityIndicator,
  Text,
  TextInput,
  TouchableOpacity,
  View,
} from "react-native";
import { StyleSheet } from "react-native-unistyles";

export function SignIn() {
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const handleLogin = async () => {
    setIsLoading(true);
    setError(null);

    await authClient.signIn.email(
      {
        email,
        password,
      },
      {
        onError: (error) => {
          setError(error.error?.message || "Failed to sign in");
          setIsLoading(false);
        },
        onSuccess: () => {
          setEmail("");
          setPassword("");
        },
        onFinished: () => {
          setIsLoading(false);
        },
      },
    );
  };

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Sign In</Text>

      {error && (
        <View style={styles.errorContainer}>
          <Text style={styles.errorText}>{error}</Text>
        </View>
      )}

      <TextInput
        style={styles.input}
        placeholder="Email"
        value={email}
        onChangeText={setEmail}
        keyboardType="email-address"
        autoCapitalize="none"
      />

      <TextInput
        style={styles.input}
        placeholder="Password"
        value={password}
        onChangeText={setPassword}
        secureTextEntry
      />

      <TouchableOpacity
        onPress={handleLogin}
        disabled={isLoading}
        style={styles.button}
      >
        {isLoading ? (
          <ActivityIndicator size="small" color="#fff" />
        ) : (
          <Text style={styles.buttonText}>Sign In</Text>
        )}
      </TouchableOpacity>
    </View>
  );
}

const styles = StyleSheet.create((theme) => ({
  container: {
    marginTop: 24,
    padding: 16,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: theme.colors.border,
  },
  title: {
    fontSize: 18,
    fontWeight: "600",
    color: theme.colors.typography,
    marginBottom: 16,
  },
  errorContainer: {
    marginBottom: 16,
    padding: 12,
    borderRadius: 6,
  },
  errorText: {
    color: theme.colors.destructive,
    fontSize: 14,
  },
  input: {
    marginBottom: 12,
    padding: 16,
    borderRadius: 6,
    color: theme.colors.typography,
    borderWidth: 1,
    borderColor: theme.colors.border,
  },
  button: {
    backgroundColor: theme.colors.primary,
    padding: 16,
    borderRadius: 6,
    flexDirection: "row",
    justifyContent: "center",
    alignItems: "center",
  },
  buttonText: {
    fontWeight: "500",
  },
}));
`],
  ["auth/clerk/convex/native/base/components/sign-out-button.tsx.hbs", `import { useClerk } from "@clerk/clerk-expo";
import { useRouter } from "expo-router";
import { Text, TouchableOpacity } from "react-native";

export const SignOutButton = () => {
  // Use \`useClerk()\` to access the \`signOut()\` function
  const { signOut } = useClerk();
  const router = useRouter();

  const handleSignOut = async () => {
    try {
      await signOut();
      // Redirect to your desired page
      router.replace("/");
    } catch (err) {
      // See https://clerk.com/docs/custom-flows/error-handling
      // for more info on error handling
      console.error(JSON.stringify(err, null, 2));
    }
  };

  return (
    <TouchableOpacity onPress={handleSignOut}>
      <Text>Sign out</Text>
    </TouchableOpacity>
  );
};
`],
  ["examples/todo/native/bare/app/(drawer)/todos.tsx.hbs", `import { useState } from "react";
import {
  View,
  Text,
  TextInput,
  ScrollView,
  ActivityIndicator,
  Alert,
  TouchableOpacity,
  StyleSheet,
} from "react-native";
import { Ionicons } from "@expo/vector-icons";
{{#if (eq backend "convex")}}
import { useMutation, useQuery } from "convex/react";
import { api } from "@{{projectName}}/backend/convex/_generated/api";
import type { Id } from "@{{projectName}}/backend/convex/_generated/dataModel";
{{else}}
import { useMutation, useQuery } from "@tanstack/react-query";
{{/if}}
import { Container } from "@/components/container";
import { useColorScheme } from "@/lib/use-color-scheme";
import { NAV_THEME } from "@/lib/constants";
{{#unless (eq backend "convex")}}
  {{#if (eq api "orpc")}}
import { orpc } from "@/utils/orpc";
  {{/if}}
  {{#if (eq api "trpc")}}
import { trpc } from "@/utils/trpc";
  {{/if}}
{{/unless}}

export default function TodosScreen() {
  const { colorScheme } = useColorScheme();
  const theme = colorScheme === "dark" ? NAV_THEME.dark : NAV_THEME.light;
  const [newTodoText, setNewTodoText] = useState("");

  {{#if (eq backend "convex")}}
  const todos = useQuery(api.todos.getAll);
  const createTodoMutation = useMutation(api.todos.create);
  const toggleTodoMutation = useMutation(api.todos.toggle);
  const deleteTodoMutation = useMutation(api.todos.deleteTodo);

  async function handleAddTodo() {
    const text = newTodoText.trim();
    if (!text) return;
    await createTodoMutation({ text });
    setNewTodoText("");
  }

  function handleToggleTodo(id: Id<"todos">, currentCompleted: boolean) {
    toggleTodoMutation({ id, completed: !currentCompleted });
  }

  function handleDeleteTodo(id: Id<"todos">) {
    Alert.alert("Delete Todo", "Are you sure you want to delete this todo?", [
      { text: "Cancel", style: "cancel" },
      {
        text: "Delete",
        style: "destructive",
        onPress: () => deleteTodoMutation({ id }),
      },
    ]);
  }

  const isLoading = !todos;
  const completedCount = todos?.filter((t) => t.completed).length || 0;
  const totalCount = todos?.length || 0;
  {{else}}
    {{#if (eq api "orpc")}}
  const todos = useQuery(orpc.todo.getAll.queryOptions());
  const createMutation = useMutation(
    orpc.todo.create.mutationOptions({
      onSuccess: () => {
        todos.refetch();
        setNewTodoText("");
      },
    })
  );
  const toggleMutation = useMutation(
    orpc.todo.toggle.mutationOptions({
      onSuccess: () => {
        todos.refetch();
      },
    })
  );
  const deleteMutation = useMutation(
    orpc.todo.delete.mutationOptions({
      onSuccess: () => {
        todos.refetch();
      },
    })
  );
    {{/if}}
    {{#if (eq api "trpc")}}
  const todos = useQuery(trpc.todo.getAll.queryOptions());
  const createMutation = useMutation(
    trpc.todo.create.mutationOptions({
      onSuccess: () => {
        todos.refetch();
        setNewTodoText("");
      },
    })
  );
  const toggleMutation = useMutation(
    trpc.todo.toggle.mutationOptions({
      onSuccess: () => {
        todos.refetch();
      },
    })
  );
  const deleteMutation = useMutation(
    trpc.todo.delete.mutationOptions({
      onSuccess: () => {
        todos.refetch();
      },
    })
  );
    {{/if}}

  function handleAddTodo() {
    if (newTodoText.trim()) {
      createMutation.mutate({ text: newTodoText });
    }
  }

  function handleToggleTodo(id: number, completed: boolean) {
    toggleMutation.mutate({ id, completed: !completed });
  }

  function handleDeleteTodo(id: number) {
    Alert.alert("Delete Todo", "Are you sure you want to delete this todo?", [
      { text: "Cancel", style: "cancel" },
      {
        text: "Delete",
        style: "destructive",
        onPress: () => deleteMutation.mutate({ id }),
      },
    ]);
  }

  const isLoading = todos?.isLoading;
  const completedCount = todos?.data?.filter((t) => t.completed).length || 0;
  const totalCount = todos?.data?.length || 0;
  {{/if}}

  return (
    <Container>
      <ScrollView
        style={styles.scrollView}
        contentContainerStyle={styles.contentContainer}
      >
        <View style={styles.header}>
          <View style={styles.headerRow}>
            <Text style={[styles.title, { color: theme.text }]}>
              Todo List
            </Text>
            {totalCount > 0 && (
              <View style={[styles.badge, { backgroundColor: theme.primary }]}>
                <Text style={styles.badgeText}>
                  {completedCount}/{totalCount}
                </Text>
              </View>
            )}
          </View>
        </View>
        <View
          style={[
            styles.inputCard,
            { backgroundColor: theme.card, borderColor: theme.border },
          ]}
        >
          <View style={styles.inputRow}>
            <View style={styles.inputContainer}>
              <TextInput
                value={newTodoText}
                onChangeText={setNewTodoText}
                placeholder="Add a new task..."
                placeholderTextColor={theme.text}
                {{#unless (eq backend "convex")}}
                editable={!createMutation.isPending}
                {{/unless}}
                onSubmitEditing={handleAddTodo}
                returnKeyType="done"
                style={[
                  styles.input,
                  {
                    color: theme.text,
                    borderColor: theme.border,
                    backgroundColor: theme.background,
                  },
                ]}
              />
            </View>
            <TouchableOpacity
              onPress={handleAddTodo}
              {{#if (eq backend "convex")}}
              disabled={!newTodoText.trim()}
              style={[
                styles.addButton,
                {
                  backgroundColor: !newTodoText.trim()
                    ? theme.border
                    : theme.primary,
                  opacity: !newTodoText.trim() ? 0.5 : 1,
                },
              ]}
            >
              <Ionicons
                name="add"
                size={24}
                color={newTodoText.trim() ? "#ffffff" : theme.text}
              />
              {{else}}
              disabled={createMutation.isPending || !newTodoText.trim()}
              style={[
                styles.addButton,
                {
                  backgroundColor:
                    createMutation.isPending || !newTodoText.trim()
                      ? theme.border
                      : theme.primary,
                  opacity:
                    createMutation.isPending || !newTodoText.trim() ? 0.5 : 1,
                },
              ]}
            >
              {createMutation.isPending ? (
                <ActivityIndicator size="small" color="#ffffff" />
              ) : (
                <Ionicons name="add" size={24} color="#ffffff" />
              )}
              {{/if}}
            </TouchableOpacity>
          </View>
        </View>

        {{#if (eq backend "convex")}}
        {isLoading && (
          <View style={styles.centerContainer}>
            <ActivityIndicator size="large" color={theme.primary} />
            <Text
              style={[styles.loadingText, { color: theme.text, opacity: 0.7 }]}
            >
              Loading todos...
            </Text>
          </View>
        )}

        {todos && todos.length === 0 && !isLoading && (
          <View
            style={[
              styles.emptyCard,
              { backgroundColor: theme.card, borderColor: theme.border },
            ]}
          >
            <Ionicons
              name="checkbox-outline"
              size={64}
              color={theme.text}
              style=\\{{ opacity: 0.5, marginBottom: 16 }}
            />
            <Text style={[styles.emptyTitle, { color: theme.text }]}>
              No todos yet
            </Text>
            <Text
              style={[styles.emptyText, { color: theme.text, opacity: 0.7 }]}
            >
              Add your first task to get started!
            </Text>
          </View>
        )}

        {todos && todos.length > 0 && (
          <View style={styles.todosList}>
            {todos.map((todo) => (
              <View
                key={todo._id}
                style={[
                  styles.todoCard,
                  { backgroundColor: theme.card, borderColor: theme.border },
                ]}
              >
                <View style={styles.todoRow}>
                  <TouchableOpacity
                    onPress={() => handleToggleTodo(todo._id, todo.completed)}
                    style={[styles.checkbox, { borderColor: theme.border }]}
                  >
                    {todo.completed && (
                      <Ionicons
                        name="checkmark"
                        size={16}
                        color={theme.primary}
                      />
                    )}
                  </TouchableOpacity>
                  <View style={styles.todoTextContainer}>
                    <Text
                      style={[
                        styles.todoText,
                        { color: theme.text },
                        todo.completed && {
                          textDecorationLine: "line-through",
                          opacity: 0.5,
                        },
                      ]}
                    >
                      {todo.text}
                    </Text>
                  </View>
                  <TouchableOpacity
                    onPress={() => handleDeleteTodo(todo._id)}
                    style={styles.deleteButton}
                  >
                    <Ionicons
                      name="trash-outline"
                      size={24}
                      color={theme.notification}
                    />
                  </TouchableOpacity>
                </View>
              </View>
            ))}
          </View>
        )}
        {{else}}
        {isLoading && (
          <View style={styles.centerContainer}>
            <ActivityIndicator size="large" color={theme.primary} />
            <Text
              style={[styles.loadingText, { color: theme.text, opacity: 0.7 }]}
            >
              Loading todos...
            </Text>
          </View>
        )}

        {todos?.data && todos.data.length === 0 && !isLoading && (
          <View
            style={[
              styles.emptyCard,
              { backgroundColor: theme.card, borderColor: theme.border },
            ]}
          >
            <Ionicons
              name="checkbox-outline"
              size={64}
              color={theme.text}
              style=\\{{ opacity: 0.5, marginBottom: 16 }}
            />
            <Text style={[styles.emptyTitle, { color: theme.text }]}>
              No todos yet
            </Text>
            <Text
              style={[styles.emptyText, { color: theme.text, opacity: 0.7 }]}
            >
              Add your first task to get started!
            </Text>
          </View>
        )}

        {todos?.data && todos.data.length > 0 && (
          <View style={styles.todosList}>
            {todos.data.map((todo) => (
              <View
                key={todo.id}
                style={[
                  styles.todoCard,
                  { backgroundColor: theme.card, borderColor: theme.border },
                ]}
              >
                <View style={styles.todoRow}>
                  <TouchableOpacity
                    onPress={() => handleToggleTodo(todo.id, todo.completed)}
                    style={[styles.checkbox, { borderColor: theme.border }]}
                  >
                    {todo.completed && (
                      <Ionicons
                        name="checkmark"
                        size={16}
                        color={theme.primary}
                      />
                    )}
                  </TouchableOpacity>
                  <View style={styles.todoTextContainer}>
                    <Text
                      style={[
                        styles.todoText,
                        { color: theme.text },
                        todo.completed && {
                          textDecorationLine: "line-through",
                          opacity: 0.5,
                        },
                      ]}
                    >
                      {todo.text}
                    </Text>
                  </View>
                  <TouchableOpacity
                    onPress={() => handleDeleteTodo(todo.id)}
                    style={styles.deleteButton}
                  >
                    <Ionicons
                      name="trash-outline"
                      size={24}
                      color={theme.notification}
                    />
                  </TouchableOpacity>
                </View>
              </View>
            ))}
          </View>
        )}
        {{/if}}
      </ScrollView>
    </Container>
  );
}

const styles = StyleSheet.create({
  scrollView: {
    flex: 1,
  },
  contentContainer: {
    padding: 16,
  },
  header: {
    marginBottom: 16,
  },
  headerRow: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
  },
  title: {
    fontSize: 24,
    fontWeight: "bold",
  },
  badge: {
    paddingHorizontal: 8,
    paddingVertical: 4,
  },
  badgeText: {
    color: "#ffffff",
    fontSize: 12,
  },
  inputCard: {
    borderWidth: 1,
    padding: 12,
    marginBottom: 16,
  },
  inputRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
  },
  inputContainer: {
    flex: 1,
  },
  input: {
    borderWidth: 1,
    padding: 12,
    fontSize: 16,
  },
  addButton: {
    padding: 12,
    justifyContent: "center",
    alignItems: "center",
  },
  centerContainer: {
    alignItems: "center",
    justifyContent: "center",
    paddingVertical: 32,
  },
  loadingText: {
    marginTop: 16,
    fontSize: 14,
  },
  emptyCard: {
    borderWidth: 1,
    padding: 32,
    alignItems: "center",
    justifyContent: "center",
  },
  emptyTitle: {
    fontSize: 16,
    fontWeight: "bold",
    marginBottom: 8,
  },
  emptyText: {
    fontSize: 14,
    textAlign: "center",
  },
  todosList: {
    gap: 8,
  },
  todoCard: {
    borderWidth: 1,
    padding: 12,
  },
  todoRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 12,
  },
  checkbox: {
    width: 20,
    height: 20,
    borderWidth: 2,
    justifyContent: "center",
    alignItems: "center",
  },
  todoTextContainer: {
    flex: 1,
  },
  todoText: {
    fontSize: 16,
  },
  deleteButton: {
    padding: 8,
  },
});`],
  ["auth/better-auth/convex/native/base/lib/auth-client.ts.hbs", `import { createAuthClient } from "better-auth/react";
import { convexClient } from "@convex-dev/better-auth/client/plugins";
import { expoClient } from "@better-auth/expo/client";
import Constants from "expo-constants";
import * as SecureStore from "expo-secure-store";
import { env } from "@{{projectName}}/env/native";

export const authClient = createAuthClient({
	baseURL: env.EXPO_PUBLIC_CONVEX_SITE_URL,
	plugins: [
		expoClient({
			scheme: Constants.expoConfig?.scheme as string,
			storagePrefix: Constants.expoConfig?.scheme as string,
			storage: SecureStore,
		}),
		convexClient(),
	],
});
`],
  ["job-queue/trigger-dev/server/base/src/trigger/tasks.ts.hbs", `import { task, logger, schedules, AbortTaskRunError } from "@trigger.dev/sdk/v3";

/**
 * Example email sending task
 * Trigger from your backend with: await sendEmailTask.trigger({ to, subject, body })
 * @see https://trigger.dev/docs
 */
export const sendEmailTask = task({
  id: "send-email",
  // Retry configuration
  retry: {
    maxAttempts: 3,
    minTimeoutInMs: 1000,
    maxTimeoutInMs: 10000,
    factor: 2,
  },
  run: async (payload: {
    to: string;
    subject: string;
    body: string;
    templateId?: string;
  }) => {
    const { to, subject, body, templateId } = payload;

    logger.info("Processing email task", { to, subject });

    // TODO: Implement your email sending logic here
    // Example with a hypothetical email service:
    // await emailService.send({ to, subject, body, templateId });

    // Simulate email sending
    await new Promise((resolve) => setTimeout(resolve, 1000));

    logger.info("Email sent successfully", { to });

    return {
      sent: true,
      to,
      timestamp: new Date().toISOString(),
    };
  },
});

/**
 * Example notification task
 * Supports different notification types: push, in-app, sms
 */
export const sendNotificationTask = task({
  id: "send-notification",
  retry: {
    maxAttempts: 3,
    minTimeoutInMs: 500,
    maxTimeoutInMs: 5000,
    factor: 2,
  },
  run: async (payload: {
    userId: string;
    type: "push" | "in-app" | "sms";
    title: string;
    message: string;
    data?: Record<string, unknown>;
  }) => {
    const { userId, type, title, message, data } = payload;

    logger.info("Processing notification", { userId, type, title });

    // TODO: Implement your notification logic here
    // switch (type) {
    //   case "push":
    //     await pushService.send(userId, { title, message, data });
    //     break;
    //   case "in-app":
    //     await inAppNotificationService.create(userId, { title, message, data });
    //     break;
    //   case "sms":
    //     await smsService.send(userId, message);
    //     break;
    // }

    // Simulate notification processing
    await new Promise((resolve) => setTimeout(resolve, 500));

    logger.info("Notification sent", { userId, type });

    return {
      sent: true,
      type,
      userId,
      timestamp: new Date().toISOString(),
    };
  },
});

/**
 * Example data processing task with error handling
 * Demonstrates AbortTaskRunError for permanent failures
 */
export const processDataTask = task({
  id: "process-data",
  // Machine resources (uncomment for larger workloads)
  // machine: { preset: "medium-1x" }, // 1 vCPU, 2 GB RAM
  maxDuration: 300, // 5 minutes timeout
  retry: {
    maxAttempts: 2,
  },
  run: async (payload: {
    dataId: string;
    operation: "transform" | "aggregate" | "export";
  }) => {
    const { dataId, operation } = payload;

    logger.info("Processing data", { dataId, operation });

    // Example of handling permanent errors
    if (!dataId) {
      // This is a known permanent error, don't retry
      throw new AbortTaskRunError("Data ID is required");
    }

    // TODO: Implement your data processing logic here
    // const data = await database.getData(dataId);
    // switch (operation) {
    //   case "transform":
    //     return await transformData(data);
    //   case "aggregate":
    //     return await aggregateData(data);
    //   case "export":
    //     return await exportData(data);
    // }

    // Simulate data processing
    await new Promise((resolve) => setTimeout(resolve, 2000));

    logger.info("Data processing complete", { dataId, operation });

    return {
      processed: true,
      dataId,
      operation,
      timestamp: new Date().toISOString(),
    };
  },
});

/**
 * Example scheduled task (cron job)
 * Runs every hour - customize the cron pattern as needed
 * @see https://trigger.dev/docs/tasks/scheduled
 */
export const hourlyCleanupTask = schedules.task({
  id: "hourly-cleanup",
  // Every hour at minute 0
  cron: "0 * * * *",
  run: async (payload) => {
    logger.info("Running scheduled cleanup", {
      scheduledTime: payload.timestamp,
      timezone: payload.timezone,
    });

    // TODO: Implement your cleanup logic here
    // await database.deleteExpiredSessions();
    // await cache.clearStale();

    // Simulate cleanup
    await new Promise((resolve) => setTimeout(resolve, 1000));

    logger.info("Scheduled cleanup complete", {
      nextRun: payload.upcoming[0],
    });

    return {
      cleaned: true,
      timestamp: new Date().toISOString(),
    };
  },
});

/**
 * Example daily report task with timezone
 * Runs at 9 AM in the specified timezone
 */
export const dailyReportTask = schedules.task({
  id: "daily-report",
  cron: {
    // 9 AM every day
    pattern: "0 9 * * *",
    // Change to your preferred timezone
    // See: https://cloud.trigger.dev/timezones
    timezone: "UTC",
  },
  run: async (payload) => {
    logger.info("Generating daily report", {
      scheduledTime: payload.timestamp,
      timezone: payload.timezone,
    });

    // TODO: Implement your report generation logic here
    // const report = await generateReport();
    // await sendReportEmail(report);

    // Simulate report generation
    await new Promise((resolve) => setTimeout(resolve, 3000));

    logger.info("Daily report sent", {
      nextRun: payload.upcoming[0],
    });

    return {
      reportGenerated: true,
      timestamp: new Date().toISOString(),
    };
  },
});
`],
  ["job-queue/trigger-dev/server/base/src/lib/trigger.ts.hbs", `import { tasks, configure } from "@trigger.dev/sdk/v3";
import type {
  sendEmailTask,
  sendNotificationTask,
  processDataTask,
} from "../trigger/tasks";

/**
 * Configure Trigger.dev SDK
 * This is called automatically when importing this module
 * @see https://trigger.dev/docs
 */
configure({
  secretKey: process.env.TRIGGER_SECRET_KEY,
});

/**
 * Type-safe task triggering utilities
 * Use these functions to trigger background tasks from your backend
 */

// Type definitions for task payloads
export interface EmailPayload {
  to: string;
  subject: string;
  body: string;
  templateId?: string;
}

export interface NotificationPayload {
  userId: string;
  type: "push" | "in-app" | "sms";
  title: string;
  message: string;
  data?: Record<string, unknown>;
}

export interface DataProcessingPayload {
  dataId: string;
  operation: "transform" | "aggregate" | "export";
}

/**
 * Trigger an email task
 * @example
 * const handle = await triggerEmail({
 *   to: "user@example.com",
 *   subject: "Welcome!",
 *   body: "Thanks for signing up."
 * });
 */
export async function triggerEmail(
  payload: EmailPayload,
  options?: { delay?: string | number }
) {
  return tasks.trigger<typeof sendEmailTask>("send-email", payload, options);
}

/**
 * Trigger a notification task
 * @example
 * const handle = await triggerNotification({
 *   userId: "user_123",
 *   type: "push",
 *   title: "New message",
 *   message: "You have a new message!"
 * });
 */
export async function triggerNotification(
  payload: NotificationPayload,
  options?: { delay?: string | number }
) {
  return tasks.trigger<typeof sendNotificationTask>(
    "send-notification",
    payload,
    options
  );
}

/**
 * Trigger a data processing task
 * @example
 * const handle = await triggerDataProcessing({
 *   dataId: "data_456",
 *   operation: "transform"
 * });
 */
export async function triggerDataProcessing(
  payload: DataProcessingPayload,
  options?: { delay?: string | number }
) {
  return tasks.trigger<typeof processDataTask>(
    "process-data",
    payload,
    options
  );
}

/**
 * Trigger multiple emails in batch
 * @example
 * const handles = await triggerEmailBatch([
 *   { to: "user1@example.com", subject: "Hello", body: "Hi!" },
 *   { to: "user2@example.com", subject: "Hello", body: "Hi!" }
 * ]);
 */
export async function triggerEmailBatch(payloads: EmailPayload[]) {
  return tasks.batchTrigger<typeof sendEmailTask>(
    "send-email",
    payloads.map((payload) => ({ payload }))
  );
}

/**
 * Get the status of a task run
 * @example
 * const run = await getTaskRun("run_123");
 * console.log(run.status); // "COMPLETED" | "FAILED" | "RUNNING" etc.
 */
export { tasks };
`],
  ["auth/better-auth/convex/native/uniwind/components/sign-up.tsx.hbs", `import { authClient } from "@/lib/auth-client";
import { useState } from "react";
import { Text, View } from "react-native";
import { Button, ErrorView, Spinner, Surface, TextField } from "heroui-native";

export function SignUp() {
  const [name, setName] = useState("");
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const handleSignUp = async () => {
    setIsLoading(true);
    setError(null);

    await authClient.signUp.email(
      {
        name,
        email,
        password,
      },
      {
        onError: (error) => {
          setError(error.error?.message || "Failed to sign up");
          setIsLoading(false);
        },
        onSuccess: () => {
          setName("");
          setEmail("");
          setPassword("");
        },
        onFinished: () => {
          setIsLoading(false);
        },
      },
    );
  };

  return (
    <Surface variant="secondary" className="p-4 rounded-lg">
      <Text className="text-foreground font-medium mb-4">Create Account</Text>

      <ErrorView isInvalid={!!error} className="mb-3">
        {error}
      </ErrorView>

      <View className="gap-3">
        <TextField>
          <TextField.Label>Name</TextField.Label>
          <TextField.Input value={name} onChangeText={setName} placeholder="John Doe" />
        </TextField>

        <TextField>
          <TextField.Label>Email</TextField.Label>
          <TextField.Input
            value={email}
            onChangeText={setEmail}
            placeholder="email@example.com"
            keyboardType="email-address"
            autoCapitalize="none"
          />
        </TextField>

        <TextField>
          <TextField.Label>Password</TextField.Label>
          <TextField.Input
            value={password}
            onChangeText={setPassword}
            placeholder=""
            secureTextEntry
          />
        </TextField>

        <Button onPress={handleSignUp} isDisabled={isLoading} className="mt-1">
          {isLoading ? (
            <Spinner size="sm" color="default" />
          ) : (
            <Button.Label>Create Account</Button.Label>
          )}
        </Button>
      </View>
    </Surface>
  );
}
`],
  ["auth/better-auth/convex/native/uniwind/components/sign-in.tsx.hbs", `import { authClient } from "@/lib/auth-client";
import { useState } from "react";
import { Text, View } from "react-native";
import { Button, ErrorView, Spinner, Surface, TextField } from "heroui-native";

export function SignIn() {
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const handleLogin = async () => {
    setIsLoading(true);
    setError(null);

    await authClient.signIn.email(
      {
        email,
        password,
      },
      {
        onError: (error) => {
          setError(error.error?.message || "Failed to sign in");
          setIsLoading(false);
        },
        onSuccess: () => {
          setEmail("");
          setPassword("");
        },
        onFinished: () => {
          setIsLoading(false);
        },
      },
    );
  };

  return (
    <Surface variant="secondary" className="p-4 rounded-lg">
      <Text className="text-foreground font-medium mb-4">Sign In</Text>

      <ErrorView isInvalid={!!error} className="mb-3">
        {error}
      </ErrorView>

      <View className="gap-3">
        <TextField>
          <TextField.Label>Email</TextField.Label>
          <TextField.Input
            value={email}
            onChangeText={setEmail}
            placeholder="email@example.com"
            keyboardType="email-address"
            autoCapitalize="none"
          />
        </TextField>

        <TextField>
          <TextField.Label>Password</TextField.Label>
          <TextField.Input
            value={password}
            onChangeText={setPassword}
            placeholder=""
            secureTextEntry
          />
        </TextField>

        <Button onPress={handleLogin} isDisabled={isLoading} className="mt-1">
          {isLoading ? <Spinner size="sm" color="default" /> : <Button.Label>Sign In</Button.Label>}
        </Button>
      </View>
    </Surface>
  );
}
`],
  ["auth/better-auth/native/uniwind/app/(drawer)/index.tsx.hbs", `import { Text, View, Pressable } from "react-native";
import { Container } from "@/components/container";
import { authClient } from "@/lib/auth-client";
import { Ionicons } from "@expo/vector-icons";
import { Card, Chip, useThemeColor } from "heroui-native";
import { SignIn } from "@/components/sign-in";
import { SignUp } from "@/components/sign-up";
{{#if (eq api "orpc")}}
import { useQuery } from "@tanstack/react-query";
import { queryClient, orpc } from "@/utils/orpc";
{{/if}}
{{#if (eq api "trpc")}}
import { useQuery } from "@tanstack/react-query";
import { queryClient, trpc } from "@/utils/trpc";
{{/if}}

export default function Home() {
{{#if (eq api "orpc")}}
const healthCheck = useQuery(orpc.healthCheck.queryOptions());
const privateData = useQuery(orpc.privateData.queryOptions());
const isConnected = healthCheck?.data === "OK";
const isLoading = healthCheck?.isLoading;
{{/if}}
{{#if (eq api "trpc")}}
const healthCheck = useQuery(trpc.healthCheck.queryOptions());
const privateData = useQuery(trpc.privateData.queryOptions());
const isConnected = healthCheck?.data === "OK";
const isLoading = healthCheck?.isLoading;
{{/if}}
const { data: session } = authClient.useSession();

const mutedColor = useThemeColor("muted");
const successColor = useThemeColor("success");
const dangerColor = useThemeColor("danger");
const foregroundColor = useThemeColor("foreground");

return (
<Container className="p-6">
  <View className="py-4 mb-6">
    <Text className="text-4xl font-bold text-foreground mb-2">
      BETTER T STACK
    </Text>
  </View>

  {session?.user ? (
  <Card variant="secondary" className="mb-6 p-4">
    <Text className="text-foreground text-base mb-2">
      Welcome, <Text className="font-medium">{session.user.name}</Text>
    </Text>
    <Text className="text-muted text-sm mb-4">
      {session.user.email}
    </Text>
    <Pressable className="bg-danger py-3 px-4 rounded-lg self-start active:opacity-70" onPress={()=> {
      authClient.signOut();
      {{#if (eq api "orpc")}}
      queryClient.invalidateQueries();
      {{/if}}
      {{#if (eq api "trpc")}}
      queryClient.invalidateQueries();
      {{/if}}
      }}
      >
      <Text className="text-foreground font-medium">Sign Out</Text>
    </Pressable>
  </Card>
  ) : null}

  {{#unless (eq api "none")}}
  <Card variant="secondary" className="p-6">
    <View className="flex-row items-center justify-between mb-4">
      <Card.Title>System Status</Card.Title>
      <Chip variant="secondary" color={isConnected ? "success" : "danger" } size="sm">
        <Chip.Label>{isConnected ? "LIVE" : "OFFLINE"}</Chip.Label>
      </Chip>
    </View>

    <Card className="p-4">
      <View className="flex-row items-center">
        <View className={\`w-3 h-3 rounded-full mr-3 \${isConnected ? "bg-success" : "bg-muted" }\`} />
        <View className="flex-1">
          <Text className="text-foreground font-medium mb-1">
            {{#if (eq api "orpc")}}ORPC{{else}}TRPC{{/if}} Backend
          </Text>
          <Card.Description>
            {isLoading
            ? "Checking connection..."
            : isConnected
            ? "Connected to API"
            : "API Disconnected"}
          </Card.Description>
        </View>
        {isLoading && (
        <Ionicons name="hourglass-outline" size={20} color={mutedColor} />
        )}
        {!isLoading && isConnected && (
        <Ionicons name="checkmark-circle" size={20} color={successColor} />
        )}
        {!isLoading && !isConnected && (
        <Ionicons name="close-circle" size={20} color={dangerColor} />
        )}
      </View>
    </Card>
  </Card>

  <Card variant="secondary" className="mt-6 p-4">
    <Card.Title className="mb-3">Private Data</Card.Title>
    {privateData && (
    <Card.Description>
      {privateData.data?.message}
    </Card.Description>
    )}
  </Card>
  {{/unless}}

  {!session?.user && (
  <>
    <SignIn />
    <SignUp />
  </>
  )}
</Container>
);
}`],
  ["auth/better-auth/web/solid/src/routes/login.tsx.hbs", `import SignInForm from "@/components/sign-in-form";
import SignUpForm from "@/components/sign-up-form";
import { createFileRoute } from "@tanstack/solid-router";
import { createSignal, Match, Switch } from "solid-js";

export const Route = createFileRoute("/login")({
  component: RouteComponent,
});

function RouteComponent() {
  const [showSignIn, setShowSignIn] = createSignal(false);

  return (
    <Switch>
      <Match when={showSignIn()}>
        <SignInForm onSwitchToSignUp={() => setShowSignIn(false)} />
      </Match>
      <Match when={!showSignIn()}>
        <SignUpForm onSwitchToSignIn={() => setShowSignIn(true)} />
      </Match>
    </Switch>
  );
}
`],
  ["auth/better-auth/web/solid/src/routes/dashboard.tsx.hbs", `import { authClient } from "@/lib/auth-client";
{{#if (eq api "orpc")}}
import { orpc } from "@/utils/orpc";
import { useQuery } from "@tanstack/solid-query";
{{/if}}
import { createFileRoute, redirect } from "@tanstack/solid-router";

export const Route = createFileRoute("/dashboard")({
	component: RouteComponent,
	beforeLoad: async () => {
		const session = await authClient.getSession();
		if (!session.data) {
			redirect({
				to: "/login",
				throw: true,
			});
		}
		{{#if (eq payments "polar")}}
		const { data: customerState } = await authClient.customer.state();
		return { session, customerState };
		{{else}}
		return { session };
		{{/if}}
	},
});

function RouteComponent() {
	const context = Route.useRouteContext();

	const session = context().session;
	{{#if (eq payments "polar")}}
	const customerState = context().customerState;
	{{/if}}

	{{#if (eq api "orpc")}}
	const privateData = useQuery(() => orpc.privateData.queryOptions());
	{{/if}}

	{{#if (eq payments "polar")}}
	const hasProSubscription = () =>
		customerState?.activeSubscriptions?.length! > 0;
	{{/if}}

	return (
		<div>
			<h1>Dashboard</h1>
			<p>Welcome {session.data?.user.name}</p>
			{{#if (eq api "orpc")}}
			<p>API: {privateData.data?.message}</p>
			{{/if}}
			{{#if (eq payments "polar")}}
			<p>Plan: {hasProSubscription() ? "Pro" : "Free"}</p>
			{hasProSubscription() ? (
				<button onClick={async () => await authClient.customer.portal()}>
					Manage Subscription
				</button>
			) : (
				<button
					onClick={async () => await authClient.checkout({ slug: "pro" })}
				>
					Upgrade to Pro
				</button>
			)}
			{{/if}}
		</div>
	);
}
`],
  ["auth/better-auth/web/solid/src/components/user-menu.tsx.hbs", `import { authClient } from "@/lib/auth-client";
import { useNavigate, Link } from "@tanstack/solid-router";
import { createSignal, Show } from "solid-js";

export default function UserMenu() {
  const navigate = useNavigate();
  const session = authClient.useSession();
  const [isMenuOpen, setIsMenuOpen] = createSignal(false);

  return (
    <div class="relative inline-block text-left">
      <Show when={session().isPending}>
        <div class="h-9 w-24 animate-pulse rounded" />
      </Show>

      <Show when={!session().isPending && !session().data}>
        <Link to="/login" class="inline-block border rounded px-4  text-sm">
          Sign In
        </Link>
      </Show>

      <Show when={!session().isPending && session().data}>
        <button
          type="button"
          class="inline-block border rounded px-4  text-sm"
          onClick={() => setIsMenuOpen(!isMenuOpen())}
        >
          {session().data?.user.name}
        </button>

        <Show when={isMenuOpen()}>
          <div class="absolute right-0 mt-2 w-56 rounded p-1 shadow-sm">
            <div class="px-4  text-sm">{session().data?.user.email}</div>
            <button
              type="button"
              class="mt-1 w-full border rounded px-4  text-center text-sm"
              onClick={() => {
                setIsMenuOpen(false);
                authClient.signOut({
                  fetchOptions: {
                    onSuccess: () => {
                      navigate({ to: "/" });
                    },
                  },
                });
              }}
            >
              Sign Out
            </button>
          </div>
        </Show>
      </Show>
    </div>
  );
}
`],
  ["auth/better-auth/web/solid/src/components/sign-in-form.tsx.hbs", `import { authClient } from "@/lib/auth-client";
import { createForm } from "@tanstack/solid-form";
import { useNavigate } from "@tanstack/solid-router";
import z from "zod";
import { For } from "solid-js";

export default function SignInForm({ onSwitchToSignUp }: { onSwitchToSignUp: () => void }) {
  const navigate = useNavigate({
    from: "/",
  });

  const form = createForm(() => ({
    defaultValues: {
      email: "",
      password: "",
    },
    onSubmit: async ({ value }) => {
      await authClient.signIn.email(
        {
          email: value.email,
          password: value.password,
        },
        {
          onSuccess: () => {
            navigate({
              to: "/dashboard",
            });
            console.log("Sign in successful");
          },
          onError: (error) => {
            console.error(error.error.message);
          },
        },
      );
    },
    validators: {
      onSubmit: z.object({
        email: z.email("Invalid email address"),
        password: z.string().min(8, "Password must be at least 8 characters"),
      }),
    },
  }));

  return (
    <div class="mx-auto w-full mt-10 max-w-md p-6">
      <h1 class="mb-6 text-center text-3xl font-bold">Welcome Back</h1>

      <form
        onSubmit={(e) => {
          e.preventDefault();
          e.stopPropagation();
          form.handleSubmit();
        }}
        class="space-y-4"
      >
        <div>
          <form.Field name="email">
            {(field) => (
              <div class="space-y-2">
                <label for={field().name}>Email</label>
                <input
                  id={field().name}
                  name={field().name}
                  type="email"
                  value={field().state.value}
                  onBlur={field().handleBlur}
                  onInput={(e) => field().handleChange(e.currentTarget.value)}
                  class="w-full rounded border p-2"
                />
                <For each={field().state.meta.errors}>
                  {(error) => <p class="text-sm text-red-600">{error?.message}</p>}
                </For>
              </div>
            )}
          </form.Field>
        </div>

        <div>
          <form.Field name="password">
            {(field) => (
              <div class="space-y-2">
                <label for={field().name}>Password</label>
                <input
                  id={field().name}
                  name={field().name}
                  type="password"
                  value={field().state.value}
                  onBlur={field().handleBlur}
                  onInput={(e) => field().handleChange(e.currentTarget.value)}
                  class="w-full rounded border p-2"
                />
                <For each={field().state.meta.errors}>
                  {(error) => <p class="text-sm text-red-600">{error?.message}</p>}
                </For>
              </div>
            )}
          </form.Field>
        </div>

        <form.Subscribe>
          {(state) => (
            <button
              type="submit"
              class="w-full rounded bg-indigo-600 p-2 text-white hover:bg-indigo-700 disabled:opacity-50"
              disabled={!state().canSubmit || state().isSubmitting}
            >
              {state().isSubmitting ? "Submitting..." : "Sign In"}
            </button>
          )}
        </form.Subscribe>
      </form>

      <div class="mt-4 text-center">
        <button
          type="button"
          onClick={onSwitchToSignUp}
          class="text-sm text-indigo-600 hover:text-indigo-800 hover:underline"
        >
          Need an account? Sign Up
        </button>
      </div>
    </div>
  );
}
`],
  ["auth/better-auth/web/solid/src/components/sign-up-form.tsx.hbs", `import { authClient } from "@/lib/auth-client";
import { createForm } from "@tanstack/solid-form";
import { useNavigate } from "@tanstack/solid-router";
import z from "zod";
import { For } from "solid-js";

export default function SignUpForm({ onSwitchToSignIn }: { onSwitchToSignIn: () => void }) {
  const navigate = useNavigate({
    from: "/",
  });

  const form = createForm(() => ({
    defaultValues: {
      email: "",
      password: "",
      name: "",
    },
    onSubmit: async ({ value }) => {
      await authClient.signUp.email(
        {
          email: value.email,
          password: value.password,
          name: value.name,
        },
        {
          onSuccess: () => {
            navigate({
              to: "/dashboard",
            });
            console.log("Sign up successful");
          },
          onError: (error) => {
            console.error(error.error.message);
          },
        },
      );
    },
    validators: {
      onSubmit: z.object({
        name: z.string().min(2, "Name must be at least 2 characters"),
        email: z.email("Invalid email address"),
        password: z.string().min(8, "Password must be at least 8 characters"),
      }),
    },
  }));

  return (
    <div class="mx-auto w-full mt-10 max-w-md p-6">
      <h1 class="mb-6 text-center text-3xl font-bold">Create Account</h1>

      <form
        onSubmit={(e) => {
          e.preventDefault();
          e.stopPropagation();
          form.handleSubmit();
        }}
        class="space-y-4"
      >
        <div>
          <form.Field name="name">
            {(field) => (
              <div class="space-y-2">
                <label for={field().name}>Name</label>
                <input
                  id={field().name}
                  name={field().name}
                  value={field().state.value}
                  onBlur={field().handleBlur}
                  onInput={(e) => field().handleChange(e.currentTarget.value)}
                  class="w-full rounded border p-2"
                />
                <For each={field().state.meta.errors}>
                  {(error) => <p class="text-sm text-red-600">{error?.message}</p>}
                </For>
              </div>
            )}
          </form.Field>
        </div>

        <div>
          <form.Field name="email">
            {(field) => (
              <div class="space-y-2">
                <label for={field().name}>Email</label>
                <input
                  id={field().name}
                  name={field().name}
                  type="email"
                  value={field().state.value}
                  onBlur={field().handleBlur}
                  onInput={(e) => field().handleChange(e.currentTarget.value)}
                  class="w-full rounded border p-2"
                />
                <For each={field().state.meta.errors}>
                  {(error) => <p class="text-sm text-red-600">{error?.message}</p>}
                </For>
              </div>
            )}
          </form.Field>
        </div>

        <div>
          <form.Field name="password">
            {(field) => (
              <div class="space-y-2">
                <label for={field().name}>Password</label>
                <input
                  id={field().name}
                  name={field().name}
                  type="password"
                  value={field().state.value}
                  onBlur={field().handleBlur}
                  onInput={(e) => field().handleChange(e.currentTarget.value)}
                  class="w-full rounded border p-2"
                />
                <For each={field().state.meta.errors}>
                  {(error) => <p class="text-sm text-red-600">{error?.message}</p>}
                </For>
              </div>
            )}
          </form.Field>
        </div>

        <form.Subscribe>
          {(state) => (
            <button
              type="submit"
              class="w-full rounded bg-indigo-600 p-2 text-white hover:bg-indigo-700 disabled:opacity-50"
              disabled={!state().canSubmit || state().isSubmitting}
            >
              {state().isSubmitting ? "Submitting..." : "Sign Up"}
            </button>
          )}
        </form.Subscribe>
      </form>

      <div class="mt-4 text-center">
        <button
          type="button"
          onClick={onSwitchToSignIn}
          class="text-sm text-indigo-600 hover:text-indigo-800 hover:underline"
        >
          Already have an account? Sign In
        </button>
      </div>
    </div>
  );
}
`],
  ["auth/better-auth/web/solid/src/lib/auth-client.ts.hbs", `import { createAuthClient } from "better-auth/solid";
{{#if (eq payments "polar")}}
import { polarClient } from "@polar-sh/better-auth";
{{/if}}
import { env } from "@{{projectName}}/env/web";

export const authClient = createAuthClient({
	baseURL: env.VITE_SERVER_URL,
{{#if (eq payments "polar")}}
	plugins: [polarClient()]
{{/if}}
});
`],
  ["auth/better-auth/web/nuxt/app/plugins/auth-client.ts.hbs", `import { createAuthClient } from "better-auth/vue";
{{#if (eq payments "polar")}}
import { polarClient } from "@polar-sh/better-auth";
{{/if}}

export default defineNuxtPlugin(() => {
  const config = useRuntimeConfig();

  const authClient = createAuthClient({
    baseURL: config.public.serverUrl,
    {{#if (eq payments "polar")}}
    plugins: [polarClient()],
    {{/if}}
  });

  return {
    provide: {
      authClient: authClient,
    },
  };
});
`],
  ["auth/better-auth/native/unistyles/app/(drawer)/index.tsx.hbs", `import { authClient } from "@/lib/auth-client";
import { ScrollView, Text, TouchableOpacity, View } from "react-native";
import { StyleSheet } from "react-native-unistyles";

import { Container } from "@/components/container";
import { SignIn } from "@/components/sign-in";
import { SignUp } from "@/components/sign-up";
{{#if (eq api "orpc")}}
import { useQuery } from "@tanstack/react-query";
import { queryClient, orpc } from "@/utils/orpc";
{{/if}}
{{#if (eq api "trpc")}}
import { useQuery } from "@tanstack/react-query";
import { queryClient, trpc } from "@/utils/trpc";
{{/if}}

export default function Home() {
    {{#if (eq api "orpc")}}
    const healthCheck = useQuery(orpc.healthCheck.queryOptions());
    const privateData = useQuery(orpc.privateData.queryOptions());
    {{/if}}
    {{#if (eq api "trpc")}}
    const healthCheck = useQuery(trpc.healthCheck.queryOptions());
    const privateData = useQuery(trpc.privateData.queryOptions());
    {{/if}}
  const { data: session } = authClient.useSession();

  return (
    <Container>
      <ScrollView>
        <View style={styles.pageContainer}>
          <Text style={styles.headerTitle}>BETTER T STACK</Text>
          {session?.user ? (
            <View style={styles.sessionInfoCard}>
              <View style={styles.sessionUserRow}>
                <Text style={styles.welcomeText}>
                  Welcome,{" "}
                  <Text style={styles.userNameText}>{session.user.name}</Text>
                </Text>
              </View>
              <Text style={styles.emailText}>{session.user.email}</Text>

              <TouchableOpacity
                style={styles.signOutButton}
                onPress={() => {
                  authClient.signOut();
                  {{#if (eq api "orpc")}}
                  queryClient.invalidateQueries();
                  {{/if}}
                  {{#if (eq api "trpc")}}
                  queryClient.invalidateQueries();
                  {{/if}}
                }}
              >
                <Text style={styles.signOutButtonText}>Sign Out</Text>
              </TouchableOpacity>
            </View>
          ) : null}
          {{#unless (eq api "none")}}
          <View style={styles.apiStatusCard}>
            <Text style={styles.cardTitle}>API Status</Text>
            <View style={styles.apiStatusRow}>
              <View
                style={[
                  styles.statusIndicatorDot,
                  healthCheck.data
                    ? styles.statusIndicatorGreen
                    : styles.statusIndicatorRed,
                ]}
              />
              <Text style={styles.mutedText}>
                {healthCheck.isLoading
                  ? "Checking..."
                  : healthCheck.data
                    ? "Connected to API"
                    : "API Disconnected"}
              </Text>
            </View>
          </View>
          <View style={styles.privateDataCard}>
            <Text style={styles.cardTitle}>Private Data</Text>
            {privateData && (
              <View>
                <Text style={styles.mutedText}>
                  {privateData.data?.message}
                </Text>
              </View>
            )}
          </View>
          {{/unless}}
          {!session?.user && (
            <>
              <SignIn />
              <SignUp />
            </>
          )}
        </View>
      </ScrollView>
    </Container>
  );
}

const styles = StyleSheet.create((theme) => ({
  pageContainer: {
    paddingHorizontal: 8,
  },
  headerTitle: {
    color: theme?.colors?.typography,
    fontSize: 30,
    fontWeight: "bold",
    marginBottom: 16,
  },
  sessionInfoCard: {
    marginBottom: 24,
    padding: 16,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: theme?.colors?.border,
  },
  sessionUserRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    marginBottom: 8,
  },
  welcomeText: {
    color: theme?.colors?.typography,
    fontSize: 16,
  },
  userNameText: {
    fontWeight: "500",
    color: theme?.colors?.typography,
  },
  emailText: {
    color: theme?.colors?.typography,
    fontSize: 14,
    marginBottom: 16,
  },
  signOutButton: {
    backgroundColor: theme?.colors?.destructive,
    paddingVertical: 8,
    paddingHorizontal: 16,
    borderRadius: 6,
    alignSelf: "flex-start",
  },
  signOutButtonText: {
    fontWeight: "500",
  },
  apiStatusCard: {
    marginBottom: 24,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: theme?.colors?.border,
    padding: 16,
  },
  cardTitle: {
    marginBottom: 12,
    fontWeight: "500",
    color: theme?.colors?.typography,
  },
  apiStatusRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
  },
  statusIndicatorDot: {
    height: 12,
    width: 12,
    borderRadius: 9999,
  },
  statusIndicatorGreen: {
    backgroundColor: theme.colors.success,
  },
  statusIndicatorRed: {
    backgroundColor: theme.colors.destructive,
  },
  mutedText: {
    color: theme?.colors?.typography,
  },
  privateDataCard: {
    marginBottom: 24,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: theme?.colors?.border,
    padding: 16,
  },
}));
`],
  ["auth/better-auth/web/nuxt/app/middleware/auth.ts.hbs", `export default defineNuxtRouteMiddleware(async (to, from) => {
  if (import.meta.server) return;

  const { $authClient } = useNuxtApp();
  const session = $authClient.useSession();

  if (session.value.isPending) {
    return;
  }

  if (!session.value.data) {
    return navigateTo("/login");
  }
});
`],
  ["auth/better-auth/web/nuxt/app/components/SignInForm.vue.hbs", `<script setup lang="ts">
import * as z from 'zod'
import type { FormSubmitEvent, AuthFormField } from '@nuxt/ui'

const { $authClient } = useNuxtApp()

const emit = defineEmits(['switchToSignUp'])

const toast = useToast()
const loading = ref(false)

const fields: AuthFormField[] = [
  {
    name: 'email',
    type: 'email',
    label: 'Email',
    placeholder: 'Enter your email',
    required: true
  },
  {
    name: 'password',
    type: 'password',
    label: 'Password',
    placeholder: 'Enter your password',
    required: true
  }
]

const schema = z.object({
  email: z.email('Invalid email address'),
  password: z.string().min(8, 'Password must be at least 8 characters'),
})

type Schema = z.output<typeof schema>

async function onSubmit(event: FormSubmitEvent<Schema>) {
  loading.value = true
  try {
    await $authClient.signIn.email(
      {
        email: event.data.email,
        password: event.data.password,
      },
      {
        onSuccess: () => {
          toast.add({ title: 'Sign in successful' })
          navigateTo('/dashboard', { replace: true })
        },
        onError: (error) => {
          toast.add({ title: 'Sign in failed', description: error.error.message })
        },
      },
    )
  } catch (error: any) {
    toast.add({ title: 'An unexpected error occurred', description: error.message || 'Please try again.' })
  } finally {
    loading.value = false
  }
}
</script>

<template>
  <div class="flex flex-col items-center justify-center gap-4 p-4">
    <UPageCard class="w-full max-w-md">
      <UAuthForm
        :schema="schema"
        :fields="fields"
        title="Welcome Back"
        icon="i-lucide-log-in"
        :submit="{ label: 'Sign In', loading }"
        @submit="onSubmit"
      >
        <template #description>
          Need an account?
          <ULink class="text-primary font-medium" @click="$emit('switchToSignUp')">
            Sign Up
          </ULink>
        </template>
      </UAuthForm>
    </UPageCard>
  </div>
</template>
`],
  ["auth/better-auth/web/nuxt/app/components/UserMenu.vue.hbs", `<script setup lang="ts">

const {$authClient} = useNuxtApp()
const session = $authClient.useSession()
const toast = useToast()

const handleSignOut = async () => {
  try {
    await $authClient.signOut({
      fetchOptions: {
        onSuccess: async () => {
          toast.add({ title: 'Signed out successfully' })
          await navigateTo('/', { replace: true, external: true })
        },
        onError: (error) => {
           toast.add({ title: 'Sign out failed', description: error?.error?.message || 'Unknown error'})
        }
      },
    })
  } catch (error: any) {
     toast.add({ title: 'An unexpected error occurred during sign out', description: error.message || 'Please try again.'})
  }
}
</script>

<template>
  <div>
    <USkeleton v-if="session.isPending" class="h-9 w-24" />

    <UButton v-else-if="!session.data" variant="outline" to="/login">
      Sign In
    </UButton>

    <UButton
      v-else
      variant="solid"
      icon="i-lucide-log-out"
      label="Sign out"
      @click="handleSignOut()"
    />
  </div>
</template>
`],
  ["auth/better-auth/web/nuxt/app/components/SignUpForm.vue.hbs", `<script setup lang="ts">
import * as z from 'zod'
import type { FormSubmitEvent, AuthFormField } from '@nuxt/ui'

const { $authClient } = useNuxtApp()

const emit = defineEmits(['switchToSignIn'])

const toast = useToast()
const loading = ref(false)

const fields: AuthFormField[] = [
  {
    name: 'name',
    type: 'text',
    label: 'Name',
    placeholder: 'Enter your name',
    required: true
  },
  {
    name: 'email',
    type: 'email',
    label: 'Email',
    placeholder: 'Enter your email',
    required: true
  },
  {
    name: 'password',
    type: 'password',
    label: 'Password',
    placeholder: 'Enter your password',
    required: true
  }
]

const schema = z.object({
  name: z.string().min(2, 'Name must be at least 2 characters'),
  email: z.email('Invalid email address'),
  password: z.string().min(8, 'Password must be at least 8 characters'),
})

type Schema = z.output<typeof schema>

async function onSubmit(event: FormSubmitEvent<Schema>) {
  loading.value = true
  try {
    await $authClient.signUp.email(
      {
        name: event.data.name,
        email: event.data.email,
        password: event.data.password,
      },
      {
        onSuccess: () => {
          toast.add({ title: 'Sign up successful' })
          navigateTo('/dashboard', { replace: true })
        },
        onError: (error) => {
          toast.add({ title: 'Sign up failed', description: error.error.message })
        },
      },
    )
  } catch (error: any) {
    toast.add({ title: 'An unexpected error occurred', description: error.message || 'Please try again.' })
  } finally {
    loading.value = false
  }
}
</script>

<template>
  <div class="flex flex-col items-center justify-center gap-4 p-4">
    <UPageCard class="w-full max-w-md">
      <UAuthForm
        :schema="schema"
        :fields="fields"
        title="Create Account"
        icon="i-lucide-user-plus"
        :submit="{ label: 'Sign Up', loading }"
        @submit="onSubmit"
      >
        <template #description>
          Already have an account?
          <ULink class="text-primary font-medium" @click="$emit('switchToSignIn')">
            Sign In
          </ULink>
        </template>
      </UAuthForm>
    </UPageCard>
  </div>
</template>
`],
  ["auth/better-auth/native/bare/app/(drawer)/index.tsx.hbs", `import { View, Text, ScrollView, TouchableOpacity, StyleSheet } from "react-native";
import { Container } from "@/components/container";
import { useColorScheme } from "@/lib/use-color-scheme";
import { NAV_THEME } from "@/lib/constants";
import { authClient } from "@/lib/auth-client";
import { SignIn } from "@/components/sign-in";
import { SignUp } from "@/components/sign-up";
{{#if (eq api "orpc")}}
import { useQuery } from "@tanstack/react-query";
import { queryClient, orpc } from "@/utils/orpc";
{{/if}}
{{#if (eq api "trpc")}}
import { useQuery } from "@tanstack/react-query";
import { queryClient, trpc } from "@/utils/trpc";
{{/if}}

export default function Home() {
const { colorScheme } = useColorScheme();
const theme = colorScheme === "dark" ? NAV_THEME.dark : NAV_THEME.light;
{{#if (eq api "orpc")}}
const healthCheck = useQuery(orpc.healthCheck.queryOptions());
const privateData = useQuery(orpc.privateData.queryOptions());
const isConnected = healthCheck?.data === "OK";
const isLoading = healthCheck?.isLoading;
{{/if}}
{{#if (eq api "trpc")}}
const healthCheck = useQuery(trpc.healthCheck.queryOptions());
const privateData = useQuery(trpc.privateData.queryOptions());
const isConnected = healthCheck?.data === "OK";
const isLoading = healthCheck?.isLoading;
{{/if}}
const { data: session } = authClient.useSession();

return (
<Container>
  <ScrollView style={styles.scrollView}>
    <View style={styles.content}>
      <Text style={[styles.title, { color: theme.text }]}>
        BETTER T STACK
      </Text>

      {session?.user ? (
      <View style={[styles.userCard, { backgroundColor: theme.card, borderColor: theme.border }]}>
        <View style={styles.userHeader}>
          <Text style={[styles.userText, { color: theme.text }]}>
            Welcome, <Text style={styles.userName}>{session.user.name}</Text>
          </Text>
        </View>
        <Text style={[styles.userEmail, { color: theme.text, opacity: 0.7 }]}>
          {session.user.email}
        </Text>
        <TouchableOpacity style={[styles.signOutButton, { backgroundColor: theme.notification }]} onPress={()=> {
          authClient.signOut();
          {{#if (eq api "orpc")}}
          queryClient.invalidateQueries();
          {{/if}}
          {{#if (eq api "trpc")}}
          queryClient.invalidateQueries();
          {{/if}}
          }}
          >
          <Text style={styles.signOutText}>Sign Out</Text>
        </TouchableOpacity>
      </View>
      ) : null}

      {{#unless (eq api "none")}}
      <View style={[styles.statusCard, { backgroundColor: theme.card, borderColor: theme.border }]}>
        <Text style={[styles.cardTitle, { color: theme.text }]}>
          System Status
        </Text>
        <View style={styles.statusRow}>
          <View style={[styles.statusIndicator, { backgroundColor: isConnected ? "#10b981" : "#ef4444" }]} />
          <View style={styles.statusContent}>
            <Text style={[styles.statusTitle, { color: theme.text }]}>
              {{#if (eq api "orpc")}}ORPC{{else}}TRPC{{/if}} Backend
            </Text>
            <Text style={[styles.statusText, { color: theme.text, opacity: 0.7 }]}>
              {isLoading
              ? "Checking connection..."
              : isConnected
              ? "Connected to API"
              : "API Disconnected"}
            </Text>
          </View>
        </View>
      </View>

      <View style={[styles.privateDataCard, { backgroundColor: theme.card, borderColor: theme.border }]}>
        <Text style={[styles.cardTitle, { color: theme.text }]}>
          Private Data
        </Text>
        {privateData && (
        <Text style={[styles.privateDataText, { color: theme.text, opacity: 0.7 }]}>
          {privateData.data?.message}
        </Text>
        )}
      </View>
      {{/unless}}

      {!session?.user && (
      <>
        <SignIn />
        <SignUp />
      </>
      )}
    </View>
  </ScrollView>
</Container>
);
}

const styles = StyleSheet.create({
scrollView: {
flex: 1,
},
content: {
padding: 16,
},
title: {
fontSize: 24,
fontWeight: "bold",
marginBottom: 16,
},
userCard: {
marginBottom: 16,
padding: 16,
borderWidth: 1,
},
userHeader: {
marginBottom: 8,
},
userText: {
fontSize: 16,
},
userName: {
fontWeight: "bold",
},
userEmail: {
fontSize: 14,
marginBottom: 12,
},
signOutButton: {
padding: 12,
},
signOutText: {
color: "#ffffff",
},
statusCard: {
marginBottom: 16,
padding: 16,
borderWidth: 1,
},
cardTitle: {
fontSize: 16,
fontWeight: "bold",
marginBottom: 12,
},
statusRow: {
flexDirection: "row",
alignItems: "center",
gap: 8,
},
statusIndicator: {
height: 8,
width: 8,
},
statusContent: {
flex: 1,
},
statusTitle: {
fontSize: 14,
fontWeight: "bold",
},
statusText: {
fontSize: 12,
},
privateDataCard: {
marginBottom: 16,
padding: 16,
borderWidth: 1,
},
privateDataText: {
fontSize: 14,
},
});`],
  ["auth/better-auth/web/nuxt/app/pages/login.vue.hbs", `<script setup lang="ts">
const { $authClient } = useNuxtApp();
import SignInForm from "~/components/SignInForm.vue";
import SignUpForm from "~/components/SignUpForm.vue";

const session = $authClient.useSession();
const showSignIn = ref(true);

watchEffect(() => {
  if (!session?.value.isPending && session?.value.data) {
    navigateTo("/dashboard", { replace: true });
  }
});
</script>

<template>
  <UContainer class="py-8">
    <div v-if="session.isPending" class="flex flex-col items-center justify-center gap-4 py-12">
      <UIcon name="i-lucide-loader-2" class="animate-spin text-4xl text-primary" />
      <span class="text-muted">Loading...</span>
    </div>
    <div v-else-if="!session.data">
      <SignInForm v-if="showSignIn" @switch-to-sign-up="showSignIn = false" />
      <SignUpForm v-else @switch-to-sign-in="showSignIn = true" />
    </div>
  </UContainer>
</template>
`],
  ["auth/better-auth/web/nuxt/app/pages/dashboard.vue.hbs", `<script setup lang="ts">
{{#if (eq api "orpc")}}
import { useQuery } from '@tanstack/vue-query'
{{/if}}

const { $authClient, $orpc } = useNuxtApp()

definePageMeta({
  middleware: ['auth']
})

const session = $authClient.useSession()

{{#if (eq payments "polar")}}
const customerState = ref<any>(null)
{{/if}}

{{#if (eq api "orpc")}}
const privateData = useQuery({
  ...$orpc.privateData.queryOptions(),
  enabled: computed(() => !!session.value?.data?.user)
})
{{/if}}

{{#if (eq payments "polar")}}
onMounted(async () => {
  if (session.value?.data) {
    const { data } = await $authClient.customer.state()
    customerState.value = data
  }
})

const hasProSubscription = computed(() => 
  customerState.value?.activeSubscriptions?.length! > 0
)
{{/if}}
</script>

<template>
  <UContainer class="py-8">
    <UPageHeader
      title="Dashboard"
      :description="session?.data?.user ? \`Welcome back, \${session.data.user.name}!\` : 'Loading...'"
    />

    <div class="mt-6 space-y-4">
      {{#if (eq api "orpc")}}
      <UCard>
        <template #header>
          <div class="font-medium">Private Data</div>
        </template>

        <USkeleton v-if="privateData.status.value === 'pending'" class="h-6 w-48" />

        <UAlert
          v-else-if="privateData.status.value === 'error'"
          color="error"
          icon="i-lucide-alert-circle"
          title="Error loading data"
          :description="privateData.error.value?.message || 'Failed to load private data'"
        />

        <div v-else-if="privateData.data.value" class="flex items-center gap-2">
          <UIcon name="i-lucide-check-circle" class="text-success" />
          <span>\\{{ privateData.data.value.message }}</span>
        </div>
      </UCard>
      {{/if}}

      {{#if (eq payments "polar")}}
      <UCard>
        <template #header>
          <div class="font-medium">Subscription</div>
        </template>

        <div class="flex items-center justify-between">
          <div class="flex items-center gap-2">
            <UIcon :name="hasProSubscription ? 'i-lucide-crown' : 'i-lucide-user'" :class="hasProSubscription ? 'text-warning' : 'text-muted'" />
            <span>Plan: \\{{ hasProSubscription ? "Pro" : "Free" }}</span>
          </div>
          <UButton 
            v-if="hasProSubscription"
            variant="outline"
            @click="() => { $authClient.customer.portal() }"
          >
            Manage Subscription
          </UButton>
          <UButton 
            v-else
            @click="() => { $authClient.checkout({ slug: 'pro' }) }"
          >
            Upgrade to Pro
          </UButton>
        </div>
      </UCard>
      {{/if}}
    </div>
  </UContainer>
</template>
`],
  ["auth/nextauth/fullstack/next/src/lib/auth.ts.hbs", `import NextAuth from "next-auth";
import Credentials from "next-auth/providers/credentials";
import GitHub from "next-auth/providers/github";
import Google from "next-auth/providers/google";
{{#if (eq orm "drizzle")}}
import { DrizzleAdapter } from "@auth/drizzle-adapter";
import { db } from "@{{projectName}}/db";
import * as schema from "@{{projectName}}/db/schema/auth";
{{/if}}
{{#if (eq orm "prisma")}}
import { PrismaAdapter } from "@auth/prisma-adapter";
import prisma from "@{{projectName}}/db";
{{/if}}

export const { handlers, auth, signIn, signOut } = NextAuth({
{{#if (eq orm "drizzle")}}
  adapter: DrizzleAdapter(db, {
    usersTable: schema.users,
    accountsTable: schema.accounts,
    sessionsTable: schema.sessions,
    verificationTokensTable: schema.verificationTokens,
  }),
{{/if}}
{{#if (eq orm "prisma")}}
  adapter: PrismaAdapter(prisma),
{{/if}}
  session: {
    strategy: "{{#if (or (eq orm "drizzle") (eq orm "prisma"))}}database{{else}}jwt{{/if}}",
  },
  providers: [
    // OAuth providers - configure in your .env file
    GitHub({
      clientId: process.env.AUTH_GITHUB_ID,
      clientSecret: process.env.AUTH_GITHUB_SECRET,
    }),
    Google({
      clientId: process.env.AUTH_GOOGLE_ID,
      clientSecret: process.env.AUTH_GOOGLE_SECRET,
    }),
    // Email/Password authentication
    Credentials({
      name: "credentials",
      credentials: {
        email: { label: "Email", type: "email" },
        password: { label: "Password", type: "password" },
      },
      async authorize(credentials) {
        // Add your own authentication logic here
        // This is a placeholder - implement proper password validation
        if (!credentials?.email || !credentials?.password) {
          return null;
        }

        // Example: Replace with your actual user lookup and password verification
        // const user = await db.query.users.findFirst({
        //   where: eq(users.email, credentials.email),
        // });
        // if (user && await verifyPassword(credentials.password, user.password)) {
        //   return { id: user.id, email: user.email, name: user.name };
        // }

        return null;
      },
    }),
  ],
  pages: {
    signIn: "/login",
  },
  callbacks: {
    async session({ session, user, token }) {
      if (session.user) {
        session.user.id = user?.id ?? token?.sub ?? "";
      }
      return session;
    },
    async jwt({ token, user }) {
      if (user) {
        token.sub = user.id;
      }
      return token;
    },
  },
  trustHost: true,
});
`],
  ["job-queue/temporal/server/base/src/temporal/client.ts.hbs", `import { Client, Connection } from "@temporalio/client";

/**
 * Temporal client configuration
 * @see https://docs.temporal.io/develop/typescript/core-application
 */

let client: Client | null = null;

/**
 * Get or create a Temporal client connection
 * Reuses existing connection if available
 */
export async function getTemporalClient(): Promise<Client> {
  if (client) {
    return client;
  }

  const connection = await Connection.connect({
    // Connect to Temporal server (default: localhost:7233)
    // Use TEMPORAL_ADDRESS env var for custom server address
    address: process.env.TEMPORAL_ADDRESS || "localhost:7233",
  });

  client = new Client({
    connection,
    // Namespace to use (default: "default")
    namespace: process.env.TEMPORAL_NAMESPACE || "default",
  });

  return client;
}

/**
 * Close the Temporal client connection
 * Call this during graceful shutdown
 */
export async function closeTemporalClient(): Promise<void> {
  if (client) {
    await client.connection.close();
    client = null;
  }
}
`],
  ["job-queue/temporal/server/base/src/temporal/activities.ts.hbs", `/**
 * Temporal Activities
 *
 * Activities are the building blocks of workflows - they perform the actual work.
 * Activities can make network calls, interact with databases, or perform any side effects.
 * They automatically retry on failure based on configuration.
 *
 * @see https://docs.temporal.io/develop/typescript/core-application#develop-activities
 */

// Activity context provides utilities like heartbeating for long-running activities
// import { Context } from "@temporalio/activity";

/**
 * Send an email activity
 * @param to - Recipient email address
 * @param subject - Email subject
 * @param body - Email body content
 */
export async function sendEmail(
  to: string,
  subject: string,
  body: string
): Promise<{ sent: boolean; timestamp: string }> {
  // TODO: Implement your email sending logic here
  // Example with a hypothetical email service:
  // await emailService.send({ to, subject, body });

  // Simulate email sending
  await new Promise((resolve) => setTimeout(resolve, 1000));

  console.log(\`[Activity] Sending email to \${to}: \${subject}\`);

  return {
    sent: true,
    timestamp: new Date().toISOString(),
  };
}

/**
 * Send a notification activity
 * @param userId - User ID to send notification to
 * @param type - Notification type: "push" | "in-app" | "sms"
 * @param message - Notification message
 */
export async function sendNotification(
  userId: string,
  type: "push" | "in-app" | "sms",
  message: string
): Promise<{ sent: boolean; type: string; timestamp: string }> {
  // TODO: Implement your notification logic here
  // switch (type) {
  //   case "push":
  //     await pushService.send(userId, message);
  //     break;
  //   case "in-app":
  //     await inAppNotificationService.create(userId, message);
  //     break;
  //   case "sms":
  //     await smsService.send(userId, message);
  //     break;
  // }

  // Simulate notification sending
  await new Promise((resolve) => setTimeout(resolve, 500));

  console.log(\`[Activity] Sending \${type} notification to user \${userId}: \${message}\`);

  return {
    sent: true,
    type,
    timestamp: new Date().toISOString(),
  };
}

/**
 * Process data activity
 * @param dataId - ID of the data to process
 * @param operation - Operation to perform: "transform" | "aggregate" | "export"
 */
export async function processData(
  dataId: string,
  operation: "transform" | "aggregate" | "export"
): Promise<{ processed: boolean; dataId: string; operation: string }> {
  // TODO: Implement your data processing logic here
  // const data = await database.getData(dataId);
  // switch (operation) {
  //   case "transform":
  //     return await transformData(data);
  //   case "aggregate":
  //     return await aggregateData(data);
  //   case "export":
  //     return await exportData(data);
  // }

  // For long-running activities, use heartbeating to report progress
  // const ctx = Context.current();
  // ctx.heartbeat("Processing started");

  // Simulate data processing
  await new Promise((resolve) => setTimeout(resolve, 2000));

  console.log(\`[Activity] Processing data \${dataId} with operation \${operation}\`);

  return {
    processed: true,
    dataId,
    operation,
  };
}

/**
 * Cleanup activity for scheduled jobs
 * Removes expired sessions, clears stale cache, etc.
 */
export async function performCleanup(): Promise<{ cleaned: boolean; timestamp: string }> {
  // TODO: Implement your cleanup logic here
  // await database.deleteExpiredSessions();
  // await cache.clearStale();

  // Simulate cleanup
  await new Promise((resolve) => setTimeout(resolve, 1000));

  console.log("[Activity] Performing scheduled cleanup");

  return {
    cleaned: true,
    timestamp: new Date().toISOString(),
  };
}

/**
 * Generate daily report activity
 */
export async function generateReport(): Promise<{
  generatedAt: string;
  metrics: { users: number; events: number };
}> {
  // TODO: Implement your report generation logic here
  // const stats = await analytics.getDailyStats();
  // return generateReportData(stats);

  // Simulate report generation
  await new Promise((resolve) => setTimeout(resolve, 2000));

  console.log("[Activity] Generating daily report");

  return {
    generatedAt: new Date().toISOString(),
    metrics: {
      users: 100,
      events: 500,
    },
  };
}

/**
 * Fetch user data activity
 * @param userId - User ID to fetch data for
 */
export async function fetchUserData(
  userId: string
): Promise<{ userId: string; email: string; name: string }> {
  // TODO: Implement your user data fetching logic
  // return await database.getUser(userId);

  // Simulate database fetch
  await new Promise((resolve) => setTimeout(resolve, 300));

  return {
    userId,
    email: \`user-\${userId}@example.com\`,
    name: \`User \${userId}\`,
  };
}
`],
  ["job-queue/temporal/server/base/src/temporal/worker.ts.hbs", `import { Worker, NativeConnection } from "@temporalio/worker";

import * as activities from "./activities";

/**
 * Temporal Worker Configuration
 *
 * Workers execute workflows and activities. You can run multiple workers
 * for scalability - they will automatically coordinate via the Temporal server.
 *
 * @see https://docs.temporal.io/develop/typescript/core-application#run-a-dev-worker
 */

const TASK_QUEUE = process.env.TEMPORAL_TASK_QUEUE || "{{projectName}}-task-queue";

/**
 * Create and run a Temporal worker
 */
export async function runWorker(): Promise<void> {
  // Connect to the Temporal server
  const connection = await NativeConnection.connect({
    address: process.env.TEMPORAL_ADDRESS || "localhost:7233",
  });

  try {
    // Create a worker that connects to the server and executes workflows/activities
    const worker = await Worker.create({
      connection,
      namespace: process.env.TEMPORAL_NAMESPACE || "default",
      taskQueue: TASK_QUEUE,
      // Point to compiled workflow file for bundling
      workflowsPath: require.resolve("./workflows"),
      // Register activities directly
      activities,
      // Optional: Configure worker behavior
      maxConcurrentActivityTaskExecutions: 100,
      maxConcurrentWorkflowTaskExecutions: 100,
    });

    // Start accepting tasks
    console.log(\`[Temporal Worker] Starting worker on task queue: \${TASK_QUEUE}\`);
    await worker.run();
  } finally {
    // Ensure we close the connection when shutting down
    await connection.close();
  }
}

/**
 * Run the worker when this file is executed directly
 * Usage: npx ts-node src/temporal/worker.ts
 */
if (require.main === module) {
  runWorker().catch((err) => {
    console.error("[Temporal Worker] Failed to start:", err);
    process.exit(1);
  });
}
`],
  ["job-queue/temporal/server/base/src/temporal/workflows.ts.hbs", `/**
 * Temporal Workflows
 *
 * Workflows are the core abstraction in Temporal. They orchestrate activities
 * and other workflows, and are durable - they survive process restarts.
 *
 * IMPORTANT: Workflow code must be deterministic!
 * - No direct I/O, network calls, or random number generation
 * - Use activities for any non-deterministic operations
 * - Use workflow.sleep instead of setTimeout
 *
 * @see https://docs.temporal.io/develop/typescript/core-application#develop-workflows
 */

import { proxyActivities, sleep, defineSignal, setHandler, condition } from "@temporalio/workflow";

// Import activity types for type-safe proxy
import type * as activities from "./activities";

// Create activity proxies with retry policies
const { sendEmail, sendNotification, processData, performCleanup, generateReport, fetchUserData } =
  proxyActivities<typeof activities>({
    // Default activity options
    startToCloseTimeout: "1 minute",
    retry: {
      initialInterval: "1 second",
      maximumInterval: "1 minute",
      backoffCoefficient: 2,
      maximumAttempts: 3,
    },
  });

// Define signals for workflow interaction
export const cancelSignal = defineSignal("cancel");

/**
 * Email sending workflow
 * Simple workflow that sends a single email
 */
export async function sendEmailWorkflow(
  to: string,
  subject: string,
  body: string
): Promise<{ sent: boolean; timestamp: string }> {
  return await sendEmail(to, subject, body);
}

/**
 * Notification workflow
 * Sends a notification to a user
 */
export async function sendNotificationWorkflow(
  userId: string,
  type: "push" | "in-app" | "sms",
  message: string
): Promise<{ sent: boolean; type: string; timestamp: string }> {
  return await sendNotification(userId, type, message);
}

/**
 * Data processing workflow with cancellation support
 * Demonstrates multi-step workflow with signal handling
 */
export async function processDataWorkflow(
  dataId: string,
  operation: "transform" | "aggregate" | "export"
): Promise<{ processed: boolean; dataId: string; operation: string; timestamp: string }> {
  let cancelled = false;

  // Set up cancellation signal handler
  setHandler(cancelSignal, () => {
    cancelled = true;
  });

  // Step 1: Validate input
  if (!dataId) {
    throw new Error("Data ID is required");
  }

  // Check for cancellation
  if (cancelled) {
    return {
      processed: false,
      dataId,
      operation,
      timestamp: new Date().toISOString(),
    };
  }

  // Step 2: Process data
  const result = await processData(dataId, operation);

  // Step 3: Send completion notification
  await sendNotification("system", "in-app", \`Data \${dataId} has been \${operation}ed successfully\`);

  return {
    ...result,
    timestamp: new Date().toISOString(),
  };
}

/**
 * Scheduled cleanup workflow
 * Can be started with a cron schedule
 *
 * Start with: client.schedule.create({
 *   scheduleId: "hourly-cleanup",
 *   spec: { cronExpressions: ["0 * * * *"] },
 *   action: { type: "startWorkflow", workflowType: "cleanupWorkflow", ... }
 * })
 */
export async function cleanupWorkflow(): Promise<{ cleaned: boolean; timestamp: string }> {
  return await performCleanup();
}

/**
 * Daily report workflow
 * Generates a report and sends it via email
 *
 * Start with cron schedule: "0 9 * * *" (9 AM daily)
 */
export async function dailyReportWorkflow(): Promise<{
  reportGenerated: boolean;
  timestamp: string;
}> {
  // Step 1: Generate report
  const reportData = await generateReport();

  // Step 2: Send report via email
  await sendEmail(
    "admin@example.com",
    "Daily Report",
    \`Daily metrics: \${JSON.stringify(reportData.metrics)}\`
  );

  return {
    reportGenerated: true,
    timestamp: new Date().toISOString(),
  };
}

/**
 * Welcome sequence workflow
 * Demonstrates long-running workflow with delays
 *
 * This workflow sends a series of emails over several days:
 * - Immediate: Welcome email
 * - After 1 day: Tips email
 * - After 3 more days: Feature highlight email
 */
export async function welcomeSequenceWorkflow(
  userId: string
): Promise<{ completed: boolean; userId: string; timestamp: string }> {
  // Fetch user data
  const user = await fetchUserData(userId);

  // Send immediate welcome email
  await sendEmail(user.email, "Welcome to {{projectName}}!", \`Hi \${user.name}, welcome aboard!\`);

  // Wait 1 day before sending tips email
  await sleep("1 day");

  await sendEmail(
    user.email,
    "Getting Started Tips",
    \`Hi \${user.name}, here are some tips to get the most out of {{projectName}}...\`
  );

  // Wait 3 more days before sending feature highlight
  await sleep("3 days");

  await sendEmail(
    user.email,
    "Discover More Features",
    \`Hi \${user.name}, have you tried these features yet?\`
  );

  return {
    completed: true,
    userId,
    timestamp: new Date().toISOString(),
  };
}

/**
 * Order processing workflow
 * Example of a saga pattern with compensation
 */
export async function orderProcessingWorkflow(orderId: string): Promise<{
  success: boolean;
  orderId: string;
  steps: string[];
}> {
  const completedSteps: string[] = [];

  try {
    // Step 1: Validate order
    completedSteps.push("validated");

    // Step 2: Reserve inventory (simulated with notification)
    await sendNotification("system", "in-app", \`Reserving inventory for order \${orderId}\`);
    completedSteps.push("inventory_reserved");

    // Step 3: Process payment (simulated)
    await sendNotification("system", "in-app", \`Processing payment for order \${orderId}\`);
    completedSteps.push("payment_processed");

    // Step 4: Ship order (simulated)
    await sendNotification("system", "in-app", \`Shipping order \${orderId}\`);
    completedSteps.push("shipped");

    // Step 5: Send confirmation email
    await sendEmail("customer@example.com", "Order Confirmed", \`Your order \${orderId} has shipped!\`);
    completedSteps.push("notification_sent");

    return {
      success: true,
      orderId,
      steps: completedSteps,
    };
  } catch (error) {
    // Compensation logic would go here
    // For example: release inventory, refund payment, etc.
    return {
      success: false,
      orderId,
      steps: completedSteps,
    };
  }
}

/**
 * Batch processing workflow with child workflows
 * Demonstrates parent-child workflow pattern
 */
export async function batchEmailWorkflow(
  recipients: Array<{ email: string; subject: string; body: string }>
): Promise<{ sent: number; failed: number }> {
  let sent = 0;
  let failed = 0;

  for (const recipient of recipients) {
    try {
      await sendEmail(recipient.email, recipient.subject, recipient.body);
      sent++;
    } catch {
      failed++;
    }
  }

  return { sent, failed };
}
`],
  ["auth/better-auth/web/svelte/src/components/SignInForm.svelte.hbs", `<script lang="ts">
	import { createForm } from '@tanstack/svelte-form';
	import { z } from 'zod';
	import { authClient } from '$lib/auth-client';
	import { goto } from '$app/navigation';

	let { switchToSignUp } = $props<{ switchToSignUp: () => void }>();

	const validationSchema = z.object({
		email: z.email('Invalid email address'),
		password: z.string().min(1, 'Password is required'),
	});

	const form = createForm(() => ({
		defaultValues: { email: '', password: '' },
		onSubmit: async ({ value }) => {
				await authClient.signIn.email(
					{ email: value.email, password: value.password },
					{
						onSuccess: () => goto('/dashboard'),
						onError: (error) => {
							console.log(error.error.message || 'Sign in failed. Please try again.');
						},
					}
				);

		},
		validators: {
			onSubmit: validationSchema,
		},
	}));
</script>

<div class="mx-auto mt-10 w-full max-w-md p-6">
	<h1 class="mb-6 text-center font-bold text-3xl">Welcome Back</h1>

	<form
		class="space-y-4"
		onsubmit={(e) => {
			e.preventDefault();
			e.stopPropagation();
			form.handleSubmit();
		}}
	>
		<form.Field name="email">
			{#snippet children(field)}
				<div class="space-y-1">
					<label for={field.name}>Email</label>
					<input
						id={field.name}
						name={field.name}
						type="email"
						class="w-full border"
						onblur={field.handleBlur}
						value={field.state.value}
						oninput={(e: Event) => {
							const target = e.target as HTMLInputElement;
							field.handleChange(target.value);
						}}
					/>
					{#if field.state.meta.isTouched}
						{#each field.state.meta.errors as error}
							<p class="text-sm text-red-500" role="alert">{error}</p>
						{/each}
					{/if}
				</div>
			{/snippet}
		</form.Field>

		<form.Field name="password">
			{#snippet children(field)}
				<div class="space-y-1">
					<label for={field.name}>Password</label>
					<input
						id={field.name}
						name={field.name}
						type="password"
						class="w-full border"
						onblur={field.handleBlur}
						value={field.state.value}
						oninput={(e: Event) => {
							const target = e.target as HTMLInputElement;
							field.handleChange(target.value);
						}}
					/>
					{#if field.state.meta.isTouched}
						{#each field.state.meta.errors as error}
							<p class="text-sm text-red-500" role="alert">{error}</p>
						{/each}
					{/if}
				</div>
			{/snippet}
		</form.Field>

		<form.Subscribe selector={(state) => ({ canSubmit: state.canSubmit, isSubmitting: state.isSubmitting })}>
			{#snippet children(state)}
				<button type="submit" class="w-full" disabled={!state.canSubmit || state.isSubmitting}>
					{state.isSubmitting ? 'Submitting...' : 'Sign In'}
				</button>
			{/snippet}
		</form.Subscribe>
	</form>

	<div class="mt-4 text-center">
		<button type="button" class="text-indigo-600 hover:text-indigo-800" onclick={switchToSignUp}>
			Need an account? Sign Up
		</button>
	</div>
</div>
`],
  ["auth/better-auth/web/svelte/src/components/UserMenu.svelte.hbs", `<script lang="ts">
	import { authClient } from '$lib/auth-client';
	import { goto } from '$app/navigation';

	const sessionQuery = authClient.useSession();

	async function handleSignOut() {
		await authClient.signOut({
		fetchOptions: {
			onSuccess: () => {
				goto('/');
			},
			onError: (error) => {
				console.error('Sign out failed:', error);
			}
		}
		});
	}

	function goToLogin() {
		goto('/login');
	}

</script>

<div class="relative">
	{#if $sessionQuery.isPending}
		<div class="h-8 w-24 animate-pulse rounded bg-neutral-700"></div>
	{:else if $sessionQuery.data?.user}
		{@const user = $sessionQuery.data.user}
		<div class="flex items-center gap-3">
			<span class="text-sm text-neutral-300 hidden sm:inline" title={user.email}>
				{user.name || user.email?.split('@')[0] || 'User'}
			</span>
			<button
				onclick={handleSignOut}
				class="rounded px-3 py-1 text-sm bg-red-600 hover:bg-red-700 text-white transition-colors"
			>
				Sign Out
			</button>
		</div>
	{:else}
		<div class="flex items-center gap-2">
			<button
				onclick={goToLogin}
				class="rounded px-3 py-1 text-sm bg-indigo-600 hover:bg-indigo-700 text-white transition-colors"
			>
				Sign In
			</button>
		</div>
	{/if}
</div>
`],
  ["auth/better-auth/web/svelte/src/components/SignUpForm.svelte.hbs", `<script lang="ts">
	import { createForm } from '@tanstack/svelte-form';
	import { z } from 'zod';
	import { authClient } from '$lib/auth-client';
	import { goto } from '$app/navigation';

	let { switchToSignIn } = $props<{ switchToSignIn: () => void }>();

	const validationSchema = z.object({
		name: z.string().min(2, 'Name must be at least 2 characters'),
		email: z.email('Invalid email address'),
		password: z.string().min(8, 'Password must be at least 8 characters'),
	});


	const form = createForm(() => ({
		defaultValues: { name: '', email: '', password: '' },
		onSubmit: async ({ value }) => {
				await authClient.signUp.email(
					{
						email: value.email,
						password: value.password,
						name: value.name,
					},
					{
						onSuccess: () => {
							goto('/dashboard');
						},
						onError: (error) => {
							console.log(error.error.message || 'Sign up failed. Please try again.');
						},
					}
				);

		},
		validators: {
			onSubmit: validationSchema,
		},
	}));
</script>

<div class="mx-auto mt-10 w-full max-w-md p-6">
	<h1 class="mb-6 text-center font-bold text-3xl">Create Account</h1>

	<form
		id="form"
		class="space-y-4"
		onsubmit={(e) => {
			e.preventDefault();
			e.stopPropagation();
			form.handleSubmit();
		}}
	>
		<form.Field name="name">
			{#snippet children(field)}
				<div class="space-y-1">
					<label for={field.name}>Name</label>
					<input
						id={field.name}
						name={field.name}
						class="w-full border"
						onblur={field.handleBlur}
						value={field.state.value}
						oninput={(e: Event) => {
							const target = e.target as HTMLInputElement;
							field.handleChange(target.value);
						}}
					/>
					{#if field.state.meta.isTouched}
						{#each field.state.meta.errors as error}
							<p class="text-sm text-red-500" role="alert">{error}</p>
						{/each}
					{/if}
				</div>
			{/snippet}
		</form.Field>

		<form.Field name="email">
			{#snippet children(field)}
				<div class="space-y-1">
					<label for={field.name}>Email</label>
					<input
						id={field.name}
						name={field.name}
						type="email"
						class="w-full border"
						onblur={field.handleBlur}
						value={field.state.value}
						oninput={(e: Event) => {
							const target = e.target as HTMLInputElement;
							field.handleChange(target.value);
						}}
					/>
					{#if field.state.meta.isTouched}
						{#each field.state.meta.errors as error}
							<p class="text-sm text-red-500" role="alert">{error}</p>
						{/each}
					{/if}
				</div>
			{/snippet}
		</form.Field>

		<form.Field name="password">
			{#snippet children(field)}
				<div class="space-y-1">
					<label for={field.name}>Password</label>
					<input
						id={field.name}
						name={field.name}
						type="password"
						class="w-full border"
						onblur={field.handleBlur}
						value={field.state.value}
						oninput={(e: Event) => {
							const target = e.target as HTMLInputElement;
							field.handleChange(target.value);
						}}
					/>
					{#if field.state.meta.isTouched}
						{#each field.state.meta.errors as error}
							<p class="text-sm text-red-500" role="alert">{error}</p>
						{/each}
					{/if}
				</div>
			{/snippet}
		</form.Field>

		<form.Subscribe selector={(state) => ({ canSubmit: state.canSubmit, isSubmitting: state.isSubmitting })}>
			{#snippet children(state)}
				<button type="submit" class="w-full" disabled={!state.canSubmit || state.isSubmitting}>
					{state.isSubmitting ? 'Submitting...' : 'Sign Up'}
				</button>
			{/snippet}
		</form.Subscribe>
	</form>

	<div class="mt-4 text-center">
		<button type="button" class="text-indigo-600 hover:text-indigo-800" onclick={switchToSignIn}>
			Already have an account? Sign In
		</button>
	</div>
</div>
`],
  ["auth/better-auth/web/svelte/src/lib/auth-client.ts.hbs", `import { PUBLIC_SERVER_URL } from "$env/static/public";
import { createAuthClient } from "better-auth/svelte";
{{#if (eq payments "polar")}}
import { polarClient } from "@polar-sh/better-auth";
{{/if}}

export const authClient = createAuthClient({
	baseURL: PUBLIC_SERVER_URL,
{{#if (eq payments "polar")}}
	plugins: [polarClient()]
{{/if}}
});
`],
  ["email/resend/server/base/src/lib/email.ts.hbs", `import { Resend } from "resend";

// Initialize Resend client
const resend = new Resend(process.env.RESEND_API_KEY);

export interface SendEmailOptions {
  to: string | string[];
  subject: string;
  html?: string;
  text?: string;
  react?: React.ReactElement;
  from?: string;
  replyTo?: string;
}

/**
 * Send an email using Resend
 * @see https://resend.com/docs/send-with-nodejs
 */
export async function sendEmail(options: SendEmailOptions) {
  const { to, subject, html, text, react, from, replyTo } = options;

  const fromAddress = from || process.env.RESEND_FROM_EMAIL || "onboarding@resend.dev";

  try {
    const { data, error } = await resend.emails.send({
      from: fromAddress,
      to: Array.isArray(to) ? to : [to],
      subject,
      html,
      text,
      react,
      replyTo,
    });

    if (error) {
      console.error("Failed to send email:", error);
      throw new Error(\`Failed to send email: \${error.message}\`);
    }

    return { success: true, data };
  } catch (error) {
    console.error("Email sending error:", error);
    throw error;
  }
}

/**
 * Get the Resend client instance for advanced usage
 */
export function getResendClient() {
  return resend;
}

export { resend };
`],
  ["job-queue/bullmq/server/base/src/lib/queue.ts.hbs", `import { Queue, Worker, type Job, type ConnectionOptions } from "bullmq";
import IORedis from "ioredis";

// Redis connection configuration
// For production, use environment variables to configure the connection
const redisConnection: ConnectionOptions = {
  host: process.env.REDIS_HOST || "localhost",
  port: Number(process.env.REDIS_PORT) || 6379,
  password: process.env.REDIS_PASSWORD || undefined,
  maxRetriesPerRequest: null, // Required for BullMQ
};

// Create a shared Redis connection for all queues
const connection = new IORedis(redisConnection);

// Export connection for reuse
export { connection };

/**
 * Example queue for background job processing
 * @see https://docs.bullmq.io/
 */
export const emailQueue = new Queue("email", { connection });
export const notificationQueue = new Queue("notification", { connection });

// Define job data types
export interface EmailJobData {
  to: string;
  subject: string;
  body: string;
  templateId?: string;
}

export interface NotificationJobData {
  userId: string;
  type: "push" | "in-app" | "sms";
  title: string;
  message: string;
  data?: Record<string, unknown>;
}

/**
 * Add an email job to the queue
 */
export async function queueEmail(data: EmailJobData, options?: { delay?: number; priority?: number }) {
  return emailQueue.add("send-email", data, {
    delay: options?.delay,
    priority: options?.priority,
    attempts: 3,
    backoff: {
      type: "exponential",
      delay: 1000,
    },
  });
}

/**
 * Add a notification job to the queue
 */
export async function queueNotification(data: NotificationJobData, options?: { delay?: number }) {
  return notificationQueue.add("send-notification", data, {
    delay: options?.delay,
    attempts: 3,
    backoff: {
      type: "exponential",
      delay: 1000,
    },
  });
}

/**
 * Schedule a recurring job (cron-style)
 * @example scheduleRecurringJob(emailQueue, "daily-report", { type: "report" }, "0 9 * * *")
 */
export async function scheduleRecurringJob<T>(
  queue: Queue,
  name: string,
  data: T,
  pattern: string, // Cron pattern
) {
  return queue.upsertJobScheduler(
    name,
    { pattern },
    { name, data: data as object },
  );
}

/**
 * Get queue statistics
 */
export async function getQueueStats(queue: Queue) {
  const [waiting, active, completed, failed, delayed] = await Promise.all([
    queue.getWaitingCount(),
    queue.getActiveCount(),
    queue.getCompletedCount(),
    queue.getFailedCount(),
    queue.getDelayedCount(),
  ]);

  return { waiting, active, completed, failed, delayed };
}

/**
 * Gracefully close all queues and connections
 * Call this during application shutdown
 */
export async function closeQueues() {
  await emailQueue.close();
  await notificationQueue.close();
  await connection.quit();
}
`],
  ["job-queue/bullmq/server/base/src/lib/workers.ts.hbs", `import { Worker, type Job } from "bullmq";
import { connection, type EmailJobData, type NotificationJobData } from "./queue";

/**
 * Email worker - processes email sending jobs
 * @see https://docs.bullmq.io/guide/workers
 */
export const emailWorker = new Worker<EmailJobData>(
  "email",
  async (job: Job<EmailJobData>) => {
    const { to, subject, body, templateId } = job.data;

    console.log(\`Processing email job \${job.id}: sending to \${to}\`);

    // TODO: Implement your email sending logic here
    // Example with a hypothetical email service:
    // await emailService.send({ to, subject, body, templateId });

    // Simulate email sending
    await new Promise((resolve) => setTimeout(resolve, 1000));

    console.log(\`Email job \${job.id} completed: sent to \${to}\`);

    return { sent: true, to, timestamp: new Date().toISOString() };
  },
  {
    connection,
    concurrency: 5, // Process up to 5 jobs in parallel
    limiter: {
      max: 100, // Max 100 jobs
      duration: 60000, // Per minute (rate limiting)
    },
  },
);

/**
 * Notification worker - processes notification jobs
 */
export const notificationWorker = new Worker<NotificationJobData>(
  "notification",
  async (job: Job<NotificationJobData>) => {
    const { userId, type, title, message, data } = job.data;

    console.log(\`Processing notification job \${job.id}: \${type} to user \${userId}\`);

    // TODO: Implement your notification logic here
    // Example:
    // switch (type) {
    //   case "push":
    //     await pushService.send(userId, { title, message, data });
    //     break;
    //   case "in-app":
    //     await inAppNotificationService.create(userId, { title, message, data });
    //     break;
    //   case "sms":
    //     await smsService.send(userId, message);
    //     break;
    // }

    // Simulate notification processing
    await new Promise((resolve) => setTimeout(resolve, 500));

    console.log(\`Notification job \${job.id} completed\`);

    return { sent: true, type, userId, timestamp: new Date().toISOString() };
  },
  {
    connection,
    concurrency: 10,
  },
);

// Event handlers for monitoring
emailWorker.on("completed", (job) => {
  console.log(\`Email job \${job.id} has completed\`);
});

emailWorker.on("failed", (job, err) => {
  console.error(\`Email job \${job?.id} has failed with error: \${err.message}\`);
});

notificationWorker.on("completed", (job) => {
  console.log(\`Notification job \${job.id} has completed\`);
});

notificationWorker.on("failed", (job, err) => {
  console.error(\`Notification job \${job?.id} has failed with error: \${err.message}\`);
});

/**
 * Gracefully close all workers
 * Call this during application shutdown
 */
export async function closeWorkers() {
  await emailWorker.close();
  await notificationWorker.close();
}

/**
 * Start all workers
 * Workers start automatically when created, but this function can be used
 * to ensure they're running or to restart after being paused
 */
export function startWorkers() {
  // Workers are already running by default
  // This function is here for explicit control if needed
  console.log("BullMQ workers started");
  console.log("- Email worker: processing 'email' queue");
  console.log("- Notification worker: processing 'notification' queue");
}
`],
  ["email/sendgrid/server/base/src/lib/email.ts.hbs", `import sgMail from "@sendgrid/mail";

// Initialize SendGrid with API key
sgMail.setApiKey(process.env.SENDGRID_API_KEY || "");

export interface SendEmailOptions {
  to: string | string[];
  subject: string;
  html?: string;
  text?: string;
  from?: string;
  replyTo?: string;
  attachments?: Array<{
    filename: string;
    content: string; // Base64 encoded content
    type: string;
    disposition?: "attachment" | "inline";
    contentId?: string;
  }>;
  categories?: string[];
  sendAt?: number; // Unix timestamp for scheduled sending
}

/**
 * Send an email using SendGrid
 * @see https://docs.sendgrid.com/api-reference/mail-send/mail-send
 */
export async function sendEmail(options: SendEmailOptions) {
  const { to, subject, html, text, from, replyTo, attachments, categories, sendAt } = options;

  const fromAddress = from || process.env.SENDGRID_FROM_EMAIL || "noreply@example.com";
  const toAddresses = Array.isArray(to) ? to : [to];

  try {
    const msg: sgMail.MailDataRequired = {
      to: toAddresses,
      from: fromAddress,
      subject,
      html: html || undefined,
      text: text || undefined,
      replyTo: replyTo || undefined,
      attachments: attachments?.map((a) => ({
        filename: a.filename,
        content: a.content,
        type: a.type,
        disposition: a.disposition || "attachment",
        contentId: a.contentId,
      })),
      categories,
      sendAt,
    };

    const response = await sgMail.send(msg);
    console.log("Email sent:", response[0].statusCode);
    return { success: true, statusCode: response[0].statusCode };
  } catch (error) {
    console.error("Email sending error:", error);
    throw error;
  }
}

/**
 * Send multiple emails in a batch (up to 1000 per batch)
 * @see https://docs.sendgrid.com/api-reference/mail-send/mail-send
 */
export async function sendBatchEmails(
  emails: Array<{
    to: string | string[];
    subject: string;
    html?: string;
    text?: string;
    from?: string;
    categories?: string[];
  }>
) {
  const fromAddress = process.env.SENDGRID_FROM_EMAIL || "noreply@example.com";

  const messages: sgMail.MailDataRequired[] = emails.map((email) => ({
    to: Array.isArray(email.to) ? email.to : [email.to],
    from: email.from || fromAddress,
    subject: email.subject,
    html: email.html || undefined,
    text: email.text || undefined,
    categories: email.categories,
  }));

  try {
    const responses = await sgMail.send(messages);
    console.log(\`Batch of \${emails.length} emails sent\`);
    return {
      success: true,
      results: responses.map((r) => ({
        statusCode: r[0].statusCode,
      })),
    };
  } catch (error) {
    console.error("Batch email sending error:", error);
    throw error;
  }
}

/**
 * Send personalized emails to multiple recipients using dynamic templates
 * @see https://docs.sendgrid.com/api-reference/mail-send/mail-send#dynamic-templates
 */
export async function sendTemplateEmail(options: {
  to: string | string[];
  templateId: string;
  dynamicTemplateData: Record<string, unknown>;
  from?: string;
  categories?: string[];
}) {
  const { to, templateId, dynamicTemplateData, from, categories } = options;

  const fromAddress = from || process.env.SENDGRID_FROM_EMAIL || "noreply@example.com";
  const toAddresses = Array.isArray(to) ? to : [to];

  try {
    const msg: sgMail.MailDataRequired = {
      to: toAddresses,
      from: fromAddress,
      templateId,
      dynamicTemplateData,
      categories,
    };

    const response = await sgMail.send(msg);
    console.log("Template email sent:", response[0].statusCode);
    return { success: true, statusCode: response[0].statusCode };
  } catch (error) {
    console.error("Template email sending error:", error);
    throw error;
  }
}

/**
 * Get the SendGrid mail client for advanced usage
 */
export function getSendGridClient() {
  return sgMail;
}

export { sgMail };
`],
  ["email/aws-ses/server/base/src/lib/email.ts.hbs", `import { SESClient, SendEmailCommand, SendRawEmailCommand } from "@aws-sdk/client-ses";

// Initialize AWS SES client
const sesClient = new SESClient({
  region: process.env.AWS_REGION || "us-east-1",
  credentials: {
    accessKeyId: process.env.AWS_ACCESS_KEY_ID || "",
    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY || "",
  },
});

export interface SendEmailOptions {
  to: string | string[];
  subject: string;
  html?: string;
  text?: string;
  from?: string;
  replyTo?: string | string[];
  cc?: string | string[];
  bcc?: string | string[];
}

/**
 * Send an email using AWS SES
 * @see https://docs.aws.amazon.com/ses/latest/APIReference/API_SendEmail.html
 */
export async function sendEmail(options: SendEmailOptions) {
  const { to, subject, html, text, from, replyTo, cc, bcc } = options;

  const fromAddress = from || process.env.AWS_SES_FROM_EMAIL || "noreply@example.com";
  const toAddresses = Array.isArray(to) ? to : [to];
  const replyToAddresses = replyTo ? (Array.isArray(replyTo) ? replyTo : [replyTo]) : undefined;
  const ccAddresses = cc ? (Array.isArray(cc) ? cc : [cc]) : undefined;
  const bccAddresses = bcc ? (Array.isArray(bcc) ? bcc : [bcc]) : undefined;

  const command = new SendEmailCommand({
    Source: fromAddress,
    Destination: {
      ToAddresses: toAddresses,
      CcAddresses: ccAddresses,
      BccAddresses: bccAddresses,
    },
    Message: {
      Subject: {
        Data: subject,
        Charset: "UTF-8",
      },
      Body: {
        ...(html && {
          Html: {
            Data: html,
            Charset: "UTF-8",
          },
        }),
        ...(text && {
          Text: {
            Data: text,
            Charset: "UTF-8",
          },
        }),
      },
    },
    ReplyToAddresses: replyToAddresses,
  });

  try {
    const response = await sesClient.send(command);
    console.log("Email sent:", response.MessageId);
    return { success: true, messageId: response.MessageId };
  } catch (error) {
    console.error("Email sending error:", error);
    throw error;
  }
}

export interface SendRawEmailOptions {
  to: string | string[];
  subject: string;
  html?: string;
  text?: string;
  from?: string;
  replyTo?: string;
  attachments?: Array<{
    filename: string;
    content: string | Buffer;
    contentType: string;
  }>;
}

/**
 * Send a raw email with attachments using AWS SES
 * @see https://docs.aws.amazon.com/ses/latest/APIReference/API_SendRawEmail.html
 */
export async function sendRawEmail(options: SendRawEmailOptions) {
  const { to, subject, html, text, from, replyTo, attachments } = options;

  const fromAddress = from || process.env.AWS_SES_FROM_EMAIL || "noreply@example.com";
  const toAddresses = Array.isArray(to) ? to : [to];

  // Build MIME message
  const boundary = \`----=_Part_\${Date.now().toString(36)}\`;
  const mixedBoundary = \`----=_Mixed_\${Date.now().toString(36)}\`;

  let rawMessage = "";
  rawMessage += \`From: \${fromAddress}\\r\\n\`;
  rawMessage += \`To: \${toAddresses.join(", ")}\\r\\n\`;
  rawMessage += \`Subject: \${subject}\\r\\n\`;
  if (replyTo) {
    rawMessage += \`Reply-To: \${replyTo}\\r\\n\`;
  }
  rawMessage += "MIME-Version: 1.0\\r\\n";

  if (attachments && attachments.length > 0) {
    rawMessage += \`Content-Type: multipart/mixed; boundary="\${mixedBoundary}"\\r\\n\\r\\n\`;
    rawMessage += \`--\${mixedBoundary}\\r\\n\`;
    rawMessage += \`Content-Type: multipart/alternative; boundary="\${boundary}"\\r\\n\\r\\n\`;
  } else {
    rawMessage += \`Content-Type: multipart/alternative; boundary="\${boundary}"\\r\\n\\r\\n\`;
  }

  // Text part
  if (text) {
    rawMessage += \`--\${boundary}\\r\\n\`;
    rawMessage += "Content-Type: text/plain; charset=UTF-8\\r\\n";
    rawMessage += "Content-Transfer-Encoding: 7bit\\r\\n\\r\\n";
    rawMessage += \`\${text}\\r\\n\`;
  }

  // HTML part
  if (html) {
    rawMessage += \`--\${boundary}\\r\\n\`;
    rawMessage += "Content-Type: text/html; charset=UTF-8\\r\\n";
    rawMessage += "Content-Transfer-Encoding: 7bit\\r\\n\\r\\n";
    rawMessage += \`\${html}\\r\\n\`;
  }

  rawMessage += \`--\${boundary}--\\r\\n\`;

  // Attachments
  if (attachments && attachments.length > 0) {
    for (const attachment of attachments) {
      rawMessage += \`--\${mixedBoundary}\\r\\n\`;
      rawMessage += \`Content-Type: \${attachment.contentType}; name="\${attachment.filename}"\\r\\n\`;
      rawMessage += "Content-Transfer-Encoding: base64\\r\\n";
      rawMessage += \`Content-Disposition: attachment; filename="\${attachment.filename}"\\r\\n\\r\\n\`;

      const content =
        typeof attachment.content === "string"
          ? attachment.content
          : attachment.content.toString("base64");

      rawMessage += \`\${content}\\r\\n\`;
    }
    rawMessage += \`--\${mixedBoundary}--\\r\\n\`;
  }

  const command = new SendRawEmailCommand({
    RawMessage: {
      Data: Buffer.from(rawMessage),
    },
  });

  try {
    const response = await sesClient.send(command);
    console.log("Raw email sent:", response.MessageId);
    return { success: true, messageId: response.MessageId };
  } catch (error) {
    console.error("Raw email sending error:", error);
    throw error;
  }
}

/**
 * Send multiple emails (note: SES has rate limits, consider using bulk sending for large volumes)
 */
export async function sendBatchEmails(
  emails: Array<{
    to: string | string[];
    subject: string;
    html?: string;
    text?: string;
    from?: string;
  }>
) {
  const results = await Promise.allSettled(
    emails.map((email) => sendEmail(email))
  );

  const successful = results.filter((r) => r.status === "fulfilled").length;
  const failed = results.filter((r) => r.status === "rejected").length;

  console.log(\`Batch emails: \${successful} sent, \${failed} failed\`);

  return {
    success: failed === 0,
    total: emails.length,
    successful,
    failed,
    results: results.map((r, i) => ({
      email: emails[i]?.to,
      status: r.status,
      ...(r.status === "fulfilled" ? { messageId: r.value.messageId } : { error: r.reason }),
    })),
  };
}

/**
 * Get the SES client for advanced usage
 */
export function getSESClient() {
  return sesClient;
}

export { sesClient, SESClient, SendEmailCommand, SendRawEmailCommand };
`],
  ["email/nodemailer/server/base/src/lib/email.ts.hbs", `import nodemailer from "nodemailer";

// Create reusable transporter object using SMTP transport
// For development, you can use services like Mailtrap, Ethereal, or a local SMTP server
// For production, configure with your SMTP provider (Gmail, SendGrid, AWS SES, etc.)
const transporter = nodemailer.createTransport({
  host: process.env.SMTP_HOST || "smtp.ethereal.email",
  port: Number(process.env.SMTP_PORT) || 587,
  secure: process.env.SMTP_SECURE === "true", // true for 465, false for other ports
  auth: {
    user: process.env.SMTP_USER,
    pass: process.env.SMTP_PASS,
  },
});

export interface SendEmailOptions {
  to: string | string[];
  subject: string;
  html?: string;
  text?: string;
  from?: string;
  replyTo?: string;
  attachments?: Array<{
    filename: string;
    content?: string | Buffer;
    path?: string;
    contentType?: string;
  }>;
}

/**
 * Send an email using Nodemailer
 * @see https://nodemailer.com/
 */
export async function sendEmail(options: SendEmailOptions) {
  const { to, subject, html, text, from, replyTo, attachments } = options;

  const fromAddress = from || process.env.SMTP_FROM_EMAIL || "noreply@example.com";

  try {
    const info = await transporter.sendMail({
      from: fromAddress,
      to: Array.isArray(to) ? to.join(", ") : to,
      subject,
      html,
      text,
      replyTo,
      attachments,
    });

    console.log("Email sent:", info.messageId);
    return { success: true, messageId: info.messageId };
  } catch (error) {
    console.error("Email sending error:", error);
    throw error;
  }
}

/**
 * Verify SMTP connection configuration
 * Call this on startup to ensure email sending will work
 */
export async function verifyEmailConnection(): Promise<boolean> {
  try {
    await transporter.verify();
    console.log("SMTP connection verified successfully");
    return true;
  } catch (error) {
    console.error("SMTP connection verification failed:", error);
    return false;
  }
}

/**
 * Get the nodemailer transporter instance for advanced usage
 */
export function getTransporter() {
  return transporter;
}

export { transporter };
`],
  ["email/plunk/server/base/src/lib/email.ts.hbs", `import Plunk from "@plunk/node";

// Initialize Plunk client with secret API key
const plunk = new Plunk(process.env.PLUNK_API_KEY || "");

export interface SendEmailOptions {
  to: string;
  subject: string;
  body: string;
  from?: string;
  name?: string;
  reply?: string;
  headers?: Record<string, string>;
  subscribed?: boolean;
}

/**
 * Send an email using Plunk
 * @see https://docs.useplunk.com/api-reference/emails/send
 */
export async function sendEmail(options: SendEmailOptions) {
  const { to, subject, body, name, reply, headers, subscribed } = options;

  try {
    const success = await plunk.emails.send({
      to,
      subject,
      body,
      name,
      reply,
      headers,
      subscribed,
    });

    if (success) {
      console.log("Email sent successfully to:", to);
      return { success: true };
    }

    return { success: false, error: "Failed to send email" };
  } catch (error) {
    console.error("Email sending error:", error);
    throw error;
  }
}

export interface TrackEventOptions {
  event: string;
  email: string;
  data?: Record<string, string | number | boolean>;
}

/**
 * Track an event for a contact in Plunk
 * Events can trigger automated email sequences (automations)
 * @see https://docs.useplunk.com/api-reference/events/track
 */
export async function trackEvent(options: TrackEventOptions) {
  const { event, email, data } = options;

  try {
    const success = await plunk.events.track({
      event,
      email,
      data,
    });

    if (success) {
      console.log(\`Event "\${event}" tracked for:\`, email);
      return { success: true };
    }

    return { success: false, error: "Failed to track event" };
  } catch (error) {
    console.error("Event tracking error:", error);
    throw error;
  }
}

/**
 * Get the Plunk client instance for advanced usage
 * Useful for accessing contacts API or other advanced features
 */
export function getPlunkClient() {
  return plunk;
}

export { plunk };
`],
  ["email/mailgun/server/base/src/lib/email.ts.hbs", `import Mailgun from "mailgun.js";
import FormData from "form-data";

// Initialize Mailgun client
const mailgun = new Mailgun(FormData);
const mg = mailgun.client({
  username: "api",
  key: process.env.MAILGUN_API_KEY || "",
});

const DOMAIN = process.env.MAILGUN_DOMAIN || "";

export interface SendEmailOptions {
  to: string | string[];
  subject: string;
  html?: string;
  text?: string;
  from?: string;
  replyTo?: string;
  cc?: string | string[];
  bcc?: string | string[];
  attachments?: Array<{
    filename: string;
    data: Buffer | string;
    contentType?: string;
  }>;
  tags?: string[];
  trackingClicks?: boolean;
  trackingOpens?: boolean;
}

/**
 * Send an email using Mailgun
 * @see https://documentation.mailgun.com/en/latest/api-sending-messages.html
 */
export async function sendEmail(options: SendEmailOptions) {
  const {
    to,
    subject,
    html,
    text,
    from,
    replyTo,
    cc,
    bcc,
    attachments,
    tags,
    trackingClicks,
    trackingOpens,
  } = options;

  const fromAddress = from || process.env.MAILGUN_FROM_EMAIL || "noreply@example.com";
  const toAddresses = Array.isArray(to) ? to.join(",") : to;

  try {
    const messageData: Record<string, unknown> = {
      from: fromAddress,
      to: toAddresses,
      subject,
    };

    if (html) messageData.html = html;
    if (text) messageData.text = text;
    if (replyTo) messageData["h:Reply-To"] = replyTo;
    if (cc) messageData.cc = Array.isArray(cc) ? cc.join(",") : cc;
    if (bcc) messageData.bcc = Array.isArray(bcc) ? bcc.join(",") : bcc;
    if (tags) messageData["o:tag"] = tags;
    if (trackingClicks !== undefined) messageData["o:tracking-clicks"] = trackingClicks ? "yes" : "no";
    if (trackingOpens !== undefined) messageData["o:tracking-opens"] = trackingOpens ? "yes" : "no";

    if (attachments && attachments.length > 0) {
      messageData.attachment = attachments.map((att) => ({
        filename: att.filename,
        data: att.data,
        contentType: att.contentType,
      }));
    }

    const response = await mg.messages.create(DOMAIN, messageData);
    console.log("Email sent:", response.id);
    return { success: true, messageId: response.id };
  } catch (error) {
    console.error("Email sending error:", error);
    throw error;
  }
}

/**
 * Send multiple emails in a batch using Mailgun's recipient variables
 * @see https://documentation.mailgun.com/en/latest/user_manual.html#batch-sending
 */
export async function sendBatchEmails(
  emails: Array<{
    to: string;
    subject: string;
    html?: string;
    text?: string;
    variables?: Record<string, string>;
  }>,
  commonOptions?: {
    from?: string;
    tags?: string[];
  }
) {
  const fromAddress =
    commonOptions?.from || process.env.MAILGUN_FROM_EMAIL || "noreply@example.com";

  // Mailgun batch sending uses recipient variables
  const recipients = emails.map((e) => e.to);
  const recipientVariables: Record<string, Record<string, string>> = {};

  for (const email of emails) {
    if (email.variables) {
      recipientVariables[email.to] = email.variables;
    }
  }

  try {
    // For batch emails, we use the first email as template
    const firstEmail = emails[0];
    if (!firstEmail) throw new Error("No emails provided");

    const messageData: Record<string, unknown> = {
      from: fromAddress,
      to: recipients,
      subject: firstEmail.subject,
      "recipient-variables": JSON.stringify(recipientVariables),
    };

    if (firstEmail.html) messageData.html = firstEmail.html;
    if (firstEmail.text) messageData.text = firstEmail.text;
    if (commonOptions?.tags) messageData["o:tag"] = commonOptions.tags;

    const response = await mg.messages.create(DOMAIN, messageData);
    console.log(\`Batch of \${emails.length} emails queued:\`, response.id);
    return { success: true, messageId: response.id };
  } catch (error) {
    console.error("Batch email sending error:", error);
    throw error;
  }
}

/**
 * Send an email using a Mailgun template
 * @see https://documentation.mailgun.com/en/latest/api-sending-messages.html#sending-via-api
 */
export async function sendTemplateEmail(options: {
  to: string | string[];
  template: string;
  variables: Record<string, string>;
  subject?: string;
  from?: string;
  tags?: string[];
}) {
  const { to, template, variables, subject, from, tags } = options;

  const fromAddress = from || process.env.MAILGUN_FROM_EMAIL || "noreply@example.com";
  const toAddresses = Array.isArray(to) ? to.join(",") : to;

  try {
    const messageData: Record<string, unknown> = {
      from: fromAddress,
      to: toAddresses,
      template,
      "h:X-Mailgun-Variables": JSON.stringify(variables),
    };

    if (subject) messageData.subject = subject;
    if (tags) messageData["o:tag"] = tags;

    const response = await mg.messages.create(DOMAIN, messageData);
    console.log("Template email sent:", response.id);
    return { success: true, messageId: response.id };
  } catch (error) {
    console.error("Template email sending error:", error);
    throw error;
  }
}

/**
 * Validate an email address using Mailgun's email validation API
 * Note: This requires the email validation feature to be enabled on your account
 * @see https://documentation.mailgun.com/en/latest/api-email-validation.html
 */
export async function validateEmail(email: string) {
  try {
    const result = await mg.validate.get(email);
    return {
      valid: result.is_valid,
      didYouMean: result.did_you_mean,
      isDisposable: result.is_disposable_address,
      isRoleAddress: result.is_role_address,
    };
  } catch (error) {
    console.error("Email validation error:", error);
    throw error;
  }
}

/**
 * Get the Mailgun client for advanced usage
 */
export function getMailgunClient() {
  return mg;
}

export { mg as mailgun };
`],
  ["email/postmark/server/base/src/lib/email.ts.hbs", `import * as postmark from "postmark";

// Initialize Postmark client with Server API Token
const client = new postmark.ServerClient(process.env.POSTMARK_SERVER_TOKEN || "");

export interface SendEmailOptions {
  to: string | string[];
  subject: string;
  html?: string;
  text?: string;
  from?: string;
  replyTo?: string;
  tag?: string;
  attachments?: Array<{
    name: string;
    content: string; // Base64 encoded content
    contentType: string;
    contentId?: string;
  }>;
}

/**
 * Send an email using Postmark
 * @see https://postmarkapp.com/developer/user-guide/send-email-with-api
 */
export async function sendEmail(options: SendEmailOptions) {
  const { to, subject, html, text, from, replyTo, tag, attachments } = options;

  const fromAddress = from || process.env.POSTMARK_FROM_EMAIL || "noreply@example.com";
  const toAddresses = Array.isArray(to) ? to.join(", ") : to;

  try {
    const response = await client.sendEmail({
      From: fromAddress,
      To: toAddresses,
      Subject: subject,
      HtmlBody: html,
      TextBody: text,
      ReplyTo: replyTo,
      Tag: tag,
      Attachments: attachments?.map((a) => ({
        Name: a.name,
        Content: a.content,
        ContentType: a.contentType,
        ContentID: a.contentId,
      })),
    });

    console.log("Email sent:", response.MessageID);
    return { success: true, messageId: response.MessageID };
  } catch (error) {
    console.error("Email sending error:", error);
    throw error;
  }
}

/**
 * Send an email using a Postmark template
 * @see https://postmarkapp.com/developer/user-guide/send-email-with-templates
 */
export async function sendTemplateEmail(options: {
  to: string | string[];
  templateId: number;
  templateModel: Record<string, unknown>;
  from?: string;
  tag?: string;
}) {
  const { to, templateId, templateModel, from, tag } = options;

  const fromAddress = from || process.env.POSTMARK_FROM_EMAIL || "noreply@example.com";
  const toAddresses = Array.isArray(to) ? to.join(", ") : to;

  try {
    const response = await client.sendEmailWithTemplate({
      From: fromAddress,
      To: toAddresses,
      TemplateId: templateId,
      TemplateModel: templateModel,
      Tag: tag,
    });

    console.log("Template email sent:", response.MessageID);
    return { success: true, messageId: response.MessageID };
  } catch (error) {
    console.error("Template email sending error:", error);
    throw error;
  }
}

/**
 * Send batch emails (up to 500 per batch)
 * @see https://postmarkapp.com/developer/user-guide/send-email-with-api#batch-emails
 */
export async function sendBatchEmails(
  emails: Array<{
    to: string;
    subject: string;
    html?: string;
    text?: string;
    from?: string;
    tag?: string;
  }>
) {
  const fromAddress = process.env.POSTMARK_FROM_EMAIL || "noreply@example.com";

  const messages = emails.map((email) => ({
    From: email.from || fromAddress,
    To: email.to,
    Subject: email.subject,
    HtmlBody: email.html,
    TextBody: email.text,
    Tag: email.tag,
  }));

  try {
    const responses = await client.sendEmailBatch(messages);
    console.log(\`Batch of \${responses.length} emails sent\`);
    return {
      success: true,
      results: responses.map((r) => ({
        messageId: r.MessageID,
        errorCode: r.ErrorCode,
        message: r.Message,
      })),
    };
  } catch (error) {
    console.error("Batch email sending error:", error);
    throw error;
  }
}

/**
 * Get the Postmark client instance for advanced usage
 */
export function getPostmarkClient() {
  return client;
}

export { client };
`],
  ["job-queue/inngest/server/base/src/inngest/client.ts.hbs", `import { Inngest } from "inngest";

/**
 * Inngest client configuration
 * @see https://www.inngest.com/docs
 */
export const inngest = new Inngest({
  id: "{{projectName}}",
  // Event key is optional for local development
  // Required in production - get it at https://app.inngest.com
  eventKey: process.env.INNGEST_EVENT_KEY,
});
`],
  ["job-queue/inngest/server/base/src/inngest/functions.ts.hbs", `import { inngest } from "./client";

/**
 * Example email sending function
 * Triggered by: inngest.send({ name: "app/email.send", data: { to, subject, body } })
 * @see https://www.inngest.com/docs/functions
 */
export const sendEmail = inngest.createFunction(
  {
    id: "send-email",
    // Retry configuration
    retries: 3,
  },
  { event: "app/email.send" },
  async ({ event, step }) => {
    const { to, subject, body, templateId } = event.data;

    // Use steps for reliable execution with automatic retries
    const result = await step.run("send-email", async () => {
      // TODO: Implement your email sending logic here
      // Example with a hypothetical email service:
      // await emailService.send({ to, subject, body, templateId });

      // Simulate email sending
      await new Promise((resolve) => setTimeout(resolve, 1000));

      return {
        sent: true,
        to,
        timestamp: new Date().toISOString(),
      };
    });

    return result;
  }
);

/**
 * Example notification function
 * Supports different notification types: push, in-app, sms
 */
export const sendNotification = inngest.createFunction(
  {
    id: "send-notification",
    retries: 3,
  },
  { event: "app/notification.send" },
  async ({ event, step }) => {
    const { userId, type, title, message, data } = event.data;

    const result = await step.run("send-notification", async () => {
      // TODO: Implement your notification logic here
      // switch (type) {
      //   case "push":
      //     await pushService.send(userId, { title, message, data });
      //     break;
      //   case "in-app":
      //     await inAppNotificationService.create(userId, { title, message, data });
      //     break;
      //   case "sms":
      //     await smsService.send(userId, message);
      //     break;
      // }

      // Simulate notification processing
      await new Promise((resolve) => setTimeout(resolve, 500));

      return {
        sent: true,
        type,
        userId,
        timestamp: new Date().toISOString(),
      };
    });

    return result;
  }
);

/**
 * Example data processing function with multiple steps
 * Demonstrates step-based workflows for complex operations
 */
export const processData = inngest.createFunction(
  {
    id: "process-data",
    retries: 2,
    // Cancel if another run for the same dataId starts
    cancelOn: [
      {
        event: "app/data.cancel",
        match: "data.dataId",
      },
    ],
  },
  { event: "app/data.process" },
  async ({ event, step }) => {
    const { dataId, operation } = event.data;

    // Step 1: Validate input
    await step.run("validate", async () => {
      if (!dataId) {
        throw new Error("Data ID is required");
      }
    });

    // Step 2: Process data based on operation
    const result = await step.run("process", async () => {
      // TODO: Implement your data processing logic here
      // const data = await database.getData(dataId);
      // switch (operation) {
      //   case "transform":
      //     return await transformData(data);
      //   case "aggregate":
      //     return await aggregateData(data);
      //   case "export":
      //     return await exportData(data);
      // }

      // Simulate data processing
      await new Promise((resolve) => setTimeout(resolve, 2000));

      return {
        processed: true,
        dataId,
        operation,
      };
    });

    // Step 3: Send completion notification
    await step.sendEvent("send-completion-notification", {
      name: "app/notification.send",
      data: {
        userId: "system",
        type: "in-app" as const,
        title: "Processing Complete",
        message: \`Data \${dataId} has been \${operation}ed successfully\`,
      },
    });

    return {
      ...result,
      timestamp: new Date().toISOString(),
    };
  }
);

/**
 * Example scheduled function (cron job)
 * Runs every hour - customize the cron pattern as needed
 * @see https://www.inngest.com/docs/guides/scheduled-functions
 */
export const hourlyCleanup = inngest.createFunction(
  { id: "hourly-cleanup" },
  { cron: "0 * * * *" }, // Every hour at minute 0
  async ({ step }) => {
    const result = await step.run("cleanup", async () => {
      // TODO: Implement your cleanup logic here
      // await database.deleteExpiredSessions();
      // await cache.clearStale();

      // Simulate cleanup
      await new Promise((resolve) => setTimeout(resolve, 1000));

      return {
        cleaned: true,
        timestamp: new Date().toISOString(),
      };
    });

    return result;
  }
);

/**
 * Example daily report function with timezone
 * Runs at 9 AM UTC - change timezone as needed
 */
export const dailyReport = inngest.createFunction(
  { id: "daily-report" },
  { cron: "TZ=UTC 0 9 * * *" }, // 9 AM UTC every day
  async ({ step }) => {
    // Step 1: Generate report data
    const reportData = await step.run("generate-report", async () => {
      // TODO: Implement your report generation logic here
      // const stats = await analytics.getDailyStats();
      // return generateReportData(stats);

      // Simulate report generation
      await new Promise((resolve) => setTimeout(resolve, 2000));

      return {
        generatedAt: new Date().toISOString(),
        metrics: {
          users: 100,
          events: 500,
        },
      };
    });

    // Step 2: Send report via email
    await step.sendEvent("send-report-email", {
      name: "app/email.send",
      data: {
        to: "admin@example.com",
        subject: "Daily Report",
        body: \`Daily metrics: \${JSON.stringify(reportData.metrics)}\`,
      },
    });

    return {
      reportGenerated: true,
      timestamp: new Date().toISOString(),
    };
  }
);

/**
 * Example delayed function
 * Demonstrates using step.sleep for delayed execution
 */
export const welcomeSequence = inngest.createFunction(
  { id: "welcome-sequence" },
  { event: "app/user.signup" },
  async ({ event, step }) => {
    const { userId, email, name } = event.data;

    // Send immediate welcome email
    await step.sendEvent("send-welcome", {
      name: "app/email.send",
      data: {
        to: email,
        subject: "Welcome to {{projectName}}!",
        body: \`Hi \${name}, welcome aboard!\`,
      },
    });

    // Wait 1 day before sending tips email
    await step.sleep("wait-1-day", "1d");

    await step.sendEvent("send-tips", {
      name: "app/email.send",
      data: {
        to: email,
        subject: "Getting Started Tips",
        body: \`Hi \${name}, here are some tips to get the most out of {{projectName}}...\`,
      },
    });

    // Wait 3 more days before sending feature highlight
    await step.sleep("wait-3-days", "3d");

    await step.sendEvent("send-features", {
      name: "app/email.send",
      data: {
        to: email,
        subject: "Discover More Features",
        body: \`Hi \${name}, have you tried these features yet?\`,
      },
    });

    return {
      completed: true,
      userId,
      timestamp: new Date().toISOString(),
    };
  }
);

// Export all functions for the serve handler
export const functions = [
  sendEmail,
  sendNotification,
  processData,
  hourlyCleanup,
  dailyReport,
  welcomeSequence,
];
`],
  ["job-queue/inngest/server/base/src/lib/inngest.ts.hbs", `/**
 * Inngest utility functions for triggering events from your backend
 * @see https://www.inngest.com/docs
 */
import { inngest } from "../inngest/client";

// Type definitions for event payloads
export interface EmailPayload {
  to: string;
  subject: string;
  body: string;
  templateId?: string;
}

export interface NotificationPayload {
  userId: string;
  type: "push" | "in-app" | "sms";
  title: string;
  message: string;
  data?: Record<string, unknown>;
}

export interface DataProcessingPayload {
  dataId: string;
  operation: "transform" | "aggregate" | "export";
}

export interface UserSignupPayload {
  userId: string;
  email: string;
  name: string;
}

/**
 * Trigger an email event
 * @example
 * await triggerEmail({
 *   to: "user@example.com",
 *   subject: "Welcome!",
 *   body: "Thanks for signing up."
 * });
 */
export async function triggerEmail(payload: EmailPayload) {
  return inngest.send({
    name: "app/email.send",
    data: payload,
  });
}

/**
 * Trigger a notification event
 * @example
 * await triggerNotification({
 *   userId: "user_123",
 *   type: "push",
 *   title: "New message",
 *   message: "You have a new message!"
 * });
 */
export async function triggerNotification(payload: NotificationPayload) {
  return inngest.send({
    name: "app/notification.send",
    data: payload,
  });
}

/**
 * Trigger a data processing event
 * @example
 * await triggerDataProcessing({
 *   dataId: "data_456",
 *   operation: "transform"
 * });
 */
export async function triggerDataProcessing(payload: DataProcessingPayload) {
  return inngest.send({
    name: "app/data.process",
    data: payload,
  });
}

/**
 * Cancel a running data processing job
 * @example
 * await cancelDataProcessing("data_456");
 */
export async function cancelDataProcessing(dataId: string) {
  return inngest.send({
    name: "app/data.cancel",
    data: { dataId },
  });
}

/**
 * Trigger user signup welcome sequence
 * @example
 * await triggerWelcomeSequence({
 *   userId: "user_123",
 *   email: "user@example.com",
 *   name: "John"
 * });
 */
export async function triggerWelcomeSequence(payload: UserSignupPayload) {
  return inngest.send({
    name: "app/user.signup",
    data: payload,
  });
}

/**
 * Trigger multiple events in a batch
 * @example
 * await triggerEmailBatch([
 *   { to: "user1@example.com", subject: "Hello", body: "Hi!" },
 *   { to: "user2@example.com", subject: "Hello", body: "Hi!" }
 * ]);
 */
export async function triggerEmailBatch(payloads: EmailPayload[]) {
  return inngest.send(
    payloads.map((data) => ({
      name: "app/email.send" as const,
      data,
    }))
  );
}

// Re-export the inngest client for advanced usage
export { inngest };
`],
  ["caching/upstash-redis/server/base/src/lib/cache.ts.hbs", `import { Redis } from "@upstash/redis";

/**
 * Upstash Redis client for serverless caching
 * @see https://upstash.com/docs/redis/overall/getstarted
 */
export const redis = new Redis({
  url: process.env.UPSTASH_REDIS_REST_URL!,
  token: process.env.UPSTASH_REDIS_REST_TOKEN!,
});

/**
 * Cache utilities for common caching patterns
 */

/**
 * Get a cached value by key
 */
export async function cacheGet<T>(key: string): Promise<T | null> {
  return redis.get<T>(key);
}

/**
 * Set a cached value with optional TTL (in seconds)
 */
export async function cacheSet<T>(
  key: string,
  value: T,
  options?: { ex?: number; px?: number; nx?: boolean; xx?: boolean }
): Promise<"OK" | null> {
  if (options?.ex) {
    return redis.set(key, value, { ex: options.ex });
  }
  if (options?.px) {
    return redis.set(key, value, { px: options.px });
  }
  if (options?.nx) {
    return redis.set(key, value, { nx: true });
  }
  if (options?.xx) {
    return redis.set(key, value, { xx: true });
  }
  return redis.set(key, value);
}

/**
 * Delete a cached value
 */
export async function cacheDelete(key: string): Promise<number> {
  return redis.del(key);
}

/**
 * Delete multiple cached values
 */
export async function cacheDeleteMany(keys: string[]): Promise<number> {
  if (keys.length === 0) return 0;
  return redis.del(...keys);
}

/**
 * Check if a key exists in cache
 */
export async function cacheExists(key: string): Promise<boolean> {
  const result = await redis.exists(key);
  return result === 1;
}

/**
 * Set expiration time on a key (in seconds)
 */
export async function cacheExpire(key: string, seconds: number): Promise<boolean> {
  const result = await redis.expire(key, seconds);
  return result === 1;
}

/**
 * Get remaining TTL of a key (in seconds)
 * Returns -1 if key has no expiration, -2 if key doesn't exist
 */
export async function cacheTTL(key: string): Promise<number> {
  return redis.ttl(key);
}

/**
 * Increment a numeric value
 */
export async function cacheIncr(key: string): Promise<number> {
  return redis.incr(key);
}

/**
 * Increment a numeric value by amount
 */
export async function cacheIncrBy(key: string, amount: number): Promise<number> {
  return redis.incrby(key, amount);
}

/**
 * Decrement a numeric value
 */
export async function cacheDecr(key: string): Promise<number> {
  return redis.decr(key);
}

/**
 * Get or set pattern - retrieves from cache or executes function and caches result
 */
export async function cacheGetOrSet<T>(
  key: string,
  fn: () => Promise<T>,
  ttlSeconds?: number
): Promise<T> {
  const cached = await cacheGet<T>(key);
  if (cached !== null) {
    return cached;
  }

  const value = await fn();
  await cacheSet(key, value, ttlSeconds ? { ex: ttlSeconds } : undefined);
  return value;
}

/**
 * Hash operations - useful for storing objects
 */
export const cacheHash = {
  async get<T>(key: string, field: string): Promise<T | null> {
    return redis.hget<T>(key, field);
  },

  async getAll<T extends Record<string, unknown>>(key: string): Promise<T | null> {
    return redis.hgetall<T>(key);
  },

  async set(key: string, field: string, value: unknown): Promise<number> {
    return redis.hset(key, { [field]: value });
  },

  async setMultiple(key: string, values: Record<string, unknown>): Promise<number> {
    return redis.hset(key, values);
  },

  async delete(key: string, ...fields: string[]): Promise<number> {
    return redis.hdel(key, ...fields);
  },

  async exists(key: string, field: string): Promise<boolean> {
    const result = await redis.hexists(key, field);
    return result === 1;
  },
};

/**
 * List operations - useful for queues, recent items, etc.
 */
export const cacheList = {
  async push(key: string, ...values: unknown[]): Promise<number> {
    return redis.rpush(key, ...values);
  },

  async unshift(key: string, ...values: unknown[]): Promise<number> {
    return redis.lpush(key, ...values);
  },

  async pop<T>(key: string): Promise<T | null> {
    return redis.rpop<T>(key);
  },

  async shift<T>(key: string): Promise<T | null> {
    return redis.lpop<T>(key);
  },

  async range<T>(key: string, start: number, stop: number): Promise<T[]> {
    return redis.lrange<T>(key, start, stop);
  },

  async length(key: string): Promise<number> {
    return redis.llen(key);
  },

  async trim(key: string, start: number, stop: number): Promise<"OK"> {
    return redis.ltrim(key, start, stop);
  },
};

/**
 * Set operations - useful for unique collections, tags, etc.
 */
export const cacheSet_ = {
  async add(key: string, ...members: unknown[]): Promise<number> {
    return redis.sadd(key, ...members);
  },

  async remove(key: string, ...members: unknown[]): Promise<number> {
    return redis.srem(key, ...members);
  },

  async members<T>(key: string): Promise<T[]> {
    return redis.smembers<T>(key);
  },

  async isMember(key: string, member: unknown): Promise<boolean> {
    const result = await redis.sismember(key, member);
    return result === 1;
  },

  async size(key: string): Promise<number> {
    return redis.scard(key);
  },
};

/**
 * JSON operations - for complex data structures
 * Note: Requires Upstash Redis with JSON module enabled
 */
export const cacheJson = {
  async get<T>(key: string, path = "$"): Promise<T | null> {
    const result = await redis.json.get<T>(key, path);
    return result;
  },

  async set(key: string, path: string, value: unknown): Promise<"OK" | null> {
    return redis.json.set(key, path, value);
  },

  async delete(key: string, path = "$"): Promise<number> {
    return redis.json.del(key, path);
  },
};
`],
  ["frontend/redwood/api/src/services/posts/posts.ts", `import type { QueryResolvers, MutationResolvers } from "types/graphql";

import { db } from "src/lib/db";

export const posts: QueryResolvers["posts"] = () => {
  return db.post.findMany();
};

export const post: QueryResolvers["post"] = ({ id }) => {
  return db.post.findUnique({
    where: { id },
  });
};

export const createPost: MutationResolvers["createPost"] = ({ input }) => {
  return db.post.create({
    data: input,
  });
};

export const updatePost: MutationResolvers["updatePost"] = ({ id, input }) => {
  return db.post.update({
    data: input,
    where: { id },
  });
};

export const deletePost: MutationResolvers["deletePost"] = ({ id }) => {
  return db.post.delete({
    where: { id },
  });
};
`],
  ["frontend/redwood/web/src/pages/FatalErrorPage/FatalErrorPage.tsx", `// This page will be rendered when an error makes it all the way to the top of the
// application without being handled by a Javascript catch statement.
// https://redwoodjs.com/docs/app-configuration-redwood-toml#handleuncaughtexception

export default () => (
  <main>
    <style
      dangerouslySetInnerHTML={{
        __html: \`
          html, body {
            margin: 0;
          }
          html * {
            box-sizing: border-box;
          }
          main {
            display: flex;
            align-items: center;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
            text-align: center;
            background-color: #0f172a;
            color: #f8fafc;
            height: 100vh;
          }
          section {
            background-color: #1e293b;
            border-radius: 0.25rem;
            width: 32rem;
            padding: 1rem;
            margin: 0 auto;
            box-shadow: 0 1px 3px rgba(0,0,0,0.5);
          }
          h1 {
            font-size: 2rem;
            margin: 0;
            font-weight: 500;
            line-height: 1;
            color: #ef4444;
          }
          p {
            color: #94a3b8;
          }
        \`,
      }}
    />
    <section>
      <h1>
        <span>Something went wrong</span>
      </h1>
      <p>
        Sorry, something went wrong. Please try refreshing the page or contact support if the
        problem persists.
      </p>
    </section>
  </main>
);
`],
  ["frontend/redwood/web/src/pages/HomePage/HomePage.tsx.hbs", `import { Link, routes } from '@redwoodjs/router'
import { Metadata } from '@redwoodjs/web'

const HomePage = () => {
  return (
    <>
      <Metadata title="Home" description="Home page" />

      <main{{#if (eq cssFramework "tailwind")}} className="min-h-screen bg-slate-900 text-slate-100 flex flex-col items-center justify-center p-8"{{/if}}>
        <div{{#if (eq cssFramework "tailwind")}} className="max-w-4xl mx-auto text-center"{{/if}}>
          <h1{{#if (eq cssFramework "tailwind")}} className="text-5xl font-bold text-cyan-400 mb-6"{{/if}}>
            Welcome to RedwoodJS
          </h1>
          <p{{#if (eq cssFramework "tailwind")}} className="text-xl text-slate-300 mb-8"{{/if}}>
            Built with the Better T Stack
          </p>

          <div{{#if (eq cssFramework "tailwind")}} className="grid grid-cols-1 md:grid-cols-3 gap-6 mt-12"{{/if}}>
            <div{{#if (eq cssFramework "tailwind")}} className="bg-slate-800 p-6 rounded-lg border border-slate-700"{{/if}}>
              <h3{{#if (eq cssFramework "tailwind")}} className="text-lg font-semibold text-cyan-400 mb-2"{{/if}}>
                React Frontend
              </h3>
              <p{{#if (eq cssFramework "tailwind")}} className="text-slate-400 text-sm"{{/if}}>
                Modern React with file-based routing and Cells for data fetching.
              </p>
            </div>

            <div{{#if (eq cssFramework "tailwind")}} className="bg-slate-800 p-6 rounded-lg border border-slate-700"{{/if}}>
              <h3{{#if (eq cssFramework "tailwind")}} className="text-lg font-semibold text-cyan-400 mb-2"{{/if}}>
                GraphQL API
              </h3>
              <p{{#if (eq cssFramework "tailwind")}} className="text-slate-400 text-sm"{{/if}}>
                Type-safe GraphQL with auto-generated types and SDL-first schema.
              </p>
            </div>

            <div{{#if (eq cssFramework "tailwind")}} className="bg-slate-800 p-6 rounded-lg border border-slate-700"{{/if}}>
              <h3{{#if (eq cssFramework "tailwind")}} className="text-lg font-semibold text-cyan-400 mb-2"{{/if}}>
                Prisma ORM
              </h3>
              <p{{#if (eq cssFramework "tailwind")}} className="text-slate-400 text-sm"{{/if}}>
                Database access made easy with Prisma and automatic migrations.
              </p>
            </div>
          </div>

          <div{{#if (eq cssFramework "tailwind")}} className="mt-12"{{/if}}>
            <a
              href="https://redwoodjs.com/docs"
              target="_blank"
              rel="noopener noreferrer"
              {{#if (eq cssFramework "tailwind")}}className="inline-block bg-cyan-500 text-slate-900 px-6 py-3 rounded-lg font-semibold hover:bg-cyan-400 transition-colors"{{/if}}
            >
              Read the Docs
            </a>
          </div>
        </div>
      </main>
    </>
  )
}

export default HomePage
`],
  ["frontend/redwood/web/src/pages/NotFoundPage/NotFoundPage.tsx", `export default () => (
  <main>
    <style
      dangerouslySetInnerHTML={{
        __html: \`
          html, body {
            margin: 0;
          }
          html * {
            box-sizing: border-box;
          }
          main {
            display: flex;
            align-items: center;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
            text-align: center;
            background-color: #0f172a;
            color: #f8fafc;
            height: 100vh;
          }
          section {
            background-color: #1e293b;
            border-radius: 0.25rem;
            width: 32rem;
            padding: 1rem;
            margin: 0 auto;
            box-shadow: 0 1px 3px rgba(0,0,0,0.5);
          }
          h1 {
            font-size: 2rem;
            margin: 0;
            font-weight: 500;
            line-height: 1;
            color: #38bdf8;
          }
        \`,
      }}
    />
    <section>
      <h1>
        <span>404 Page Not Found</span>
      </h1>
    </section>
  </main>
);
`],
  ["frontend/redwood/api/src/directives/skipAuth/skipAuth.ts", `import { createValidatorDirective } from "@redwoodjs/graphql-server";
import gql from "graphql-tag";

export const schema = gql\`
  """
  Use to skip authentication checks and allow public access.
  """
  directive @skipAuth on FIELD_DEFINITION
\`;

const skipAuth = createValidatorDirective(schema, () => {
  return;
});

export default skipAuth;
`],
  ["frontend/redwood/api/src/directives/requireAuth/requireAuth.ts", `import type { ValidatorDirectiveFunc } from "@redwoodjs/graphql-server";

import { createValidatorDirective } from "@redwoodjs/graphql-server";
import gql from "graphql-tag";
import { requireAuth as applicationRequireAuth } from "src/lib/auth";

export const schema = gql\`
  """
  Use to check whether or not a user is authenticated and is associated
  with an optional set of roles.
  """
  directive @requireAuth(roles: [String]) on FIELD_DEFINITION
\`;

type RequireAuthValidate = ValidatorDirectiveFunc<{ roles?: string[] }>;

const validate: RequireAuthValidate = ({ directiveArgs }) => {
  const { roles } = directiveArgs;
  applicationRequireAuth({ roles });
};

const requireAuth = createValidatorDirective(schema, validate);

export default requireAuth;
`],
  ["frontend/native/unistyles/app/(drawer)/(tabs)/_layout.tsx.hbs", `import { Tabs } from "expo-router";
import { useUnistyles } from "react-native-unistyles";

import { TabBarIcon } from "@/components/tabbar-icon";

export default function TabLayout() {
  const { theme } = useUnistyles();

  return (
    <Tabs
      screenOptions=\\{{
        headerShown: false,
        tabBarActiveTintColor: theme.colors.primary,
        tabBarInactiveTintColor: theme.colors.mutedForeground,
        tabBarStyle: {
          backgroundColor: theme.colors.background,
          borderTopColor: theme.colors.border,
        },
      }}
    >
      <Tabs.Screen
        name="index"
        options=\\{{
          title: "Home",
          tabBarIcon: ({ color }) => <TabBarIcon name="home" color={color} />,
        }}
      />
      <Tabs.Screen
        name="two"
        options=\\{{
          title: "Explore",
          tabBarIcon: ({ color }) => (
            <TabBarIcon name="compass" color={color} />
          ),
        }}
      />
    </Tabs>
  );
}
`],
  ["frontend/native/unistyles/app/(drawer)/(tabs)/two.tsx.hbs", `import { Container } from "@/components/container";
import { ScrollView, Text, View } from "react-native";
import { StyleSheet } from "react-native-unistyles";

export default function TabTwo() {
  return (
    <Container>
      <ScrollView contentContainerStyle={styles.container}>
        <View style={styles.headerSection}>
          <Text style={styles.title}>Tab Two</Text>
          <Text style={styles.subtitle}>
            Discover more features and content
          </Text>
        </View>
      </ScrollView>
    </Container>
  );
}

const styles = StyleSheet.create((theme) => ({
  container: {
    padding: theme.spacing.lg,
  },
  headerSection: {
    paddingVertical: theme.spacing.xl,
  },
  title: {
    fontSize: theme.fontSize["3xl"],
    fontWeight: "bold",
    color: theme.colors.foreground,
    marginBottom: theme.spacing.sm,
  },
  subtitle: {
    fontSize: theme.fontSize.lg,
    color: theme.colors.mutedForeground,
  },
}));
`],
  ["frontend/native/unistyles/app/(drawer)/(tabs)/index.tsx.hbs", `import { Container } from "@/components/container";
import { ScrollView, Text, View } from "react-native";
import { StyleSheet } from "react-native-unistyles";

export default function Home() {
  return (
    <Container>
      <ScrollView contentContainerStyle={styles.container}>
        <View style={styles.headerSection}>
          <Text style={styles.title}>Tab One</Text>
          <Text style={styles.subtitle}>
            Explore the first section of your app
          </Text>
        </View>
      </ScrollView>
    </Container>
  );
}

const styles = StyleSheet.create((theme) => ({
  container: {
    padding: theme.spacing.lg,
  },
  headerSection: {
    paddingVertical: theme.spacing.xl,
  },
  title: {
    fontSize: theme.fontSize["3xl"],
    fontWeight: "bold",
    color: theme.colors.foreground,
    marginBottom: theme.spacing.sm,
  },
  subtitle: {
    fontSize: theme.fontSize.lg,
    color: theme.colors.mutedForeground,
  },
}));
`],
  ["frontend/angular/src/app/pages/home/home.component.ts.hbs", `import { Component } from '@angular/core';

@Component({
  selector: 'app-home',
  standalone: true,
  template: \`
    {{#if (eq cssFramework "tailwind")}}
    <div class="container mx-auto max-w-3xl px-4 py-2">
      <pre class="overflow-x-auto font-mono text-sm whitespace-pre">{{ titleText }}</pre>
      <div class="grid gap-6 mt-6">
        <section class="rounded-lg border border-gray-200 dark:border-gray-800 p-4">
          <h2 class="mb-2 font-medium">Welcome to Angular</h2>
          <p class="text-sm text-gray-600 dark:text-gray-400">
            Angular is a platform and framework for building single-page client applications
            using HTML and TypeScript. It implements core and optional functionality as a
            set of TypeScript libraries that you import into your applications.
          </p>
        </section>
        <section class="rounded-lg border border-gray-200 dark:border-gray-800 p-4">
          <h2 class="mb-2 font-medium">Key Features</h2>
          <ul class="list-disc list-inside text-sm text-gray-600 dark:text-gray-400 space-y-1">
            <li>Standalone components - No NgModule required</li>
            <li>Signals - Fine-grained reactivity</li>
            <li>Built-in routing and forms</li>
            <li>Dependency injection</li>
          </ul>
        </section>
      </div>
    </div>
    {{else}}
    <div [style.maxWidth]="'48rem'" [style.margin]="'0 auto'" [style.padding]="'0.5rem 1rem'">
      <pre [style.overflow]="'auto'" [style.fontFamily]="'monospace'" [style.fontSize]="'0.875rem'" [style.whiteSpace]="'pre'">{{ titleText }}</pre>
      <div [style.display]="'grid'" [style.gap]="'1.5rem'" [style.marginTop]="'1.5rem'">
        <section [style.borderRadius]="'0.5rem'" [style.border]="'1px solid var(--border-color)'" [style.padding]="'1rem'">
          <h2 [style.marginBottom]="'0.5rem'" [style.fontWeight]="500">Welcome to Angular</h2>
          <p [style.fontSize]="'0.875rem'" [style.color]="'var(--muted-color)'">
            Angular is a platform and framework for building single-page client applications
            using HTML and TypeScript. It implements core and optional functionality as a
            set of TypeScript libraries that you import into your applications.
          </p>
        </section>
        <section [style.borderRadius]="'0.5rem'" [style.border]="'1px solid var(--border-color)'" [style.padding]="'1rem'">
          <h2 [style.marginBottom]="'0.5rem'" [style.fontWeight]="500">Key Features</h2>
          <ul [style.fontSize]="'0.875rem'" [style.color]="'var(--muted-color)'" [style.listStyleType]="'disc'" [style.paddingLeft]="'1.5rem'">
            <li>Standalone components - No NgModule required</li>
            <li>Signals - Fine-grained reactivity</li>
            <li>Built-in routing and forms</li>
            <li>Dependency injection</li>
          </ul>
        </section>
      </div>
    </div>
    {{/if}}
  \`,
})
export class HomeComponent {
  titleText = \`
 \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2557 \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2557\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2557\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2557\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2557\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2557
 \\u2588\\u2588\\u2554\\u2550\\u2550\\u2588\\u2588\\u2557\\u2588\\u2588\\u2554\\u2550\\u2550\\u2550\\u2550\\u255D\\u255A\\u2550\\u2550\\u2588\\u2588\\u2554\\u2550\\u2550\\u255D\\u255A\\u2550\\u2550\\u2588\\u2588\\u2554\\u2550\\u2550\\u255D\\u2588\\u2588\\u2554\\u2550\\u2550\\u2550\\u2550\\u255D\\u2588\\u2588\\u2554\\u2550\\u2550\\u2588\\u2588\\u2557
 \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2554\\u255D\\u2588\\u2588\\u2588\\u2588\\u2588\\u2557     \\u2588\\u2588\\u2551      \\u2588\\u2588\\u2551   \\u2588\\u2588\\u2588\\u2588\\u2588\\u2557  \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2554\\u255D
 \\u2588\\u2588\\u2554\\u2550\\u2550\\u2588\\u2588\\u2557\\u2588\\u2588\\u2554\\u2550\\u2550\\u255D     \\u2588\\u2588\\u2551      \\u2588\\u2588\\u2551   \\u2588\\u2588\\u2554\\u2550\\u2550\\u255D  \\u2588\\u2588\\u2554\\u2550\\u2550\\u2588\\u2588\\u2557
 \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2554\\u255D\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2557   \\u2588\\u2588\\u2551      \\u2588\\u2588\\u2551   \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2557\\u2588\\u2588\\u2551  \\u2588\\u2588\\u2557
 \\u255A\\u2550\\u2550\\u2550\\u2550\\u2550\\u255D \\u255A\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u255D   \\u255A\\u2550\\u255D      \\u255A\\u2550\\u255D   \\u255A\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u255D\\u255A\\u2550\\u255D  \\u255A\\u2550\\u255D

 \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2557    \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2557\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2557 \\u2588\\u2588\\u2588\\u2588\\u2588\\u2557  \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2557\\u2588\\u2588\\u2557  \\u2588\\u2588\\u2557
 \\u255A\\u2550\\u2550\\u2588\\u2588\\u2554\\u2550\\u2550\\u255D    \\u2588\\u2588\\u2554\\u2550\\u2550\\u2550\\u2550\\u255D\\u255A\\u2550\\u2550\\u2588\\u2588\\u2554\\u2550\\u2550\\u255D\\u2588\\u2588\\u2554\\u2550\\u2550\\u2588\\u2588\\u2557\\u2588\\u2588\\u2554\\u2550\\u2550\\u2550\\u2550\\u255D\\u2588\\u2588\\u2551 \\u2588\\u2588\\u2554\\u255D
    \\u2588\\u2588\\u2551       \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2557   \\u2588\\u2588\\u2551   \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2551\\u2588\\u2588\\u2551     \\u2588\\u2588\\u2588\\u2588\\u2588\\u2554\\u255D
    \\u2588\\u2588\\u2551       \\u255A\\u2550\\u2550\\u2550\\u2550\\u2588\\u2588\\u2551   \\u2588\\u2588\\u2551   \\u2588\\u2588\\u2554\\u2550\\u2550\\u2588\\u2588\\u2551\\u2588\\u2588\\u2551     \\u2588\\u2588\\u2554\\u2550\\u2588\\u2588\\u2557
    \\u2588\\u2588\\u2551       \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2551   \\u2588\\u2588\\u2551   \\u2588\\u2588\\u2551  \\u2588\\u2588\\u2551\\u255A\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2557\\u2588\\u2588\\u2551  \\u2588\\u2588\\u2557
    \\u255A\\u2550\\u255D       \\u255A\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u255D   \\u255A\\u2550\\u255D   \\u255A\\u2550\\u255D  \\u255A\\u2550\\u255D \\u255A\\u2550\\u2550\\u2550\\u2550\\u2550\\u255D\\u255A\\u2550\\u255D  \\u255A\\u2550\\u255D
\`;
}
`],
  ["frontend/native/uniwind/app/(drawer)/(tabs)/_layout.tsx.hbs", `import { Tabs } from "expo-router";
import { Ionicons } from "@expo/vector-icons";
import { useThemeColor } from "heroui-native";

export default function TabLayout() {
	const themeColorForeground = useThemeColor("foreground");
	const themeColorBackground = useThemeColor("background");

	return (
		<Tabs
			screenOptions=\\{{
				headerShown: false,
				headerStyle: {
					backgroundColor: themeColorBackground,
				},
				headerTintColor: themeColorForeground,
				headerTitleStyle: {
					color: themeColorForeground,
					fontWeight: "600",
				},
				tabBarStyle: {
					backgroundColor: themeColorBackground,
				},
			}}
		>
			<Tabs.Screen
				name="index"
				options=\\{{
					title: "Home",
					tabBarIcon: ({ color, size }: { color: string; size: number }) => (
						<Ionicons name="home" size={size} color={color} />
					),
				}}
			/>
			<Tabs.Screen
				name="two"
				options=\\{{
					title: "Explore",
					tabBarIcon: ({ color, size }: { color: string; size: number }) => (
						<Ionicons name="compass" size={size} color={color} />
					),
				}}
			/>
		</Tabs>
	);
}
`],
  ["frontend/native/uniwind/app/(drawer)/(tabs)/two.tsx.hbs", `import { Container } from "@/components/container";
import { Text, View } from "react-native";
import { Card } from "heroui-native";

export default function TabTwo() {
	return (
		<Container className="p-6">
			<View className="flex-1 justify-center items-center">
				<Card variant="secondary" className="p-8 items-center">
					<Card.Title className="text-3xl mb-2">TabTwo</Card.Title>
				</Card>
			</View>
		</Container>
	);
}
`],
  ["frontend/native/uniwind/app/(drawer)/(tabs)/index.tsx.hbs", `import { Container } from "@/components/container";
import { Text, View } from "react-native";
import { Card } from "heroui-native";

export default function Home() {
	return (
		<Container className="p-6">
			<View className="flex-1 justify-center items-center">
				<Card variant="secondary" className="p-8 items-center">
					<Card.Title className="text-3xl mb-2">Tab One</Card.Title>
				</Card>
			</View>
		</Container>
	);
}
`],
  ["frontend/native/bare/app/(drawer)/(tabs)/_layout.tsx.hbs", `import { TabBarIcon } from "@/components/tabbar-icon";
import { useColorScheme } from "@/lib/use-color-scheme";
import { Tabs } from "expo-router";
import { NAV_THEME } from "@/lib/constants";

export default function TabLayout() {
  const { isDarkColorScheme } = useColorScheme();
  const theme = isDarkColorScheme ? NAV_THEME.dark : NAV_THEME.light;

  return (
    <Tabs
      screenOptions=\\{{
        headerShown: false,
        tabBarActiveTintColor: theme.primary,
        tabBarInactiveTintColor: theme.text,
        tabBarStyle: {
          backgroundColor: theme.background,
          borderTopColor: theme.border,
        },
      }}
    >
      <Tabs.Screen
        name="index"
        options=\\{{
          title: "Home",
          tabBarIcon: ({ color }) => <TabBarIcon name="home" color={color} />,
        }}
      />
      <Tabs.Screen
        name="two"
        options=\\{{
          title: "Explore",
          tabBarIcon: ({ color }) => (
            <TabBarIcon name="compass" color={color} />
          ),
        }}
      />
    </Tabs>
  );
}

`],
  ["frontend/native/bare/app/(drawer)/(tabs)/two.tsx.hbs", `import { Container } from "@/components/container";
import { ScrollView, Text, View, StyleSheet } from "react-native";
import { useColorScheme } from "@/lib/use-color-scheme";
import { NAV_THEME } from "@/lib/constants";

export default function TabTwo() {
  const { colorScheme } = useColorScheme();
  const theme = colorScheme === "dark" ? NAV_THEME.dark : NAV_THEME.light;

  return (
    <Container>
      <ScrollView style={styles.scrollView}>
        <View style={styles.content}>
          <Text style={[styles.title, { color: theme.text }]}>
            Tab Two
          </Text>
          <Text style={[styles.subtitle, { color: theme.text, opacity: 0.7 }]}>
            Discover more features and content
          </Text>
        </View>
      </ScrollView>
    </Container>
  );
}

const styles = StyleSheet.create({
  scrollView: {
    flex: 1,
    padding: 16,
  },
  content: {
    paddingVertical: 16,
  },
  title: {
    fontSize: 24,
    fontWeight: "bold",
    marginBottom: 8,
  },
  subtitle: {
    fontSize: 16,
  },
});

`],
  ["frontend/native/bare/app/(drawer)/(tabs)/index.tsx.hbs", `import { Container } from "@/components/container";
import { ScrollView, Text, View, StyleSheet } from "react-native";
import { useColorScheme } from "@/lib/use-color-scheme";
import { NAV_THEME } from "@/lib/constants";

export default function TabOne() {
  const { colorScheme } = useColorScheme();
  const theme = colorScheme === "dark" ? NAV_THEME.dark : NAV_THEME.light;

  return (
    <Container>
      <ScrollView style={styles.scrollView}>
        <View style={styles.content}>
          <Text style={[styles.title, { color: theme.text }]}>
            Tab One
          </Text>
          <Text style={[styles.subtitle, { color: theme.text, opacity: 0.7 }]}>
            Explore the first section of your app
          </Text>
        </View>
      </ScrollView>
    </Container>
  );
}

const styles = StyleSheet.create({
  scrollView: {
    flex: 1,
    padding: 16,
  },
  content: {
    paddingVertical: 16,
  },
  title: {
    fontSize: 24,
    fontWeight: "bold",
    marginBottom: 8,
  },
  subtitle: {
    fontSize: 16,
  },
});

`],
  ["frontend/react/web-base/src/components/ui/skeleton.tsx.hbs", `import { cn } from "@/lib/utils";

function Skeleton({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      data-slot="skeleton"
      className={cn("bg-muted rounded-none animate-pulse", className)}
      {...props}
    />
  );
}

export { Skeleton };
`],
  ["frontend/react/web-base/src/components/ui/dropdown-menu.tsx.hbs", `import * as React from 'react'
import { Menu as MenuPrimitive } from '@base-ui/react/menu'

import { CheckIcon, ChevronRightIcon } from 'lucide-react'
import { cn } from '@/lib/utils'

function DropdownMenu({ ...props }: MenuPrimitive.Root.Props) {
  return <MenuPrimitive.Root data-slot="dropdown-menu" {...props} />
}

function DropdownMenuPortal({ ...props }: MenuPrimitive.Portal.Props) {
  return <MenuPrimitive.Portal data-slot="dropdown-menu-portal" {...props} />
}

function DropdownMenuTrigger({ ...props }: MenuPrimitive.Trigger.Props) {
  return <MenuPrimitive.Trigger data-slot="dropdown-menu-trigger" {...props} />
}

function DropdownMenuContent({
  align = 'start',
  alignOffset = 0,
  side = 'bottom',
  sideOffset = 4,
  className,
  ...props
}: MenuPrimitive.Popup.Props &
  Pick<
    MenuPrimitive.Positioner.Props,
    'align' | 'alignOffset' | 'side' | 'sideOffset'
  >) {
  return (
    <MenuPrimitive.Portal>
      <MenuPrimitive.Positioner
        className="isolate z-50 outline-none"
        align={align}
        alignOffset={alignOffset}
        side={side}
        sideOffset={sideOffset}
      >
        <MenuPrimitive.Popup
          data-slot="dropdown-menu-content"
          className={cn(
            'data-open:animate-in data-closed:animate-out data-closed:fade-out-0 data-open:fade-in-0 data-closed:zoom-out-95 data-open:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 ring-foreground/10 bg-popover text-popover-foreground min-w-32 rounded-none shadow-md ring-1 duration-100 z-50 max-h-(--available-height) w-(--anchor-width) origin-(--transform-origin) overflow-x-hidden overflow-y-auto outline-none data-closed:overflow-hidden',
            className,
          )}
          {...props}
        />
      </MenuPrimitive.Positioner>
    </MenuPrimitive.Portal>
  )
}

function DropdownMenuGroup({ ...props }: MenuPrimitive.Group.Props) {
  return <MenuPrimitive.Group data-slot="dropdown-menu-group" {...props} />
}

function DropdownMenuLabel({
  className,
  inset,
  ...props
}: MenuPrimitive.GroupLabel.Props & {
  inset?: boolean
}) {
  return (
    <MenuPrimitive.GroupLabel
      data-slot="dropdown-menu-label"
      data-inset={inset}
      className={cn(
        'text-muted-foreground px-2 py-2 text-xs data-[inset]:pl-8',
        className,
      )}
      {...props}
    />
  )
}

function DropdownMenuItem({
  className,
  inset,
  variant = 'default',
  ...props
}: MenuPrimitive.Item.Props & {
  inset?: boolean
  variant?: 'default' | 'destructive'
}) {
  return (
    <MenuPrimitive.Item
      data-slot="dropdown-menu-item"
      data-inset={inset}
      data-variant={variant}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:text-destructive not-data-[variant=destructive]:focus:**:text-accent-foreground gap-2 rounded-none px-2 py-2 text-xs [&_svg:not([class*='size-'])]:size-4 group/dropdown-menu-item relative flex cursor-default items-center outline-hidden select-none data-disabled:pointer-events-none data-disabled:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0",
        className,
      )}
      {...props}
    />
  )
}

function DropdownMenuSub({ ...props }: MenuPrimitive.SubmenuRoot.Props) {
  return <MenuPrimitive.SubmenuRoot data-slot="dropdown-menu-sub" {...props} />
}

function DropdownMenuSubTrigger({
  className,
  inset,
  children,
  ...props
}: MenuPrimitive.SubmenuTrigger.Props & {
  inset?: boolean
}) {
  return (
    <MenuPrimitive.SubmenuTrigger
      data-slot="dropdown-menu-sub-trigger"
      data-inset={inset}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-open:bg-accent data-open:text-accent-foreground not-data-[variant=destructive]:focus:**:text-accent-foreground gap-2 rounded-none px-2 py-2 text-xs [&_svg:not([class*='size-'])]:size-4 flex cursor-default items-center outline-hidden select-none data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0",
        className,
      )}
      {...props}
    >
      {children}
      <ChevronRightIcon className="ml-auto" />
    </MenuPrimitive.SubmenuTrigger>
  )
}

function DropdownMenuSubContent({
  align = 'start',
  alignOffset = -3,
  side = 'right',
  sideOffset = 0,
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuContent>) {
  return (
    <DropdownMenuContent
      data-slot="dropdown-menu-sub-content"
      className={cn(
        'data-open:animate-in data-closed:animate-out data-closed:fade-out-0 data-open:fade-in-0 data-closed:zoom-out-95 data-open:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 ring-foreground/10 bg-popover text-popover-foreground min-w-[96px] rounded-none shadow-lg ring-1 duration-100 w-auto',
        className,
      )}
      align={align}
      alignOffset={alignOffset}
      side={side}
      sideOffset={sideOffset}
      {...props}
    />
  )
}

function DropdownMenuCheckboxItem({
  className,
  children,
  checked,
  ...props
}: MenuPrimitive.CheckboxItem.Props) {
  return (
    <MenuPrimitive.CheckboxItem
      data-slot="dropdown-menu-checkbox-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground focus:**:text-accent-foreground gap-2 rounded-none py-2 pr-8 pl-2 text-xs [&_svg:not([class*='size-'])]:size-4 relative flex cursor-default items-center outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0",
        className,
      )}
      checked={checked}
      {...props}
    >
      <span
        className="pointer-events-none absolute right-2 flex items-center justify-center pointer-events-none"
        data-slot="dropdown-menu-checkbox-item-indicator"
      >
        <MenuPrimitive.CheckboxItemIndicator>
          <CheckIcon />
        </MenuPrimitive.CheckboxItemIndicator>
      </span>
      {children}
    </MenuPrimitive.CheckboxItem>
  )
}

function DropdownMenuRadioGroup({ ...props }: MenuPrimitive.RadioGroup.Props) {
  return (
    <MenuPrimitive.RadioGroup
      data-slot="dropdown-menu-radio-group"
      {...props}
    />
  )
}

function DropdownMenuRadioItem({
  className,
  children,
  ...props
}: MenuPrimitive.RadioItem.Props) {
  return (
    <MenuPrimitive.RadioItem
      data-slot="dropdown-menu-radio-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground focus:**:text-accent-foreground gap-2 rounded-none py-2 pr-8 pl-2 text-xs [&_svg:not([class*='size-'])]:size-4 relative flex cursor-default items-center outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0",
        className,
      )}
      {...props}
    >
      <span
        className="pointer-events-none absolute right-2 flex items-center justify-center pointer-events-none"
        data-slot="dropdown-menu-radio-item-indicator"
      >
        <MenuPrimitive.RadioItemIndicator>
          <CheckIcon />
        </MenuPrimitive.RadioItemIndicator>
      </span>
      {children}
    </MenuPrimitive.RadioItem>
  )
}

function DropdownMenuSeparator({
  className,
  ...props
}: MenuPrimitive.Separator.Props) {
  return (
    <MenuPrimitive.Separator
      data-slot="dropdown-menu-separator"
      className={cn('bg-border -mx-1 h-px', className)}
      {...props}
    />
  )
}

function DropdownMenuShortcut({
  className,
  ...props
}: React.ComponentProps<'span'>) {
  return (
    <span
      data-slot="dropdown-menu-shortcut"
      className={cn(
        'text-muted-foreground group-focus/dropdown-menu-item:text-accent-foreground ml-auto text-xs tracking-widest',
        className,
      )}
      {...props}
    />
  )
}

export {
  DropdownMenu,
  DropdownMenuPortal,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuLabel,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuSub,
  DropdownMenuSubTrigger,
  DropdownMenuSubContent,
}
`],
  ["frontend/react/web-base/src/components/ui/label.tsx.hbs", `'use client'

import * as React from 'react'

import { cn } from '@/lib/utils'

function Label({ className, ...props }: React.ComponentProps<'label'>) {
  return (
    <label
      data-slot="label"
      className={cn(
        'gap-2 text-xs leading-none group-data-[disabled=true]:opacity-50 peer-disabled:opacity-50 flex items-center select-none group-data-[disabled=true]:pointer-events-none peer-disabled:cursor-not-allowed',
        className,
      )}
      {...props}
    />
  )
}

export { Label }
`],
  ["frontend/react/web-base/src/components/ui/button.tsx.hbs", `import { Button as ButtonPrimitive } from '@base-ui/react/button'
import {  cva } from 'class-variance-authority'
import type {VariantProps} from 'class-variance-authority';

import { cn } from '@/lib/utils'

const buttonVariants = cva(
  "focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:aria-invalid:border-destructive/50 rounded-none border border-transparent bg-clip-padding text-xs font-medium focus-visible:ring-1 aria-invalid:ring-1 [&_svg:not([class*='size-'])]:size-4 inline-flex items-center justify-center whitespace-nowrap transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none shrink-0 [&_svg]:shrink-0 outline-none group/button select-none",
  {
    variants: {
      variant: {
        default: 'bg-primary text-primary-foreground [a]:hover:bg-primary/80',
        outline:
          'border-border bg-background hover:bg-muted hover:text-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50 aria-expanded:bg-muted aria-expanded:text-foreground',
        secondary:
          'bg-secondary text-secondary-foreground hover:bg-secondary/80 aria-expanded:bg-secondary aria-expanded:text-secondary-foreground',
        ghost:
          'hover:bg-muted hover:text-foreground dark:hover:bg-muted/50 aria-expanded:bg-muted aria-expanded:text-foreground',
        destructive:
          'bg-destructive/10 hover:bg-destructive/20 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/20 text-destructive focus-visible:border-destructive/40 dark:hover:bg-destructive/30',
        link: 'text-primary underline-offset-4 hover:underline',
      },
      size: {
        default:
          'h-8 gap-1.5 px-2.5 has-data-[icon=inline-end]:pr-2 has-data-[icon=inline-start]:pl-2',
        xs: "h-6 gap-1 rounded-none px-2 text-xs has-data-[icon=inline-end]:pr-1.5 has-data-[icon=inline-start]:pl-1.5 [&_svg:not([class*='size-'])]:size-3",
        sm: "h-7 gap-1 rounded-none px-2.5 has-data-[icon=inline-end]:pr-1.5 has-data-[icon=inline-start]:pl-1.5 [&_svg:not([class*='size-'])]:size-3.5",
        lg: 'h-9 gap-1.5 px-2.5 has-data-[icon=inline-end]:pr-3 has-data-[icon=inline-start]:pl-3',
        icon: 'size-8',
        'icon-xs': "size-6 rounded-none [&_svg:not([class*='size-'])]:size-3",
        'icon-sm': 'size-7 rounded-none',
        'icon-lg': 'size-9',
      },
    },
    defaultVariants: {
      variant: 'default',
      size: 'default',
    },
  },
)

function Button({
  className,
  variant = 'default',
  size = 'default',
  ...props
}: ButtonPrimitive.Props & VariantProps<typeof buttonVariants>) {
  return (
    <ButtonPrimitive
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Button, buttonVariants }
`],
  ["frontend/react/web-base/src/components/ui/checkbox.tsx.hbs", `import { Checkbox as CheckboxPrimitive } from '@base-ui/react/checkbox'

import { CheckIcon } from 'lucide-react'
import { cn } from '@/lib/utils'

function Checkbox({ className, ...props }: CheckboxPrimitive.Root.Props) {
  return (
    <CheckboxPrimitive.Root
      data-slot="checkbox"
      className={cn(
        'border-input dark:bg-input/30 data-checked:bg-primary data-checked:text-primary-foreground dark:data-checked:bg-primary data-checked:border-primary aria-invalid:aria-checked:border-primary aria-invalid:border-destructive dark:aria-invalid:border-destructive/50 focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 flex size-4 items-center justify-center rounded-none border transition-colors group-has-disabled/field:opacity-50 focus-visible:ring-1 aria-invalid:ring-1 peer relative shrink-0 outline-none after:absolute after:-inset-x-3 after:-inset-y-2 disabled:cursor-not-allowed disabled:opacity-50',
        className,
      )}
      {...props}
    >
      <CheckboxPrimitive.Indicator
        data-slot="checkbox-indicator"
        className="[&>svg]:size-3.5 grid place-content-center text-current transition-none"
      >
        <CheckIcon />
      </CheckboxPrimitive.Indicator>
    </CheckboxPrimitive.Root>
  )
}

export { Checkbox }
`],
  ["frontend/react/web-base/src/components/ui/input.tsx.hbs", `import * as React from 'react'
import { Input as InputPrimitive } from '@base-ui/react/input'

import { cn } from '@/lib/utils'

function Input({ className, type, ...props }: React.ComponentProps<'input'>) {
  return (
    <InputPrimitive
      type={type}
      data-slot="input"
      className={cn(
        'dark:bg-input/30 border-input focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:aria-invalid:border-destructive/50 disabled:bg-input/50 dark:disabled:bg-input/80 h-8 rounded-none border bg-transparent px-2.5 py-1 text-xs transition-colors file:h-6 file:text-xs file:font-medium focus-visible:ring-1 aria-invalid:ring-1 md:text-xs file:text-foreground placeholder:text-muted-foreground w-full min-w-0 outline-none file:inline-flex file:border-0 file:bg-transparent disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50',
        className,
      )}
      {...props}
    />
  )
}

export { Input }
`],
  ["frontend/react/web-base/src/components/ui/sonner.tsx.hbs", `import { useTheme } from 'next-themes'
import { Toaster as Sonner  } from 'sonner'
import {
  CircleCheckIcon,
  InfoIcon,
  Loader2Icon,
  OctagonXIcon,
  TriangleAlertIcon,
} from 'lucide-react'
import type {ToasterProps} from 'sonner';

const Toaster = ({ ...props }: ToasterProps) => {
  const { theme = 'system' } = useTheme()

  return (
    <Sonner
      theme={theme as ToasterProps['theme']}
      className="toaster group"
      icons=\\{{
        success: <CircleCheckIcon className="size-4" />,
        info: <InfoIcon className="size-4" />,
        warning: <TriangleAlertIcon className="size-4" />,
        error: <OctagonXIcon className="size-4" />,
        loading: <Loader2Icon className="size-4 animate-spin" />,
      }}
      style={
        {
          '--normal-bg': 'var(--popover)',
          '--normal-text': 'var(--popover-foreground)',
          '--normal-border': 'var(--border)',
          '--border-radius': 'var(--radius)',
        } as React.CSSProperties
      }
      toastOptions=\\{{
        classNames: {
          toast: 'cn-toast',
        },
      }}
      {...props}
    />
  )
}

export { Toaster }
`],
  ["frontend/react/web-base/src/components/ui/card.tsx.hbs", `import * as React from 'react'

import { cn } from '@/lib/utils'

function Card({
  className,
  size = 'default',
  ...props
}: React.ComponentProps<'div'> & { size?: 'default' | 'sm' }) {
  return (
    <div
      data-slot="card"
      data-size={size}
      className={cn(
        'ring-foreground/10 bg-card text-card-foreground gap-4 overflow-hidden rounded-none py-4 text-xs/relaxed ring-1 has-data-[slot=card-footer]:pb-0 has-[>img:first-child]:pt-0 data-[size=sm]:gap-2 data-[size=sm]:py-3 data-[size=sm]:has-data-[slot=card-footer]:pb-0 *:[img:first-child]:rounded-none *:[img:last-child]:rounded-none group/card flex flex-col',
        className,
      )}
      {...props}
    />
  )
}

function CardHeader({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="card-header"
      className={cn(
        'gap-1 rounded-none px-4 group-data-[size=sm]/card:px-3 [.border-b]:pb-4 group-data-[size=sm]/card:[.border-b]:pb-3 group/card-header @container/card-header grid auto-rows-min items-start has-data-[slot=card-action]:grid-cols-[1fr_auto] has-data-[slot=card-description]:grid-rows-[auto_auto]',
        className,
      )}
      {...props}
    />
  )
}

function CardTitle({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="card-title"
      className={cn(
        'text-sm font-medium group-data-[size=sm]/card:text-sm',
        className,
      )}
      {...props}
    />
  )
}

function CardDescription({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="card-description"
      className={cn('text-muted-foreground text-xs/relaxed', className)}
      {...props}
    />
  )
}

function CardAction({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="card-action"
      className={cn(
        'col-start-2 row-span-2 row-start-1 self-start justify-self-end',
        className,
      )}
      {...props}
    />
  )
}

function CardContent({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="card-content"
      className={cn('px-4 group-data-[size=sm]/card:px-3', className)}
      {...props}
    />
  )
}

function CardFooter({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="card-footer"
      className={cn(
        'rounded-none border-t p-4 group-data-[size=sm]/card:p-3 flex items-center',
        className,
      )}
      {...props}
    />
  )
}

export {
  Card,
  CardHeader,
  CardFooter,
  CardTitle,
  CardAction,
  CardDescription,
  CardContent,
}
`],
  ["backend/server/nitro/routes/api/auth/[...path].ts.hbs", `{{#if (eq auth "better-auth")}}
import { auth } from "@{{projectName}}/auth";
import { toNodeHandler } from "better-auth/node";

const authHandler = toNodeHandler(auth);

export default defineEventHandler(async (event) => {
	const { req, res } = event.node;
	await authHandler(req, res);
});
{{else}}
// Auth placeholder - Better Auth not configured
export default defineEventHandler(() => {
	return { error: "Auth not configured" };
});
{{/if}}
`],
  ["api/garph/fullstack/astro/src/utils/garph.ts.hbs", `import { QueryClient } from "@tanstack/react-query";
import { createClient, type InferClient } from "@garph/gqty";
import {
  createGeneratedSchema,
  createScalarsEnumsHash,
} from "@garph/gqty/dist/utils";
import {
  g,
  queryType,
  mutationType,
{{#if (includes examples "todo")}}
  todoType,
{{/if}}
} from "@{{projectName}}/api/index";

// Create QueryClient for React Query integration
export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      retry: 2,
      staleTime: 1000 * 60,
    },
  },
});

// Generate schema and scalars for GQty client
const generatedSchema = createGeneratedSchema(g);
const scalarsEnumsHash = createScalarsEnumsHash(g);

// Create type-safe GraphQL client
export const client = createClient<{
  query: InferClient<typeof queryType>;
  mutation: InferClient<typeof mutationType>;
}>({
  generatedSchema,
  scalarsEnumsHash,
  url: "/api/graphql",
{{#if (eq auth "better-auth")}}
  credentials: "include",
{{/if}}
});

// Export typed query and mutation functions
export const { query, mutation, resolved } = client;

// Helper for React Query integration
export async function graphqlFetcher<T>(
  fn: () => T | Promise<T>
): Promise<T> {
  return resolved(fn);
}
`],
  ["api/orpc/web/astro/src/utils/orpc.ts.hbs", `import { createORPCClient } from '@orpc/client';
import { RPCLink } from '@orpc/client/fetch';
import type { appRouter } from '@{{projectName}}/api/routers/index';

const link = new RPCLink({
{{#if (eq backend "self")}}
	url: '/api/rpc',
{{else}}
	url: import.meta.env.PUBLIC_SERVER_URL
		? \`\${import.meta.env.PUBLIC_SERVER_URL}/rpc\`
		: 'http://localhost:3001/rpc',
{{/if}}
	headers: () => ({}),
});

export const client = createORPCClient<typeof appRouter>(link);
`],
  ["api/ts-rest/fullstack/next/src/utils/ts-rest.ts.hbs", `import { QueryClient } from "@tanstack/react-query";
import { initClient, tsRestFetchApi } from "@ts-rest/core";
import { initTsrReactQuery } from "@ts-rest/react-query";
import { contract } from "@{{projectName}}/api/index";

export const queryClient = new QueryClient({
	defaultOptions: {
		queries: {
			retry: 2,
			staleTime: 1000 * 60,
		},
	},
});

const client = initClient(contract, {
	baseUrl: "/api/rest",
	baseHeaders: {},
{{#if (eq auth "better-auth")}}
	credentials: "include",
{{/if}}
	api: tsRestFetchApi,
});

export const tsr = initTsrReactQuery(contract, client);
`],
  ["api/garph/web/astro/src/utils/garph.ts.hbs", `import { createClient, type InferClient } from "@garph/gqty";
import {
  createGeneratedSchema,
  createScalarsEnumsHash,
} from "@garph/gqty/dist/utils";
import {
  g,
  queryType,
  mutationType,
{{#if (includes examples "todo")}}
  todoType,
{{/if}}
} from "@{{projectName}}/api/index";
import { env } from "@{{projectName}}/env/web";

// Generate schema and scalars for GQty client
const generatedSchema = createGeneratedSchema(g);
const scalarsEnumsHash = createScalarsEnumsHash(g);

// Create type-safe GraphQL client
export const client = createClient<{
  query: InferClient<typeof queryType>;
  mutation: InferClient<typeof mutationType>;
}>({
  generatedSchema,
  scalarsEnumsHash,
  url: \`\${env.VITE_SERVER_URL}/graphql\`,
{{#if (eq auth "better-auth")}}
  credentials: "include",
{{/if}}
});

// Export typed query and mutation functions
export const { query, mutation, resolved } = client;

// Helper for fetching data
export async function graphqlFetcher<T>(
  fn: () => T | Promise<T>
): Promise<T> {
  return resolved(fn);
}
`],
  ["api/orpc/web/nuxt/app/plugins/orpc.ts.hbs", `import { defineNuxtPlugin } from '#app'
import type { AppRouterClient } from "@{{projectName}}/api/routers/index";
import { createORPCClient } from '@orpc/client'
import { RPCLink } from '@orpc/client/fetch'
import { createTanstackQueryUtils } from "@orpc/tanstack-query";

export default defineNuxtPlugin(() => {
  const config = useRuntimeConfig();
  const rpcUrl = \`\${config.public.serverUrl}/rpc\`;

  const rpcLink = new RPCLink({
    url: rpcUrl,
    {{#if (eq auth "better-auth")}}
    fetch(url, options) {
        return fetch(url, {
        ...options,
        credentials: "include",
        });
    },
    {{/if}}
  })


  const client: AppRouterClient = createORPCClient(rpcLink)
  const orpcUtils = createTanstackQueryUtils(client)

  return {
    provide: {
      orpc: orpcUtils
    }
  }
})
`],
  ["api/orpc/web/nuxt/app/plugins/vue-query.ts.hbs", `import type {
  DehydratedState,
  VueQueryPluginOptions,
} from '@tanstack/vue-query'
import {
  dehydrate,
  hydrate,
  QueryCache,
  QueryClient,
  VueQueryPlugin,
} from '@tanstack/vue-query'

export default defineNuxtPlugin((nuxt) => {
  const vueQueryState = useState<DehydratedState | null>('vue-query')

  const toast = useToast()

  const queryClient = new QueryClient({
    queryCache: new QueryCache({
      onError: (error) => {
        console.log(error)
        toast.add({
          title: 'Error',
          description: error?.message || 'An unexpected error occurred.',
        })
      },
    }),
  })
  const options: VueQueryPluginOptions = { queryClient }

  nuxt.vueApp.use(VueQueryPlugin, options)

  if (import.meta.server) {
    nuxt.hooks.hook('app:rendered', () => {
      vueQueryState.value = dehydrate(queryClient)
    })
  }

  if (import.meta.client) {
    nuxt.hooks.hook('app:created', () => {
      hydrate(queryClient, vueQueryState.value)
    })
  }
})
`],
  ["api/orpc/web/solid/src/utils/orpc.ts.hbs", `import { createORPCClient } from "@orpc/client";
import { RPCLink } from "@orpc/client/fetch";
import { createTanstackQueryUtils } from "@orpc/tanstack-query";
import { QueryCache, QueryClient } from "@tanstack/solid-query";
import type { AppRouterClient } from "@{{projectName}}/api/routers/index";
import { env } from "@{{projectName}}/env/web";

export const queryClient = new QueryClient({
	queryCache: new QueryCache({
		onError: (error) => {
			console.error(\`Error: \${error.message}\`);
		},
	}),
});

export const link = new RPCLink({
	url: \`\${env.VITE_SERVER_URL}/rpc\`,
{{#if (eq auth "better-auth")}}
	fetch(url, options) {
		return fetch(url, {
			...options,
			credentials: "include",
		});
	},
{{/if}}
});

export const client: AppRouterClient = createORPCClient(link);

export const orpc = createTanstackQueryUtils(client);
`],
  ["api/garph/fullstack/tanstack-start/src/utils/garph.ts.hbs", `import { QueryClient } from "@tanstack/react-query";
import { createClient, type InferClient } from "@garph/gqty";
import {
  createGeneratedSchema,
  createScalarsEnumsHash,
} from "@garph/gqty/dist/utils";
import {
  g,
  queryType,
  mutationType,
{{#if (includes examples "todo")}}
  todoType,
{{/if}}
} from "@{{projectName}}/api/index";

// Create QueryClient for React Query integration
export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      retry: 2,
      staleTime: 1000 * 60,
    },
  },
});

// Generate schema and scalars for GQty client
const generatedSchema = createGeneratedSchema(g);
const scalarsEnumsHash = createScalarsEnumsHash(g);

// Create type-safe GraphQL client
export const client = createClient<{
  query: InferClient<typeof queryType>;
  mutation: InferClient<typeof mutationType>;
}>({
  generatedSchema,
  scalarsEnumsHash,
  url: "/api/graphql",
{{#if (eq auth "better-auth")}}
  credentials: "include",
{{/if}}
});

// Export typed query and mutation functions
export const { query, mutation, resolved } = client;

// Helper for React Query integration
export async function graphqlFetcher<T>(
  fn: () => T | Promise<T>
): Promise<T> {
  return resolved(fn);
}
`],
  ["api/orpc/web/svelte/src/lib/orpc.ts.hbs", `import { PUBLIC_SERVER_URL } from "$env/static/public";
import { createORPCClient } from "@orpc/client";
import { RPCLink } from "@orpc/client/fetch";
import { createTanstackQueryUtils } from "@orpc/tanstack-query";
import { QueryCache, QueryClient } from "@tanstack/svelte-query";
import type { AppRouterClient } from "@{{projectName}}/api/routers/index";

export const queryClient = new QueryClient({
	queryCache: new QueryCache({
		onError: (error) => {
			console.error(\`Error: \${error.message}\`);
		},
	}),
});

export const link = new RPCLink({
	url: \`\${PUBLIC_SERVER_URL}/rpc\`,
	{{#if (eq auth "better-auth")}}
	fetch(url, options) {
		return fetch(url, {
			...options,
			credentials: "include",
		});
	},
	{{/if}}
});

export const client: AppRouterClient = createORPCClient(link);

export const orpc = createTanstackQueryUtils(client);
`],
  ["logging/pino/server/base/src/lib/logger.ts.hbs", `import pino from "pino";
import type { Logger, LoggerOptions } from "pino";

// Log levels: trace, debug, info, warn, error, fatal
const logLevel = (process.env.LOG_LEVEL || "info") as pino.LevelWithSilent;
const isDevelopment = process.env.NODE_ENV !== "production";

// Create logger options
const loggerOptions: LoggerOptions = {
  level: logLevel,
  // Add timestamp formatting
  timestamp: pino.stdTimeFunctions.isoTime,
  // Base context for all logs
  base: {
    env: process.env.NODE_ENV || "development",
  },
};

// Use pino-pretty in development for readable logs
// In production, use raw JSON for better performance and log aggregation
let logger: Logger;

if (isDevelopment && process.env.PINO_PRETTY !== "false") {
  logger = pino({
    ...loggerOptions,
    transport: {
      target: "pino-pretty",
      options: {
        colorize: true,
        translateTime: "SYS:standard",
        ignore: "pid,hostname",
        singleLine: false,
      },
    },
  });
} else {
  logger = pino(loggerOptions);
}

/**
 * Create a child logger with additional context
 * Useful for adding request IDs, user IDs, or other contextual information
 *
 * @example
 * const requestLogger = createChildLogger({ requestId: 'abc123', userId: 'user456' });
 * requestLogger.info('Processing request');
 */
export function createChildLogger(bindings: Record<string, unknown>): Logger {
  return logger.child(bindings);
}

/**
 * Log levels explained:
 * - trace: Most detailed logging, typically disabled in production
 * - debug: Detailed information useful during development
 * - info: General information about application flow
 * - warn: Warning messages for potentially problematic situations
 * - error: Error messages for failures that don't stop the application
 * - fatal: Critical errors that may cause the application to terminate
 *
 * @example
 * logger.info('Server started');
 * logger.info({ port: 3000 }, 'Server started on port');
 * logger.error({ err: error }, 'Failed to process request');
 * logger.debug({ userId, action }, 'User action logged');
 */
export { logger };

export default logger;
`],
  ["api/ts-rest/fullstack/astro/src/utils/ts-rest.ts.hbs", `import { QueryClient } from "@tanstack/react-query";
import { initClient, tsRestFetchApi } from "@ts-rest/core";
import { initTsrReactQuery } from "@ts-rest/react-query";
import { contract } from "@{{projectName}}/api/index";

export const queryClient = new QueryClient({
	defaultOptions: {
		queries: {
			retry: 2,
			staleTime: 1000 * 60,
		},
	},
});

const client = initClient(contract, {
	baseUrl: "/api/rest",
	baseHeaders: {},
{{#if (eq auth "better-auth")}}
	credentials: "include",
{{/if}}
	api: tsRestFetchApi,
});

export const tsr = initTsrReactQuery(contract, client);
`],
  ["api/ts-rest/fullstack/tanstack-start/src/utils/ts-rest.ts.hbs", `import { QueryClient } from "@tanstack/react-query";
import { initClient, tsRestFetchApi } from "@ts-rest/core";
import { initTsrReactQuery } from "@ts-rest/react-query";
import { contract } from "@{{projectName}}/api/index";

export const queryClient = new QueryClient({
	defaultOptions: {
		queries: {
			retry: 2,
			staleTime: 1000 * 60,
		},
	},
});

const client = initClient(contract, {
	baseUrl: "/api/rest",
	baseHeaders: {},
{{#if (eq auth "better-auth")}}
	credentials: "include",
{{/if}}
	api: tsRestFetchApi,
});

export const tsr = initTsrReactQuery(contract, client);
`],
  ["api/garph/fullstack/next/src/utils/garph.ts.hbs", `import { QueryClient } from "@tanstack/react-query";
import { createClient, type InferClient } from "@garph/gqty";
import {
  createGeneratedSchema,
  createScalarsEnumsHash,
} from "@garph/gqty/dist/utils";
import {
  g,
  queryType,
  mutationType,
{{#if (includes examples "todo")}}
  todoType,
{{/if}}
} from "@{{projectName}}/api/index";

// Create QueryClient for React Query integration
export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      retry: 2,
      staleTime: 1000 * 60,
    },
  },
});

// Generate schema and scalars for GQty client
const generatedSchema = createGeneratedSchema(g);
const scalarsEnumsHash = createScalarsEnumsHash(g);

// Create type-safe GraphQL client
export const client = createClient<{
  query: InferClient<typeof queryType>;
  mutation: InferClient<typeof mutationType>;
}>({
  generatedSchema,
  scalarsEnumsHash,
  url: "/api/graphql",
{{#if (eq auth "better-auth")}}
  credentials: "include",
{{/if}}
});

// Export typed query and mutation functions
export const { query, mutation, resolved } = client;

// Helper for React Query integration
export async function graphqlFetcher<T>(
  fn: () => T | Promise<T>
): Promise<T> {
  return resolved(fn);
}
`],
  ["logging/winston/server/base/src/lib/logger.ts.hbs", `import winston from "winston";

// Log levels: error, warn, info, http, verbose, debug, silly
const logLevel = process.env.LOG_LEVEL || "info";
const isDevelopment = process.env.NODE_ENV !== "production";

// Custom format for development with colors
const devFormat = winston.format.combine(
  winston.format.colorize(),
  winston.format.timestamp({ format: "YYYY-MM-DD HH:mm:ss" }),
  winston.format.printf(({ timestamp, level, message, ...meta }) => {
    const metaStr = Object.keys(meta).length ? \` \${JSON.stringify(meta)}\` : "";
    return \`\${timestamp} [\${level}]: \${message}\${metaStr}\`;
  }),
);

// JSON format for production
const prodFormat = winston.format.combine(
  winston.format.timestamp(),
  winston.format.errors({ stack: true }),
  winston.format.json(),
);

// Create logger instance
const logger = winston.createLogger({
  level: logLevel,
  format: isDevelopment ? devFormat : prodFormat,
  defaultMeta: { env: process.env.NODE_ENV || "development" },
  transports: [
    new winston.transports.Console({
      stderrLevels: ["error"],
    }),
  ],
});

/**
 * Create a child logger with additional context
 * Useful for adding request IDs, user IDs, or other contextual information
 *
 * @example
 * const requestLogger = createChildLogger({ requestId: 'abc123', userId: 'user456' });
 * requestLogger.info('Processing request');
 */
export function createChildLogger(bindings: Record<string, unknown>): winston.Logger {
  return logger.child(bindings);
}

/**
 * Log levels explained (npm log levels):
 * - error (0): Error messages for failures that don't stop the application
 * - warn (1): Warning messages for potentially problematic situations
 * - info (2): General information about application flow
 * - http (3): HTTP request logging
 * - verbose (4): More detailed than info
 * - debug (5): Detailed information useful during development
 * - silly (6): Most detailed logging
 *
 * @example
 * logger.info('Server started');
 * logger.info('Server started on port', { port: 3000 });
 * logger.error('Failed to process request', { err: error });
 * logger.debug('User action logged', { userId, action });
 */
export { logger };

export default logger;
`],
  ["addons/pwa/apps/web/vite/public/logo.png", `[Binary file]`],
  ["addons/msw/apps/server/src/mocks/handlers.ts.hbs", `/**
 * MSW (Mock Service Worker) request handlers for server-side testing
 *
 * Define your mock API handlers here. These handlers intercept outgoing
 * HTTP requests during tests, useful for mocking external API calls.
 *
 * @see https://mswjs.io/docs/basics/mocking-responses
 */
import { http, HttpResponse } from "msw";

export const handlers = [
  // Example: Mock an external API call
  http.get("https://api.example.com/data", () => {
    return HttpResponse.json({
      items: [
        { id: "1", name: "Item 1" },
        { id: "2", name: "Item 2" },
      ],
    });
  }),

  // Add more handlers as needed for external API mocking
];
`],
  ["addons/msw/apps/server/src/mocks/server.ts.hbs", `/**
 * MSW Node.js server setup for server-side testing
 *
 * This file sets up the MSW request interception for Node.js environments.
 * Use this in your test setup files (e.g., vitest.setup.ts or jest.setup.ts).
 *
 * @see https://mswjs.io/docs/integrations/node
 */
import { setupServer } from "msw/node";
import { handlers } from "./handlers";

export const server = setupServer(...handlers);
`],
  ["addons/storybook/apps/web/src/stories/Button.stories.ts.hbs", `{{#if (or (eq frontend "tanstack-router") (eq frontend "react-router") (eq frontend "next") (eq frontend "solid"))}}
import type { Meta, StoryObj } from "{{#if (eq frontend "next")}}@storybook/nextjs{{else}}@storybook/react-vite{{/if}}";

// Example Button component for demonstration
// Replace this with your actual component imports
const Button = ({
  primary = false,
  size = "medium",
  label,
  onClick,
}: {
  primary?: boolean;
  size?: "small" | "medium" | "large";
  label: string;
  onClick?: () => void;
}) => {
  const baseStyles = "font-semibold rounded-lg transition-colors";
  const sizeStyles = {
    small: "px-3 py-1.5 text-sm",
    medium: "px-4 py-2 text-base",
    large: "px-6 py-3 text-lg",
  };
  const variantStyles = primary
    ? "bg-blue-600 text-white hover:bg-blue-700"
    : "bg-gray-200 text-gray-900 hover:bg-gray-300";

  return (
    <button
      type="button"
      className={\`\${baseStyles} \${sizeStyles[size]} \${variantStyles}\`}
      onClick={onClick}
    >
      {label}
    </button>
  );
};

const meta: Meta<typeof Button> = {
  title: "Example/Button",
  component: Button,
  parameters: {
    layout: "centered",
  },
  tags: ["autodocs"],
  argTypes: {
    size: {
      control: { type: "select" },
      options: ["small", "medium", "large"],
    },
    onClick: { action: "clicked" },
  },
};

export default meta;
type Story = StoryObj<typeof meta>;

export const Primary: Story = {
  args: {
    primary: true,
    label: "Primary Button",
  },
};

export const Secondary: Story = {
  args: {
    label: "Secondary Button",
  },
};

export const Large: Story = {
  args: {
    size: "large",
    label: "Large Button",
  },
};

export const Small: Story = {
  args: {
    size: "small",
    label: "Small Button",
  },
};
{{else if (eq frontend "nuxt")}}
import type { Meta, StoryObj } from "@storybook/vue3-vite";
import { fn } from "@storybook/test";

// Example Button component for demonstration
const Button = {
  name: "Button",
  props: {
    primary: { type: Boolean, default: false },
    size: { type: String, default: "medium" },
    label: { type: String, required: true },
  },
  emits: ["click"],
  template: \`
    <button
      type="button"
      :class="[
        'font-semibold rounded-lg transition-colors',
        size === 'small' ? 'px-3 py-1.5 text-sm' : size === 'large' ? 'px-6 py-3 text-lg' : 'px-4 py-2 text-base',
        primary ? 'bg-blue-600 text-white hover:bg-blue-700' : 'bg-gray-200 text-gray-900 hover:bg-gray-300'
      ]"
      @click="$emit('click')"
    >
      \\{{ label }}
    </button>
  \`,
};

const meta: Meta<typeof Button> = {
  title: "Example/Button",
  component: Button,
  parameters: {
    layout: "centered",
  },
  tags: ["autodocs"],
  argTypes: {
    size: {
      control: { type: "select" },
      options: ["small", "medium", "large"],
    },
  },
  args: {
    onClick: fn(),
  },
};

export default meta;
type Story = StoryObj<typeof meta>;

export const Primary: Story = {
  args: {
    primary: true,
    label: "Primary Button",
  },
};

export const Secondary: Story = {
  args: {
    label: "Secondary Button",
  },
};
{{else if (eq frontend "svelte")}}
import type { Meta, StoryObj } from "@storybook/svelte-vite";
import { fn } from "@storybook/test";

// Example Button component for demonstration
// In real usage, import your actual Svelte component
const Button = {
  render: (args: { primary?: boolean; size?: string; label: string }) => ({
    Component: {
      // Simplified Svelte-like component representation
      $$: { on_mount: [], on_destroy: [], after_update: [], context: new Map() },
    },
    props: args,
  }),
};

const meta: Meta<typeof Button> = {
  title: "Example/Button",
  component: Button as any,
  parameters: {
    layout: "centered",
  },
  tags: ["autodocs"],
  argTypes: {
    size: {
      control: { type: "select" },
      options: ["small", "medium", "large"],
    },
  },
  args: {
    onClick: fn(),
  },
};

export default meta;
type Story = StoryObj<typeof meta>;

export const Primary: Story = {
  args: {
    primary: true,
    label: "Primary Button",
  },
};

export const Secondary: Story = {
  args: {
    label: "Secondary Button",
  },
};
{{else}}
// Generic Storybook example
import type { Meta, StoryObj } from "@storybook/react-vite";

const Button = ({ label }: { label: string }) => (
  <button type="button">{label}</button>
);

const meta: Meta<typeof Button> = {
  title: "Example/Button",
  component: Button,
};

export default meta;
type Story = StoryObj<typeof meta>;

export const Default: Story = {
  args: {
    label: "Click me",
  },
};
{{/if}}
`],
  ["addons/msw/apps/web/src/mocks/node.ts.hbs", `/**
 * MSW Node.js server setup
 *
 * This file sets up the MSW request interception for Node.js environments.
 * Use this in your test setup files (e.g., vitest.setup.ts or jest.setup.ts).
 *
 * @see https://mswjs.io/docs/integrations/node
 */
import { setupServer } from "msw/node";
import { handlers } from "./handlers";

export const server = setupServer(...handlers);
`],
  ["addons/msw/apps/web/src/mocks/handlers.ts.hbs", `/**
 * MSW (Mock Service Worker) request handlers
 *
 * Define your mock API handlers here. These handlers intercept network requests
 * and return mocked responses, useful for testing and development.
 *
 * @see https://mswjs.io/docs/basics/mocking-responses
 */
import { http, HttpResponse } from "msw";

export const handlers = [
  // Example: Mock a GET request to /api/user
  http.get("/api/user", () => {
    return HttpResponse.json({
      id: "1",
      name: "John Doe",
      email: "john@example.com",
    });
  }),

  // Example: Mock a POST request to /api/login
  http.post("/api/login", async ({ request }) => {
    const body = (await request.json()) as { email: string; password: string };

    if (body.email === "test@example.com" && body.password === "password") {
      return HttpResponse.json({
        success: true,
        token: "mock-jwt-token",
      });
    }

    return HttpResponse.json(
      { success: false, message: "Invalid credentials" },
      { status: 401 }
    );
  }),

  // Add more handlers as needed for your API endpoints
];
`],
  ["addons/msw/apps/web/src/mocks/browser.ts.hbs", `/**
 * MSW browser worker setup
 *
 * This file sets up the MSW service worker for browser environments.
 * Import and start this in your app's entry point for development mocking.
 *
 * @see https://mswjs.io/docs/integrations/browser
 */
import { setupWorker } from "msw/browser";
import { handlers } from "./handlers";

export const worker = setupWorker(...handlers);
`],
  ["payments/paddle/web/react/react-router/src/routes/success.tsx.hbs", `import { useSearchParams } from "react-router";

export default function SuccessPage() {
	const [searchParams] = useSearchParams();
	const transactionId = searchParams.get("transaction_id");

	return (
		<div className="container mx-auto px-4 py-8">
			<h1 className="text-2xl font-bold mb-4">Payment Successful!</h1>
			<p className="text-gray-600 mb-4">
				Thank you for your purchase. Your payment has been processed successfully.
			</p>
			{transactionId && (
				<p className="text-sm text-gray-500">Transaction ID: {transactionId}</p>
			)}
		</div>
	);
}
`],
  ["payments/paddle/web/react/tanstack-start/src/routes/success.tsx.hbs", `import { createFileRoute } from "@tanstack/react-router";

export const Route = createFileRoute("/success")({
	component: SuccessPage,
});

function SuccessPage() {
	const { transaction_id } = Route.useSearch<{ transaction_id?: string }>();

	return (
		<div className="container mx-auto px-4 py-8">
			<h1 className="text-2xl font-bold mb-4">Payment Successful!</h1>
			<p className="text-gray-600 mb-4">
				Thank you for your purchase. Your payment has been processed successfully.
			</p>
			{transaction_id && (
				<p className="text-sm text-gray-500">Transaction ID: {transaction_id}</p>
			)}
		</div>
	);
}
`],
  ["payments/paddle/web/react/tanstack-router/src/routes/success.tsx.hbs", `import { createFileRoute } from "@tanstack/react-router";

export const Route = createFileRoute("/success")({
	component: SuccessPage,
});

function SuccessPage() {
	const { transaction_id } = Route.useSearch<{ transaction_id?: string }>();

	return (
		<div className="container mx-auto px-4 py-8">
			<h1 className="text-2xl font-bold mb-4">Payment Successful!</h1>
			<p className="text-gray-600 mb-4">
				Thank you for your purchase. Your payment has been processed successfully.
			</p>
			{transaction_id && (
				<p className="text-sm text-gray-500">Transaction ID: {transaction_id}</p>
			)}
		</div>
	);
}
`],
  ["payments/paddle/web/svelte/src/routes/success/+page.svelte.hbs", `<script lang="ts">
	import { page } from "$app/stores";

	$: transactionId = $page.url.searchParams.get("transaction_id");
</script>

<div class="container mx-auto px-4 py-8">
	<h1 class="text-2xl font-bold mb-4">Payment Successful!</h1>
	<p class="text-gray-600 mb-4">
		Thank you for your purchase. Your payment has been processed successfully.
	</p>
	{#if transactionId}
		<p class="text-sm text-gray-500">Transaction ID: {transactionId}</p>
	{/if}
</div>
`],
  ["cms/strapi/web/next/src/strapi/lib/client.ts.hbs", `import { strapi } from "@strapi/client";
import { strapiApiUrl, strapiApiToken } from "../env";

// Public client for client-side requests (no auth)
export const strapiClient = strapi({
  baseURL: strapiApiUrl,
});

// Authenticated client for server-side requests
export const strapiServerClient = strapi({
  baseURL: strapiApiUrl,
  auth: strapiApiToken,
});

// Type-safe fetch helper with revalidation support
export async function strapiFetch<T>({
  collection,
  documentId,
  params = {},
  revalidate = 60,
  tags = [],
  useAuth = false,
}: {
  collection: string;
  documentId?: string;
  params?: Record<string, unknown>;
  revalidate?: number | false;
  tags?: string[];
  useAuth?: boolean;
}): Promise<T> {
  const client = useAuth ? strapiServerClient : strapiClient;
  const collectionManager = client.collection(collection);

  // Build fetch options for Next.js caching
  const fetchOptions = {
    next: {
      revalidate: tags.length ? false : revalidate,
      tags,
    },
  };

  if (documentId) {
    // Fetch single document
    const response = await collectionManager.findOne(documentId, {
      ...params,
      ...fetchOptions,
    });
    return response as T;
  }

  // Fetch collection
  const response = await collectionManager.find({
    ...params,
    ...fetchOptions,
  });
  return response as T;
}

// Helper for single-type content
export async function strapiFetchSingle<T>({
  resource,
  params = {},
  revalidate = 60,
  tags = [],
  useAuth = false,
}: {
  resource: string;
  params?: Record<string, unknown>;
  revalidate?: number | false;
  tags?: string[];
  useAuth?: boolean;
}): Promise<T> {
  const client = useAuth ? strapiServerClient : strapiClient;
  const singleManager = client.single(resource);

  const fetchOptions = {
    next: {
      revalidate: tags.length ? false : revalidate,
      tags,
    },
  };

  const response = await singleManager.find({
    ...params,
    ...fetchOptions,
  });
  return response as T;
}
`],
  ["cms/strapi/web/next/src/strapi/lib/media.ts.hbs", `import { strapiUrl } from "../env";
import type { StrapiMedia } from "./types";

// Get full URL for Strapi media
export function getStrapiMediaUrl(media: StrapiMedia | null | undefined): string | null {
  if (!media?.url) return null;

  // If URL is already absolute, return as-is
  if (media.url.startsWith("http://") || media.url.startsWith("https://")) {
    return media.url;
  }

  // Prepend Strapi URL for relative paths
  return \`\${strapiUrl}\${media.url}\`;
}

// Get responsive image URL based on format
export function getStrapiMediaFormat(
  media: StrapiMedia | null | undefined,
  format: "thumbnail" | "small" | "medium" | "large" = "medium"
): string | null {
  if (!media) return null;

  // Try to get the requested format, fallback to original
  const formatData = media.formats?.[format];
  if (formatData?.url) {
    if (formatData.url.startsWith("http://") || formatData.url.startsWith("https://")) {
      return formatData.url;
    }
    return \`\${strapiUrl}\${formatData.url}\`;
  }

  // Fallback to original
  return getStrapiMediaUrl(media);
}

// Get image dimensions
export function getStrapiMediaDimensions(
  media: StrapiMedia | null | undefined,
  format?: "thumbnail" | "small" | "medium" | "large"
): { width: number; height: number } | null {
  if (!media) return null;

  if (format && media.formats?.[format]) {
    const formatData = media.formats[format];
    return {
      width: formatData.width,
      height: formatData.height,
    };
  }

  if (media.width && media.height) {
    return {
      width: media.width,
      height: media.height,
    };
  }

  return null;
}

// Generate srcset for responsive images
export function getStrapiSrcSet(media: StrapiMedia | null | undefined): string | null {
  if (!media?.formats) return null;

  const srcsetParts: string[] = [];
  const formats = ["thumbnail", "small", "medium", "large"] as const;

  for (const format of formats) {
    const formatData = media.formats[format];
    if (formatData?.url && formatData.width) {
      const url =
        formatData.url.startsWith("http://") || formatData.url.startsWith("https://")
          ? formatData.url
          : \`\${strapiUrl}\${formatData.url}\`;
      srcsetParts.push(\`\${url} \${formatData.width}w\`);
    }
  }

  // Add original as largest
  if (media.url && media.width) {
    const url =
      media.url.startsWith("http://") || media.url.startsWith("https://")
        ? media.url
        : \`\${strapiUrl}\${media.url}\`;
    srcsetParts.push(\`\${url} \${media.width}w\`);
  }

  return srcsetParts.length > 0 ? srcsetParts.join(", ") : null;
}
`],
  ["cms/strapi/web/next/src/strapi/lib/queries.ts.hbs", `import qs from "qs";

// Query parameter builders for common Strapi operations

// Build query string for collection fetching with pagination
export function buildCollectionQuery({
  page = 1,
  pageSize = 25,
  sort,
  filters,
  populate,
  fields,
  locale,
  publicationState = "live",
}: {
  page?: number;
  pageSize?: number;
  sort?: string | string[];
  filters?: Record<string, unknown>;
  populate?: string | string[] | Record<string, unknown>;
  fields?: string[];
  locale?: string;
  publicationState?: "live" | "preview";
}): Record<string, unknown> {
  return {
    pagination: { page, pageSize },
    ...(sort && { sort }),
    ...(filters && { filters }),
    ...(populate && { populate }),
    ...(fields && { fields }),
    ...(locale && { locale }),
    publicationState,
  };
}

// Stringify query params for URL
export function stringifyQuery(params: Record<string, unknown>): string {
  return qs.stringify(params, {
    encodeValuesOnly: true,
    arrayFormat: "brackets",
  });
}

// Common populate configurations
export const populateConfigs = {
  // Populate all first-level relations
  all: "*",
  // Deep populate for nested content
  deep: {
    populate: "*",
  },
  // Common blog post populate
  blogPost: {
    author: {
      fields: ["name", "email"],
      populate: {
        avatar: {
          fields: ["url", "alternativeText"],
        },
      },
    },
    featuredImage: {
      fields: ["url", "alternativeText", "width", "height"],
    },
    categories: {
      fields: ["name", "slug"],
    },
    seo: {
      populate: "*",
    },
  },
  // Common page populate
  page: {
    seo: {
      populate: "*",
    },
    blocks: {
      populate: "*",
    },
  },
} as const;

// Common filter builders
export const filterBuilders = {
  // Filter by slug
  bySlug: (slug: string) => ({
    slug: { $eq: slug },
  }),
  // Filter by published status
  published: () => ({
    publishedAt: { $notNull: true },
  }),
  // Filter by category
  byCategory: (categorySlug: string) => ({
    categories: {
      slug: { $eq: categorySlug },
    },
  }),
  // Search by title
  searchTitle: (query: string) => ({
    title: { $containsi: query },
  }),
  // Date range filter
  dateRange: (start: string, end: string) => ({
    publishedAt: {
      $gte: start,
      $lte: end,
    },
  }),
} as const;
`],
  ["cms/strapi/web/next/src/strapi/lib/types.ts.hbs", `// Common Strapi response types

// Pagination metadata from Strapi
export interface StrapiPagination {
  page: number;
  pageSize: number;
  pageCount: number;
  total: number;
}

// Standard Strapi collection response
export interface StrapiCollectionResponse<T> {
  data: T[];
  meta: {
    pagination: StrapiPagination;
  };
}

// Standard Strapi single response
export interface StrapiSingleResponse<T> {
  data: T;
  meta: Record<string, unknown>;
}

// Base Strapi document attributes
export interface StrapiBaseDocument {
  documentId: string;
  createdAt: string;
  updatedAt: string;
  publishedAt: string | null;
  locale?: string;
}

// Media/file type
export interface StrapiMedia {
  id: number;
  documentId: string;
  name: string;
  alternativeText: string | null;
  caption: string | null;
  width: number | null;
  height: number | null;
  formats: {
    thumbnail?: StrapiMediaFormat;
    small?: StrapiMediaFormat;
    medium?: StrapiMediaFormat;
    large?: StrapiMediaFormat;
  } | null;
  hash: string;
  ext: string;
  mime: string;
  size: number;
  url: string;
  previewUrl: string | null;
  provider: string;
}

export interface StrapiMediaFormat {
  name: string;
  hash: string;
  ext: string;
  mime: string;
  width: number;
  height: number;
  size: number;
  url: string;
}

// SEO component type (common in Strapi projects)
export interface StrapiSEO {
  metaTitle?: string;
  metaDescription?: string;
  metaImage?: StrapiMedia;
  keywords?: string;
  canonicalURL?: string;
  metaRobots?: string;
  structuredData?: Record<string, unknown>;
}

// Example content types - customize these for your project

export interface Article extends StrapiBaseDocument {
  title: string;
  slug: string;
  content: string;
  excerpt?: string;
  featuredImage?: StrapiMedia;
  author?: Author;
  categories?: Category[];
  seo?: StrapiSEO;
}

export interface Author extends StrapiBaseDocument {
  name: string;
  email?: string;
  bio?: string;
  avatar?: StrapiMedia;
}

export interface Category extends StrapiBaseDocument {
  name: string;
  slug: string;
  description?: string;
}

export interface Page extends StrapiBaseDocument {
  title: string;
  slug: string;
  content?: string;
  seo?: StrapiSEO;
}

// Homepage single type example
export interface Homepage extends StrapiBaseDocument {
  title: string;
  description?: string;
  heroImage?: StrapiMedia;
  seo?: StrapiSEO;
}
`],
  ["payments/stripe/web/svelte/src/routes/success/+page.svelte.hbs", `<script lang="ts">
	import { page } from '$app/state';

	const session_id = $derived(page.url.searchParams.get('session_id'));
</script>

<div class="container mx-auto px-4 py-8">
	<h1 class="text-2xl font-bold mb-4">Payment Successful!</h1>
	<p class="text-gray-600 mb-4">
		Thank you for your purchase. Your payment has been processed successfully.
	</p>
	{#if session_id}
		<p class="text-sm text-gray-500">Session ID: {session_id}</p>
	{/if}
</div>
`],
  ["payments/stripe/web/react/tanstack-start/src/routes/success.tsx.hbs", `import { createFileRoute, useSearch } from "@tanstack/react-router";

export const Route = createFileRoute("/success")({
	component: SuccessPage,
	validateSearch: (search) => ({
		session_id: search.session_id as string,
	}),
});

function SuccessPage() {
	const { session_id } = useSearch({ from: "/success" });

	return (
		<div className="container mx-auto px-4 py-8">
			<h1 className="text-2xl font-bold mb-4">Payment Successful!</h1>
			<p className="text-gray-600 mb-4">
				Thank you for your purchase. Your payment has been processed successfully.
			</p>
			{session_id && (
				<p className="text-sm text-gray-500">Session ID: {session_id}</p>
			)}
		</div>
	);
}
`],
  ["payments/lemon-squeezy/web/react/tanstack-router/src/routes/success.tsx.hbs", `import { createFileRoute } from "@tanstack/react-router";

export const Route = createFileRoute("/success")({
	component: SuccessPage,
});

function SuccessPage() {
	const { checkout_id } = Route.useSearch();

	return (
		<div className="container mx-auto px-4 py-8">
			<h1 className="text-2xl font-bold mb-4">Payment Successful!</h1>
			<p className="text-gray-600 mb-4">
				Thank you for your purchase. Your payment has been processed successfully.
			</p>
			{checkout_id && (
				<p className="text-sm text-gray-500">Checkout ID: {checkout_id}</p>
			)}
		</div>
	);
}
`],
  ["payments/polar/web/svelte/src/routes/success/+page.svelte.hbs", `<script lang="ts">
	import { page } from '$app/state';
	
	const checkout_id = $derived(page.url.searchParams.get('checkout_id'));
</script>

<div class="container mx-auto px-4 py-8">
	<h1>Payment Successful!</h1>
	{#if checkout_id}
		<p>Checkout ID: {checkout_id}</p>
	{/if}
</div>
`],
  ["payments/stripe/web/react/react-router/src/routes/success.tsx.hbs", `import { useSearchParams } from "react-router";

export default function SuccessPage() {
	const [searchParams] = useSearchParams();
	const session_id = searchParams.get("session_id");

	return (
		<div className="container mx-auto px-4 py-8">
			<h1 className="text-2xl font-bold mb-4">Payment Successful!</h1>
			<p className="text-gray-600 mb-4">
				Thank you for your purchase. Your payment has been processed successfully.
			</p>
			{session_id && (
				<p className="text-sm text-gray-500">Session ID: {session_id}</p>
			)}
		</div>
	);
}
`],
  ["payments/polar/web/react/tanstack-router/src/routes/success.tsx.hbs", `import { createFileRoute, useSearch } from "@tanstack/react-router";

export const Route = createFileRoute("/success")({
	component: SuccessPage,
	validateSearch: (search) => ({
		checkout_id: search.checkout_id as string,
	}),
});

function SuccessPage() {
	const { checkout_id } = useSearch({ from: "/success" });

	return (
		<div className="container mx-auto px-4 py-8">
			<h1>Payment Successful!</h1>
			{checkout_id && <p>Checkout ID: {checkout_id}</p>}
		</div>
	);
}
`],
  ["payments/stripe/web/react/tanstack-router/src/routes/success.tsx.hbs", `import { createFileRoute, useSearch } from "@tanstack/react-router";

export const Route = createFileRoute("/success")({
	component: SuccessPage,
	validateSearch: (search) => ({
		session_id: search.session_id as string,
	}),
});

function SuccessPage() {
	const { session_id } = useSearch({ from: "/success" });

	return (
		<div className="container mx-auto px-4 py-8">
			<h1 className="text-2xl font-bold mb-4">Payment Successful!</h1>
			<p className="text-gray-600 mb-4">
				Thank you for your purchase. Your payment has been processed successfully.
			</p>
			{session_id && (
				<p className="text-sm text-gray-500">Session ID: {session_id}</p>
			)}
		</div>
	);
}
`],
  ["cms/sanity/web/next/src/sanity/schemas/post.ts.hbs", `import { defineField, defineType } from "sanity";

export const post = defineType({
  name: "post",
  title: "Post",
  type: "document",
  fields: [
    defineField({
      name: "title",
      title: "Title",
      type: "string",
      validation: (rule) => rule.required(),
    }),
    defineField({
      name: "slug",
      title: "Slug",
      type: "slug",
      options: {
        source: "title",
        maxLength: 96,
      },
      validation: (rule) => rule.required(),
    }),
    defineField({
      name: "author",
      title: "Author",
      type: "reference",
      to: { type: "author" },
    }),
    defineField({
      name: "mainImage",
      title: "Main image",
      type: "image",
      options: {
        hotspot: true,
      },
    }),
    defineField({
      name: "publishedAt",
      title: "Published at",
      type: "datetime",
    }),
    defineField({
      name: "excerpt",
      title: "Excerpt",
      type: "text",
      rows: 3,
    }),
    defineField({
      name: "body",
      title: "Body",
      type: "blockContent",
    }),
  ],
  preview: {
    select: {
      title: "title",
      author: "author.name",
      media: "mainImage",
    },
    prepare(selection) {
      const { author } = selection;
      return { ...selection, subtitle: author && \`by \${author}\` };
    },
  },
});
`],
  ["cms/sanity/web/next/src/sanity/schemas/author.ts.hbs", `import { defineField, defineType } from "sanity";

export const author = defineType({
  name: "author",
  title: "Author",
  type: "document",
  fields: [
    defineField({
      name: "name",
      title: "Name",
      type: "string",
      validation: (rule) => rule.required(),
    }),
    defineField({
      name: "slug",
      title: "Slug",
      type: "slug",
      options: {
        source: "name",
        maxLength: 96,
      },
      validation: (rule) => rule.required(),
    }),
    defineField({
      name: "image",
      title: "Image",
      type: "image",
      options: {
        hotspot: true,
      },
    }),
    defineField({
      name: "bio",
      title: "Bio",
      type: "array",
      of: [
        {
          title: "Block",
          type: "block",
          styles: [{ title: "Normal", value: "normal" }],
          lists: [],
        },
      ],
    }),
  ],
  preview: {
    select: {
      title: "name",
      media: "image",
    },
  },
});
`],
  ["cms/sanity/web/next/src/sanity/schemas/page.ts.hbs", `import { defineField, defineType } from "sanity";

export const page = defineType({
  name: "page",
  title: "Page",
  type: "document",
  fields: [
    defineField({
      name: "title",
      title: "Title",
      type: "string",
      validation: (rule) => rule.required(),
    }),
    defineField({
      name: "slug",
      title: "Slug",
      type: "slug",
      options: {
        source: "title",
        maxLength: 96,
      },
      validation: (rule) => rule.required(),
    }),
    defineField({
      name: "content",
      title: "Content",
      type: "blockContent",
    }),
    defineField({
      name: "seo",
      title: "SEO",
      type: "object",
      fields: [
        defineField({
          name: "metaTitle",
          title: "Meta Title",
          type: "string",
        }),
        defineField({
          name: "metaDescription",
          title: "Meta Description",
          type: "text",
          rows: 3,
        }),
      ],
    }),
  ],
  preview: {
    select: {
      title: "title",
      subtitle: "slug.current",
    },
  },
});
`],
  ["cms/sanity/web/next/src/sanity/schemas/index.ts.hbs", `import { author } from "./author";
import { blockContent } from "./blockContent";
import { page } from "./page";
import { post } from "./post";

export const schemaTypes = [author, blockContent, page, post];
`],
  ["cms/sanity/web/next/src/sanity/schemas/blockContent.ts.hbs", `import { defineType, defineArrayMember } from "sanity";

export const blockContent = defineType({
  title: "Block Content",
  name: "blockContent",
  type: "array",
  of: [
    defineArrayMember({
      title: "Block",
      type: "block",
      styles: [
        { title: "Normal", value: "normal" },
        { title: "H1", value: "h1" },
        { title: "H2", value: "h2" },
        { title: "H3", value: "h3" },
        { title: "H4", value: "h4" },
        { title: "Quote", value: "blockquote" },
      ],
      lists: [
        { title: "Bullet", value: "bullet" },
        { title: "Numbered", value: "number" },
      ],
      marks: {
        decorators: [
          { title: "Strong", value: "strong" },
          { title: "Emphasis", value: "em" },
          { title: "Code", value: "code" },
          { title: "Underline", value: "underline" },
          { title: "Strike", value: "strike-through" },
        ],
        annotations: [
          {
            title: "URL",
            name: "link",
            type: "object",
            fields: [
              {
                title: "URL",
                name: "href",
                type: "url",
              },
            ],
          },
        ],
      },
    }),
    defineArrayMember({
      type: "image",
      options: { hotspot: true },
    }),
  ],
});
`],
  ["cms/sanity/web/next/src/sanity/lib/client.ts.hbs", `import { createClient, type QueryParams } from "next-sanity";

import { apiVersion, dataset, projectId, token } from "../env";

export const client = createClient({
  projectId,
  dataset,
  apiVersion,
  useCdn: true, // Set to false for ISR/SSG or tag-based revalidation
});

// Server-side client with token for authenticated requests
export const serverClient = token
  ? client.withConfig({
      token,
      useCdn: false,
    })
  : client;

// Helper function for fetching data with revalidation options
export async function sanityFetch<T>({
  query,
  params = {},
  revalidate = 60,
  tags = [],
}: {
  query: string;
  params?: QueryParams;
  revalidate?: number | false;
  tags?: string[];
}): Promise<T> {
  return client.fetch<T>(query, params, {
    next: {
      revalidate: tags.length ? false : revalidate,
      tags,
    },
  });
}
`],
  ["cms/sanity/web/next/src/sanity/lib/image.ts.hbs", `import createImageUrlBuilder from "@sanity/image-url";
import type { SanityImageSource } from "@sanity/image-url/lib/types/types";

import { dataset, projectId } from "../env";

const imageBuilder = createImageUrlBuilder({
  projectId,
  dataset,
});

export function urlFor(source: SanityImageSource) {
  return imageBuilder.image(source);
}
`],
  ["cms/sanity/web/next/src/sanity/lib/queries.ts.hbs", `import { defineQuery } from "next-sanity";

// Get all posts
export const POSTS_QUERY = defineQuery(\`
  *[_type == "post" && defined(slug.current)] | order(publishedAt desc) {
    _id,
    title,
    slug,
    excerpt,
    publishedAt,
    mainImage,
    "author": author->{ name, image }
  }
\`);

// Get a single post by slug
export const POST_QUERY = defineQuery(\`
  *[_type == "post" && slug.current == $slug][0] {
    _id,
    title,
    slug,
    excerpt,
    body,
    publishedAt,
    mainImage,
    "author": author->{ name, image, bio }
  }
\`);

// Get all pages
export const PAGES_QUERY = defineQuery(\`
  *[_type == "page" && defined(slug.current)] | order(title asc) {
    _id,
    title,
    slug
  }
\`);

// Get a single page by slug
export const PAGE_QUERY = defineQuery(\`
  *[_type == "page" && slug.current == $slug][0] {
    _id,
    title,
    slug,
    content
  }
\`);

// Get all authors
export const AUTHORS_QUERY = defineQuery(\`
  *[_type == "author"] | order(name asc) {
    _id,
    name,
    slug,
    image,
    bio
  }
\`);
`],
  ["payments/lemon-squeezy/web/svelte/src/routes/success/+page.svelte.hbs", `<script lang="ts">
	import { page } from "$app/stores";

	$: checkoutId = $page.url.searchParams.get("checkout_id");
</script>

<div class="container mx-auto px-4 py-8">
	<h1 class="text-2xl font-bold mb-4">Payment Successful!</h1>
	<p class="text-gray-600 mb-4">
		Thank you for your purchase. Your payment has been processed successfully.
	</p>
	{#if checkoutId}
		<p class="text-sm text-gray-500">Checkout ID: {checkoutId}</p>
	{/if}
</div>
`],
  ["payments/lemon-squeezy/web/react/react-router/src/routes/success.tsx.hbs", `import { useSearchParams } from "react-router";

export default function SuccessPage() {
	const [searchParams] = useSearchParams();
	const checkoutId = searchParams.get("checkout_id");

	return (
		<div className="container mx-auto px-4 py-8">
			<h1 className="text-2xl font-bold mb-4">Payment Successful!</h1>
			<p className="text-gray-600 mb-4">
				Thank you for your purchase. Your payment has been processed successfully.
			</p>
			{checkoutId && (
				<p className="text-sm text-gray-500">Checkout ID: {checkoutId}</p>
			)}
		</div>
	);
}
`],
  ["payments/polar/web/react/tanstack-start/src/routes/success.tsx.hbs", `import { createFileRoute, useSearch } from "@tanstack/react-router";

export const Route = createFileRoute("/success")({
	component: SuccessPage,
	validateSearch: (search) => ({
		checkout_id: search.checkout_id as string,
	}),
});

function SuccessPage() {
	const { checkout_id } = useSearch({ from: "/success" });

	return (
		<div className="container mx-auto px-4 py-8">
			<h1>Payment Successful!</h1>
			{checkout_id && <p>Checkout ID: {checkout_id}</p>}
		</div>
	);
}
`],
  ["payments/lemon-squeezy/web/react/tanstack-start/src/routes/success.tsx.hbs", `import { createFileRoute } from "@tanstack/react-router";

export const Route = createFileRoute("/success")({
	component: SuccessPage,
});

function SuccessPage() {
	const { checkout_id } = Route.useSearch();

	return (
		<div className="container mx-auto px-4 py-8">
			<h1 className="text-2xl font-bold mb-4">Payment Successful!</h1>
			<p className="text-gray-600 mb-4">
				Thank you for your purchase. Your payment has been processed successfully.
			</p>
			{checkout_id && (
				<p className="text-sm text-gray-500">Checkout ID: {checkout_id}</p>
			)}
		</div>
	);
}
`],
  ["payments/polar/web/react/tanstack-start/src/functions/get-payment.ts.hbs", `import { authClient } from "@/lib/auth-client";
import { authMiddleware } from "@/middleware/auth";
import { createServerFn } from "@tanstack/react-start";
import { getRequestHeaders } from "@tanstack/react-start/server";

export const getPayment = createServerFn({ method: "GET" })
    .middleware([authMiddleware])
    .handler(async () => {
        const { data: customerState } = await authClient.customer.state({
            fetchOptions: {
                headers: getRequestHeaders()
            }
        });
        return customerState;
    });
`],
  ["cms/payload/web/next/src/payload/collections/Media.ts.hbs", `import type { CollectionConfig } from "payload";

export const Media: CollectionConfig = {
  slug: "media",
  upload: {
    staticDir: "media",
    mimeTypes: ["image/*", "video/*", "audio/*", "application/pdf"],
  },
  admin: {
    useAsTitle: "alt",
  },
  fields: [
    {
      name: "alt",
      type: "text",
      required: true,
    },
    {
      name: "caption",
      type: "textarea",
    },
  ],
};
`],
  ["cms/payload/web/next/src/payload/collections/Pages.ts.hbs", `import type { CollectionConfig } from "payload";

export const Pages: CollectionConfig = {
  slug: "pages",
  admin: {
    useAsTitle: "title",
    defaultColumns: ["title", "slug", "status", "updatedAt"],
  },
  versions: {
    drafts: true,
  },
  fields: [
    {
      name: "title",
      type: "text",
      required: true,
    },
    {
      name: "slug",
      type: "text",
      required: true,
      unique: true,
      admin: {
        position: "sidebar",
      },
    },
    {
      name: "status",
      type: "select",
      options: [
        { label: "Draft", value: "draft" },
        { label: "Published", value: "published" },
      ],
      defaultValue: "draft",
      admin: {
        position: "sidebar",
      },
    },
    {
      name: "content",
      type: "richText",
    },
    {
      name: "featuredImage",
      type: "upload",
      relationTo: "media",
    },
    {
      name: "meta",
      type: "group",
      fields: [
        {
          name: "title",
          type: "text",
          label: "Meta Title",
        },
        {
          name: "description",
          type: "textarea",
          label: "Meta Description",
        },
      ],
    },
  ],
};
`],
  ["cms/payload/web/next/src/payload/collections/Users.ts.hbs", `import type { CollectionConfig } from "payload";

export const Users: CollectionConfig = {
  slug: "users",
  auth: true,
  admin: {
    useAsTitle: "email",
  },
  fields: [
    {
      name: "name",
      type: "text",
    },
    {
      name: "role",
      type: "select",
      options: [
        { label: "Admin", value: "admin" },
        { label: "Editor", value: "editor" },
        { label: "User", value: "user" },
      ],
      defaultValue: "user",
      required: true,
    },
  ],
};
`],
  ["payments/polar/web/react/react-router/src/routes/success.tsx.hbs", `import { useSearchParams } from "react-router";

export default function SuccessPage() {
    const [searchParams] = useSearchParams();
    const checkout_id = searchParams.get("checkout_id");

    return (
        <div className="container mx-auto px-4 py-8">
            <h1>Payment Successful!</h1>
            {checkout_id && <p>Checkout ID: {checkout_id}</p>}
        </div>
    );
}
`],
  ["examples/ai/web/react/tanstack-start/src/routes/ai.tsx.hbs", `{{#if (eq backend "convex")}}
import { api } from "@{{projectName}}/backend/convex/_generated/api";
import {
  useUIMessages,
  useSmoothText,
  type UIMessage,
} from "@convex-dev/agent/react";
import { createFileRoute } from "@tanstack/react-router";
import { useMutation } from "convex/react";
import { Send, Loader2 } from "lucide-react";
import { useRef, useEffect, useState } from "react";
import { Streamdown } from "streamdown";

import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";

export const Route = createFileRoute("/ai")({
  component: RouteComponent,
});

function MessageContent({
  text,
  isStreaming,
}: {
  text: string;
  isStreaming: boolean;
}) {
  const [visibleText] = useSmoothText(text, {
    startStreaming: isStreaming,
  });
  return <Streamdown>{visibleText}</Streamdown>;
}

function RouteComponent() {
  const [input, setInput] = useState("");
  const [threadId, setThreadId] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const messagesEndRef = useRef<HTMLDivElement>(null);

  const createThread = useMutation(api.chat.createNewThread);
  const sendMessage = useMutation(api.chat.sendMessage);

  const { results: messages } = useUIMessages(
    api.chat.listMessages,
    threadId ? { threadId } : "skip",
    { initialNumItems: 50, stream: true },
  );

  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  }, [messages]);

  const hasStreamingMessage = messages?.some(
    (m: UIMessage) => m.status === "streaming",
  );

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    const text = input.trim();
    if (!text || isLoading) return;

    setIsLoading(true);
    setInput("");

    try {
      let currentThreadId = threadId;
      if (!currentThreadId) {
        currentThreadId = await createThread();
        setThreadId(currentThreadId);
      }

      await sendMessage({ threadId: currentThreadId, prompt: text });
    } catch (error) {
      console.error("Failed to send message:", error);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="grid grid-rows-[1fr_auto] overflow-hidden w-full mx-auto p-4">
      <div className="overflow-y-auto space-y-4 pb-4">
        {!messages || messages.length === 0 ? (
          <div className="text-center text-muted-foreground mt-8">
            Ask me anything to get started!
          </div>
        ) : (
          messages.map((message: UIMessage) => (
            <div
              key={message.key}
              className={\`p-3 rounded-lg \${
                message.role === "user"
                  ? "bg-primary/10 ml-8"
                  : "bg-secondary/20 mr-8"
              }\`}
            >
              <p className="text-sm font-semibold mb-1">
                {message.role === "user" ? "You" : "AI Assistant"}
              </p>
              <MessageContent
                text={message.text ?? ""}
                isStreaming={message.status === "streaming"}
              />
            </div>
          ))
        )}
        {isLoading && !hasStreamingMessage && (
          <div className="p-3 rounded-lg bg-secondary/20 mr-8">
            <p className="text-sm font-semibold mb-1">AI Assistant</p>
            <div className="flex items-center gap-2 text-muted-foreground">
              <Loader2 className="h-4 w-4 animate-spin" />
              <span>Thinking...</span>
            </div>
          </div>
        )}
        <div ref={messagesEndRef} />
      </div>

      <form
        onSubmit={handleSubmit}
        className="w-full flex items-center space-x-2 pt-2 border-t"
      >
        <Input
          name="prompt"
          value={input}
          onChange={(e) => setInput(e.target.value)}
          placeholder="Type your message..."
          className="flex-1"
          autoComplete="off"
          autoFocus
          disabled={isLoading}
        />
        <Button type="submit" size="icon" disabled={isLoading || !input.trim()}>
          {isLoading ? (
            <Loader2 className="h-4 w-4 animate-spin" />
          ) : (
            <Send size={18} />
          )}
        </Button>
      </form>
    </div>
  );
}
{{else if (eq ai "modelfusion")}}
import { createFileRoute } from "@tanstack/react-router";
import { Send, Loader2 } from "lucide-react";
import { useRef, useEffect, useState, useCallback } from "react";
import { Streamdown } from "streamdown";
{{#unless (eq backend "self")}}
import { env } from "@{{projectName}}/env/web";
{{/unless}}

import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";

type Message = {
  id: string;
  role: "user" | "assistant";
  content: string;
};

export const Route = createFileRoute("/ai")({
  component: RouteComponent,
});

function RouteComponent() {
  const [input, setInput] = useState("");
  const [messages, setMessages] = useState<Message[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [streamingContent, setStreamingContent] = useState("");
  const messagesEndRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  }, [messages, streamingContent]);

  const sendMessage = useCallback(async (text: string) => {
    const userMessage: Message = {
      id: Date.now().toString(),
      role: "user",
      content: text,
    };

    setMessages((prev) => [...prev, userMessage]);
    setIsLoading(true);
    setStreamingContent("");

    try {
      const response = await fetch({{#if (eq backend "self")}}"/api/ai"{{else}}\`\${env.VITE_SERVER_URL}/ai\`{{/if}}, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          messages: [...messages, userMessage].map((m) => ({
            role: m.role,
            content: m.content,
          })),
        }),
      });

      if (!response.ok) throw new Error("Failed to send message");

      const reader = response.body?.getReader();
      const decoder = new TextDecoder();
      let fullContent = "";

      if (reader) {
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          const chunk = decoder.decode(value, { stream: true });
          const lines = chunk.split("\\n");

          for (const line of lines) {
            if (line.startsWith("data: ")) {
              const data = line.slice(6);
              if (data === "[DONE]") continue;
              try {
                const parsed = JSON.parse(data);
                if (parsed.content) {
                  fullContent += parsed.content;
                  setStreamingContent(fullContent);
                }
              } catch {
                // Ignore parsing errors for incomplete chunks
              }
            }
          }
        }
      }

      const assistantMessage: Message = {
        id: (Date.now() + 1).toString(),
        role: "assistant",
        content: fullContent,
      };
      setMessages((prev) => [...prev, assistantMessage]);
      setStreamingContent("");
    } catch (error) {
      console.error("Failed to send message:", error);
    } finally {
      setIsLoading(false);
    }
  }, [messages]);

  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    const text = input.trim();
    if (!text || isLoading) return;
    setInput("");
    sendMessage(text);
  };

  return (
    <div className="grid grid-rows-[1fr_auto] overflow-hidden w-full mx-auto p-4">
      <div className="overflow-y-auto space-y-4 pb-4">
        {messages.length === 0 && !streamingContent ? (
          <div className="text-center text-muted-foreground mt-8">
            Ask me anything to get started!
          </div>
        ) : (
          <>
            {messages.map((message) => (
              <div
                key={message.id}
                className={\`p-3 rounded-lg \${
                  message.role === "user"
                    ? "bg-primary/10 ml-8"
                    : "bg-secondary/20 mr-8"
                }\`}
              >
                <p className="text-sm font-semibold mb-1">
                  {message.role === "user" ? "You" : "AI Assistant"}
                </p>
                <Streamdown>{message.content}</Streamdown>
              </div>
            ))}
            {streamingContent && (
              <div className="p-3 rounded-lg bg-secondary/20 mr-8">
                <p className="text-sm font-semibold mb-1">AI Assistant</p>
                <Streamdown isAnimating>{streamingContent}</Streamdown>
              </div>
            )}
          </>
        )}
        {isLoading && !streamingContent && (
          <div className="p-3 rounded-lg bg-secondary/20 mr-8">
            <p className="text-sm font-semibold mb-1">AI Assistant</p>
            <div className="flex items-center gap-2 text-muted-foreground">
              <Loader2 className="h-4 w-4 animate-spin" />
              <span>Thinking...</span>
            </div>
          </div>
        )}
        <div ref={messagesEndRef} />
      </div>

      <form
        onSubmit={handleSubmit}
        className="w-full flex items-center space-x-2 pt-2 border-t"
      >
        <Input
          name="prompt"
          value={input}
          onChange={(e) => setInput(e.target.value)}
          placeholder="Type your message..."
          className="flex-1"
          autoComplete="off"
          autoFocus
          disabled={isLoading}
        />
        <Button type="submit" size="icon" disabled={isLoading || !input.trim()}>
          {isLoading ? (
            <Loader2 className="h-4 w-4 animate-spin" />
          ) : (
            <Send size={18} />
          )}
        </Button>
      </form>
    </div>
  );
}
{{else if (eq ai "langgraph")}}
import { createFileRoute } from "@tanstack/react-router";
import { Send, Loader2 } from "lucide-react";
import { useRef, useEffect, useState, useCallback } from "react";
import { Streamdown } from "streamdown";
{{#unless (eq backend "self")}}
import { env } from "@{{projectName}}/env/web";
{{/unless}}

import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";

type Message = {
  id: string;
  role: "user" | "assistant";
  content: string;
};

export const Route = createFileRoute("/ai")({
  component: RouteComponent,
});

function RouteComponent() {
  const [input, setInput] = useState("");
  const [messages, setMessages] = useState<Message[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [streamingContent, setStreamingContent] = useState("");
  const messagesEndRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  }, [messages, streamingContent]);

  const sendMessage = useCallback(async (text: string) => {
    const userMessage: Message = {
      id: Date.now().toString(),
      role: "user",
      content: text,
    };

    setMessages((prev) => [...prev, userMessage]);
    setIsLoading(true);
    setStreamingContent("");

    try {
      const response = await fetch({{#if (eq backend "self")}}"/api/ai"{{else}}\`\${env.VITE_SERVER_URL}/ai\`{{/if}}, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          messages: [...messages, userMessage].map((m) => ({
            role: m.role,
            content: m.content,
          })),
        }),
      });

      if (!response.ok) throw new Error("Failed to send message");

      const reader = response.body?.getReader();
      const decoder = new TextDecoder();
      let fullContent = "";

      if (reader) {
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          const chunk = decoder.decode(value, { stream: true });
          const lines = chunk.split("\\n");

          for (const line of lines) {
            if (line.startsWith("data: ")) {
              const data = line.slice(6);
              if (data === "[DONE]") continue;
              try {
                const parsed = JSON.parse(data);
                if (parsed.content) {
                  fullContent += parsed.content;
                  setStreamingContent(fullContent);
                }
              } catch {
                // Ignore parsing errors for incomplete chunks
              }
            }
          }
        }
      }

      const assistantMessage: Message = {
        id: (Date.now() + 1).toString(),
        role: "assistant",
        content: fullContent,
      };
      setMessages((prev) => [...prev, assistantMessage]);
      setStreamingContent("");
    } catch (error) {
      console.error("Failed to send message:", error);
    } finally {
      setIsLoading(false);
    }
  }, [messages]);

  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    const text = input.trim();
    if (!text || isLoading) return;
    setInput("");
    sendMessage(text);
  };

  return (
    <div className="grid grid-rows-[1fr_auto] overflow-hidden w-full mx-auto p-4">
      <div className="overflow-y-auto space-y-4 pb-4">
        {messages.length === 0 && !streamingContent ? (
          <div className="text-center text-muted-foreground mt-8">
            Ask me anything to get started!
          </div>
        ) : (
          <>
            {messages.map((message) => (
              <div
                key={message.id}
                className={\`p-3 rounded-lg \${
                  message.role === "user"
                    ? "bg-primary/10 ml-8"
                    : "bg-secondary/20 mr-8"
                }\`}
              >
                <p className="text-sm font-semibold mb-1">
                  {message.role === "user" ? "You" : "AI Assistant"}
                </p>
                <Streamdown>{message.content}</Streamdown>
              </div>
            ))}
            {streamingContent && (
              <div className="p-3 rounded-lg bg-secondary/20 mr-8">
                <p className="text-sm font-semibold mb-1">AI Assistant</p>
                <Streamdown isAnimating>{streamingContent}</Streamdown>
              </div>
            )}
          </>
        )}
        {isLoading && !streamingContent && (
          <div className="p-3 rounded-lg bg-secondary/20 mr-8">
            <p className="text-sm font-semibold mb-1">AI Assistant</p>
            <div className="flex items-center gap-2 text-muted-foreground">
              <Loader2 className="h-4 w-4 animate-spin" />
              <span>Thinking...</span>
            </div>
          </div>
        )}
        <div ref={messagesEndRef} />
      </div>

      <form
        onSubmit={handleSubmit}
        className="w-full flex items-center space-x-2 pt-2 border-t"
      >
        <Input
          name="prompt"
          value={input}
          onChange={(e) => setInput(e.target.value)}
          placeholder="Type your message..."
          className="flex-1"
          autoComplete="off"
          autoFocus
          disabled={isLoading}
        />
        <Button type="submit" size="icon" disabled={isLoading || !input.trim()}>
          {isLoading ? (
            <Loader2 className="h-4 w-4 animate-spin" />
          ) : (
            <Send size={18} />
          )}
        </Button>
      </form>
    </div>
  );
}
{{else}}
import { createFileRoute } from "@tanstack/react-router";
import { useChat } from "@ai-sdk/react";
import { DefaultChatTransport } from "ai";
import { Send } from "lucide-react";
import { useRef, useEffect, useState } from "react";
import { Streamdown } from "streamdown";
{{#unless (eq backend "self")}}
import { env } from "@{{projectName}}/env/web";
{{/unless}}

import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";

export const Route = createFileRoute("/ai")({
  component: RouteComponent,
});

function RouteComponent() {
  const [input, setInput] = useState("");
  const { messages, sendMessage, status } = useChat({
    transport: new DefaultChatTransport({
      api: {{#if (eq backend "self")}}"/api/ai"{{else}}\`\${env.VITE_SERVER_URL}/ai\`{{/if}},
    }),
  });

  const messagesEndRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  }, [messages]);

  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    const text = input.trim();
    if (!text) return;
    sendMessage({ text });
    setInput("");
  };

  return (
    <div className="grid grid-rows-[1fr_auto] overflow-hidden w-full mx-auto p-4">
      <div className="overflow-y-auto space-y-4 pb-4">
        {messages.length === 0 ? (
          <div className="text-center text-muted-foreground mt-8">
            Ask me anything to get started!
          </div>
        ) : (
          messages.map((message) => (
            <div
              key={message.id}
              className={\`p-3 rounded-lg \${
                message.role === "user"
                  ? "bg-primary/10 ml-8"
                  : "bg-secondary/20 mr-8"
              }\`}
            >
              <p className="text-sm font-semibold mb-1">
                {message.role === "user" ? "You" : "AI Assistant"}
              </p>
              {message.parts?.map((part, index) => {
                if (part.type === "text") {
                  return (
                    <Streamdown
                      key={index}
                      isAnimating={status === "streaming" && message.role === "assistant"}
                    >
                      {part.text}
                    </Streamdown>
                  );
                }
                return null;
              })}
            </div>
          ))
        )}
        <div ref={messagesEndRef} />
      </div>

      <form
        onSubmit={handleSubmit}
        className="w-full flex items-center space-x-2 pt-2 border-t"
      >
        <Input
          name="prompt"
          value={input}
          onChange={(e) => setInput(e.target.value)}
          placeholder="Type your message..."
          className="flex-1"
          autoComplete="off"
          autoFocus
        />
        <Button type="submit" size="icon">
          <Send size={18} />
        </Button>
      </form>
    </div>
  );
}
{{/if}}
`],
  ["examples/todo/web/react/react-router/src/routes/todos.tsx.hbs", `import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Checkbox } from "@/components/ui/checkbox";
import { Input } from "@/components/ui/input";
import { Loader2, Trash2 } from "lucide-react";
import { useState } from "react";

{{#if (eq backend "convex")}}
import { useMutation, useQuery } from "convex/react";
import { api } from "@{{projectName}}/backend/convex/_generated/api";
import type { Id } from "@{{projectName}}/backend/convex/_generated/dataModel";
{{else}}
  {{#if (eq api "orpc")}}
  import { orpc } from "@/utils/orpc";
  {{/if}}
  {{#if (eq api "trpc")}}
  import { trpc } from "@/utils/trpc";
  {{/if}}
import { useMutation, useQuery } from "@tanstack/react-query";
{{/if}}

export default function Todos() {
  const [newTodoText, setNewTodoText] = useState("");

  {{#if (eq backend "convex")}}
  const todos = useQuery(api.todos.getAll);
  const createTodo = useMutation(api.todos.create);
  const toggleTodo = useMutation(api.todos.toggle);
  const deleteTodo = useMutation(api.todos.deleteTodo);

  const handleAddTodo = async (e: React.FormEvent) => {
    e.preventDefault();
    const text = newTodoText.trim();
    if (!text) return;
    await createTodo({ text });
    setNewTodoText("");
  };

  const handleToggleTodo = (id: Id<"todos">, currentCompleted: boolean) => {
    toggleTodo({ id, completed: !currentCompleted });
  };

  const handleDeleteTodo = (id: Id<"todos">) => {
    deleteTodo({ id });
  };
  {{else}}
    {{#if (eq api "orpc")}}
    const todos = useQuery(orpc.todo.getAll.queryOptions());
    const createMutation = useMutation(
      orpc.todo.create.mutationOptions({
        onSuccess: () => {
          todos.refetch();
          setNewTodoText("");
        },
      })
    );
    const toggleMutation = useMutation(
      orpc.todo.toggle.mutationOptions({
        onSuccess: () => { todos.refetch() },
      })
    );
    const deleteMutation = useMutation(
      orpc.todo.delete.mutationOptions({
        onSuccess: () => { todos.refetch() },
      })
    );
    {{/if}}
    {{#if (eq api "trpc")}}
    const todos = useQuery(trpc.todo.getAll.queryOptions());
    const createMutation = useMutation(
      trpc.todo.create.mutationOptions({
        onSuccess: () => {
          todos.refetch();
          setNewTodoText("");
        },
      })
    );
    const toggleMutation = useMutation(
      trpc.todo.toggle.mutationOptions({
        onSuccess: () => { todos.refetch() },
      })
    );
    const deleteMutation = useMutation(
      trpc.todo.delete.mutationOptions({
        onSuccess: () => { todos.refetch() },
      })
    );
    {{/if}}

  const handleAddTodo = (e: React.FormEvent) => {
    e.preventDefault();
    if (newTodoText.trim()) {
      createMutation.mutate({ text: newTodoText });
    }
  };

  const handleToggleTodo = (id: number, completed: boolean) => {
    toggleMutation.mutate({ id, completed: !completed });
  };

  const handleDeleteTodo = (id: number) => {
    deleteMutation.mutate({ id });
  };
  {{/if}}

  return (
    <div className="w-full mx-auto max-w-md py-10">
      <Card>
        <CardHeader>
          <CardTitle>Todo List</CardTitle>
          <CardDescription>Manage your tasks efficiently</CardDescription>
        </CardHeader>
        <CardContent>
          <form
            onSubmit={handleAddTodo}
            className="mb-6 flex items-center space-x-2"
          >
            <Input
              value={newTodoText}
              onChange={(e) => setNewTodoText(e.target.value)}
              placeholder="Add a new task..."
              {{#if (eq backend "convex")}}
              {{else}}
              disabled={createMutation.isPending}
              {{/if}}
            />
            <Button
              type="submit"
              {{#if (eq backend "convex")}}
              disabled={!newTodoText.trim()}
              {{else}}
              disabled={createMutation.isPending || !newTodoText.trim()}
              {{/if}}
            >
              {{#if (eq backend "convex")}}
              Add
              {{else}}
                {createMutation.isPending ? (
                  <Loader2 className="h-4 w-4 animate-spin" />
                ) : (
                  "Add"
                )}
              {{/if}}
            </Button>
          </form>

          {{#if (eq backend "convex")}}
            {todos === undefined ? (
              <div className="flex justify-center py-4">
                <Loader2 className="h-6 w-6 animate-spin" />
              </div>
            ) : todos.length === 0 ? (
              <p className="py-4 text-center">No todos yet. Add one above!</p>
            ) : (
              <ul className="space-y-2">
                {todos.map((todo) => (
                  <li
                    key={todo._id}
                    className="flex items-center justify-between rounded-md border p-2"
                  >
                    <div className="flex items-center space-x-2">
                      <Checkbox
                        checked={todo.completed}
                        onCheckedChange={() =>
                          handleToggleTodo(todo._id, todo.completed)
                        }
                        id={\`todo-\${todo._id}\`}
                      />
                      <label
                        htmlFor={\`todo-\${todo._id}\`}
                        className={\`\${todo.completed ? "line-through text-muted-foreground" : ""}\`}
                      >
                        {todo.text}
                      </label>
                    </div>
                    <Button
                      variant="ghost"
                      size="icon"
                      onClick={() => handleDeleteTodo(todo._id)}
                      aria-label="Delete todo"
                    >
                      <Trash2 className="h-4 w-4" />
                    </Button>
                  </li>
                ))}
              </ul>
            )}
          {{else}}
            {todos.isLoading ? (
              <div className="flex justify-center py-4">
                <Loader2 className="h-6 w-6 animate-spin" />
              </div>
            ) : todos.data?.length === 0 ? (
              <p className="py-4 text-center">
                No todos yet. Add one above!
              </p>
            ) : (
              <ul className="space-y-2">
                {todos.data?.map((todo) => (
                  <li
                    key={todo.id}
                    className="flex items-center justify-between rounded-md border p-2"
                  >
                    <div className="flex items-center space-x-2">
                      <Checkbox
                        checked={todo.completed}
                        onCheckedChange={() =>
                          handleToggleTodo(todo.id, todo.completed)
                        }
                        id={\`todo-\${todo.id}\`}
                      />
                      <label
                        htmlFor={\`todo-\${todo.id}\`}
                        className={\`\${todo.completed ? "line-through" : ""}\`}
                      >
                        {todo.text}
                      </label>
                    </div>
                    <Button
                      variant="ghost"
                      size="icon"
                      onClick={() => handleDeleteTodo(todo.id)}
                      aria-label="Delete todo"
                    >
                      <Trash2 className="h-4 w-4" />
                    </Button>
                  </li>
                ))}
              </ul>
            )}
          {{/if}}
        </CardContent>
      </Card>
    </div>
  );
}
`],
  ["examples/ai/web/react/tanstack-router/src/routes/ai.tsx.hbs", `{{#if (eq backend "convex")}}
import { api } from "@{{projectName}}/backend/convex/_generated/api";
import {
  useUIMessages,
  useSmoothText,
  type UIMessage,
} from "@convex-dev/agent/react";
import { createFileRoute } from "@tanstack/react-router";
import { useMutation } from "convex/react";
import { Send, Loader2 } from "lucide-react";
import { useRef, useEffect, useState } from "react";
import { Streamdown } from "streamdown";

import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";

export const Route = createFileRoute("/ai")({
  component: RouteComponent,
});

function MessageContent({
  text,
  isStreaming,
}: {
  text: string;
  isStreaming: boolean;
}) {
  const [visibleText] = useSmoothText(text, {
    startStreaming: isStreaming,
  });
  return <Streamdown>{visibleText}</Streamdown>;
}

function RouteComponent() {
  const [input, setInput] = useState("");
  const [threadId, setThreadId] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const messagesEndRef = useRef<HTMLDivElement>(null);

  const createThread = useMutation(api.chat.createNewThread);
  const sendMessage = useMutation(api.chat.sendMessage);

  const { results: messages } = useUIMessages(
    api.chat.listMessages,
    threadId ? { threadId } : "skip",
    { initialNumItems: 50, stream: true },
  );

  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  }, [messages]);

  const hasStreamingMessage = messages?.some(
    (m: UIMessage) => m.status === "streaming",
  );

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    const text = input.trim();
    if (!text || isLoading) return;

    setIsLoading(true);
    setInput("");

    try {
      let currentThreadId = threadId;
      if (!currentThreadId) {
        currentThreadId = await createThread();
        setThreadId(currentThreadId);
      }

      await sendMessage({ threadId: currentThreadId, prompt: text });
    } catch (error) {
      console.error("Failed to send message:", error);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="grid grid-rows-[1fr_auto] overflow-hidden w-full mx-auto p-4">
      <div className="overflow-y-auto space-y-4 pb-4">
        {!messages || messages.length === 0 ? (
          <div className="text-center text-muted-foreground mt-8">
            Ask me anything to get started!
          </div>
        ) : (
          messages.map((message: UIMessage) => (
            <div
              key={message.key}
              className={\`p-3 rounded-lg \${
                message.role === "user"
                  ? "bg-primary/10 ml-8"
                  : "bg-secondary/20 mr-8"
              }\`}
            >
              <p className="text-sm font-semibold mb-1">
                {message.role === "user" ? "You" : "AI Assistant"}
              </p>
              <MessageContent
                text={message.text ?? ""}
                isStreaming={message.status === "streaming"}
              />
            </div>
          ))
        )}
        {isLoading && !hasStreamingMessage && (
          <div className="p-3 rounded-lg bg-secondary/20 mr-8">
            <p className="text-sm font-semibold mb-1">AI Assistant</p>
            <div className="flex items-center gap-2 text-muted-foreground">
              <Loader2 className="h-4 w-4 animate-spin" />
              <span>Thinking...</span>
            </div>
          </div>
        )}
        <div ref={messagesEndRef} />
      </div>

      <form
        onSubmit={handleSubmit}
        className="w-full flex items-center space-x-2 pt-2 border-t"
      >
        <Input
          name="prompt"
          value={input}
          onChange={(e) => setInput(e.target.value)}
          placeholder="Type your message..."
          className="flex-1"
          autoComplete="off"
          autoFocus
          disabled={isLoading}
        />
        <Button type="submit" size="icon" disabled={isLoading || !input.trim()}>
          {isLoading ? (
            <Loader2 className="h-4 w-4 animate-spin" />
          ) : (
            <Send size={18} />
          )}
        </Button>
      </form>
    </div>
  );
}
{{else if (eq ai "modelfusion")}}
import { createFileRoute } from "@tanstack/react-router";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Send, Loader2 } from "lucide-react";
import { useRef, useEffect, useState, useCallback } from "react";
import { Streamdown } from "streamdown";
{{#unless (eq backend "self")}}
import { env } from "@{{projectName}}/env/web";
{{/unless}}

type Message = {
  id: string;
  role: "user" | "assistant";
  content: string;
};

export const Route = createFileRoute("/ai")({
  component: RouteComponent,
});

function RouteComponent() {
  const [input, setInput] = useState("");
  const [messages, setMessages] = useState<Message[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [streamingContent, setStreamingContent] = useState("");
  const messagesEndRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  }, [messages, streamingContent]);

  const sendMessage = useCallback(async (text: string) => {
    const userMessage: Message = {
      id: Date.now().toString(),
      role: "user",
      content: text,
    };

    setMessages((prev) => [...prev, userMessage]);
    setIsLoading(true);
    setStreamingContent("");

    try {
      const response = await fetch({{#if (eq backend "self")}}"/api/ai"{{else}}\`\${env.VITE_SERVER_URL}/ai\`{{/if}}, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          messages: [...messages, userMessage].map((m) => ({
            role: m.role,
            content: m.content,
          })),
        }),
      });

      if (!response.ok) throw new Error("Failed to send message");

      const reader = response.body?.getReader();
      const decoder = new TextDecoder();
      let fullContent = "";

      if (reader) {
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          const chunk = decoder.decode(value, { stream: true });
          const lines = chunk.split("\\n");

          for (const line of lines) {
            if (line.startsWith("data: ")) {
              const data = line.slice(6);
              if (data === "[DONE]") continue;
              try {
                const parsed = JSON.parse(data);
                if (parsed.content) {
                  fullContent += parsed.content;
                  setStreamingContent(fullContent);
                }
              } catch {
                // Ignore parsing errors for incomplete chunks
              }
            }
          }
        }
      }

      const assistantMessage: Message = {
        id: (Date.now() + 1).toString(),
        role: "assistant",
        content: fullContent,
      };
      setMessages((prev) => [...prev, assistantMessage]);
      setStreamingContent("");
    } catch (error) {
      console.error("Failed to send message:", error);
    } finally {
      setIsLoading(false);
    }
  }, [messages]);

  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    const text = input.trim();
    if (!text || isLoading) return;
    setInput("");
    sendMessage(text);
  };

  return (
    <div className="grid grid-rows-[1fr_auto] overflow-hidden w-full mx-auto p-4">
      <div className="overflow-y-auto space-y-4 pb-4">
        {messages.length === 0 && !streamingContent ? (
          <div className="text-center text-muted-foreground mt-8">
            Ask me anything to get started!
          </div>
        ) : (
          <>
            {messages.map((message) => (
              <div
                key={message.id}
                className={\`p-3 rounded-lg \${
                  message.role === "user"
                    ? "bg-primary/10 ml-8"
                    : "bg-secondary/20 mr-8"
                }\`}
              >
                <p className="text-sm font-semibold mb-1">
                  {message.role === "user" ? "You" : "AI Assistant"}
                </p>
                <Streamdown>{message.content}</Streamdown>
              </div>
            ))}
            {streamingContent && (
              <div className="p-3 rounded-lg bg-secondary/20 mr-8">
                <p className="text-sm font-semibold mb-1">AI Assistant</p>
                <Streamdown isAnimating>{streamingContent}</Streamdown>
              </div>
            )}
          </>
        )}
        {isLoading && !streamingContent && (
          <div className="p-3 rounded-lg bg-secondary/20 mr-8">
            <p className="text-sm font-semibold mb-1">AI Assistant</p>
            <div className="flex items-center gap-2 text-muted-foreground">
              <Loader2 className="h-4 w-4 animate-spin" />
              <span>Thinking...</span>
            </div>
          </div>
        )}
        <div ref={messagesEndRef} />
      </div>

      <form
        onSubmit={handleSubmit}
        className="w-full flex items-center space-x-2 pt-2 border-t"
      >
        <Input
          name="prompt"
          value={input}
          onChange={(e) => setInput(e.target.value)}
          placeholder="Type your message..."
          className="flex-1"
          autoComplete="off"
          autoFocus
          disabled={isLoading}
        />
        <Button type="submit" size="icon" disabled={isLoading || !input.trim()}>
          {isLoading ? (
            <Loader2 className="h-4 w-4 animate-spin" />
          ) : (
            <Send size={18} />
          )}
        </Button>
      </form>
    </div>
  );
}
{{else if (eq ai "langgraph")}}
import { createFileRoute } from "@tanstack/react-router";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Send, Loader2 } from "lucide-react";
import { useRef, useEffect, useState, useCallback } from "react";
import { Streamdown } from "streamdown";
{{#unless (eq backend "self")}}
import { env } from "@{{projectName}}/env/web";
{{/unless}}

type Message = {
  id: string;
  role: "user" | "assistant";
  content: string;
};

export const Route = createFileRoute("/ai")({
  component: RouteComponent,
});

function RouteComponent() {
  const [input, setInput] = useState("");
  const [messages, setMessages] = useState<Message[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [streamingContent, setStreamingContent] = useState("");
  const messagesEndRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  }, [messages, streamingContent]);

  const sendMessage = useCallback(async (text: string) => {
    const userMessage: Message = {
      id: Date.now().toString(),
      role: "user",
      content: text,
    };

    setMessages((prev) => [...prev, userMessage]);
    setIsLoading(true);
    setStreamingContent("");

    try {
      const response = await fetch({{#if (eq backend "self")}}"/api/ai"{{else}}\`\${env.VITE_SERVER_URL}/ai\`{{/if}}, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          messages: [...messages, userMessage].map((m) => ({
            role: m.role,
            content: m.content,
          })),
        }),
      });

      if (!response.ok) throw new Error("Failed to send message");

      const reader = response.body?.getReader();
      const decoder = new TextDecoder();
      let fullContent = "";

      if (reader) {
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          const chunk = decoder.decode(value, { stream: true });
          const lines = chunk.split("\\n");

          for (const line of lines) {
            if (line.startsWith("data: ")) {
              const data = line.slice(6);
              if (data === "[DONE]") continue;
              try {
                const parsed = JSON.parse(data);
                if (parsed.content) {
                  fullContent += parsed.content;
                  setStreamingContent(fullContent);
                }
              } catch {
                // Ignore parsing errors for incomplete chunks
              }
            }
          }
        }
      }

      const assistantMessage: Message = {
        id: (Date.now() + 1).toString(),
        role: "assistant",
        content: fullContent,
      };
      setMessages((prev) => [...prev, assistantMessage]);
      setStreamingContent("");
    } catch (error) {
      console.error("Failed to send message:", error);
    } finally {
      setIsLoading(false);
    }
  }, [messages]);

  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    const text = input.trim();
    if (!text || isLoading) return;
    setInput("");
    sendMessage(text);
  };

  return (
    <div className="grid grid-rows-[1fr_auto] overflow-hidden w-full mx-auto p-4">
      <div className="overflow-y-auto space-y-4 pb-4">
        {messages.length === 0 && !streamingContent ? (
          <div className="text-center text-muted-foreground mt-8">
            Ask me anything to get started!
          </div>
        ) : (
          <>
            {messages.map((message) => (
              <div
                key={message.id}
                className={\`p-3 rounded-lg \${
                  message.role === "user"
                    ? "bg-primary/10 ml-8"
                    : "bg-secondary/20 mr-8"
                }\`}
              >
                <p className="text-sm font-semibold mb-1">
                  {message.role === "user" ? "You" : "AI Assistant"}
                </p>
                <Streamdown>{message.content}</Streamdown>
              </div>
            ))}
            {streamingContent && (
              <div className="p-3 rounded-lg bg-secondary/20 mr-8">
                <p className="text-sm font-semibold mb-1">AI Assistant</p>
                <Streamdown isAnimating>{streamingContent}</Streamdown>
              </div>
            )}
          </>
        )}
        {isLoading && !streamingContent && (
          <div className="p-3 rounded-lg bg-secondary/20 mr-8">
            <p className="text-sm font-semibold mb-1">AI Assistant</p>
            <div className="flex items-center gap-2 text-muted-foreground">
              <Loader2 className="h-4 w-4 animate-spin" />
              <span>Thinking...</span>
            </div>
          </div>
        )}
        <div ref={messagesEndRef} />
      </div>

      <form
        onSubmit={handleSubmit}
        className="w-full flex items-center space-x-2 pt-2 border-t"
      >
        <Input
          name="prompt"
          value={input}
          onChange={(e) => setInput(e.target.value)}
          placeholder="Type your message..."
          className="flex-1"
          autoComplete="off"
          autoFocus
          disabled={isLoading}
        />
        <Button type="submit" size="icon" disabled={isLoading || !input.trim()}>
          {isLoading ? (
            <Loader2 className="h-4 w-4 animate-spin" />
          ) : (
            <Send size={18} />
          )}
        </Button>
      </form>
    </div>
  );
}
{{else}}
import { createFileRoute } from "@tanstack/react-router";
import { useChat } from "@ai-sdk/react";
import { DefaultChatTransport } from "ai";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Send } from "lucide-react";
import { useRef, useEffect, useState } from "react";
import { Streamdown } from "streamdown";
{{#unless (eq backend "self")}}
import { env } from "@{{projectName}}/env/web";
{{/unless}}

export const Route = createFileRoute("/ai")({
  component: RouteComponent,
});

function RouteComponent() {
  const [input, setInput] = useState("");
  const { messages, sendMessage, status } = useChat({
    transport: new DefaultChatTransport({
      api: {{#if (eq backend "self")}}"/api/ai"{{else}}\`\${env.VITE_SERVER_URL}/ai\`{{/if}},
    }),
  });

  const messagesEndRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  }, [messages]);

  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    const text = input.trim();
    if (!text) return;
    sendMessage({ text });
    setInput("");
  };

  return (
    <div className="grid grid-rows-[1fr_auto] overflow-hidden w-full mx-auto p-4">
      <div className="overflow-y-auto space-y-4 pb-4">
        {messages.length === 0 ? (
          <div className="text-center text-muted-foreground mt-8">
            Ask me anything to get started!
          </div>
        ) : (
          messages.map((message) => (
            <div
              key={message.id}
              className={\`p-3 rounded-lg \${
                message.role === "user"
                  ? "bg-primary/10 ml-8"
                  : "bg-secondary/20 mr-8"
              }\`}
            >
              <p className="text-sm font-semibold mb-1">
                {message.role === "user" ? "You" : "AI Assistant"}
              </p>
              {message.parts?.map((part, index) => {
                if (part.type === "text") {
                  return (
                    <Streamdown
                      key={index}
                      isAnimating={status === "streaming" && message.role === "assistant"}
                    >
                      {part.text}
                    </Streamdown>
                  );
                }
                return null;
              })}
            </div>
          ))
        )}
        <div ref={messagesEndRef} />
      </div>

      <form
        onSubmit={handleSubmit}
        className="w-full flex items-center space-x-2 pt-2 border-t"
      >
        <Input
          name="prompt"
          value={input}
          onChange={(e) => setInput(e.target.value)}
          placeholder="Type your message..."
          className="flex-1"
          autoComplete="off"
          autoFocus
        />
        <Button type="submit" size="icon">
          <Send size={18} />
        </Button>
      </form>
    </div>
  );
}
{{/if}}
`],
  ["auth/clerk/convex/web/react/tanstack-start/src/start.ts.hbs", `import { clerkMiddleware } from '@clerk/tanstack-react-start/server'
import { createStart } from '@tanstack/react-start'

export const startInstance = createStart(() => {
	return {
		requestMiddleware: [clerkMiddleware()],
	}
})`],
  ["examples/ai/web/svelte/src/routes/ai/+page.svelte.hbs", `<script lang="ts">
	import { PUBLIC_SERVER_URL } from "$env/static/public";
	import { Chat } from "@ai-sdk/svelte";
	import { DefaultChatTransport } from "ai";

	let input = $state("");
	const chat = new Chat({
		transport: new DefaultChatTransport({
			api: \`\${PUBLIC_SERVER_URL}/ai\`,
		}),
	});

	let messagesEndElement: HTMLDivElement | null = $state(null);

	$effect(() => {
		if (chat.messages.length > 0) {
			setTimeout(() => {
				messagesEndElement?.scrollIntoView({ behavior: "smooth" });
			}, 0);
		}
	});

	function handleSubmit(e: Event) {
		e.preventDefault();
		const text = input.trim();
		if (!text) return;
		chat.sendMessage({ text });
		input = "";
	}
</script>

<div
	class="mx-auto grid h-full w-full max-w-2xl grid-rows-[1fr_auto] overflow-hidden p-4"
>
	<div class="mb-4 space-y-4 overflow-y-auto pb-4">
		{#if chat.messages.length === 0}
			<div class="mt-8 text-center text-neutral-500">
				Ask me anything to get started!
			</div>
		{/if}

		{#each chat.messages as message (message.id)}
			<div
				class="p-3 rounded-lg w-fit max-w-[85%] text-sm md:text-base"
				class:ml-auto={message.role === "user"}
				class:bg-primary={message.role === "user"}
				class:bg-secondary={message.role === "assistant"}
			>
				<p
					class="mb-1 text-sm font-semibold"
					class:text-indigo-600={message.role === "user"}
					class:text-neutral-400={message.role === "assistant"}
				>
					{message.role === "user" ? "You" : "AI Assistant"}
				</p>
				<div class="whitespace-pre-wrap break-words">
					{#each message.parts as part, partIndex (partIndex)}
						{#if part.type === "text"}
							{part.text}
						{/if}
					{/each}
				</div>
			</div>
		{/each}
		<div bind:this={messagesEndElement}></div>
	</div>

	<form
		onsubmit={handleSubmit}
		class="w-full flex items-center space-x-2 pt-2 border-t"
	>
		<input
			name="prompt"
			bind:value={input}
			placeholder="Type your message..."
			class="flex-1 rounded border border-neutral-600 bg-neutral-800 px-3 py-2 text-neutral-100 placeholder-neutral-500 focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500 disabled:opacity-50"
			autocomplete="off"
			onkeydown={(e) => {
				if (e.key === "Enter" && !e.shiftKey) {
					e.preventDefault();
					handleSubmit(e);
				}
			}}
		/>
		<button
			type="submit"
			disabled={!input.trim()}
			class="inline-flex h-10 w-10 items-center justify-center rounded bg-indigo-600 text-white hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 focus:ring-offset-neutral-900 disabled:cursor-not-allowed disabled:opacity-50"
			aria-label="Send message"
		>
			<svg
				xmlns="http://www.w3.org/2000/svg"
				width="18"
				height="18"
				viewBox="0 0 24 24"
				fill="none"
				stroke="currentColor"
				stroke-width="2"
				stroke-linecap="round"
				stroke-linejoin="round"
			>
				<path d="m22 2-7 20-4-9-9-4Z" />
				<path d="M22 2 11 13" />
			</svg>
		</button>
	</form>
</div>
`],
  ["examples/todo/web/react/tanstack-router/src/routes/todos.tsx.hbs", `import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Checkbox } from "@/components/ui/checkbox";
import { Input } from "@/components/ui/input";
import { createFileRoute } from "@tanstack/react-router";
import { Loader2, Trash2 } from "lucide-react";
import { useState } from "react";

{{#if (eq backend "convex")}}
import { useMutation, useQuery } from "convex/react";
import { api } from "@{{projectName}}/backend/convex/_generated/api";
import type { Id } from "@{{projectName}}/backend/convex/_generated/dataModel";
{{else}}
  {{#if (eq api "orpc")}}
  import { orpc } from "@/utils/orpc";
  {{/if}}
  {{#if (eq api "trpc")}}
  import { trpc } from "@/utils/trpc";
  {{/if}}
import { useMutation, useQuery } from "@tanstack/react-query";
{{/if}}

export const Route = createFileRoute("/todos")({
  component: TodosRoute,
});

function TodosRoute() {
  const [newTodoText, setNewTodoText] = useState("");

  {{#if (eq backend "convex")}}
  const todos = useQuery(api.todos.getAll);
  const createTodo = useMutation(api.todos.create);
  const toggleTodo = useMutation(api.todos.toggle);
  const deleteTodo = useMutation(api.todos.deleteTodo);

  const handleAddTodo = async (e: React.FormEvent) => {
    e.preventDefault();
    const text = newTodoText.trim();
    if (!text) return;
    await createTodo({ text });
    setNewTodoText("");
  };

  const handleToggleTodo = (id: Id<"todos">, currentCompleted: boolean) => {
    toggleTodo({ id, completed: !currentCompleted });
  };

  const handleDeleteTodo = (id: Id<"todos">) => {
    deleteTodo({ id });
  };
  {{else}}
    {{#if (eq api "orpc")}}
    const todos = useQuery(orpc.todo.getAll.queryOptions());
    const createMutation = useMutation(
      orpc.todo.create.mutationOptions({
        onSuccess: () => {
          todos.refetch();
          setNewTodoText("");
        },
      }),
    );
    const toggleMutation = useMutation(
      orpc.todo.toggle.mutationOptions({
        onSuccess: () => { todos.refetch() },
      }),
    );
    const deleteMutation = useMutation(
      orpc.todo.delete.mutationOptions({
        onSuccess: () => { todos.refetch() },
      }),
    );
    {{/if}}
    {{#if (eq api "trpc")}}
    const todos = useQuery(trpc.todo.getAll.queryOptions());
    const createMutation = useMutation(
      trpc.todo.create.mutationOptions({
        onSuccess: () => {
          todos.refetch();
          setNewTodoText("");
        },
      }),
    );
    const toggleMutation = useMutation(
      trpc.todo.toggle.mutationOptions({
        onSuccess: () => { todos.refetch() },
      }),
    );
    const deleteMutation = useMutation(
      trpc.todo.delete.mutationOptions({
        onSuccess: () => { todos.refetch() },
      }),
    );
    {{/if}}

  const handleAddTodo = (e: React.FormEvent) => {
    e.preventDefault();
    if (newTodoText.trim()) {
      createMutation.mutate({ text: newTodoText });
    }
  };

  const handleToggleTodo = (id: number, completed: boolean) => {
    toggleMutation.mutate({ id, completed: !completed });
  };

  const handleDeleteTodo = (id: number) => {
    deleteMutation.mutate({ id });
  };
  {{/if}}

  return (
    <div className="mx-auto w-full max-w-md py-10">
      <Card>
        <CardHeader>
          <CardTitle>Todo List</CardTitle>
          <CardDescription>Manage your tasks efficiently</CardDescription>
        </CardHeader>
        <CardContent>
          <form
            onSubmit={handleAddTodo}
            className="mb-6 flex items-center space-x-2"
          >
            <Input
              value={newTodoText}
              onChange={(e) => setNewTodoText(e.target.value)}
              placeholder="Add a new task..."
              {{#if (eq backend "convex")}}
              {{else}}
              disabled={createMutation.isPending}
              {{/if}}
            />
            <Button
              type="submit"
              {{#if (eq backend "convex")}}
              disabled={!newTodoText.trim()}
              {{else}}
              disabled={createMutation.isPending || !newTodoText.trim()}
              {{/if}}
            >
              {{#if (eq backend "convex")}}
              Add
              {{else}}
                {createMutation.isPending ? (
                  <Loader2 className="h-4 w-4 animate-spin" />
                ) : (
                  "Add"
                )}
              {{/if}}
            </Button>
          </form>

          {{#if (eq backend "convex")}}
            {todos === undefined ? (
              <div className="flex justify-center py-4">
                <Loader2 className="h-6 w-6 animate-spin" />
              </div>
            ) : todos.length === 0 ? (
              <p className="py-4 text-center">No todos yet. Add one above!</p>
            ) : (
              <ul className="space-y-2">
                {todos.map((todo) => (
                  <li
                    key={todo._id}
                    className="flex items-center justify-between rounded-md border p-2"
                  >
                    <div className="flex items-center space-x-2">
                      <Checkbox
                        checked={todo.completed}
                        onCheckedChange={() =>
                          handleToggleTodo(todo._id, todo.completed)
                        }
                        id={\`todo-\${todo._id}\`}
                      />
                      <label
                        htmlFor={\`todo-\${todo._id}\`}
                        className={\`\${todo.completed ? "line-through text-muted-foreground" : ""}\`}
                      >
                        {todo.text}
                      </label>
                    </div>
                    <Button
                      variant="ghost"
                      size="icon"
                      onClick={() => handleDeleteTodo(todo._id)}
                      aria-label="Delete todo"
                    >
                      <Trash2 className="h-4 w-4" />
                    </Button>
                  </li>
                ))}
              </ul>
            )}
          {{else}}
            {todos.isLoading ? (
              <div className="flex justify-center py-4">
                <Loader2 className="h-6 w-6 animate-spin" />
              </div>
            ) : todos.data?.length === 0 ? (
              <p className="py-4 text-center">
                No todos yet. Add one above!
              </p>
            ) : (
              <ul className="space-y-2">
                {todos.data?.map((todo) => (
                  <li
                    key={todo.id}
                    className="flex items-center justify-between rounded-md border p-2"
                  >
                    <div className="flex items-center space-x-2">
                      <Checkbox
                        checked={todo.completed}
                        onCheckedChange={() =>
                          handleToggleTodo(todo.id, todo.completed)
                        }
                        id={\`todo-\${todo.id}\`}
                      />
                      <label
                        htmlFor={\`todo-\${todo.id}\`}
                        className={\`\${todo.completed ? "line-through" : ""}\`}
                      >
                        {todo.text}
                      </label>
                    </div>
                    <Button
                      variant="ghost"
                      size="icon"
                      onClick={() => handleDeleteTodo(todo.id)}
                      aria-label="Delete todo"
                    >
                      <Trash2 className="h-4 w-4" />
                    </Button>
                  </li>
                ))}
              </ul>
            )}
          {{/if}}
        </CardContent>
      </Card>
    </div>
  );
}
`],
  ["examples/ai/web/react/react-router/src/routes/ai.tsx.hbs", `{{#if (eq backend "convex")}}
import { api } from "@{{projectName}}/backend/convex/_generated/api";
import {
  useUIMessages,
  useSmoothText,
  type UIMessage,
} from "@convex-dev/agent/react";
import { useMutation } from "convex/react";
import { Send, Loader2 } from "lucide-react";
import React, { useRef, useEffect, useState } from "react";
import { Streamdown } from "streamdown";

import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";

function MessageContent({
  text,
  isStreaming,
}: {
  text: string;
  isStreaming: boolean;
}) {
  const [visibleText] = useSmoothText(text, {
    startStreaming: isStreaming,
  });
  return <Streamdown>{visibleText}</Streamdown>;
}

const AI: React.FC = () => {
  const [input, setInput] = useState("");
  const [threadId, setThreadId] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const messagesEndRef = useRef<HTMLDivElement>(null);

  const createThread = useMutation(api.chat.createNewThread);
  const sendMessage = useMutation(api.chat.sendMessage);

  const { results: messages } = useUIMessages(
    api.chat.listMessages,
    threadId ? { threadId } : "skip",
    { initialNumItems: 50, stream: true },
  );

  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  }, [messages]);

  const hasStreamingMessage = messages?.some(
    (m: UIMessage) => m.status === "streaming",
  );

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    const text = input.trim();
    if (!text || isLoading) return;

    setIsLoading(true);
    setInput("");

    try {
      let currentThreadId = threadId;
      if (!currentThreadId) {
        currentThreadId = await createThread();
        setThreadId(currentThreadId);
      }

      await sendMessage({ threadId: currentThreadId, prompt: text });
    } catch (error) {
      console.error("Failed to send message:", error);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="grid grid-rows-[1fr_auto] overflow-hidden w-full mx-auto p-4">
      <div className="overflow-y-auto space-y-4 pb-4">
        {!messages || messages.length === 0 ? (
          <div className="text-center text-muted-foreground mt-8">
            Ask me anything to get started!
          </div>
        ) : (
          messages.map((message: UIMessage) => (
            <div
              key={message.key}
              className={\`p-3 rounded-lg \${
                message.role === "user"
                  ? "bg-primary/10 ml-8"
                  : "bg-secondary/20 mr-8"
              }\`}
            >
              <p className="text-sm font-semibold mb-1">
                {message.role === "user" ? "You" : "AI Assistant"}
              </p>
              <MessageContent
                text={message.text ?? ""}
                isStreaming={message.status === "streaming"}
              />
            </div>
          ))
        )}
        {isLoading && !hasStreamingMessage && (
          <div className="p-3 rounded-lg bg-secondary/20 mr-8">
            <p className="text-sm font-semibold mb-1">AI Assistant</p>
            <div className="flex items-center gap-2 text-muted-foreground">
              <Loader2 className="h-4 w-4 animate-spin" />
              <span>Thinking...</span>
            </div>
          </div>
        )}
        <div ref={messagesEndRef} />
      </div>

      <form
        onSubmit={handleSubmit}
        className="w-full flex items-center space-x-2 pt-2 border-t"
      >
        <Input
          name="prompt"
          value={input}
          onChange={(e) => setInput(e.target.value)}
          placeholder="Type your message..."
          className="flex-1"
          autoComplete="off"
          autoFocus
          disabled={isLoading}
        />
        <Button type="submit" size="icon" disabled={isLoading || !input.trim()}>
          {isLoading ? (
            <Loader2 className="h-4 w-4 animate-spin" />
          ) : (
            <Send size={18} />
          )}
        </Button>
      </form>
    </div>
  );
};

export default AI;
{{else if (eq ai "modelfusion")}}
import React, { useRef, useEffect, useState, useCallback } from "react";
import { Send, Loader2 } from "lucide-react";
import { Streamdown } from "streamdown";
import { env } from "@{{projectName}}/env/web";

import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";

type Message = {
  id: string;
  role: "user" | "assistant";
  content: string;
};

const AI: React.FC = () => {
  const [input, setInput] = useState("");
  const [messages, setMessages] = useState<Message[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [streamingContent, setStreamingContent] = useState("");
  const messagesEndRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  }, [messages, streamingContent]);

  const sendMessage = useCallback(async (text: string) => {
    const userMessage: Message = {
      id: Date.now().toString(),
      role: "user",
      content: text,
    };

    setMessages((prev) => [...prev, userMessage]);
    setIsLoading(true);
    setStreamingContent("");

    try {
      const response = await fetch(\`\${env.VITE_SERVER_URL}/ai\`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          messages: [...messages, userMessage].map((m) => ({
            role: m.role,
            content: m.content,
          })),
        }),
      });

      if (!response.ok) throw new Error("Failed to send message");

      const reader = response.body?.getReader();
      const decoder = new TextDecoder();
      let fullContent = "";

      if (reader) {
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          const chunk = decoder.decode(value, { stream: true });
          const lines = chunk.split("\\n");

          for (const line of lines) {
            if (line.startsWith("data: ")) {
              const data = line.slice(6);
              if (data === "[DONE]") continue;
              try {
                const parsed = JSON.parse(data);
                if (parsed.content) {
                  fullContent += parsed.content;
                  setStreamingContent(fullContent);
                }
              } catch {
                // Ignore parsing errors for incomplete chunks
              }
            }
          }
        }
      }

      const assistantMessage: Message = {
        id: (Date.now() + 1).toString(),
        role: "assistant",
        content: fullContent,
      };
      setMessages((prev) => [...prev, assistantMessage]);
      setStreamingContent("");
    } catch (error) {
      console.error("Failed to send message:", error);
    } finally {
      setIsLoading(false);
    }
  }, [messages]);

  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    const text = input.trim();
    if (!text || isLoading) return;
    setInput("");
    sendMessage(text);
  };

  return (
    <div className="grid grid-rows-[1fr_auto] overflow-hidden w-full mx-auto p-4">
      <div className="overflow-y-auto space-y-4 pb-4">
        {messages.length === 0 && !streamingContent ? (
          <div className="text-center text-muted-foreground mt-8">
            Ask me anything to get started!
          </div>
        ) : (
          <>
            {messages.map((message) => (
              <div
                key={message.id}
                className={\`p-3 rounded-lg \${
                  message.role === "user"
                    ? "bg-primary/10 ml-8"
                    : "bg-secondary/20 mr-8"
                }\`}
              >
                <p className="text-sm font-semibold mb-1">
                  {message.role === "user" ? "You" : "AI Assistant"}
                </p>
                <Streamdown>{message.content}</Streamdown>
              </div>
            ))}
            {streamingContent && (
              <div className="p-3 rounded-lg bg-secondary/20 mr-8">
                <p className="text-sm font-semibold mb-1">AI Assistant</p>
                <Streamdown isAnimating>{streamingContent}</Streamdown>
              </div>
            )}
          </>
        )}
        {isLoading && !streamingContent && (
          <div className="p-3 rounded-lg bg-secondary/20 mr-8">
            <p className="text-sm font-semibold mb-1">AI Assistant</p>
            <div className="flex items-center gap-2 text-muted-foreground">
              <Loader2 className="h-4 w-4 animate-spin" />
              <span>Thinking...</span>
            </div>
          </div>
        )}
        <div ref={messagesEndRef} />
      </div>

      <form
        onSubmit={handleSubmit}
        className="w-full flex items-center space-x-2 pt-2 border-t"
      >
        <Input
          name="prompt"
          value={input}
          onChange={(e) => setInput(e.target.value)}
          placeholder="Type your message..."
          className="flex-1"
          autoComplete="off"
          autoFocus
          disabled={isLoading}
        />
        <Button type="submit" size="icon" disabled={isLoading || !input.trim()}>
          {isLoading ? (
            <Loader2 className="h-4 w-4 animate-spin" />
          ) : (
            <Send size={18} />
          )}
        </Button>
      </form>
    </div>
  );
};

export default AI;
{{else if (eq ai "langgraph")}}
import React, { useRef, useEffect, useState, useCallback } from "react";
import { Send, Loader2 } from "lucide-react";
import { Streamdown } from "streamdown";
import { env } from "@{{projectName}}/env/web";

import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";

type Message = {
  id: string;
  role: "user" | "assistant";
  content: string;
};

const AI: React.FC = () => {
  const [input, setInput] = useState("");
  const [messages, setMessages] = useState<Message[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [streamingContent, setStreamingContent] = useState("");
  const messagesEndRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  }, [messages, streamingContent]);

  const sendMessage = useCallback(async (text: string) => {
    const userMessage: Message = {
      id: Date.now().toString(),
      role: "user",
      content: text,
    };

    setMessages((prev) => [...prev, userMessage]);
    setIsLoading(true);
    setStreamingContent("");

    try {
      const response = await fetch(\`\${env.VITE_SERVER_URL}/ai\`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          messages: [...messages, userMessage].map((m) => ({
            role: m.role,
            content: m.content,
          })),
        }),
      });

      if (!response.ok) throw new Error("Failed to send message");

      const reader = response.body?.getReader();
      const decoder = new TextDecoder();
      let fullContent = "";

      if (reader) {
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          const chunk = decoder.decode(value, { stream: true });
          const lines = chunk.split("\\n");

          for (const line of lines) {
            if (line.startsWith("data: ")) {
              const data = line.slice(6);
              if (data === "[DONE]") continue;
              try {
                const parsed = JSON.parse(data);
                if (parsed.content) {
                  fullContent += parsed.content;
                  setStreamingContent(fullContent);
                }
              } catch {
                // Ignore parsing errors for incomplete chunks
              }
            }
          }
        }
      }

      const assistantMessage: Message = {
        id: (Date.now() + 1).toString(),
        role: "assistant",
        content: fullContent,
      };
      setMessages((prev) => [...prev, assistantMessage]);
      setStreamingContent("");
    } catch (error) {
      console.error("Failed to send message:", error);
    } finally {
      setIsLoading(false);
    }
  }, [messages]);

  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    const text = input.trim();
    if (!text || isLoading) return;
    setInput("");
    sendMessage(text);
  };

  return (
    <div className="grid grid-rows-[1fr_auto] overflow-hidden w-full mx-auto p-4">
      <div className="overflow-y-auto space-y-4 pb-4">
        {messages.length === 0 && !streamingContent ? (
          <div className="text-center text-muted-foreground mt-8">
            Ask me anything to get started!
          </div>
        ) : (
          <>
            {messages.map((message) => (
              <div
                key={message.id}
                className={\`p-3 rounded-lg \${
                  message.role === "user"
                    ? "bg-primary/10 ml-8"
                    : "bg-secondary/20 mr-8"
                }\`}
              >
                <p className="text-sm font-semibold mb-1">
                  {message.role === "user" ? "You" : "AI Assistant"}
                </p>
                <Streamdown>{message.content}</Streamdown>
              </div>
            ))}
            {streamingContent && (
              <div className="p-3 rounded-lg bg-secondary/20 mr-8">
                <p className="text-sm font-semibold mb-1">AI Assistant</p>
                <Streamdown isAnimating>{streamingContent}</Streamdown>
              </div>
            )}
          </>
        )}
        {isLoading && !streamingContent && (
          <div className="p-3 rounded-lg bg-secondary/20 mr-8">
            <p className="text-sm font-semibold mb-1">AI Assistant</p>
            <div className="flex items-center gap-2 text-muted-foreground">
              <Loader2 className="h-4 w-4 animate-spin" />
              <span>Thinking...</span>
            </div>
          </div>
        )}
        <div ref={messagesEndRef} />
      </div>

      <form
        onSubmit={handleSubmit}
        className="w-full flex items-center space-x-2 pt-2 border-t"
      >
        <Input
          name="prompt"
          value={input}
          onChange={(e) => setInput(e.target.value)}
          placeholder="Type your message..."
          className="flex-1"
          autoComplete="off"
          autoFocus
          disabled={isLoading}
        />
        <Button type="submit" size="icon" disabled={isLoading || !input.trim()}>
          {isLoading ? (
            <Loader2 className="h-4 w-4 animate-spin" />
          ) : (
            <Send size={18} />
          )}
        </Button>
      </form>
    </div>
  );
};

export default AI;
{{else}}
import React, { useRef, useEffect, useState } from "react";
import { useChat } from "@ai-sdk/react";
import { DefaultChatTransport } from "ai";
import { Send } from "lucide-react";
import { Streamdown } from "streamdown";
import { env } from "@{{projectName}}/env/web";

import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";

const AI: React.FC = () => {
  const [input, setInput] = useState("");
  const { messages, sendMessage, status } = useChat({
    transport: new DefaultChatTransport({
      api: \`\${env.VITE_SERVER_URL}/ai\`,
    }),
  });

  const messagesEndRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  }, [messages]);

  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    const text = input.trim();
    if (!text) return;
    sendMessage({ text });
    setInput("");
  };

  return (
    <div className="grid grid-rows-[1fr_auto] overflow-hidden w-full mx-auto p-4">
      <div className="overflow-y-auto space-y-4 pb-4">
        {messages.length === 0 ? (
          <div className="text-center text-muted-foreground mt-8">
            Ask me anything to get started!
          </div>
        ) : (
          messages.map((message) => (
            <div
              key={message.id}
              className={\`p-3 rounded-lg \${
                message.role === "user"
                  ? "bg-primary/10 ml-8"
                  : "bg-secondary/20 mr-8"
              }\`}
            >
              <p className="text-sm font-semibold mb-1">
                {message.role === "user" ? "You" : "AI Assistant"}
              </p>
              {message.parts?.map((part, index) => {
                if (part.type === "text") {
                  return (
                    <Streamdown
                      key={index}
                      isAnimating={status === "streaming" && message.role === "assistant"}
                    >
                      {part.text}
                    </Streamdown>
                  );
                }
                return null;
              })}
            </div>
          ))
        )}
        <div ref={messagesEndRef} />
      </div>

      <form
        onSubmit={handleSubmit}
        className="w-full flex items-center space-x-2 pt-2 border-t"
      >
        <Input
          name="prompt"
          value={input}
          onChange={(e) => setInput(e.target.value)}
          placeholder="Type your message..."
          className="flex-1"
          autoComplete="off"
          autoFocus
        />
        <Button type="submit" size="icon">
          <Send size={18} />
        </Button>
      </form>
    </div>
  );
};

export default AI;
{{/if}}
`],
  ["examples/todo/web/svelte/src/routes/todos/+page.svelte.hbs", `{{#if (eq backend "convex")}}
<script lang="ts">
	import { useQuery, useConvexClient } from 'convex-svelte';
	import { api } from '@{{projectName}}/backend/convex/_generated/api';
	import type { Id } from '@{{projectName}}/backend/convex/_generated/dataModel';

	let newTodoText = $state('');
	let isAdding = $state(false);
	let addError = $state<Error | null>(null);
	let togglingId = $state<Id<'todos'> | null>(null);
	let toggleError = $state<Error | null>(null);
	let deletingId = $state<Id<'todos'> | null>(null);
	let deleteError = $state<Error | null>(null);

	const client = useConvexClient();

	const todosQuery = useQuery(api.todos.getAll, {});

	async function handleAddTodo(event: SubmitEvent) {
		event.preventDefault();
		const text = newTodoText.trim();
		if (!text || isAdding) return;

		isAdding = true;
		addError = null;
		try {
			await client.mutation(api.todos.create, { text });
			newTodoText = '';
		} catch (err) {
			console.error('Failed to add todo:', err);
			addError = err instanceof Error ? err : new Error(String(err));
		} finally {
			isAdding = false;
		}
	}

	async function handleToggleTodo(id: Id<'todos'>, completed: boolean) {
		if (togglingId === id || deletingId === id) return;

		togglingId = id;
		toggleError = null;
		try {
			await client.mutation(api.todos.toggle, { id, completed: !completed });
		} catch (err) {
			console.error('Failed to toggle todo:', err);
			toggleError = err instanceof Error ? err : new Error(String(err));
		} finally {
			if (togglingId === id) {
				togglingId = null;
			}
		}
	}

	async function handleDeleteTodo(id: Id<'todos'>) {
		if (togglingId === id || deletingId === id) return;

		deletingId = id;
		deleteError = null;
		try {
			await client.mutation(api.todos.deleteTodo, { id });
		} catch (err) {
			console.error('Failed to delete todo:', err);
			deleteError = err instanceof Error ? err : new Error(String(err));
		} finally {
			if (deletingId === id) {
				deletingId = null;
			}
		}
	}

	const canAdd = $derived(!isAdding && newTodoText.trim().length > 0);
	const isLoadingTodos = $derived(todosQuery.isLoading);
	const todos = $derived(todosQuery.data ?? []);
	const hasTodos = $derived(todos.length > 0);

</script>

<div class="p-4">
	<h1 class="text-xl mb-4">Todos (Convex)</h1>

	<form onsubmit={handleAddTodo} class="flex gap-2 mb-4">
		<input
			type="text"
			bind:value={newTodoText}
			placeholder="New task..."
			disabled={isAdding}
			class="p-1 flex-grow"
		/>
		<button
			type="submit"
			disabled={!canAdd}
			class="bg-blue-500 text-white px-3 py-1 rounded disabled:opacity-50"
		>
			{#if isAdding}Adding...{:else}Add{/if}
		</button>
	</form>

	{#if isLoadingTodos}
		<p>Loading...</p>
	{:else if !hasTodos}
		<p>No todos yet.</p>
	{:else}
		<ul class="space-y-1">
			{#each todos as todo (todo._id)}
				{@const isTogglingThis = togglingId === todo._id}
				{@const isDeletingThis = deletingId === todo._id}
				{@const isDisabled = isTogglingThis || isDeletingThis}
				<li
					class="flex items-center justify-between p-2"
					class:opacity-50={isDisabled}
				>
					<div class="flex items-center gap-2">
						<input
							type="checkbox"
							id={\`todo-\${todo._id}\`}
							checked={todo.completed}
							onchange={() => handleToggleTodo(todo._id, todo.completed)}
							disabled={isDisabled}
						/>
						<label
							for={\`todo-\${todo._id}\`}
							class:line-through={todo.completed}
						>
							{todo.text}
						</label>
					</div>
					<button
						type="button"
						onclick={() => handleDeleteTodo(todo._id)}
						disabled={isDisabled}
						aria-label="Delete todo"
						class="text-red-500 px-1 disabled:opacity-50"
					>
						{#if isDeletingThis}Deleting...{:else}X{/if}
					</button>
				</li>
			{/each}
		</ul>
	{/if}

	{#if todosQuery.error}
		<p class="mt-4 text-red-500">
			Error loading: {todosQuery.error?.message ?? 'Unknown error'}
		</p>
	{/if}
	{#if addError}
		<p class="mt-4 text-red-500">
			Error adding: {addError.message ?? 'Unknown error'}
		</p>
	{/if}
	{#if toggleError}
		<p class="mt-4 text-red-500">
			Error updating: {toggleError.message ?? 'Unknown error'}
		</p>
	{/if}
	{#if deleteError}
		<p class="mt-4 text-red-500">
			Error deleting: {deleteError.message ?? 'Unknown error'}
		</p>
	{/if}
</div>
{{else}}
<script lang="ts">
	{{#if (eq api "orpc")}}
	import { orpc } from '$lib/orpc';
	{{/if}}
	import { createQuery, createMutation } from '@tanstack/svelte-query';

	let newTodoText = $state('');

	{{#if (eq api "orpc")}}
	const todosQuery = createQuery(orpc.todo.getAll.queryOptions());

	const addMutation = createMutation(
		orpc.todo.create.mutationOptions({
			onSuccess: () => {
				$todosQuery.refetch();
				newTodoText = '';
			},
			onError: (error) => {
				console.error('Failed to create todo:', error?.message ?? error);
			},
		})
	);

	const toggleMutation = createMutation(
		orpc.todo.toggle.mutationOptions({
			onSuccess: () => {
				$todosQuery.refetch();
			},
			onError: (error) => {
				console.error('Failed to toggle todo:', error?.message ?? error);
			},
		})
	);

	const deleteMutation = createMutation(
		orpc.todo.delete.mutationOptions({
			onSuccess: () => {
				$todosQuery.refetch();
			},
			onError: (error) => {
				console.error('Failed to delete todo:', error?.message ?? error);
			},
		})
	);
	{{/if}}

	function handleAddTodo(event: SubmitEvent) {
		event.preventDefault();
		const text = newTodoText.trim();
		if (text) {
			$addMutation.mutate({ text });
		}
	}

	function handleToggleTodo(id: number, completed: boolean) {
		$toggleMutation.mutate({ id, completed: !completed });
	}

	function handleDeleteTodo(id: number) {
		$deleteMutation.mutate({ id });
	}

	const isAdding = $derived($addMutation.isPending);
	const canAdd = $derived(!isAdding && newTodoText.trim().length > 0);
	const isLoadingTodos = $derived($todosQuery.isLoading);
	const todos = $derived($todosQuery.data ?? []);
	const hasTodos = $derived(todos.length > 0);

</script>

<div class="p-4">
	<h1 class="text-xl mb-4">Todos{{#if (eq api "orpc")}} (oRPC){{/if}}</h1>

	<form onsubmit={handleAddTodo} class="flex gap-2 mb-4">
		<input
			type="text"
			bind:value={newTodoText}
			placeholder="New task..."
			disabled={isAdding}
			class=" p-1 flex-grow"
		/>
		<button
			type="submit"
			disabled={!canAdd}
			class="bg-blue-500 text-white px-3 py-1 rounded disabled:opacity-50"
		>
			{#if isAdding}Adding...{:else}Add{/if}
		</button>
	</form>

	{#if isLoadingTodos}
		<p>Loading...</p>
	{:else if !hasTodos}
		<p>No todos yet.</p>
	{:else}
		<ul class="space-y-1">
			{#each todos as todo (todo.id)}
				{@const isToggling = $toggleMutation.isPending && $toggleMutation.variables?.id === todo.id}
				{@const isDeleting = $deleteMutation.isPending && $deleteMutation.variables?.id === todo.id}
				{@const isDisabled = isToggling || isDeleting}
				<li
					class="flex items-center justify-between p-2 "
					class:opacity-50={isDisabled}
				>
					<div class="flex items-center gap-2">
						<input
							type="checkbox"
							id={\`todo-\${todo.id}\`}
							checked={todo.completed}
							onchange={() => handleToggleTodo(todo.id, todo.completed)}
							disabled={isDisabled}
						/>
						<label
							for={\`todo-\${todo.id}\`}
							class:line-through={todo.completed}
						>
							{todo.text}
						</label>
					</div>
					<button
						type="button"
						onclick={() => handleDeleteTodo(todo.id)}
						disabled={isDisabled}
						aria-label="Delete todo"
						class="text-red-500 px-1 disabled:opacity-50"
					>
						{#if isDeleting}Deleting...{:else}X{/if}
					</button>
				</li>
			{/each}
		</ul>
	{/if}

	{#if $todosQuery.isError}
		<p class="mt-4 text-red-500">
			Error loading: {$todosQuery.error?.message ?? 'Unknown error'}
		</p>
	{/if}
	{#if $addMutation.isError}
		<p class="mt-4 text-red-500">
			Error adding: {$addMutation.error?.message ?? 'Unknown error'}
		</p>
	{/if}
	{#if $toggleMutation.isError}
		<p class="mt-4 text-red-500">
			Error updating: {$toggleMutation.error?.message ?? 'Unknown error'}
		</p>
	{/if}
	{#if $deleteMutation.isError}
		<p class="mt-4 text-red-500">
			Error deleting: {$deleteMutation.error?.message ?? 'Unknown error'}
		</p>
	{/if}
</div>
{{/if}}
`],
  ["examples/todo/web/react/tanstack-start/src/routes/todos.tsx.hbs", `import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Checkbox } from "@/components/ui/checkbox";
import { Input } from "@/components/ui/input";
import { createFileRoute } from "@tanstack/react-router";
{{#if (eq backend "convex")}}
import { Trash2 } from "lucide-react";
{{else}}
import { Loader2, Trash2 } from "lucide-react";
{{/if}}
import { useState } from "react";

{{#if (eq backend "convex")}}
import { useSuspenseQuery } from "@tanstack/react-query";
import { convexQuery } from "@convex-dev/react-query";
import { useMutation } from "convex/react";
import { api } from "@{{projectName}}/backend/convex/_generated/api";
import type { Id } from "@{{projectName}}/backend/convex/_generated/dataModel";
{{else}}
{{#if (eq api "trpc")}}
import { useTRPC } from "@/utils/trpc";
{{/if}}
{{#if (eq api "orpc")}}
import { orpc } from "@/utils/orpc";
{{/if}}
import { useMutation, useQuery } from "@tanstack/react-query";
{{/if}}

export const Route = createFileRoute("/todos")({
  component: TodosRoute,
});

function TodosRoute() {
  const [newTodoText, setNewTodoText] = useState("");

  {{#if (eq backend "convex")}}
  const todosQuery = useSuspenseQuery(convexQuery(api.todos.getAll, {}));
  const todos = todosQuery.data;

  const createTodo = useMutation(api.todos.create);
  const toggleTodo = useMutation(api.todos.toggle);
  const removeTodo = useMutation(api.todos.deleteTodo);

  const handleAddTodo = async (e: React.FormEvent) => {
    e.preventDefault();
    const text = newTodoText.trim();
    if (text) {
      setNewTodoText("");
      try {
        await createTodo({ text });
      } catch (error) {
        console.error("Failed to add todo:", error);
        setNewTodoText(text);
      }
    }
  };

  const handleToggleTodo = async (id: Id<"todos">, completed: boolean) => {
    try {
      await toggleTodo({ id, completed: !completed });
    } catch (error) {
      console.error("Failed to toggle todo:", error);
    }
  };

  const handleDeleteTodo = async (id: Id<"todos">) => {
    try {
      await removeTodo({ id });
    } catch (error) {
      console.error("Failed to delete todo:", error);
    }
  };
  {{else}}
    {{#if (eq api "trpc")}}
  const trpc = useTRPC();
    {{/if}}
    {{#if (eq api "orpc")}}
    {{/if}}

    {{#if (eq api "trpc")}}
  const todos = useQuery(trpc.todo.getAll.queryOptions());
  const createMutation = useMutation(
    trpc.todo.create.mutationOptions({
      onSuccess: () => {
        todos.refetch();
        setNewTodoText("");
      },
    }),
  );
  const toggleMutation = useMutation(
    trpc.todo.toggle.mutationOptions({
      onSuccess: () => { todos.refetch() },
    }),
  );
  const deleteMutation = useMutation(
    trpc.todo.delete.mutationOptions({
      onSuccess: () => { todos.refetch() },
    }),
  );
    {{/if}}
    {{#if (eq api "orpc")}}
  const todos = useQuery(orpc.todo.getAll.queryOptions());
  const createMutation = useMutation(
    orpc.todo.create.mutationOptions({
      onSuccess: () => {
        todos.refetch();
        setNewTodoText("");
      },
    }),
  );
  const toggleMutation = useMutation(
    orpc.todo.toggle.mutationOptions({
      onSuccess: () => { todos.refetch() },
    }),
  );
  const deleteMutation = useMutation(
    orpc.todo.delete.mutationOptions({
      onSuccess: () => { todos.refetch() },
    }),
  );
    {{/if}}

  const handleAddTodo = (e: React.FormEvent) => {
    e.preventDefault();
    if (newTodoText.trim()) {
      createMutation.mutate({ text: newTodoText });
    }
  };

  const handleToggleTodo = (id: number, completed: boolean) => {
    toggleMutation.mutate({ id, completed: !completed });
  };

  const handleDeleteTodo = (id: number) => {
    deleteMutation.mutate({ id });
  };
  {{/if}}

  return (
    <div className="mx-auto w-full max-w-md py-10">
      <Card>
        <CardHeader>
          <CardTitle>Todo List{{#if (eq backend "convex")}} (Convex){{/if}}</CardTitle>
          <CardDescription>Manage your tasks efficiently</CardDescription>
        </CardHeader>
        <CardContent>
          <form
            onSubmit={handleAddTodo}
            className="mb-6 flex items-center space-x-2"
          >
            <Input
              value={newTodoText}
              onChange={(e) => setNewTodoText(e.target.value)}
              placeholder="Add a new task..."
              {{#unless (eq backend "convex")}}
              disabled={createMutation.isPending}
              {{/unless}}
            />
            <Button
              type="submit"
              {{#unless (eq backend "convex")}}
              disabled={createMutation.isPending || !newTodoText.trim()}
              {{else}}
              disabled={!newTodoText.trim()}
              {{/unless}}
            >
              {{#unless (eq backend "convex")}}
              {createMutation.isPending ? (
                <Loader2 className="h-4 w-4 animate-spin" />
              ) : (
                "Add"
              )}
              {{else}}
              Add
              {{/unless}}
            </Button>
          </form>

          {{#if (eq backend "convex")}}
          {todos?.length === 0 ? (
            <p className="py-4 text-center">No todos yet. Add one above!</p>
          ) : (
            <ul className="space-y-2">
              {todos?.map((todo) => (
                <li
                  key={todo._id}
                  className="flex items-center justify-between rounded-md border p-2"
                >
                  <div className="flex items-center space-x-2">
                    <Checkbox
                      checked={todo.completed}
                      onCheckedChange={() =>
                        handleToggleTodo(todo._id, todo.completed)
                      }
                      id={\`todo-\${todo._id}\`}
                    />
                    <label
                      htmlFor={\`todo-\${todo._id}\`}
                      className={\`\${
                        todo.completed
                          ? "text-muted-foreground line-through"
                          : ""
                      }\`}
                    >
                      {todo.text}
                    </label>
                  </div>
                  <Button
                    variant="ghost"
                    size="icon"
                    onClick={() => handleDeleteTodo(todo._id)}
                    aria-label="Delete todo"
                  >
                    <Trash2 className="h-4 w-4" />
                  </Button>
                </li>
              ))}
            </ul>
          )}
          {{else}}
          {todos.isLoading ? (
            <div className="flex justify-center py-4">
              <Loader2 className="h-6 w-6 animate-spin" />
            </div>
          ) : todos.data?.length === 0 ? (
            <p className="py-4 text-center">No todos yet. Add one above!</p>
          ) : (
            <ul className="space-y-2">
              {todos.data?.map((todo) => (
                <li
                  key={todo.id}
                  className="flex items-center justify-between rounded-md border p-2"
                >
                  <div className="flex items-center space-x-2">
                    <Checkbox
                      checked={todo.completed}
                      onCheckedChange={() =>
                        handleToggleTodo(todo.id, todo.completed)
                      }
                      id={\`todo-\${todo.id}\`}
                    />
                    <label
                      htmlFor={\`todo-\${todo.id}\`}
                      className={\`\${todo.completed ? "line-through" : ""}\`}
                    >
                      {todo.text}
                    </label>
                  </div>
                  <Button
                    variant="ghost"
                    size="icon"
                    onClick={() => handleDeleteTodo(todo.id)}
                    aria-label="Delete todo"
                  >
                    <Trash2 className="h-4 w-4" />
                  </Button>
                </li>
              ))}
            </ul>
          )}
          {{/if}}
        </CardContent>
      </Card>
    </div>
  );
}
`],
  ["auth/clerk/convex/web/react/next/src/middleware.ts.hbs", `import { clerkMiddleware } from "@clerk/nextjs/server";

export default clerkMiddleware();

export const config = {
	matcher: [
		// Skip Next.js internals and all static files, unless found in search params
		"/((?!_next|[^?]*\\\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)",
		// Always run for API routes
		"/(api|trpc)(.*)",
	],
};
`],
  ["examples/todo/server/drizzle/mysql/src/schema/todo.ts", `import { mysqlTable, varchar, int, boolean } from "drizzle-orm/mysql-core";

export const todo = mysqlTable("todo", {
  id: int("id").primaryKey().autoincrement(),
  text: varchar("text", { length: 255 }).notNull(),
  completed: boolean("completed").default(false).notNull(),
});
`],
  ["auth/clerk/convex/native/base/app/(auth)/sign-up.tsx.hbs", `import * as React from "react";
import { Text, TextInput, TouchableOpacity, View } from "react-native";
import { useSignUp } from "@clerk/clerk-expo";
import { Link, useRouter } from "expo-router";

export default function SignUpScreen() {
  const { isLoaded, signUp, setActive } = useSignUp();
  const router = useRouter();

  const [emailAddress, setEmailAddress] = React.useState("");
  const [password, setPassword] = React.useState("");
  const [pendingVerification, setPendingVerification] = React.useState(false);
  const [code, setCode] = React.useState("");

  // Handle submission of sign-up form
  const onSignUpPress = async () => {
    if (!isLoaded) return;

    console.log(emailAddress, password);

    // Start sign-up process using email and password provided
    try {
      await signUp.create({
        emailAddress,
        password,
      });

      // Send user an email with verification code
      await signUp.prepareEmailAddressVerification({ strategy: "email_code" });

      // Set 'pendingVerification' to true to display second form
      // and capture OTP code
      setPendingVerification(true);
    } catch (err) {
      // See https://clerk.com/docs/custom-flows/error-handling
      // for more info on error handling
      console.error(JSON.stringify(err, null, 2));
    }
  };

  // Handle submission of verification form
  const onVerifyPress = async () => {
    if (!isLoaded) return;

    try {
      // Use the code the user provided to attempt verification
      const signUpAttempt = await signUp.attemptEmailAddressVerification({
        code,
      });

      // If verification was completed, set the session to active
      // and redirect the user
      if (signUpAttempt.status === "complete") {
        await setActive({ session: signUpAttempt.createdSessionId });
        router.replace("/");
      } else {
        // If the status is not complete, check why. User may need to
        // complete further steps.
        console.error(JSON.stringify(signUpAttempt, null, 2));
      }
    } catch (err) {
      // See https://clerk.com/docs/custom-flows/error-handling
      // for more info on error handling
      console.error(JSON.stringify(err, null, 2));
    }
  };

  if (pendingVerification) {
    return (
      <>
        <Text>Verify your email</Text>
        <TextInput
          value={code}
          placeholder="Enter your verification code"
          onChangeText={(code) => setCode(code)}
        />
        <TouchableOpacity onPress={onVerifyPress}>
          <Text>Verify</Text>
        </TouchableOpacity>
      </>
    );
  }

  return (
    <View>
      <Text>Sign up</Text>
      <TextInput
        autoCapitalize="none"
        value={emailAddress}
        placeholder="Enter email"
        onChangeText={(email) => setEmailAddress(email)}
      />
      <TextInput
        value={password}
        placeholder="Enter password"
        secureTextEntry={true}
        onChangeText={(password) => setPassword(password)}
      />
      <TouchableOpacity onPress={onSignUpPress}>
        <Text>Continue</Text>
      </TouchableOpacity>
      <View style=\\{{ display: "flex", flexDirection: "row", gap: 3 }}>
        <Text>Already have an account?</Text>
        <Link href="/sign-in">
          <Text>Sign in</Text>
        </Link>
      </View>
    </View>
  );
}
`],
  ["auth/clerk/convex/native/base/app/(auth)/sign-in.tsx.hbs", `import { useSignIn } from "@clerk/clerk-expo";
import { Link, useRouter } from "expo-router";
import { Text, TextInput, TouchableOpacity, View } from "react-native";
import React from "react";

export default function Page() {
  const { signIn, setActive, isLoaded } = useSignIn();
  const router = useRouter();

  const [emailAddress, setEmailAddress] = React.useState("");
  const [password, setPassword] = React.useState("");

  // Handle the submission of the sign-in form
  const onSignInPress = async () => {
    if (!isLoaded) return;

    // Start the sign-in process using the email and password provided
    try {
      const signInAttempt = await signIn.create({
        identifier: emailAddress,
        password,
      });

      // If sign-in process is complete, set the created session as active
      // and redirect the user
      if (signInAttempt.status === "complete") {
        await setActive({ session: signInAttempt.createdSessionId });
        router.replace("/");
      } else {
        // If the status isn't complete, check why. User might need to
        // complete further steps.
        console.error(JSON.stringify(signInAttempt, null, 2));
      }
    } catch (err) {
      // See https://clerk.com/docs/custom-flows/error-handling
      // for more info on error handling
      console.error(JSON.stringify(err, null, 2));
    }
  };

  return (
    <View>
      <Text>Sign in</Text>
      <TextInput
        autoCapitalize="none"
        value={emailAddress}
        placeholder="Enter email"
        onChangeText={(emailAddress) => setEmailAddress(emailAddress)}
      />
      <TextInput
        value={password}
        placeholder="Enter password"
        secureTextEntry={true}
        onChangeText={(password) => setPassword(password)}
      />
      <TouchableOpacity onPress={onSignInPress}>
        <Text>Continue</Text>
      </TouchableOpacity>
      <View style=\\{{ display: "flex", flexDirection: "row", gap: 3 }}>
        <Text>Don't have an account?</Text>
        <Link href="/sign-up">
          <Text>Sign up</Text>
        </Link>
      </View>
    </View>
  );
}
`],
  ["auth/clerk/convex/native/base/app/(auth)/_layout.tsx.hbs", `import { Redirect, Stack } from "expo-router";
import { useAuth } from "@clerk/clerk-expo";

export default function AuthRoutesLayout() {
  const { isSignedIn } = useAuth();

  if (isSignedIn) {
    return <Redirect href={"/"} />;
  }

  return <Stack />;
}
`],
  ["examples/todo/server/drizzle/sqlite/src/schema/todo.ts", `import { integer, sqliteTable, text } from "drizzle-orm/sqlite-core";

export const todo = sqliteTable("todo", {
  id: integer("id").primaryKey({ autoIncrement: true }),
  text: text("text").notNull(),
  completed: integer("completed", { mode: "boolean" }).default(false).notNull(),
});
`],
  ["examples/todo/server/drizzle/base/src/routers/todo.ts.hbs", `{{#if (eq api "orpc")}}
import { eq } from "drizzle-orm";
import z from "zod";
import { db } from "@{{projectName}}/db";
import { todo } from "@{{projectName}}/db/schema/todo";
import { publicProcedure } from "../index";

export const todoRouter = {
  getAll: publicProcedure.handler(async () => {
    return await db.select().from(todo);
  }),

  create: publicProcedure
    .input(z.object({ text: z.string().min(1) }))
    .handler(async ({ input }) => {
      return await db
        .insert(todo)
        .values({
          text: input.text,
        });
    }),

  toggle: publicProcedure
    .input(z.object({ id: z.number(), completed: z.boolean() }))
    .handler(async ({ input }) => {
      return await db
        .update(todo)
        .set({ completed: input.completed })
        .where(eq(todo.id, input.id));
    }),

  delete: publicProcedure
    .input(z.object({ id: z.number() }))
    .handler(async ({ input }) => {
      return await db.delete(todo).where(eq(todo.id, input.id));
    }),
};
{{/if}}

{{#if (eq api "trpc")}}
import z from "zod";
import { router, publicProcedure } from "../index";
import { todo } from "@{{projectName}}/db/schema/todo";
import { eq } from "drizzle-orm";
import { db } from "@{{projectName}}/db";

export const todoRouter = router({
  getAll: publicProcedure.query(async () => {
    return await db.select().from(todo);
  }),

  create: publicProcedure
    .input(z.object({ text: z.string().min(1) }))
    .mutation(async ({ input }) => {
      return await db.insert(todo).values({
        text: input.text,
      });
    }),

  toggle: publicProcedure
    .input(z.object({ id: z.number(), completed: z.boolean() }))
    .mutation(async ({ input }) => {
      return await db
        .update(todo)
        .set({ completed: input.completed })
        .where(eq(todo.id, input.id));
    }),

  delete: publicProcedure
    .input(z.object({ id: z.number() }))
    .mutation(async ({ input }) => {
      return await db.delete(todo).where(eq(todo.id, input.id));
    }),
});
{{/if}}
`],
  ["examples/todo/server/drizzle/postgres/src/schema/todo.ts", `import { pgTable, text, boolean, serial } from "drizzle-orm/pg-core";

export const todo = pgTable("todo", {
  id: serial("id").primaryKey(),
  text: text("text").notNull(),
  completed: boolean("completed").default(false).notNull(),
});
`],
  ["examples/todo/server/prisma/mongodb/prisma/schema/todo.prisma.hbs", `model Todo {
  id        String  @id @default(auto()) @map("_id") @db.ObjectId
  text      String
  completed Boolean @default(false)

  @@map("todo")
}
`],
  ["examples/todo/server/prisma/base/src/routers/todo.ts.hbs", `{{#if (eq api "orpc")}}
import z from "zod";
import prisma from "@{{projectName}}/db";
import { publicProcedure } from "../index";

export const todoRouter = {
  getAll: publicProcedure.handler(async () => {
    return await prisma.todo.findMany({
      orderBy: {
        id: "asc",
      },
    });
  }),

  create: publicProcedure
    .input(z.object({ text: z.string().min(1) }))
    .handler(async ({ input }) => {
      return await prisma.todo.create({
        data: {
          text: input.text,
        },
      });
    }),

  toggle: publicProcedure
    {{#if (eq database "mongodb")}}
    .input(z.object({ id: z.string(), completed: z.boolean() }))
    {{else}}
    .input(z.object({ id: z.number(), completed: z.boolean() }))
    {{/if}}
    .handler(async ({ input }) => {
      return await prisma.todo.update({
        where: { id: input.id },
        data: { completed: input.completed },
      });
    }),

  delete: publicProcedure
    {{#if (eq database "mongodb")}}
    .input(z.object({ id: z.string() }))
    {{else}}
    .input(z.object({ id: z.number() }))
    {{/if}}
    .handler(async ({ input }) => {
      return await prisma.todo.delete({
        where: { id: input.id },
      });
    }),
};
{{/if}}

{{#if (eq api "trpc")}}
import { TRPCError } from "@trpc/server";
import z from "zod";
import prisma from "@{{projectName}}/db";
import { publicProcedure, router } from "../index";

export const todoRouter = router({
  getAll: publicProcedure.query(async () => {
    return await prisma.todo.findMany({
      orderBy: {
        id: "asc"
      }
    });
  }),

  create: publicProcedure
    .input(z.object({ text: z.string().min(1) }))
    .mutation(async ({ input }) => {
      return await prisma.todo.create({
        data: {
          text: input.text,
        },
      });
    }),

  toggle: publicProcedure
    {{#if (eq database "mongodb")}}
    .input(z.object({ id: z.string(), completed: z.boolean() }))
    {{else}}
    .input(z.object({ id: z.number(), completed: z.boolean() }))
    {{/if}}
    .mutation(async ({ input }) => {
      try {
        return await prisma.todo.update({
          where: { id: input.id },
          data: { completed: input.completed },
        });
      } catch (error) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "Todo not found",
        });
      }
    }),

  delete: publicProcedure
    {{#if (eq database "mongodb")}}
    .input(z.object({ id: z.string() }))
    {{else}}
    .input(z.object({ id: z.number() }))
    {{/if}}
    .mutation(async ({ input }) => {
      try {
        return await prisma.todo.delete({
          where: { id: input.id },
        });
      } catch (error) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "Todo not found",
        });
      }
    }),
});
{{/if}}
`],
  ["examples/todo/server/prisma/postgres/prisma/schema/todo.prisma.hbs", `model Todo {
  id        Int     @id @default(autoincrement())
  text      String
  completed Boolean @default(false)

  @@map("todo")
}
`],
  ["examples/todo/server/prisma/sqlite/prisma/schema/todo.prisma.hbs", `model Todo {
  id        Int     @id @default(autoincrement())
  text      String
  completed Boolean @default(false)

  @@map("todo")
}
`],
  ["examples/todo/server/prisma/mysql/prisma/schema/todo.prisma.hbs", `model Todo {
  id        Int     @id @default(autoincrement())
  text      String
  completed Boolean @default(false)

  @@map("todo")
}
`],
  ["examples/todo/server/mongoose/base/src/routers/todo.ts.hbs", `{{#if (eq api "orpc")}}
import z from "zod";
import { publicProcedure } from "../index";
import { Todo } from "@{{projectName}}/db/models/todo.model";

export const todoRouter = {
    getAll: publicProcedure.handler(async () => {
        return await Todo.find().lean();
    }),

    create: publicProcedure
        .input(z.object({ text: z.string().min(1) }))
        .handler(async ({ input }) => {
            const newTodo = await Todo.create({ text: input.text });
            return newTodo.toObject();
    }),

    toggle: publicProcedure
        .input(z.object({ id: z.string(), completed: z.boolean() }))
        .handler(async ({ input }) => {
            await Todo.updateOne({ id: input.id }, { completed: input.completed });
            return { success: true };
    }),

    delete: publicProcedure
        .input(z.object({ id: z.string() }))
        .handler(async ({ input }) => {
            await Todo.deleteOne({ id: input.id });
            return { success: true };
    }),
};

{{/if}}

{{#if (eq api "trpc")}}
import z from "zod";
import { router, publicProcedure } from "../index";
import { Todo } from "@{{projectName}}/db/models/todo.model";

export const todoRouter = router({
    getAll: publicProcedure.query(async () => {
        return await Todo.find().lean();
    }),

    create: publicProcedure
        .input(z.object({ text: z.string().min(1) }))
        .mutation(async ({ input }) => {
            const newTodo = await Todo.create({ text: input.text });
        return newTodo.toObject();
    }),

    toggle: publicProcedure
        .input(z.object({ id: z.string(), completed: z.boolean() }))
        .mutation(async ({ input }) => {
            await Todo.updateOne({ id: input.id }, { completed: input.completed });
            return { success: true };
    }),

    delete: publicProcedure
        .input(z.object({ id: z.string() }))
        .mutation(async ({ input }) => {
            await Todo.deleteOne({ id: input.id });
            return { success: true };
    }),
});
{{/if}}
`],
  ["auth/better-auth/web/react/tanstack-router/src/routes/login.tsx.hbs", `import SignInForm from "@/components/sign-in-form";
import SignUpForm from "@/components/sign-up-form";
import { createFileRoute } from "@tanstack/react-router";
import { useState } from "react";

export const Route = createFileRoute("/login")({
  component: RouteComponent,
});

function RouteComponent() {
  const [showSignIn, setShowSignIn] = useState(false);

  return showSignIn ? (
    <SignInForm onSwitchToSignUp={() => setShowSignIn(false)} />
  ) : (
    <SignUpForm onSwitchToSignIn={() => setShowSignIn(true)} />
  );
}
`],
  ["auth/better-auth/web/react/tanstack-router/src/routes/dashboard.tsx.hbs", `{{#if (eq payments "polar")}}
import { Button } from "@/components/ui/button";
{{/if}}
import { authClient } from "@/lib/auth-client";
{{#if (eq api "orpc")}}
import { orpc } from "@/utils/orpc";
{{/if}}
{{#if (eq api "trpc")}}
import { trpc } from "@/utils/trpc";
{{/if}}
{{#if ( or (eq api "orpc") (eq api "trpc"))}}
import { useQuery } from "@tanstack/react-query";
{{/if}}
import { createFileRoute, redirect } from "@tanstack/react-router";

export const Route = createFileRoute("/dashboard")({
	component: RouteComponent,
	beforeLoad: async () => {
		const session = await authClient.getSession();
		if (!session.data) {
			redirect({
				to: "/login",
				throw: true
			});
		}
		{{#if (eq payments "polar")}}
		const {data: customerState} = await authClient.customer.state()
		return { session, customerState };
		{{else}}
		return { session };
		{{/if}}
	}
});

function RouteComponent() {
	const { session{{#if (eq payments "polar")}}, customerState{{/if}} } = Route.useRouteContext();

	{{#if (eq api "orpc")}}
	const privateData = useQuery(orpc.privateData.queryOptions());
	{{/if}}
	{{#if (eq api "trpc")}}
	const privateData = useQuery(trpc.privateData.queryOptions());
	{{/if}}

	{{#if (eq payments "polar")}}
	const hasProSubscription = customerState?.activeSubscriptions?.length! > 0
    console.log("Active subscriptions:", customerState?.activeSubscriptions)
	{{/if}}

	return (
		<div>
			<h1>Dashboard</h1>
			<p>Welcome {session.data?.user.name}</p>
			{{#if ( or (eq api "orpc") (eq api "trpc"))}}
			<p>API: {privateData.data?.message}</p>
			{{/if}}
			{{#if (eq payments "polar")}}
			<p>Plan: {hasProSubscription ? "Pro" : "Free"}</p>
			{hasProSubscription ? (
				<Button onClick={async () => await authClient.customer.portal()}>
					Manage Subscription
				</Button>
			) : (
				<Button onClick={async () => await authClient.checkout({ slug: "pro" })}>
					Upgrade to Pro
				</Button>
			)}
			{{/if}}
		</div>
	);
}
`],
  ["auth/better-auth/web/react/tanstack-router/src/components/user-menu.tsx.hbs", `import { Link, useNavigate } from "@tanstack/react-router";

import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { authClient } from "@/lib/auth-client";

import { Button } from "./ui/button";
import { Skeleton } from "./ui/skeleton";

export default function UserMenu() {
  const navigate = useNavigate();
  const { data: session, isPending } = authClient.useSession();

  if (isPending) {
    return <Skeleton className="h-9 w-24" />;
  }

  if (!session) {
    return (
      <Link to="/login">
        <Button variant="outline">Sign In</Button>
      </Link>
    );
  }

  return (
    <DropdownMenu>
      <DropdownMenuTrigger render={<Button variant="outline" />}>
        {session.user.name}
      </DropdownMenuTrigger>
      <DropdownMenuContent className="bg-card">
        <DropdownMenuGroup>
          <DropdownMenuLabel>My Account</DropdownMenuLabel>
          <DropdownMenuSeparator />
          <DropdownMenuItem>{session.user.email}</DropdownMenuItem>
          <DropdownMenuItem
            variant="destructive"
            onClick={() => {
              authClient.signOut({
                fetchOptions: {
                  onSuccess: () => {
                    navigate({
                      to: "/",
                    });
                  },
                },
              });
            }}
          >
            Sign Out
          </DropdownMenuItem>
        </DropdownMenuGroup>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}
`],
  ["auth/better-auth/web/react/tanstack-router/src/components/sign-in-form.tsx.hbs", `import { authClient } from "@/lib/auth-client";
import { useForm } from "@tanstack/react-form";
import { useNavigate } from "@tanstack/react-router";
import { toast } from "sonner";
import z from "zod";
import Loader from "./loader";
import { Button } from "./ui/button";
import { Input } from "./ui/input";
import { Label } from "./ui/label";

export default function SignInForm({ onSwitchToSignUp }: { onSwitchToSignUp: () => void }) {
  const navigate = useNavigate({
    from: "/",
  });
  const { isPending } = authClient.useSession();

  const form = useForm({
    defaultValues: {
      email: "",
      password: "",
    },
    onSubmit: async ({ value }) => {
      await authClient.signIn.email(
        {
          email: value.email,
          password: value.password,
        },
        {
          onSuccess: () => {
            navigate({
              to: "/dashboard",
            });
            toast.success("Sign in successful");
          },
          onError: (error) => {
            toast.error(error.error.message || error.error.statusText);
          },
        },
      );
    },
    validators: {
      onSubmit: z.object({
        email: z.email("Invalid email address"),
        password: z.string().min(8, "Password must be at least 8 characters"),
      }),
    },
  });

  if (isPending) {
    return <Loader />;
  }

  return (
    <div className="mx-auto w-full mt-10 max-w-md p-6">
      <h1 className="mb-6 text-center text-3xl font-bold">Welcome Back</h1>

      <form
        onSubmit={(e) => {
          e.preventDefault();
          e.stopPropagation();
          form.handleSubmit();
        }}
        className="space-y-4"
      >
        <div>
          <form.Field name="email">
            {(field) => (
              <div className="space-y-2">
                <Label htmlFor={field.name}>Email</Label>
                <Input
                  id={field.name}
                  name={field.name}
                  type="email"
                  value={field.state.value}
                  onBlur={field.handleBlur}
                  onChange={(e) => field.handleChange(e.target.value)}
                />
                {field.state.meta.errors.map((error) => (
                  <p key={error?.message} className="text-red-500">
                    {error?.message}
                  </p>
                ))}
              </div>
            )}
          </form.Field>
        </div>

        <div>
          <form.Field name="password">
            {(field) => (
              <div className="space-y-2">
                <Label htmlFor={field.name}>Password</Label>
                <Input
                  id={field.name}
                  name={field.name}
                  type="password"
                  value={field.state.value}
                  onBlur={field.handleBlur}
                  onChange={(e) => field.handleChange(e.target.value)}
                />
                {field.state.meta.errors.map((error) => (
                  <p key={error?.message} className="text-red-500">
                    {error?.message}
                  </p>
                ))}
              </div>
            )}
          </form.Field>
        </div>

        <form.Subscribe>
          {(state) => (
            <Button
              type="submit"
              className="w-full"
              disabled={!state.canSubmit || state.isSubmitting}
            >
              {state.isSubmitting ? "Submitting..." : "Sign In"}
            </Button>
          )}
        </form.Subscribe>
      </form>

      <div className="mt-4 text-center">
        <Button
          variant="link"
          onClick={onSwitchToSignUp}
          className="text-indigo-600 hover:text-indigo-800"
        >
          Need an account? Sign Up
        </Button>
      </div>
    </div>
  );
}
`],
  ["auth/better-auth/web/react/tanstack-router/src/components/sign-up-form.tsx.hbs", `import { authClient } from "@/lib/auth-client";
import { useForm } from "@tanstack/react-form";
import { useNavigate } from "@tanstack/react-router";
import { toast } from "sonner";
import z from "zod";
import Loader from "./loader";
import { Button } from "./ui/button";
import { Input } from "./ui/input";
import { Label } from "./ui/label";

export default function SignUpForm({ onSwitchToSignIn }: { onSwitchToSignIn: () => void }) {
  const navigate = useNavigate({
    from: "/",
  });
  const { isPending } = authClient.useSession();

  const form = useForm({
    defaultValues: {
      email: "",
      password: "",
      name: "",
    },
    onSubmit: async ({ value }) => {
      await authClient.signUp.email(
        {
          email: value.email,
          password: value.password,
          name: value.name,
        },
        {
          onSuccess: () => {
            navigate({
              to: "/dashboard",
            });
            toast.success("Sign up successful");
          },
          onError: (error) => {
            toast.error(error.error.message || error.error.statusText);
          },
        },
      );
    },
    validators: {
      onSubmit: z.object({
        name: z.string().min(2, "Name must be at least 2 characters"),
        email: z.email("Invalid email address"),
        password: z.string().min(8, "Password must be at least 8 characters"),
      }),
    },
  });

  if (isPending) {
    return <Loader />;
  }

  return (
    <div className="mx-auto w-full mt-10 max-w-md p-6">
      <h1 className="mb-6 text-center text-3xl font-bold">Create Account</h1>

      <form
        onSubmit={(e) => {
          e.preventDefault();
          e.stopPropagation();
          form.handleSubmit();
        }}
        className="space-y-4"
      >
        <div>
          <form.Field name="name">
            {(field) => (
              <div className="space-y-2">
                <Label htmlFor={field.name}>Name</Label>
                <Input
                  id={field.name}
                  name={field.name}
                  value={field.state.value}
                  onBlur={field.handleBlur}
                  onChange={(e) => field.handleChange(e.target.value)}
                />
                {field.state.meta.errors.map((error) => (
                  <p key={error?.message} className="text-red-500">
                    {error?.message}
                  </p>
                ))}
              </div>
            )}
          </form.Field>
        </div>

        <div>
          <form.Field name="email">
            {(field) => (
              <div className="space-y-2">
                <Label htmlFor={field.name}>Email</Label>
                <Input
                  id={field.name}
                  name={field.name}
                  type="email"
                  value={field.state.value}
                  onBlur={field.handleBlur}
                  onChange={(e) => field.handleChange(e.target.value)}
                />
                {field.state.meta.errors.map((error) => (
                  <p key={error?.message} className="text-red-500">
                    {error?.message}
                  </p>
                ))}
              </div>
            )}
          </form.Field>
        </div>

        <div>
          <form.Field name="password">
            {(field) => (
              <div className="space-y-2">
                <Label htmlFor={field.name}>Password</Label>
                <Input
                  id={field.name}
                  name={field.name}
                  type="password"
                  value={field.state.value}
                  onBlur={field.handleBlur}
                  onChange={(e) => field.handleChange(e.target.value)}
                />
                {field.state.meta.errors.map((error) => (
                  <p key={error?.message} className="text-red-500">
                    {error?.message}
                  </p>
                ))}
              </div>
            )}
          </form.Field>
        </div>

        <form.Subscribe>
          {(state) => (
            <Button
              type="submit"
              className="w-full"
              disabled={!state.canSubmit || state.isSubmitting}
            >
              {state.isSubmitting ? "Submitting..." : "Sign Up"}
            </Button>
          )}
        </form.Subscribe>
      </form>

      <div className="mt-4 text-center">
        <Button
          variant="link"
          onClick={onSwitchToSignIn}
          className="text-indigo-600 hover:text-indigo-800"
        >
          Already have an account? Sign In
        </Button>
      </div>
    </div>
  );
}
`],
  ["auth/better-auth/web/react/next/src/components/user-menu.tsx.hbs", `import Link from "next/link";
import { useRouter } from "next/navigation";

import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { authClient } from "@/lib/auth-client";

import { Button } from "./ui/button";
import { Skeleton } from "./ui/skeleton";

export default function UserMenu() {
  const router = useRouter();
  const { data: session, isPending } = authClient.useSession();

  if (isPending) {
    return <Skeleton className="h-9 w-24" />;
  }

  if (!session) {
    return (
      <Link href="/login">
        <Button variant="outline">Sign In</Button>
      </Link>
    );
  }

  return (
    <DropdownMenu>
      <DropdownMenuTrigger render={<Button variant="outline" />}>
        {session.user.name}
      </DropdownMenuTrigger>
      <DropdownMenuContent className="bg-card">
        <DropdownMenuGroup>
          <DropdownMenuLabel>My Account</DropdownMenuLabel>
          <DropdownMenuSeparator />
          <DropdownMenuItem>{session.user.email}</DropdownMenuItem>
          <DropdownMenuItem
            variant="destructive"
            onClick={() => {
              authClient.signOut({
                fetchOptions: {
                  onSuccess: () => {
                    router.push("/");
                  },
                },
              });
            }}
          >
            Sign Out
          </DropdownMenuItem>
        </DropdownMenuGroup>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}
`],
  ["auth/better-auth/web/react/next/src/components/sign-in-form.tsx.hbs", `import { authClient } from "@/lib/auth-client";
import { useForm } from "@tanstack/react-form";
import { toast } from "sonner";
import z from "zod";
import Loader from "./loader";
import { Button } from "./ui/button";
import { Input } from "./ui/input";
import { Label } from "./ui/label";
import { useRouter } from "next/navigation";

export default function SignInForm({
  onSwitchToSignUp,
}: {
  onSwitchToSignUp: () => void;
}) {
  const router = useRouter()
  const { isPending } = authClient.useSession();

  const form = useForm({
    defaultValues: {
      email: "",
      password: "",
    },
    onSubmit: async ({ value }) => {
      await authClient.signIn.email(
        {
          email: value.email,
          password: value.password,
        },
        {
          onSuccess: () => {
            router.push("/dashboard")
            toast.success("Sign in successful");
          },
          onError: (error) => {
            toast.error(error.error.message || error.error.statusText);
          },
        },
      );
    },
    validators: {
      onSubmit: z.object({
        email: z.email("Invalid email address"),
        password: z.string().min(8, "Password must be at least 8 characters"),
      }),
    },
  });

  if (isPending) {
    return <Loader />;
  }

  return (
    <div className="mx-auto w-full mt-10 max-w-md p-6">
      <h1 className="mb-6 text-center text-3xl font-bold">Welcome Back</h1>

      <form
        onSubmit={(e) => {
          e.preventDefault();
          e.stopPropagation();
          form.handleSubmit();
        }}
        className="space-y-4"
      >
        <div>
          <form.Field name="email">
            {(field) => (
              <div className="space-y-2">
                <Label htmlFor={field.name}>Email</Label>
                <Input
                  id={field.name}
                  name={field.name}
                  type="email"
                  value={field.state.value}
                  onBlur={field.handleBlur}
                  onChange={(e) => field.handleChange(e.target.value)}
                />
                {field.state.meta.errors.map((error) => (
                  <p key={error?.message} className="text-red-500">
                    {error?.message}
                  </p>
                ))}
              </div>
            )}
          </form.Field>
        </div>

        <div>
          <form.Field name="password">
            {(field) => (
              <div className="space-y-2">
                <Label htmlFor={field.name}>Password</Label>
                <Input
                  id={field.name}
                  name={field.name}
                  type="password"
                  value={field.state.value}
                  onBlur={field.handleBlur}
                  onChange={(e) => field.handleChange(e.target.value)}
                />
                {field.state.meta.errors.map((error) => (
                  <p key={error?.message} className="text-red-500">
                    {error?.message}
                  </p>
                ))}
              </div>
            )}
          </form.Field>
        </div>

        <form.Subscribe>
          {(state) => (
            <Button
              type="submit"
              className="w-full"
              disabled={!state.canSubmit || state.isSubmitting}
            >
              {state.isSubmitting ? "Submitting..." : "Sign In"}
            </Button>
          )}
        </form.Subscribe>
      </form>

      <div className="mt-4 text-center">
        <Button
          variant="link"
          onClick={onSwitchToSignUp}
          className="text-indigo-600 hover:text-indigo-800"
        >
          Need an account? Sign Up
        </Button>
      </div>
    </div>
  );
}
`],
  ["auth/better-auth/web/react/next/src/components/sign-up-form.tsx.hbs", `import { authClient } from "@/lib/auth-client";
import { useForm } from "@tanstack/react-form";
import { toast } from "sonner";
import z from "zod";
import Loader from "./loader";
import { Button } from "./ui/button";
import { Input } from "./ui/input";
import { Label } from "./ui/label";
import { useRouter } from "next/navigation";

export default function SignUpForm({
  onSwitchToSignIn,
}: {
  onSwitchToSignIn: () => void;
}) {
  const router = useRouter();
  const { isPending } = authClient.useSession();

  const form = useForm({
    defaultValues: {
      email: "",
      password: "",
      name: "",
    },
    onSubmit: async ({ value }) => {
      await authClient.signUp.email(
        {
          email: value.email,
          password: value.password,
          name: value.name,
        },
        {
          onSuccess: () => {
            router.push("/dashboard");
            toast.success("Sign up successful");
          },
          onError: (error) => {
            toast.error(error.error.message || error.error.statusText);
          },
        },
      );
    },
    validators: {
      onSubmit: z.object({
        name: z.string().min(2, "Name must be at least 2 characters"),
        email: z.email("Invalid email address"),
        password: z.string().min(8, "Password must be at least 8 characters"),
      }),
    },
  });

  if (isPending) {
    return <Loader />;
  }

  return (
    <div className="mx-auto w-full mt-10 max-w-md p-6">
      <h1 className="mb-6 text-center text-3xl font-bold">Create Account</h1>

      <form
        onSubmit={(e) => {
          e.preventDefault();
          e.stopPropagation();
          form.handleSubmit();
        }}
        className="space-y-4"
      >
        <div>
          <form.Field name="name">
            {(field) => (
              <div className="space-y-2">
                <Label htmlFor={field.name}>Name</Label>
                <Input
                  id={field.name}
                  name={field.name}
                  value={field.state.value}
                  onBlur={field.handleBlur}
                  onChange={(e) => field.handleChange(e.target.value)}
                />
                {field.state.meta.errors.map((error) => (
                  <p key={error?.message} className="text-red-500">
                    {error?.message}
                  </p>
                ))}
              </div>
            )}
          </form.Field>
        </div>

        <div>
          <form.Field name="email">
            {(field) => (
              <div className="space-y-2">
                <Label htmlFor={field.name}>Email</Label>
                <Input
                  id={field.name}
                  name={field.name}
                  type="email"
                  value={field.state.value}
                  onBlur={field.handleBlur}
                  onChange={(e) => field.handleChange(e.target.value)}
                />
                {field.state.meta.errors.map((error) => (
                  <p key={error?.message} className="text-red-500">
                    {error?.message}
                  </p>
                ))}
              </div>
            )}
          </form.Field>
        </div>

        <div>
          <form.Field name="password">
            {(field) => (
              <div className="space-y-2">
                <Label htmlFor={field.name}>Password</Label>
                <Input
                  id={field.name}
                  name={field.name}
                  type="password"
                  value={field.state.value}
                  onBlur={field.handleBlur}
                  onChange={(e) => field.handleChange(e.target.value)}
                />
                {field.state.meta.errors.map((error) => (
                  <p key={error?.message} className="text-red-500">
                    {error?.message}
                  </p>
                ))}
              </div>
            )}
          </form.Field>
        </div>

        <form.Subscribe>
          {(state) => (
            <Button
              type="submit"
              className="w-full"
              disabled={!state.canSubmit || state.isSubmitting}
            >
              {state.isSubmitting ? "Submitting..." : "Sign Up"}
            </Button>
          )}
        </form.Subscribe>
      </form>

      <div className="mt-4 text-center">
        <Button
          variant="link"
          onClick={onSwitchToSignIn}
          className="text-indigo-600 hover:text-indigo-800"
        >
          Already have an account? Sign In
        </Button>
      </div>
    </div>
  );
}
`],
  ["examples/todo/server/mongoose/mongodb/src/models/todo.model.ts.hbs", `import mongoose from 'mongoose';

const { Schema, model } = mongoose;

const todoSchema = new Schema({
  id: {
    type: mongoose.Schema.Types.ObjectId,
    auto: true,
  },
  text: {
    type: String,
    required: true,
  },
  completed: {
    type: Boolean,
    default: false,
  },
}, {
  collection: 'todo'
});

const Todo = model('Todo', todoSchema);

export { Todo };
`],
  ["auth/better-auth/web/react/base/src/lib/auth-client.ts.hbs", `import { createAuthClient } from "better-auth/react";
{{#if (eq payments "polar")}}
import { polarClient } from "@polar-sh/better-auth";
{{/if}}
{{#unless (eq backend "self")}}
import { env } from "@{{projectName}}/env/web";
{{/unless}}

export const authClient = createAuthClient({
{{#unless (eq backend "self")}}
	baseURL: env.{{#if (includes frontend "next")}}NEXT_PUBLIC_SERVER_URL{{else}}VITE_SERVER_URL{{/if}},
{{/unless}}
{{#if (eq payments "polar")}}
	plugins: [polarClient()]
{{/if}}
});
`],
  ["auth/better-auth/web/react/tanstack-start/src/routes/login.tsx.hbs", `import SignInForm from "@/components/sign-in-form";
import SignUpForm from "@/components/sign-up-form";
import { createFileRoute } from "@tanstack/react-router";
import { useState } from "react";

export const Route = createFileRoute("/login")({
  component: RouteComponent,
});

function RouteComponent() {
  const [showSignIn, setShowSignIn] = useState(false);

  return showSignIn ? (
    <SignInForm onSwitchToSignUp={() => setShowSignIn(false)} />
  ) : (
    <SignUpForm onSwitchToSignIn={() => setShowSignIn(true)} />
  );
}
`],
  ["auth/better-auth/web/react/tanstack-start/src/routes/dashboard.tsx.hbs", `import { getUser } from "@/functions/get-user";
{{#if (eq payments "polar") }}
import { Button } from "@/components/ui/button";
import { authClient } from "@/lib/auth-client";
import { getPayment } from "@/functions/get-payment";
{{/if}}
{{#if (eq api "trpc") }}
import { useTRPC } from "@/utils/trpc";
import { useQuery } from "@tanstack/react-query";
{{/if}}
{{#if (eq api "orpc") }}
import { orpc } from "@/utils/orpc";
import { useQuery } from "@tanstack/react-query";
{{/if}}
import { createFileRoute, redirect } from "@tanstack/react-router";

export const Route = createFileRoute("/dashboard")({
  component: RouteComponent,
  beforeLoad: async () => {
    const session = await getUser();
    {{#if (eq payments "polar") }}
    const customerState = await getPayment();
    return { session, customerState };
    {{else}}
    return { session };
    {{/if}}
  },
  loader: async ({ context }) => {
    if (!context.session) {
      throw redirect({
        to: "/login",
      });
    }
  },
});

function RouteComponent() {
  const { session{{#if (eq payments "polar") }}, customerState{{/if}} } = Route.useRouteContext();

  {{#if (eq api "trpc") }}
  const trpc = useTRPC();
  const privateData = useQuery(trpc.privateData.queryOptions());
  {{/if}}
  {{#if (eq api "orpc") }}
  const privateData = useQuery(orpc.privateData.queryOptions());
  {{/if}}

  {{#if (eq payments "polar") }}
  const hasProSubscription = (customerState?.activeSubscriptions?.length ?? 0) > 0;
  // For debugging: console.log("Active subscriptions:", customerState?.activeSubscriptions);
  {{/if}}

  return (
    <div>
      <h1>Dashboard</h1>
      <p>Welcome {session?.user.name}</p>
      {{#if (eq api "trpc") }}
      <p>API: {privateData.data?.message}</p>
      {{else if (eq api "orpc") }}
      <p>API: {privateData.data?.message}</p>
      {{/if}}
      {{#if (eq payments "polar") }}
      <p>Plan: {hasProSubscription ? "Pro" : "Free"}</p>
      {hasProSubscription ? (
        <Button
          onClick={async function handlePortal() {
            await authClient.customer.portal();
          }}
        >
          Manage Subscription
        </Button>
      ) : (
        <Button
          onClick={async function handleUpgrade() {
            await authClient.checkout({ slug: "pro" });
          }}
        >
          Upgrade to Pro
        </Button>
      )}
      {{/if}}
    </div>
  );
}`],
  ["auth/better-auth/web/react/tanstack-start/src/functions/get-user.ts.hbs", `import { authMiddleware } from "@/middleware/auth";
import { createServerFn } from "@tanstack/react-start";

export const getUser = createServerFn({ method: "GET" }).middleware([authMiddleware]).handler(async ({ context }) => {
    return context.session
})`],
  ["auth/better-auth/web/react/tanstack-start/src/components/user-menu.tsx.hbs", `import { Link, useNavigate } from "@tanstack/react-router";

import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { authClient } from "@/lib/auth-client";

import { Button } from "./ui/button";
import { Skeleton } from "./ui/skeleton";

export default function UserMenu() {
  const navigate = useNavigate();
  const { data: session, isPending } = authClient.useSession();

  if (isPending) {
    return <Skeleton className="h-9 w-24" />;
  }

  if (!session) {
    return (
      <Link to="/login">
        <Button variant="outline">Sign In</Button>
      </Link>
    );
  }

  return (
    <DropdownMenu>
      <DropdownMenuTrigger render={<Button variant="outline" />}>
        {session.user.name}
      </DropdownMenuTrigger>
      <DropdownMenuContent className="bg-card">
        <DropdownMenuGroup>
          <DropdownMenuLabel>My Account</DropdownMenuLabel>
          <DropdownMenuSeparator />
          <DropdownMenuItem>{session.user.email}</DropdownMenuItem>
          <DropdownMenuItem
            variant="destructive"
            onClick={() => {
              authClient.signOut({
                fetchOptions: {
                  onSuccess: () => {
                    navigate({
                      to: "/",
                    });
                  },
                },
              });
            }}
          >
            Sign Out
          </DropdownMenuItem>
        </DropdownMenuGroup>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}
`],
  ["auth/better-auth/web/react/tanstack-start/src/components/sign-in-form.tsx.hbs", `import { authClient } from "@/lib/auth-client";
import { useForm } from "@tanstack/react-form";
import { useNavigate } from "@tanstack/react-router";
import { toast } from "sonner";
import z from "zod";
import Loader from "./loader";
import { Button } from "./ui/button";
import { Input } from "./ui/input";
import { Label } from "./ui/label";

export default function SignInForm({ onSwitchToSignUp }: { onSwitchToSignUp: () => void }) {
  const navigate = useNavigate({
    from: "/",
  });
  const { isPending } = authClient.useSession();

  const form = useForm({
    defaultValues: {
      email: "",
      password: "",
    },
    onSubmit: async ({ value }) => {
      await authClient.signIn.email(
        {
          email: value.email,
          password: value.password,
        },
        {
          onSuccess: () => {
            navigate({
              to: "/dashboard",
            });
            toast.success("Sign in successful");
          },
          onError: (error) => {
            toast.error(error.error.message || error.error.statusText);
          },
        },
      );
    },
    validators: {
      onSubmit: z.object({
        email: z.email("Invalid email address"),
        password: z.string().min(8, "Password must be at least 8 characters"),
      }),
    },
  });

  if (isPending) {
    return <Loader />;
  }

  return (
    <div className="mx-auto w-full mt-10 max-w-md p-6">
      <h1 className="mb-6 text-center text-3xl font-bold">Welcome Back</h1>

      <form
        onSubmit={(e) => {
          e.preventDefault();
          e.stopPropagation();
          form.handleSubmit();
        }}
        className="space-y-4"
      >
        <div>
          <form.Field name="email">
            {(field) => (
              <div className="space-y-2">
                <Label htmlFor={field.name}>Email</Label>
                <Input
                  id={field.name}
                  name={field.name}
                  type="email"
                  value={field.state.value}
                  onBlur={field.handleBlur}
                  onChange={(e) => field.handleChange(e.target.value)}
                />
                {field.state.meta.errors.map((error) => (
                  <p key={error?.message} className="text-red-500">
                    {error?.message}
                  </p>
                ))}
              </div>
            )}
          </form.Field>
        </div>

        <div>
          <form.Field name="password">
            {(field) => (
              <div className="space-y-2">
                <Label htmlFor={field.name}>Password</Label>
                <Input
                  id={field.name}
                  name={field.name}
                  type="password"
                  value={field.state.value}
                  onBlur={field.handleBlur}
                  onChange={(e) => field.handleChange(e.target.value)}
                />
                {field.state.meta.errors.map((error) => (
                  <p key={error?.message} className="text-red-500">
                    {error?.message}
                  </p>
                ))}
              </div>
            )}
          </form.Field>
        </div>

        <form.Subscribe>
          {(state) => (
            <Button
              type="submit"
              className="w-full"
              disabled={!state.canSubmit || state.isSubmitting}
            >
              {state.isSubmitting ? "Submitting..." : "Sign In"}
            </Button>
          )}
        </form.Subscribe>
      </form>

      <div className="mt-4 text-center">
        <Button
          variant="link"
          onClick={onSwitchToSignUp}
          className="text-indigo-600 hover:text-indigo-800"
        >
          Need an account? Sign Up
        </Button>
      </div>
    </div>
  );
}
`],
  ["auth/better-auth/web/react/tanstack-start/src/components/sign-up-form.tsx.hbs", `import { authClient } from "@/lib/auth-client";
import { useForm } from "@tanstack/react-form";
import { useNavigate } from "@tanstack/react-router";
import { toast } from "sonner";
import z from "zod";
import Loader from "./loader";
import { Button } from "./ui/button";
import { Input } from "./ui/input";
import { Label } from "./ui/label";

export default function SignUpForm({ onSwitchToSignIn }: { onSwitchToSignIn: () => void }) {
  const navigate = useNavigate({
    from: "/",
  });
  const { isPending } = authClient.useSession();

  const form = useForm({
    defaultValues: {
      email: "",
      password: "",
      name: "",
    },
    onSubmit: async ({ value }) => {
      await authClient.signUp.email(
        {
          email: value.email,
          password: value.password,
          name: value.name,
        },
        {
          onSuccess: () => {
            navigate({
              to: "/dashboard",
            });
            toast.success("Sign up successful");
          },
          onError: (error) => {
            toast.error(error.error.message || error.error.statusText);
          },
        },
      );
    },
    validators: {
      onSubmit: z.object({
        name: z.string().min(2, "Name must be at least 2 characters"),
        email: z.email("Invalid email address"),
        password: z.string().min(8, "Password must be at least 8 characters"),
      }),
    },
  });

  if (isPending) {
    return <Loader />;
  }

  return (
    <div className="mx-auto w-full mt-10 max-w-md p-6">
      <h1 className="mb-6 text-center text-3xl font-bold">Create Account</h1>

      <form
        onSubmit={(e) => {
          e.preventDefault();
          e.stopPropagation();
          form.handleSubmit();
        }}
        className="space-y-4"
      >
        <div>
          <form.Field name="name">
            {(field) => (
              <div className="space-y-2">
                <Label htmlFor={field.name}>Name</Label>
                <Input
                  id={field.name}
                  name={field.name}
                  value={field.state.value}
                  onBlur={field.handleBlur}
                  onChange={(e) => field.handleChange(e.target.value)}
                />
                {field.state.meta.errors.map((error) => (
                  <p key={error?.message} className="text-red-500">
                    {error?.message}
                  </p>
                ))}
              </div>
            )}
          </form.Field>
        </div>

        <div>
          <form.Field name="email">
            {(field) => (
              <div className="space-y-2">
                <Label htmlFor={field.name}>Email</Label>
                <Input
                  id={field.name}
                  name={field.name}
                  type="email"
                  value={field.state.value}
                  onBlur={field.handleBlur}
                  onChange={(e) => field.handleChange(e.target.value)}
                />
                {field.state.meta.errors.map((error) => (
                  <p key={error?.message} className="text-red-500">
                    {error?.message}
                  </p>
                ))}
              </div>
            )}
          </form.Field>
        </div>

        <div>
          <form.Field name="password">
            {(field) => (
              <div className="space-y-2">
                <Label htmlFor={field.name}>Password</Label>
                <Input
                  id={field.name}
                  name={field.name}
                  type="password"
                  value={field.state.value}
                  onBlur={field.handleBlur}
                  onChange={(e) => field.handleChange(e.target.value)}
                />
                {field.state.meta.errors.map((error) => (
                  <p key={error?.message} className="text-red-500">
                    {error?.message}
                  </p>
                ))}
              </div>
            )}
          </form.Field>
        </div>

        <form.Subscribe>
          {(state) => (
            <Button
              type="submit"
              className="w-full"
              disabled={!state.canSubmit || state.isSubmitting}
            >
              {state.isSubmitting ? "Submitting..." : "Sign Up"}
            </Button>
          )}
        </form.Subscribe>
      </form>

      <div className="mt-4 text-center">
        <Button
          variant="link"
          onClick={onSwitchToSignIn}
          className="text-indigo-600 hover:text-indigo-800"
        >
          Already have an account? Sign In
        </Button>
      </div>
    </div>
  );
}
`],
  ["auth/better-auth/web/react/tanstack-start/src/middleware/auth.ts.hbs", `{{#if (eq backend "self")}}
import { auth } from "@{{projectName}}/auth";
import { createMiddleware } from "@tanstack/react-start";


export const authMiddleware = createMiddleware().server(async ({ next, request }) => {
    const session = await auth.api.getSession({
        headers: request.headers,
    })
    return next({
        context: { session }
    })
})
{{else}}
import { authClient } from "@/lib/auth-client";
import { createMiddleware } from "@tanstack/react-start";

export const authMiddleware = createMiddleware().server(
	async ({ next, request }) => {
		const session = await authClient.getSession({
			fetchOptions: {
				headers: request.headers,
				throw: true
			}
		})
		return next({
			context: { session },
		});
	},
);
{{/if}}
`],
  ["auth/better-auth/web/react/react-router/src/routes/login.tsx.hbs", `import SignInForm from "@/components/sign-in-form";
import SignUpForm from "@/components/sign-up-form";
import { useState } from "react";

export default function Login() {
  const [showSignIn, setShowSignIn] = useState(false);

  return showSignIn ? (
    <SignInForm onSwitchToSignUp={() => setShowSignIn(false)} />
  ) : (
    <SignUpForm onSwitchToSignIn={() => setShowSignIn(true)} />
  );
}
`],
  ["auth/better-auth/web/react/react-router/src/routes/dashboard.tsx.hbs", `{{#if (eq payments "polar")}}
import { Button } from "@/components/ui/button";
{{/if}}
import { authClient } from "@/lib/auth-client";
{{#if (eq api "orpc")}}
import { orpc } from "@/utils/orpc";
{{/if}}
{{#if (eq api "trpc")}}
import { trpc } from "@/utils/trpc";
{{/if}}
{{#if ( or (eq api "orpc") (eq api "trpc"))}}
import { useQuery } from "@tanstack/react-query";
{{/if}}
import { useEffect, useState } from "react";
import { useNavigate } from "react-router";

export default function Dashboard() {
  const { data: session, isPending } = authClient.useSession();
  const navigate = useNavigate();
  {{#if (eq payments "polar")}}
  const [customerState, setCustomerState] = useState<any>(null);
  {{/if}}

  {{#if (eq api "orpc")}}
  const privateData = useQuery(orpc.privateData.queryOptions());
  {{/if}}
  {{#if (eq api "trpc")}}
  const privateData = useQuery(trpc.privateData.queryOptions());
  {{/if}}

  useEffect(() => {
    if (!session && !isPending) {
      navigate("/login");
    }
  }, [session, isPending, navigate]);

  {{#if (eq payments "polar")}}
  useEffect(() => {
    async function fetchCustomerState() {
      if (session) {
        const { data } = await authClient.customer.state();
        setCustomerState(data);
      }
    }

    fetchCustomerState();
  }, [session]);
  {{/if}}

  if (isPending) {
    return <div>Loading...</div>;
  }

  {{#if (eq payments "polar")}}
  const hasProSubscription = customerState?.activeSubscriptions?.length! > 0;
  console.log("Active subscriptions:", customerState?.activeSubscriptions);
  {{/if}}

  return (
    <div>
      <h1>Dashboard</h1>
      <p>Welcome {session?.user.name}</p>
      {{#if ( or (eq api "orpc") (eq api "trpc"))}}
      <p>API: {privateData.data?.message}</p>
      {{/if}}
      {{#if (eq payments "polar")}}
      <p>Plan: {hasProSubscription ? "Pro" : "Free"}</p>
      {hasProSubscription ? (
        <Button onClick={async () => await authClient.customer.portal()}>
          Manage Subscription
        </Button>
      ) : (
        <Button onClick={async () => await authClient.checkout({ slug: "pro" })}>
          Upgrade to Pro
        </Button>
      )}
      {{/if}}
    </div>
  );
}
`],
  ["auth/better-auth/web/react/react-router/src/components/user-menu.tsx.hbs", `import { Link, useNavigate } from "react-router";

import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { authClient } from "@/lib/auth-client";

import { Button } from "./ui/button";
import { Skeleton } from "./ui/skeleton";

export default function UserMenu() {
  const navigate = useNavigate();
  const { data: session, isPending } = authClient.useSession();

  if (isPending) {
    return <Skeleton className="h-9 w-24" />;
  }

  if (!session) {
    return (
      <Link to="/login">
        <Button variant="outline">Sign In</Button>
      </Link>
    );
  }

  return (
    <DropdownMenu>
      <DropdownMenuTrigger render={<Button variant="outline" />}>
        {session.user.name}
      </DropdownMenuTrigger>
      <DropdownMenuContent className="bg-card">
        <DropdownMenuGroup>
          <DropdownMenuLabel>My Account</DropdownMenuLabel>
          <DropdownMenuSeparator />
          <DropdownMenuItem>{session.user.email}</DropdownMenuItem>
          <DropdownMenuItem
            variant="destructive"
            onClick={() => {
              authClient.signOut({
                fetchOptions: {
                  onSuccess: () => {
                    navigate("/");
                  },
                },
              });
            }}
          >
            Sign Out
          </DropdownMenuItem>
        </DropdownMenuGroup>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}
`],
  ["auth/better-auth/web/react/react-router/src/components/sign-in-form.tsx.hbs", `import { authClient } from "@/lib/auth-client";
import { useForm } from "@tanstack/react-form";
import { useNavigate } from "react-router";
import { toast } from "sonner";
import z from "zod";
import Loader from "./loader";
import { Button } from "./ui/button";
import { Input } from "./ui/input";
import { Label } from "./ui/label";

export default function SignInForm({
  onSwitchToSignUp,
}: {
  onSwitchToSignUp: () => void;
}) {
  const navigate = useNavigate();
  const { isPending } = authClient.useSession();

  const form = useForm({
    defaultValues: {
      email: "",
      password: "",
    },
    onSubmit: async ({ value }) => {
      await authClient.signIn.email(
        {
          email: value.email,
          password: value.password,
        },
        {
          onSuccess: () => {
            navigate("/dashboard");
            toast.success("Sign in successful");
          },
          onError: (error) => {
            toast.error(error.error.message || error.error.statusText);
          },
        }
      );
    },
    validators: {
      onSubmit: z.object({
        email: z.email("Invalid email address"),
        password: z.string().min(8, "Password must be at least 8 characters"),
      }),
    },
  });

  if (isPending) {
    return <Loader />;
  }

  return (
    <div className="mx-auto w-full mt-10 max-w-md p-6">
      <h1 className="mb-6 text-center text-3xl font-bold">Welcome Back</h1>

      <form
        onSubmit={(e) => {
          e.preventDefault();
          e.stopPropagation();
          form.handleSubmit();
        }}
        className="space-y-4"
      >
        <div>
          <form.Field name="email">
            {(field) => (
              <div className="space-y-2">
                <Label htmlFor={field.name}>Email</Label>
                <Input
                  id={field.name}
                  name={field.name}
                  type="email"
                  value={field.state.value}
                  onBlur={field.handleBlur}
                  onChange={(e) => field.handleChange(e.target.value)}
                />
                {field.state.meta.errors.map((error) => (
                  <p key={error?.message} className="text-red-500">
                    {error?.message}
                  </p>
                ))}
              </div>
            )}
          </form.Field>
        </div>

        <div>
          <form.Field name="password">
            {(field) => (
              <div className="space-y-2">
                <Label htmlFor={field.name}>Password</Label>
                <Input
                  id={field.name}
                  name={field.name}
                  type="password"
                  value={field.state.value}
                  onBlur={field.handleBlur}
                  onChange={(e) => field.handleChange(e.target.value)}
                />
                {field.state.meta.errors.map((error) => (
                  <p key={error?.message} className="text-red-500">
                    {error?.message}
                  </p>
                ))}
              </div>
            )}
          </form.Field>
        </div>

        <form.Subscribe>
          {(state) => (
            <Button
              type="submit"
              className="w-full"
              disabled={!state.canSubmit || state.isSubmitting}
            >
              {state.isSubmitting ? "Submitting..." : "Sign In"}
            </Button>
          )}
        </form.Subscribe>
      </form>

      <div className="mt-4 text-center">
        <Button
          variant="link"
          onClick={onSwitchToSignUp}
          className="text-indigo-600 hover:text-indigo-800"
        >
          Need an account? Sign Up
        </Button>
      </div>
    </div>
  );
}
`],
  ["auth/better-auth/web/react/react-router/src/components/sign-up-form.tsx.hbs", `import { authClient } from "@/lib/auth-client";
import { useForm } from "@tanstack/react-form";
import { useNavigate } from "react-router";
import { toast } from "sonner";
import z from "zod";
import Loader from "./loader";
import { Button } from "./ui/button";
import { Input } from "./ui/input";
import { Label } from "./ui/label";

export default function SignUpForm({
  onSwitchToSignIn,
}: {
  onSwitchToSignIn: () => void;
}) {
  const navigate = useNavigate();
  const { isPending } = authClient.useSession();

  const form = useForm({
    defaultValues: {
      email: "",
      password: "",
      name: "",
    },
    onSubmit: async ({ value }) => {
      await authClient.signUp.email(
        {
          email: value.email,
          password: value.password,
          name: value.name,
        },
        {
          onSuccess: () => {
            navigate("/dashboard");
            toast.success("Sign up successful");
          },
          onError: (error) => {
            toast.error(error.error.message || error.error.statusText);
          },
        }
      );
    },
    validators: {
      onSubmit: z.object({
        name: z.string().min(2, "Name must be at least 2 characters"),
        email: z.email("Invalid email address"),
        password: z.string().min(8, "Password must be at least 8 characters"),
      }),
    },
  });

  if (isPending) {
    return <Loader />;
  }

  return (
    <div className="mx-auto w-full mt-10 max-w-md p-6">
      <h1 className="mb-6 text-center text-3xl font-bold">Create Account</h1>

      <form
        onSubmit={(e) => {
          e.preventDefault();
          e.stopPropagation();
          form.handleSubmit();
        }}
        className="space-y-4"
      >
        <div>
          <form.Field name="name">
            {(field) => (
              <div className="space-y-2">
                <Label htmlFor={field.name}>Name</Label>
                <Input
                  id={field.name}
                  name={field.name}
                  value={field.state.value}
                  onBlur={field.handleBlur}
                  onChange={(e) => field.handleChange(e.target.value)}
                />
                {field.state.meta.errors.map((error) => (
                  <p key={error?.message} className="text-red-500">
                    {error?.message}
                  </p>
                ))}
              </div>
            )}
          </form.Field>
        </div>

        <div>
          <form.Field name="email">
            {(field) => (
              <div className="space-y-2">
                <Label htmlFor={field.name}>Email</Label>
                <Input
                  id={field.name}
                  name={field.name}
                  type="email"
                  value={field.state.value}
                  onBlur={field.handleBlur}
                  onChange={(e) => field.handleChange(e.target.value)}
                />
                {field.state.meta.errors.map((error) => (
                  <p key={error?.message} className="text-red-500">
                    {error?.message}
                  </p>
                ))}
              </div>
            )}
          </form.Field>
        </div>

        <div>
          <form.Field name="password">
            {(field) => (
              <div className="space-y-2">
                <Label htmlFor={field.name}>Password</Label>
                <Input
                  id={field.name}
                  name={field.name}
                  type="password"
                  value={field.state.value}
                  onBlur={field.handleBlur}
                  onChange={(e) => field.handleChange(e.target.value)}
                />
                {field.state.meta.errors.map((error) => (
                  <p key={error?.message} className="text-red-500">
                    {error?.message}
                  </p>
                ))}
              </div>
            )}
          </form.Field>
        </div>

        <form.Subscribe>
          {(state) => (
            <Button
              type="submit"
              className="w-full"
              disabled={!state.canSubmit || state.isSubmitting}
            >
              {state.isSubmitting ? "Submitting..." : "Sign Up"}
            </Button>
          )}
        </form.Subscribe>
      </form>

      <div className="mt-4 text-center">
        <Button
          variant="link"
          onClick={onSwitchToSignIn}
          className="text-indigo-600 hover:text-indigo-800"
        >
          Already have an account? Sign In
        </Button>
      </div>
    </div>
  );
}
`],
  ["auth/better-auth/web/svelte/src/routes/login/+page.svelte.hbs", `<script lang="ts">
	import SignInForm from '../../components/SignInForm.svelte';
	import SignUpForm from '../../components/SignUpForm.svelte';

	let showSignIn = $state(true);
</script>

{#if showSignIn}
	<SignInForm switchToSignUp={() => showSignIn = false} />
{:else}
	<SignUpForm switchToSignIn={() => showSignIn = true} />
{/if}
`],
  ["auth/better-auth/web/svelte/src/routes/dashboard/+page.svelte.hbs", `<script lang="ts">
	import { goto } from '$app/navigation';
	import { authClient } from '$lib/auth-client';
	{{#if (eq api "orpc")}}
	import { orpc } from '$lib/orpc';
	import { createQuery } from '@tanstack/svelte-query';
	{{/if}}
	{{#if (eq payments "polar")}}
	let customerState = $state<{ activeSubscriptions?: unknown[] } | null>(null);
	{{/if}}

	const sessionQuery = authClient.useSession();

	{{#if (eq api "orpc")}}
	const privateDataQuery = createQuery(orpc.privateData.queryOptions());
	{{/if}}

	$effect(() => {
		if (!$sessionQuery.isPending && !$sessionQuery.data) {
			goto('/login');
		}
	});

	{{#if (eq payments "polar")}}
	$effect(() => {
		if ($sessionQuery.data) {
			authClient.customer.state().then(({ data }) => {
				customerState = data;
			});
		}
	});
	{{/if}}
</script>

{#if $sessionQuery.isPending}
	<div>Loading...</div>
{:else if !$sessionQuery.data}
	<div>Redirecting to login...</div>
{:else}
	<div>
		<h1>Dashboard</h1>
		<p>Welcome {$sessionQuery.data.user.name}</p>
		{{#if (eq api "orpc")}}
		<p>API: {$privateDataQuery.data?.message}</p>
		{{/if}}
		{{#if (eq payments "polar")}}
		<p>Plan: {customerState?.activeSubscriptions?.length > 0 ? "Pro" : "Free"}</p>
		{#if customerState?.activeSubscriptions?.length > 0}
			<button onclick={async () => await authClient.customer.portal()}>
				Manage Subscription
			</button>
		{:else}
			<button onclick={async () => await authClient.checkout({ slug: "pro" })}>
				Upgrade to Pro
			</button>
		{/if}
		{{/if}}
	</div>
{/if}
`],
  ["auth/nextauth/web/react/next/src/components/user-menu.tsx.hbs", `"use client";

import { useAuthClient } from "@/lib/auth-client";
import { Button } from "./ui/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "./ui/dropdown-menu";

export default function UserMenu() {
  const { user, signOut } = useAuthClient();

  if (!user) {
    return null;
  }

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="outline" className="flex items-center gap-2">
          {user.image ? (
            <img
              src={user.image}
              alt={user.name || "User"}
              className="h-6 w-6 rounded-full"
            />
          ) : (
            <div className="h-6 w-6 rounded-full bg-primary text-primary-foreground flex items-center justify-center text-sm font-medium">
              {user.name?.charAt(0) || user.email?.charAt(0) || "U"}
            </div>
          )}
          <span className="hidden sm:inline">{user.name || user.email}</span>
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end" className="w-56">
        <DropdownMenuLabel>
          <div className="flex flex-col space-y-1">
            <p className="text-sm font-medium">{user.name}</p>
            <p className="text-xs text-muted-foreground">{user.email}</p>
          </div>
        </DropdownMenuLabel>
        <DropdownMenuSeparator />
        <DropdownMenuItem asChild>
          <a href="/dashboard">Dashboard</a>
        </DropdownMenuItem>
        <DropdownMenuSeparator />
        <DropdownMenuItem
          onClick={() => signOut({ callbackUrl: "/" })}
          className="text-red-600 focus:text-red-600"
        >
          Sign Out
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}
`],
  ["auth/nextauth/web/react/next/src/components/sign-in-form.tsx.hbs", `"use client";

import { useForm } from "@tanstack/react-form";
import { signIn } from "next-auth/react";
import { useRouter } from "next/navigation";
import { toast } from "sonner";
import z from "zod";
import Loader from "./loader";
import { Button } from "./ui/button";
import { Input } from "./ui/input";
import { Label } from "./ui/label";
import { useAuthClient } from "@/lib/auth-client";

export default function SignInForm({
  onSwitchToSignUp,
}: {
  onSwitchToSignUp: () => void;
}) {
  const router = useRouter();
  const { isLoading } = useAuthClient();

  const form = useForm({
    defaultValues: {
      email: "",
      password: "",
    },
    onSubmit: async ({ value }) => {
      const result = await signIn("credentials", {
        email: value.email,
        password: value.password,
        redirect: false,
      });

      if (result?.error) {
        toast.error("Invalid credentials");
      } else {
        router.push("/dashboard");
        toast.success("Sign in successful");
      }
    },
    validators: {
      onSubmit: z.object({
        email: z.email("Invalid email address"),
        password: z.string().min(8, "Password must be at least 8 characters"),
      }),
    },
  });

  if (isLoading) {
    return <Loader />;
  }

  return (
    <div className="mx-auto w-full mt-10 max-w-md p-6">
      <h1 className="mb-6 text-center text-3xl font-bold">Welcome Back</h1>

      <form
        onSubmit={(e) => {
          e.preventDefault();
          e.stopPropagation();
          form.handleSubmit();
        }}
        className="space-y-4"
      >
        <div>
          <form.Field name="email">
            {(field) => (
              <div className="space-y-2">
                <Label htmlFor={field.name}>Email</Label>
                <Input
                  id={field.name}
                  name={field.name}
                  type="email"
                  value={field.state.value}
                  onBlur={field.handleBlur}
                  onChange={(e) => field.handleChange(e.target.value)}
                />
                {field.state.meta.errors.map((error) => (
                  <p key={error?.message} className="text-red-500">
                    {error?.message}
                  </p>
                ))}
              </div>
            )}
          </form.Field>
        </div>

        <div>
          <form.Field name="password">
            {(field) => (
              <div className="space-y-2">
                <Label htmlFor={field.name}>Password</Label>
                <Input
                  id={field.name}
                  name={field.name}
                  type="password"
                  value={field.state.value}
                  onBlur={field.handleBlur}
                  onChange={(e) => field.handleChange(e.target.value)}
                />
                {field.state.meta.errors.map((error) => (
                  <p key={error?.message} className="text-red-500">
                    {error?.message}
                  </p>
                ))}
              </div>
            )}
          </form.Field>
        </div>

        <form.Subscribe>
          {(state) => (
            <Button
              type="submit"
              className="w-full"
              disabled={!state.canSubmit || state.isSubmitting}
            >
              {state.isSubmitting ? "Signing in..." : "Sign In"}
            </Button>
          )}
        </form.Subscribe>
      </form>

      <div className="mt-4 space-y-2">
        <div className="relative">
          <div className="absolute inset-0 flex items-center">
            <span className="w-full border-t" />
          </div>
          <div className="relative flex justify-center text-xs uppercase">
            <span className="bg-background px-2 text-muted-foreground">
              Or continue with
            </span>
          </div>
        </div>

        <div className="grid grid-cols-2 gap-2">
          <Button
            variant="outline"
            onClick={() => signIn("github", { callbackUrl: "/dashboard" })}
          >
            GitHub
          </Button>
          <Button
            variant="outline"
            onClick={() => signIn("google", { callbackUrl: "/dashboard" })}
          >
            Google
          </Button>
        </div>
      </div>

      <div className="mt-4 text-center">
        <Button
          variant="link"
          onClick={onSwitchToSignUp}
          className="text-indigo-600 hover:text-indigo-800"
        >
          Need an account? Sign Up
        </Button>
      </div>
    </div>
  );
}
`],
  ["auth/nextauth/web/react/next/src/components/providers.tsx.hbs", `"use client";

import { SessionProvider } from "next-auth/react";
import type { ReactNode } from "react";

export function AuthProvider({ children }: { children: ReactNode }) {
  return <SessionProvider>{children}</SessionProvider>;
}
`],
  ["auth/nextauth/web/react/next/src/components/sign-up-form.tsx.hbs", `"use client";

import { useForm } from "@tanstack/react-form";
import { toast } from "sonner";
import z from "zod";
import Loader from "./loader";
import { Button } from "./ui/button";
import { Input } from "./ui/input";
import { Label } from "./ui/label";
import { useAuthClient } from "@/lib/auth-client";

export default function SignUpForm({
  onSwitchToSignIn,
}: {
  onSwitchToSignIn: () => void;
}) {
  const { isLoading } = useAuthClient();

  const form = useForm({
    defaultValues: {
      name: "",
      email: "",
      password: "",
      confirmPassword: "",
    },
    onSubmit: async ({ value }) => {
      // Implement your sign-up logic here
      // This could call an API route to create a user in your database
      try {
        const response = await fetch("/api/auth/register", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            name: value.name,
            email: value.email,
            password: value.password,
          }),
        });

        if (!response.ok) {
          const error = await response.json();
          toast.error(error.message || "Registration failed");
          return;
        }

        toast.success("Account created! Please sign in.");
        onSwitchToSignIn();
      } catch {
        toast.error("Registration failed");
      }
    },
    validators: {
      onSubmit: z
        .object({
          name: z.string().min(2, "Name must be at least 2 characters"),
          email: z.email("Invalid email address"),
          password: z.string().min(8, "Password must be at least 8 characters"),
          confirmPassword: z.string(),
        })
        .refine((data) => data.password === data.confirmPassword, {
          message: "Passwords don't match",
          path: ["confirmPassword"],
        }),
    },
  });

  if (isLoading) {
    return <Loader />;
  }

  return (
    <div className="mx-auto w-full mt-10 max-w-md p-6">
      <h1 className="mb-6 text-center text-3xl font-bold">Create Account</h1>

      <form
        onSubmit={(e) => {
          e.preventDefault();
          e.stopPropagation();
          form.handleSubmit();
        }}
        className="space-y-4"
      >
        <div>
          <form.Field name="name">
            {(field) => (
              <div className="space-y-2">
                <Label htmlFor={field.name}>Name</Label>
                <Input
                  id={field.name}
                  name={field.name}
                  type="text"
                  value={field.state.value}
                  onBlur={field.handleBlur}
                  onChange={(e) => field.handleChange(e.target.value)}
                />
                {field.state.meta.errors.map((error) => (
                  <p key={error?.message} className="text-red-500">
                    {error?.message}
                  </p>
                ))}
              </div>
            )}
          </form.Field>
        </div>

        <div>
          <form.Field name="email">
            {(field) => (
              <div className="space-y-2">
                <Label htmlFor={field.name}>Email</Label>
                <Input
                  id={field.name}
                  name={field.name}
                  type="email"
                  value={field.state.value}
                  onBlur={field.handleBlur}
                  onChange={(e) => field.handleChange(e.target.value)}
                />
                {field.state.meta.errors.map((error) => (
                  <p key={error?.message} className="text-red-500">
                    {error?.message}
                  </p>
                ))}
              </div>
            )}
          </form.Field>
        </div>

        <div>
          <form.Field name="password">
            {(field) => (
              <div className="space-y-2">
                <Label htmlFor={field.name}>Password</Label>
                <Input
                  id={field.name}
                  name={field.name}
                  type="password"
                  value={field.state.value}
                  onBlur={field.handleBlur}
                  onChange={(e) => field.handleChange(e.target.value)}
                />
                {field.state.meta.errors.map((error) => (
                  <p key={error?.message} className="text-red-500">
                    {error?.message}
                  </p>
                ))}
              </div>
            )}
          </form.Field>
        </div>

        <div>
          <form.Field name="confirmPassword">
            {(field) => (
              <div className="space-y-2">
                <Label htmlFor={field.name}>Confirm Password</Label>
                <Input
                  id={field.name}
                  name={field.name}
                  type="password"
                  value={field.state.value}
                  onBlur={field.handleBlur}
                  onChange={(e) => field.handleChange(e.target.value)}
                />
                {field.state.meta.errors.map((error) => (
                  <p key={error?.message} className="text-red-500">
                    {error?.message}
                  </p>
                ))}
              </div>
            )}
          </form.Field>
        </div>

        <form.Subscribe>
          {(state) => (
            <Button
              type="submit"
              className="w-full"
              disabled={!state.canSubmit || state.isSubmitting}
            >
              {state.isSubmitting ? "Creating account..." : "Sign Up"}
            </Button>
          )}
        </form.Subscribe>
      </form>

      <div className="mt-4 text-center">
        <Button
          variant="link"
          onClick={onSwitchToSignIn}
          className="text-indigo-600 hover:text-indigo-800"
        >
          Already have an account? Sign In
        </Button>
      </div>
    </div>
  );
}
`],
  ["auth/nextauth/web/react/next/src/lib/auth-client.ts.hbs", `"use client";

import { signIn, signOut, useSession } from "next-auth/react";

export { signIn, signOut, useSession };

export function useAuthClient() {
  const { data: session, status } = useSession();

  return {
    session,
    user: session?.user ?? null,
    isAuthenticated: status === "authenticated",
    isLoading: status === "loading",
    signIn,
    signOut,
  };
}
`],
  ["api/garph/fullstack/astro/src/pages/api/graphql.ts.hbs", `import type { APIRoute } from "astro";
import { createYoga } from "graphql-yoga";
import { createSchema } from "@{{projectName}}/api/routers";
import { createContext } from "@{{projectName}}/api/context";
{{#if (eq auth "better-auth")}}
import { auth } from "@/lib/auth";
{{/if}}

const yoga = createYoga({
  graphqlEndpoint: "/api/graphql",
  fetchAPI: { Response },
  context: async ({ request }) => {
{{#if (eq auth "better-auth")}}
    const session = await auth.api.getSession({
      headers: request.headers,
    });
    // Create a minimal API context for Astro
    const astroContext = { request } as any;
    return createContext(astroContext, session);
{{else}}
    // Create a minimal API context for Astro
    const astroContext = { request } as any;
    return createContext(astroContext);
{{/if}}
  },
  schema: async ({ request }) => {
{{#if (eq auth "better-auth")}}
    const session = await auth.api.getSession({
      headers: request.headers,
    });
    const astroContext = { request } as any;
    const ctx = createContext(astroContext, session);
{{else}}
    const astroContext = { request } as any;
    const ctx = createContext(astroContext);
{{/if}}
    return createSchema(ctx);
  },
});

export const GET: APIRoute = async ({ request }) => {
  return yoga.handleRequest(request, {});
};

export const POST: APIRoute = async ({ request }) => {
  return yoga.handleRequest(request, {});
};
`],
  ["api/garph/web/react/base/src/utils/garph.ts.hbs", `import { QueryClient } from "@tanstack/react-query";
import { createClient, type InferClient } from "@garph/gqty";
import {
  createGeneratedSchema,
  createScalarsEnumsHash,
} from "@garph/gqty/dist/utils";
import {
  g,
  queryType,
  mutationType,
{{#if (includes examples "todo")}}
  todoType,
{{/if}}
} from "@{{projectName}}/api/index";
import { env } from "@{{projectName}}/env/web";

// Create QueryClient for React Query integration
export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      retry: 2,
      staleTime: 1000 * 60,
    },
  },
});

// Generate schema and scalars for GQty client
const generatedSchema = createGeneratedSchema(g);
const scalarsEnumsHash = createScalarsEnumsHash(g);

// Create type-safe GraphQL client
export const client = createClient<{
  query: InferClient<typeof queryType>;
  mutation: InferClient<typeof mutationType>;
}>({
  generatedSchema,
  scalarsEnumsHash,
  url: \`\${env.VITE_SERVER_URL}/graphql\`,
{{#if (eq auth "better-auth")}}
  credentials: "include",
{{/if}}
});

// Export typed query and mutation functions
export const { query, mutation, resolved } = client;

// Helper for React Query integration
export async function graphqlFetcher<T>(
  fn: () => T | Promise<T>
): Promise<T> {
  return resolved(fn);
}
`],
  ["api/garph/fullstack/tanstack-start/src/routes/api/graphql.ts.hbs", `import { createAPIFileRoute } from "@tanstack/react-start/api";
import { createYoga } from "graphql-yoga";
import { createSchema } from "@{{projectName}}/api/routers";
import { createContext } from "@{{projectName}}/api/context";
{{#if (eq auth "better-auth")}}
import { auth } from "@/lib/auth";
{{/if}}

const yoga = createYoga({
  graphqlEndpoint: "/api/graphql",
  fetchAPI: { Response },
  context: async ({ request }) => {
{{#if (eq auth "better-auth")}}
    const session = await auth.api.getSession({
      headers: request.headers,
    });
    return createContext(request, session);
{{else}}
    return createContext(request);
{{/if}}
  },
  schema: async ({ request }) => {
{{#if (eq auth "better-auth")}}
    const session = await auth.api.getSession({
      headers: request.headers,
    });
    const ctx = createContext(request, session);
{{else}}
    const ctx = createContext(request);
{{/if}}
    return createSchema(ctx);
  },
});

export const APIRoute = createAPIFileRoute("/api/graphql")({
  GET: async ({ request }) => yoga.handleRequest(request, {}),
  POST: async ({ request }) => yoga.handleRequest(request, {}),
});
`],
  ["api/ts-rest/web/react/base/src/utils/ts-rest.ts.hbs", `import { QueryClient } from "@tanstack/react-query";
import { initClient, tsRestFetchApi } from "@ts-rest/core";
import { initTsrReactQuery } from "@ts-rest/react-query";
import { contract } from "@{{projectName}}/api/index";
import { env } from "@{{projectName}}/env/web";

export const queryClient = new QueryClient({
	defaultOptions: {
		queries: {
			retry: 2,
			staleTime: 1000 * 60,
		},
	},
});

const client = initClient(contract, {
	baseUrl: \`\${env.VITE_SERVER_URL}/rest\`,
	baseHeaders: {},
{{#if (eq auth "better-auth")}}
	credentials: "include",
{{/if}}
	api: tsRestFetchApi,
});

export const tsr = initTsrReactQuery(contract, client);
`],
  ["api/orpc/web/react/base/src/utils/orpc.ts.hbs", `import { createORPCClient } from "@orpc/client";
import { RPCLink } from "@orpc/client/fetch";
import { createTanstackQueryUtils } from "@orpc/tanstack-query";
import { QueryCache, QueryClient } from "@tanstack/react-query";
import { toast } from "sonner";
{{#if (and (includes frontend "tanstack-start") (eq backend "self"))}}
import { createRouterClient } from "@orpc/server";
import type { RouterClient } from "@orpc/server";
import { createIsomorphicFn } from "@tanstack/react-start";
import { appRouter } from "@{{projectName}}/api/routers/index";
import { createContext } from "@{{projectName}}/api/context";
{{else if (includes frontend "tanstack-start")}}
import type { RouterClient } from "@orpc/server";
import type { AppRouter } from "@{{projectName}}/api/routers/index";
import { env } from "@{{projectName}}/env/web";
{{else}}
import type { AppRouterClient } from "@{{projectName}}/api/routers/index";
{{#unless (eq backend "self")}}
import { env } from "@{{projectName}}/env/web";
{{/unless}}
{{/if}}

export const queryClient = new QueryClient({
	queryCache: new QueryCache({
		onError: (error, query) => {
			toast.error(\`Error: \${error.message}\`, {
				action: {
					label: "retry",
					onClick: query.invalidate,
				},
			});
		},
	}),
});

{{#if (and (includes frontend "tanstack-start") (eq backend "self"))}}
const getORPCClient = createIsomorphicFn()
	.server(() =>
		createRouterClient(appRouter, {
			context: async ({ req }) => {
				return createContext({ req });
			},
		}),
	)
	.client((): RouterClient<typeof appRouter> => {
			const link = new RPCLink({
			url: \`\${window.location.origin}/api/rpc\`,
{{#if (eq auth "better-auth")}}
			fetch(url, options) {
				return fetch(url, {
					...options,
					credentials: "include",
				});
			},
{{/if}}
		});

		return createORPCClient(link);
	});

export const client: RouterClient<typeof appRouter> = getORPCClient();
{{else if (includes frontend "tanstack-start")}}
const link = new RPCLink({
	url: \`\${env.VITE_SERVER_URL}/rpc\`,
{{#if (eq auth "better-auth")}}
	fetch(url, options) {
		return fetch(url, {
			...options,
			credentials: "include",
		});
	},
{{/if}}
});

const getORPCClient = () => {
	return createORPCClient(link) as RouterClient<AppRouter>;
};

export const client: RouterClient<AppRouter> = getORPCClient();
{{else}}
export const link = new RPCLink({
{{#if (and (eq backend "self") (includes frontend "next"))}}
	url: \`\${typeof window !== "undefined" ? window.location.origin : "http://localhost:3001"}/api/rpc\`,
{{else if (includes frontend "next")}}
	url: \`\${env.NEXT_PUBLIC_SERVER_URL}/rpc\`,
{{else}}
	url: \`\${env.VITE_SERVER_URL}/rpc\`,
{{/if}}
{{#if (eq auth "better-auth")}}
	fetch(url, options) {
		return fetch(url, {
			...options,
			credentials: "include",
		});
	},
{{#if (includes frontend "next")}}
	headers: async () => {
		if (typeof window !== "undefined") {
			return {}
		}

		const { headers } = await import("next/headers")
		return Object.fromEntries(await headers())
	},
{{/if}}
{{/if}}
});

export const client: AppRouterClient = createORPCClient(link)
{{/if}}

export const orpc = createTanstackQueryUtils(client)

`],
  ["api/trpc/web/react/base/src/utils/trpc.ts.hbs", `{{#if (includes frontend 'next')}}
import { QueryCache, QueryClient } from '@tanstack/react-query';
import { createTRPCClient, httpBatchLink } from '@trpc/client';
import { createTRPCOptionsProxy } from '@trpc/tanstack-react-query';
import type { AppRouter } from "@{{projectName}}/api/routers/index";
import { toast } from 'sonner';
{{#unless (eq backend "self")}}
import { env } from "@{{projectName}}/env/web";
{{/unless}}

export const queryClient = new QueryClient({
	queryCache: new QueryCache({
		onError: (error, query) => {
			toast.error(error.message, {
				action: {
					label: "retry",
					onClick: query.invalidate,
				},
			});
		},
	}),
});

const trpcClient = createTRPCClient<AppRouter>({
	links: [
		httpBatchLink({
{{#if (eq backend "self")}}
			url: "/api/trpc",
{{else}}
			url: \`\${env.NEXT_PUBLIC_SERVER_URL}/trpc\`,
{{/if}}
{{#if (eq auth "better-auth")}}
			fetch(url, options) {
				return fetch(url, {
					...options,
					credentials: "include",
				});
			},
{{/if}}
		}),
	],
})

export const trpc = createTRPCOptionsProxy<AppRouter>({
	client: trpcClient,
	queryClient,
});

{{else if (includes frontend 'tanstack-start')}}
import { createTRPCContext } from "@trpc/tanstack-react-query";
import type { AppRouter } from "@{{projectName}}/api/routers/index";

export const { TRPCProvider, useTRPC, useTRPCClient } =
	createTRPCContext<AppRouter>();

{{else}}
import type { AppRouter } from "@{{projectName}}/api/routers/index";
import { QueryCache, QueryClient } from "@tanstack/react-query";
import { createTRPCClient, httpBatchLink } from "@trpc/client";
import { createTRPCOptionsProxy } from "@trpc/tanstack-react-query";
import { toast } from "sonner";
import { env } from "@{{projectName}}/env/web";

export const queryClient = new QueryClient({
	queryCache: new QueryCache({
		onError: (error, query) => {
			toast.error(error.message, {
				action: {
					label: "retry",
					onClick: query.invalidate,
				},
			});
		},
	}),
});

export const trpcClient = createTRPCClient<AppRouter>({
	links: [
		httpBatchLink({
			url: \`\${env.VITE_SERVER_URL}/trpc\`,
{{#if (eq auth "better-auth")}}
			fetch(url, options) {
				return fetch(url, {
					...options,
					credentials: "include",
				});
			},
{{/if}}
		}),
	],
});

export const trpc = createTRPCOptionsProxy<AppRouter>({
	client: trpcClient,
	queryClient,
});
{{/if}}
`],
  ["addons/pwa/apps/web/next/public/favicon/apple-touch-icon.png", `[Binary file]`],
  ["addons/pwa/apps/web/next/public/favicon/web-app-manifest-192x192.png", `[Binary file]`],
  ["addons/pwa/apps/web/next/public/favicon/favicon-96x96.png", `[Binary file]`],
  ["addons/pwa/apps/web/next/public/favicon/web-app-manifest-512x512.png", `[Binary file]`],
  ["addons/pwa/apps/web/next/public/favicon/site.webmanifest.hbs", `{
	"name": "{{projectName}}",
	"short_name": "{{projectName}}",
	"icons": [
		{
			"src": "/web-app-manifest-192x192.png",
			"sizes": "192x192",
			"type": "image/png",
			"purpose": "maskable"
		},
		{
			"src": "/web-app-manifest-512x512.png",
			"sizes": "512x512",
			"type": "image/png",
			"purpose": "maskable"
		}
	],
	"theme_color": "#ffffff",
	"background_color": "#ffffff",
	"display": "standalone"
}
`],
  ["addons/pwa/apps/web/next/public/favicon/favicon.svg", `<svg xmlns="http://www.w3.org/2000/svg" version="1.1" xmlns:xlink="http://www.w3.org/1999/xlink" width="92" height="92"><svg width="92" height="92" viewBox="0 0 92 92" fill="none" xmlns="http://www.w3.org/2000/svg">
  <rect x="8" y="8" width="76" height="76" rx="12" fill="#F5EEFF" stroke="#B79AFF" stroke-width="3"></rect>
  <text x="46" y="56" text-anchor="middle" font-family="monospace" font-size="40" fill="#8F5BFF">$<tspan dx="0" dy="0">_</tspan></text>
</svg><style>@media (prefers-color-scheme: light) { :root { filter: none; } }
@media (prefers-color-scheme: dark) { :root { filter: none; } }
</style></svg>`],
  ["addons/pwa/apps/web/next/src/app/manifest.ts.hbs", `import type { MetadataRoute } from "next";

export default function manifest(): MetadataRoute.Manifest {
	return {
		name: "{{projectName}}",
		short_name: "{{projectName}}",
		description:
			"my pwa app",
		start_url: "/new",
		display: "standalone",
		background_color: "#ffffff",
		theme_color: "#000000",
		icons: [
			{
				src: "/favicon/web-app-manifest-192x192.png",
				sizes: "192x192",
				type: "image/png",
			},
			{
				src: "/favicon/web-app-manifest-512x512.png",
				sizes: "512x512",
				type: "image/png",
			},
		],
	};
}
`],
  ["payments/paddle/web/react/next/src/app/success/page.tsx.hbs", `export default async function SuccessPage({
	searchParams,
}: {
	searchParams: Promise<{ transaction_id?: string }>
}) {
	const params = await searchParams;
	const transactionId = params.transaction_id;

	return (
		<div className="container mx-auto px-4 py-8">
			<h1 className="text-2xl font-bold mb-4">Payment Successful!</h1>
			<p className="text-gray-600 mb-4">
				Thank you for your purchase. Your payment has been processed successfully.
			</p>
			{transactionId && (
				<p className="text-sm text-gray-500">Transaction ID: {transactionId}</p>
			)}
		</div>
	);
}
`],
  ["payments/lemon-squeezy/web/react/next/src/app/success/page.tsx.hbs", `export default async function SuccessPage({
	searchParams,
}: {
	searchParams: Promise<{ checkout_id?: string }>
}) {
	const params = await searchParams;
	const checkoutId = params.checkout_id;

	return (
		<div className="container mx-auto px-4 py-8">
			<h1 className="text-2xl font-bold mb-4">Payment Successful!</h1>
			<p className="text-gray-600 mb-4">
				Thank you for your purchase. Your payment has been processed successfully.
			</p>
			{checkoutId && (
				<p className="text-sm text-gray-500">Checkout ID: {checkoutId}</p>
			)}
		</div>
	);
}
`],
  ["payments/stripe/web/react/next/src/app/success/page.tsx.hbs", `export default async function SuccessPage({
	searchParams,
}: {
	searchParams: Promise<{ session_id: string }>
}) {
	const params = await searchParams;
	const session_id = params.session_id;

	return (
		<div className="container mx-auto px-4 py-8">
			<h1 className="text-2xl font-bold mb-4">Payment Successful!</h1>
			<p className="text-gray-600 mb-4">
				Thank you for your purchase. Your payment has been processed successfully.
			</p>
			{session_id && (
				<p className="text-sm text-gray-500">Session ID: {session_id}</p>
			)}
		</div>
	);
}
`],
  ["cms/sanity/web/next/src/app/studio/[[...tool]]/page.tsx.hbs", `import { NextStudio } from "next-sanity/studio";

import config from "../../../../sanity.config";

export const dynamic = "force-static";

export { metadata, viewport } from "next-sanity/studio";

export default function StudioPage() {
  return <NextStudio config={config} />;
}
`],
  ["payments/polar/web/react/next/src/app/success/page.tsx.hbs", `export default async function SuccessPage({
    searchParams,
}: {
    searchParams: Promise<{ checkout_id: string }>
}) {
    const params = await searchParams;
    const checkout_id = params.checkout_id;

    return (
        <div className="px-4 py-8">
            <h1>Payment Successful!</h1>
            {checkout_id && <p>Checkout ID: {checkout_id}</p>}
        </div>
    );
}
`],
  ["examples/ai/fullstack/tanstack-start/src/routes/api/ai/$.ts.hbs", `{{#if (eq ai "modelfusion")}}
import { createFileRoute } from "@tanstack/react-router";
import { streamText, openai } from "modelfusion";

const model = openai.ChatTextGenerator({
	model: "gpt-4o-mini",
	temperature: 0.7,
	maxGenerationTokens: 1000,
});

export const Route = createFileRoute("/api/ai/$")({
	server: {
		handlers: {
			POST: async ({ request }) => {
				try {
					const { messages } = await request.json();

					const chatMessages = messages.map((msg: { role: string; content: string }) => {
						if (msg.role === "user") {
							return openai.ChatMessage.user(msg.content);
						}
						return openai.ChatMessage.assistant(msg.content);
					});

					const textStream = await streamText({
						model,
						prompt: chatMessages,
					});

					const encoder = new TextEncoder();
					const readable = new ReadableStream({
						async start(controller) {
							try {
								for await (const delta of textStream) {
									if (delta) {
										controller.enqueue(encoder.encode(\`data: \${JSON.stringify({ content: delta })}\\n\\n\`));
									}
								}
								controller.enqueue(encoder.encode("data: [DONE]\\n\\n"));
								controller.close();
							} catch (error) {
								controller.error(error);
							}
						},
					});

					return new Response(readable, {
						headers: {
							"Content-Type": "text/event-stream",
							"Cache-Control": "no-cache",
							Connection: "keep-alive",
						},
					});
				} catch (error) {
					console.error("AI API error:", error);
					return new Response(
						JSON.stringify({ error: "Failed to process AI request" }),
						{
							status: 500,
							headers: { "Content-Type": "application/json" },
						},
					);
				}
			},
		},
	},
});
{{else if (eq ai "langgraph")}}
import { createFileRoute } from "@tanstack/react-router";
import { ChatGoogleGenerativeAI } from "@langchain/google-genai";
import { HumanMessage, AIMessage, type BaseMessage } from "@langchain/core/messages";
import { createReactAgent } from "@langchain/langgraph/prebuilt";

const model = new ChatGoogleGenerativeAI({
	model: "gemini-2.0-flash",
	temperature: 0,
});

const agent = createReactAgent({
	llm: model,
	tools: [],
});

export const Route = createFileRoute("/api/ai/$")({
	server: {
		handlers: {
			POST: async ({ request }) => {
				try {
					const { messages } = await request.json();

					const langchainMessages: BaseMessage[] = messages.map((msg: { role: string; content: string }) => {
						if (msg.role === "user") {
							return new HumanMessage(msg.content);
						}
						return new AIMessage(msg.content);
					});

					const stream = await agent.stream(
						{ messages: langchainMessages },
						{ streamMode: "messages" }
					);

					const encoder = new TextEncoder();
					const readable = new ReadableStream({
						async start(controller) {
							try {
								for await (const [message] of stream) {
									if (message.content) {
										const content = typeof message.content === "string"
											? message.content
											: JSON.stringify(message.content);
										controller.enqueue(encoder.encode(\`data: \${JSON.stringify({ content })}\\n\\n\`));
									}
								}
								controller.enqueue(encoder.encode("data: [DONE]\\n\\n"));
								controller.close();
							} catch (error) {
								controller.error(error);
							}
						},
					});

					return new Response(readable, {
						headers: {
							"Content-Type": "text/event-stream",
							"Cache-Control": "no-cache",
							Connection: "keep-alive",
						},
					});
				} catch (error) {
					console.error("AI API error:", error);
					return new Response(
						JSON.stringify({ error: "Failed to process AI request" }),
						{
							status: 500,
							headers: { "Content-Type": "application/json" },
						},
					);
				}
			},
		},
	},
});
{{else if (eq ai "google-adk")}}
import { createFileRoute } from "@tanstack/react-router";
import { LlmAgent, Runner } from "@google/adk";

const agent = new LlmAgent({
	name: "chat_agent",
	model: "gemini-2.5-flash",
	description: "A helpful AI assistant that can answer questions and help with tasks.",
	instruction: "You are a helpful AI assistant. Respond to user queries in a clear and concise manner.",
	tools: [],
});

export const Route = createFileRoute("/api/ai/$")({
	server: {
		handlers: {
			POST: async ({ request }) => {
				try {
					const { messages } = await request.json();

					const lastMessage = messages[messages.length - 1];
					const userMessage = lastMessage?.content || "";

					const runner = new Runner({ agent, appName: "chat-app" });
					const result = await runner.runAsync({ userMessage });

					let responseText = "";
					for await (const event of result) {
						if (event.content?.parts) {
							for (const part of event.content.parts) {
								if (part.text) {
									responseText += part.text;
								}
							}
						}
					}

					const encoder = new TextEncoder();
					const readable = new ReadableStream({
						start(controller) {
							controller.enqueue(encoder.encode(\`data: \${JSON.stringify({ content: responseText })}\\n\\n\`));
							controller.enqueue(encoder.encode("data: [DONE]\\n\\n"));
							controller.close();
						},
					});

					return new Response(readable, {
						headers: {
							"Content-Type": "text/event-stream",
							"Cache-Control": "no-cache",
							Connection: "keep-alive",
						},
					});
				} catch (error) {
					console.error("AI API error:", error);
					return new Response(
						JSON.stringify({ error: "Failed to process AI request" }),
						{
							status: 500,
							headers: { "Content-Type": "application/json" },
						},
					);
				}
			},
		},
	},
});
{{else}}
import { createFileRoute } from "@tanstack/react-router";
import { google } from "@ai-sdk/google";
import { streamText, type UIMessage, convertToModelMessages, wrapLanguageModel } from "ai";
import { devToolsMiddleware } from "@ai-sdk/devtools";

export const Route = createFileRoute("/api/ai/$")({
  server: {
    handlers: {
      POST: async ({ request }) => {
        try {
          const { messages }: { messages: UIMessage[] } = await request.json();

          const model = wrapLanguageModel({
            model: google("gemini-2.5-flash"),
            middleware: devToolsMiddleware(),
          });
          const result = streamText({
            model,
            messages: await convertToModelMessages(messages),
          });

          return result.toUIMessageStreamResponse();
        } catch (error) {
          console.error("AI API error:", error);
          return new Response(
            JSON.stringify({ error: "Failed to process AI request" }),
            {
              status: 500,
              headers: { "Content-Type": "application/json" },
            },
          );
        }
      },
    },
  },
});
{{/if}}
`],
  ["examples/ai/web/react/next/src/app/ai/page.tsx.hbs", `{{#if (eq backend "convex")}}
"use client";

import { api } from "@{{projectName}}/backend/convex/_generated/api";
import {
  useUIMessages,
  useSmoothText,
  type UIMessage,
} from "@convex-dev/agent/react";
import { useMutation } from "convex/react";
import { Send, Loader2 } from "lucide-react";
{{#if (eq webDeploy "cloudflare")}}
import dynamic from "next/dynamic";

const Streamdown = dynamic(
  () => import("streamdown").then((mod) => ({ default: mod.Streamdown })),
  {
    loading: () => (
      <div className="flex h-full items-center justify-center">
        <div className="text-muted-foreground">Loading response...</div>
      </div>
    ),
    ssr: false,
  }
);
{{else}}
import { Streamdown } from "streamdown";
{{/if}}
import { useEffect, useRef, useState } from "react";

import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";

function MessageContent({
  text,
  isStreaming,
}: {
  text: string;
  isStreaming: boolean;
}) {
  const [visibleText] = useSmoothText(text, {
    startStreaming: isStreaming,
  });
  return <Streamdown>{visibleText}</Streamdown>;
}

export default function AIPage() {
  const [input, setInput] = useState("");
  const [threadId, setThreadId] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const messagesEndRef = useRef<HTMLDivElement>(null);

  const createThread = useMutation(api.chat.createNewThread);
  const sendMessage = useMutation(api.chat.sendMessage);

  const { results: messages } = useUIMessages(
    api.chat.listMessages,
    threadId ? { threadId } : "skip",
    { initialNumItems: 50, stream: true },
  );

  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  }, [messages]);

  const hasStreamingMessage = messages?.some(
    (m: UIMessage) => m.status === "streaming",
  );

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    const text = input.trim();
    if (!text || isLoading) return;

    setIsLoading(true);
    setInput("");

    try {
      let currentThreadId = threadId;
      if (!currentThreadId) {
        currentThreadId = await createThread();
        setThreadId(currentThreadId);
      }

      await sendMessage({ threadId: currentThreadId, prompt: text });
    } catch (error) {
      console.error("Failed to send message:", error);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="grid grid-rows-[1fr_auto] overflow-hidden w-full mx-auto p-4">
      <div className="overflow-y-auto space-y-4 pb-4">
        {!messages || messages.length === 0 ? (
          <div className="text-center text-muted-foreground mt-8">
            Ask me anything to get started!
          </div>
        ) : (
          messages.map((message: UIMessage) => (
            <div
              key={message.key}
              className={\`p-3 rounded-lg \${
                message.role === "user"
                  ? "bg-primary/10 ml-8"
                  : "bg-secondary/20 mr-8"
              }\`}
            >
              <p className="text-sm font-semibold mb-1">
                {message.role === "user" ? "You" : "AI Assistant"}
              </p>
              <MessageContent
                text={message.text ?? ""}
                isStreaming={message.status === "streaming"}
              />
            </div>
          ))
        )}
        {isLoading && !hasStreamingMessage && (
          <div className="p-3 rounded-lg bg-secondary/20 mr-8">
            <p className="text-sm font-semibold mb-1">AI Assistant</p>
            <div className="flex items-center gap-2 text-muted-foreground">
              <Loader2 className="h-4 w-4 animate-spin" />
              <span>Thinking...</span>
            </div>
          </div>
        )}
        <div ref={messagesEndRef} />
      </div>

      <form
        onSubmit={handleSubmit}
        className="w-full flex items-center space-x-2 pt-2 border-t"
      >
        <Input
          name="prompt"
          value={input}
          onChange={(e) => setInput(e.target.value)}
          placeholder="Type your message..."
          className="flex-1"
          autoComplete="off"
          autoFocus
          disabled={isLoading}
        />
        <Button type="submit" size="icon" disabled={isLoading || !input.trim()}>
          {isLoading ? (
            <Loader2 className="h-4 w-4 animate-spin" />
          ) : (
            <Send size={18} />
          )}
        </Button>
      </form>
    </div>
  );
}
{{else if (eq ai "modelfusion")}}
"use client";

import { Send, Loader2 } from "lucide-react";
{{#if (eq webDeploy "cloudflare")}}
import dynamic from "next/dynamic";

const Streamdown = dynamic(
  () => import("streamdown").then((mod) => ({ default: mod.Streamdown })),
  {
    loading: () => (
      <div className="flex h-full items-center justify-center">
        <div className="text-muted-foreground">Loading response...</div>
      </div>
    ),
    ssr: false,
  }
);
{{else}}
import { Streamdown } from "streamdown";
{{/if}}
import { useEffect, useRef, useState, useCallback } from "react";

import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
{{#unless (eq backend "self")}}
import { env } from "@{{projectName}}/env/web";
{{/unless}}

type Message = {
  id: string;
  role: "user" | "assistant";
  content: string;
};

export default function AIPage() {
  const [input, setInput] = useState("");
  const [messages, setMessages] = useState<Message[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [streamingContent, setStreamingContent] = useState("");
  const messagesEndRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  }, [messages, streamingContent]);

  const sendMessage = useCallback(async (text: string) => {
    const userMessage: Message = {
      id: Date.now().toString(),
      role: "user",
      content: text,
    };

    setMessages((prev) => [...prev, userMessage]);
    setIsLoading(true);
    setStreamingContent("");

    try {
      const response = await fetch({{#if (eq backend "self")}}"/api/ai"{{else}}\`\${env.NEXT_PUBLIC_SERVER_URL}/ai\`{{/if}}, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          messages: [...messages, userMessage].map((m) => ({
            role: m.role,
            content: m.content,
          })),
        }),
      });

      if (!response.ok) throw new Error("Failed to send message");

      const reader = response.body?.getReader();
      const decoder = new TextDecoder();
      let fullContent = "";

      if (reader) {
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          const chunk = decoder.decode(value, { stream: true });
          const lines = chunk.split("\\n");

          for (const line of lines) {
            if (line.startsWith("data: ")) {
              const data = line.slice(6);
              if (data === "[DONE]") continue;
              try {
                const parsed = JSON.parse(data);
                if (parsed.content) {
                  fullContent += parsed.content;
                  setStreamingContent(fullContent);
                }
              } catch {
                // Ignore parsing errors for incomplete chunks
              }
            }
          }
        }
      }

      const assistantMessage: Message = {
        id: (Date.now() + 1).toString(),
        role: "assistant",
        content: fullContent,
      };
      setMessages((prev) => [...prev, assistantMessage]);
      setStreamingContent("");
    } catch (error) {
      console.error("Failed to send message:", error);
    } finally {
      setIsLoading(false);
    }
  }, [messages]);

  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    const text = input.trim();
    if (!text || isLoading) return;
    setInput("");
    sendMessage(text);
  };

  return (
    <div className="grid grid-rows-[1fr_auto] overflow-hidden w-full mx-auto p-4">
      <div className="overflow-y-auto space-y-4 pb-4">
        {messages.length === 0 && !streamingContent ? (
          <div className="text-center text-muted-foreground mt-8">
            Ask me anything to get started!
          </div>
        ) : (
          <>
            {messages.map((message) => (
              <div
                key={message.id}
                className={\`p-3 rounded-lg \${
                  message.role === "user"
                    ? "bg-primary/10 ml-8"
                    : "bg-secondary/20 mr-8"
                }\`}
              >
                <p className="text-sm font-semibold mb-1">
                  {message.role === "user" ? "You" : "AI Assistant"}
                </p>
                <Streamdown>{message.content}</Streamdown>
              </div>
            ))}
            {streamingContent && (
              <div className="p-3 rounded-lg bg-secondary/20 mr-8">
                <p className="text-sm font-semibold mb-1">AI Assistant</p>
                <Streamdown isAnimating>{streamingContent}</Streamdown>
              </div>
            )}
          </>
        )}
        {isLoading && !streamingContent && (
          <div className="p-3 rounded-lg bg-secondary/20 mr-8">
            <p className="text-sm font-semibold mb-1">AI Assistant</p>
            <div className="flex items-center gap-2 text-muted-foreground">
              <Loader2 className="h-4 w-4 animate-spin" />
              <span>Thinking...</span>
            </div>
          </div>
        )}
        <div ref={messagesEndRef} />
      </div>

      <form
        onSubmit={handleSubmit}
        className="w-full flex items-center space-x-2 pt-2 border-t"
      >
        <Input
          name="prompt"
          value={input}
          onChange={(e) => setInput(e.target.value)}
          placeholder="Type your message..."
          className="flex-1"
          autoComplete="off"
          autoFocus
          disabled={isLoading}
        />
        <Button type="submit" size="icon" disabled={isLoading || !input.trim()}>
          {isLoading ? (
            <Loader2 className="h-4 w-4 animate-spin" />
          ) : (
            <Send size={18} />
          )}
        </Button>
      </form>
    </div>
  );
}
{{else if (eq ai "langgraph")}}
"use client";

import { Send, Loader2 } from "lucide-react";
{{#if (eq webDeploy "cloudflare")}}
import dynamic from "next/dynamic";

const Streamdown = dynamic(
  () => import("streamdown").then((mod) => ({ default: mod.Streamdown })),
  {
    loading: () => (
      <div className="flex h-full items-center justify-center">
        <div className="text-muted-foreground">Loading response...</div>
      </div>
    ),
    ssr: false,
  }
);
{{else}}
import { Streamdown } from "streamdown";
{{/if}}
import { useEffect, useRef, useState, useCallback } from "react";

import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
{{#unless (eq backend "self")}}
import { env } from "@{{projectName}}/env/web";
{{/unless}}

type Message = {
  id: string;
  role: "user" | "assistant";
  content: string;
};

export default function AIPage() {
  const [input, setInput] = useState("");
  const [messages, setMessages] = useState<Message[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [streamingContent, setStreamingContent] = useState("");
  const messagesEndRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  }, [messages, streamingContent]);

  const sendMessage = useCallback(async (text: string) => {
    const userMessage: Message = {
      id: Date.now().toString(),
      role: "user",
      content: text,
    };

    setMessages((prev) => [...prev, userMessage]);
    setIsLoading(true);
    setStreamingContent("");

    try {
      const response = await fetch({{#if (eq backend "self")}}"/api/ai"{{else}}\`\${env.NEXT_PUBLIC_SERVER_URL}/ai\`{{/if}}, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          messages: [...messages, userMessage].map((m) => ({
            role: m.role,
            content: m.content,
          })),
        }),
      });

      if (!response.ok) throw new Error("Failed to send message");

      const reader = response.body?.getReader();
      const decoder = new TextDecoder();
      let fullContent = "";

      if (reader) {
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          const chunk = decoder.decode(value, { stream: true });
          const lines = chunk.split("\\n");

          for (const line of lines) {
            if (line.startsWith("data: ")) {
              const data = line.slice(6);
              if (data === "[DONE]") continue;
              try {
                const parsed = JSON.parse(data);
                if (parsed.content) {
                  fullContent += parsed.content;
                  setStreamingContent(fullContent);
                }
              } catch {
                // Ignore parsing errors for incomplete chunks
              }
            }
          }
        }
      }

      const assistantMessage: Message = {
        id: (Date.now() + 1).toString(),
        role: "assistant",
        content: fullContent,
      };
      setMessages((prev) => [...prev, assistantMessage]);
      setStreamingContent("");
    } catch (error) {
      console.error("Failed to send message:", error);
    } finally {
      setIsLoading(false);
    }
  }, [messages]);

  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    const text = input.trim();
    if (!text || isLoading) return;
    setInput("");
    sendMessage(text);
  };

  return (
    <div className="grid grid-rows-[1fr_auto] overflow-hidden w-full mx-auto p-4">
      <div className="overflow-y-auto space-y-4 pb-4">
        {messages.length === 0 && !streamingContent ? (
          <div className="text-center text-muted-foreground mt-8">
            Ask me anything to get started!
          </div>
        ) : (
          <>
            {messages.map((message) => (
              <div
                key={message.id}
                className={\`p-3 rounded-lg \${
                  message.role === "user"
                    ? "bg-primary/10 ml-8"
                    : "bg-secondary/20 mr-8"
                }\`}
              >
                <p className="text-sm font-semibold mb-1">
                  {message.role === "user" ? "You" : "AI Assistant"}
                </p>
                <Streamdown>{message.content}</Streamdown>
              </div>
            ))}
            {streamingContent && (
              <div className="p-3 rounded-lg bg-secondary/20 mr-8">
                <p className="text-sm font-semibold mb-1">AI Assistant</p>
                <Streamdown isAnimating>{streamingContent}</Streamdown>
              </div>
            )}
          </>
        )}
        {isLoading && !streamingContent && (
          <div className="p-3 rounded-lg bg-secondary/20 mr-8">
            <p className="text-sm font-semibold mb-1">AI Assistant</p>
            <div className="flex items-center gap-2 text-muted-foreground">
              <Loader2 className="h-4 w-4 animate-spin" />
              <span>Thinking...</span>
            </div>
          </div>
        )}
        <div ref={messagesEndRef} />
      </div>

      <form
        onSubmit={handleSubmit}
        className="w-full flex items-center space-x-2 pt-2 border-t"
      >
        <Input
          name="prompt"
          value={input}
          onChange={(e) => setInput(e.target.value)}
          placeholder="Type your message..."
          className="flex-1"
          autoComplete="off"
          autoFocus
          disabled={isLoading}
        />
        <Button type="submit" size="icon" disabled={isLoading || !input.trim()}>
          {isLoading ? (
            <Loader2 className="h-4 w-4 animate-spin" />
          ) : (
            <Send size={18} />
          )}
        </Button>
      </form>
    </div>
  );
}
{{else}}
"use client";

import { useChat } from "@ai-sdk/react";
import { DefaultChatTransport } from "ai";
import { Send } from "lucide-react";
{{#if (eq webDeploy "cloudflare")}}
import dynamic from "next/dynamic";

const Streamdown = dynamic(
  () => import("streamdown").then((mod) => ({ default: mod.Streamdown })),
  {
    loading: () => (
      <div className="flex h-full items-center justify-center">
        <div className="text-muted-foreground">Loading response...</div>
      </div>
    ),
    ssr: false,
  }
);
{{else}}
import { Streamdown } from "streamdown";
{{/if}}
import { useEffect, useRef, useState } from "react";

import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { env } from "@{{projectName}}/env/web";

export default function AIPage() {
  const [input, setInput] = useState("");
  const { messages, sendMessage, status } = useChat({
    transport: new DefaultChatTransport({
      api: {{#if (eq backend "self")}}"/api/ai"{{else}}\`\${env.NEXT_PUBLIC_SERVER_URL}/ai\`{{/if}},
    }),
  });

  const messagesEndRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  }, [messages]);

  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    const text = input.trim();
    if (!text) return;
    sendMessage({ text });
    setInput("");
  };

  return (
    <div className="grid grid-rows-[1fr_auto] overflow-hidden w-full mx-auto p-4">
      <div className="overflow-y-auto space-y-4 pb-4">
        {messages.length === 0 ? (
          <div className="text-center text-muted-foreground mt-8">
            Ask me anything to get started!
          </div>
        ) : (
          messages.map((message) => (
            <div
              key={message.id}
              className={\`p-3 rounded-lg \${
                message.role === "user"
                  ? "bg-primary/10 ml-8"
                  : "bg-secondary/20 mr-8"
              }\`}
            >
              <p className="text-sm font-semibold mb-1">
                {message.role === "user" ? "You" : "AI Assistant"}
              </p>
              {message.parts?.map((part, index) => {
                if (part.type === "text") {
                  return (
                    <Streamdown
                      key={index}
                      isAnimating={status === "streaming" && message.role === "assistant"}
                    >
                      {part.text}
                    </Streamdown>
                  );
                }
                return null;
              })}
            </div>
          ))
        )}
        <div ref={messagesEndRef} />
      </div>

      <form
        onSubmit={handleSubmit}
        className="w-full flex items-center space-x-2 pt-2 border-t"
      >
        <Input
          name="prompt"
          value={input}
          onChange={(e) => setInput(e.target.value)}
          placeholder="Type your message..."
          className="flex-1"
          autoComplete="off"
          autoFocus
        />
        <Button type="submit" size="icon">
          <Send size={18} />
        </Button>
      </form>
    </div>
  );
}
{{/if}}
`],
  ["examples/ai/fullstack/next/src/app/api/ai/route.ts.hbs", `{{#if (eq ai "modelfusion")}}
import { streamText, openai } from "modelfusion";

export const maxDuration = 30;

const model = openai.ChatTextGenerator({
	model: "gpt-4o-mini",
	temperature: 0.7,
	maxGenerationTokens: 1000,
});

export async function POST(req: Request) {
	const { messages } = await req.json();

	const chatMessages = messages.map((msg: { role: string; content: string }) => {
		if (msg.role === "user") {
			return openai.ChatMessage.user(msg.content);
		}
		return openai.ChatMessage.assistant(msg.content);
	});

	const textStream = await streamText({
		model,
		prompt: chatMessages,
	});

	const encoder = new TextEncoder();
	const readable = new ReadableStream({
		async start(controller) {
			try {
				for await (const delta of textStream) {
					if (delta) {
						controller.enqueue(encoder.encode(\`data: \${JSON.stringify({ content: delta })}\\n\\n\`));
					}
				}
				controller.enqueue(encoder.encode("data: [DONE]\\n\\n"));
				controller.close();
			} catch (error) {
				controller.error(error);
			}
		},
	});

	return new Response(readable, {
		headers: {
			"Content-Type": "text/event-stream",
			"Cache-Control": "no-cache",
			Connection: "keep-alive",
		},
	});
}
{{else if (eq ai "langgraph")}}
import { ChatGoogleGenerativeAI } from "@langchain/google-genai";
import { HumanMessage, AIMessage, type BaseMessage } from "@langchain/core/messages";
import { createReactAgent } from "@langchain/langgraph/prebuilt";

export const maxDuration = 30;

const model = new ChatGoogleGenerativeAI({
	model: "gemini-2.0-flash",
	temperature: 0,
});

const agent = createReactAgent({
	llm: model,
	tools: [],
});

export async function POST(req: Request) {
	const { messages } = await req.json();

	const langchainMessages: BaseMessage[] = messages.map((msg: { role: string; content: string }) => {
		if (msg.role === "user") {
			return new HumanMessage(msg.content);
		}
		return new AIMessage(msg.content);
	});

	const stream = await agent.stream(
		{ messages: langchainMessages },
		{ streamMode: "messages" }
	);

	const encoder = new TextEncoder();
	const readable = new ReadableStream({
		async start(controller) {
			try {
				for await (const [message] of stream) {
					if (message.content) {
						const content = typeof message.content === "string"
							? message.content
							: JSON.stringify(message.content);
						controller.enqueue(encoder.encode(\`data: \${JSON.stringify({ content })}\\n\\n\`));
					}
				}
				controller.enqueue(encoder.encode("data: [DONE]\\n\\n"));
				controller.close();
			} catch (error) {
				controller.error(error);
			}
		},
	});

	return new Response(readable, {
		headers: {
			"Content-Type": "text/event-stream",
			"Cache-Control": "no-cache",
			Connection: "keep-alive",
		},
	});
}
{{else if (eq ai "google-adk")}}
import { LlmAgent, Runner } from "@google/adk";

export const maxDuration = 30;

const agent = new LlmAgent({
	name: "chat_agent",
	model: "gemini-2.5-flash",
	description: "A helpful AI assistant that can answer questions and help with tasks.",
	instruction: "You are a helpful AI assistant. Respond to user queries in a clear and concise manner.",
	tools: [],
});

export async function POST(req: Request) {
	const { messages } = await req.json();

	const lastMessage = messages[messages.length - 1];
	const userMessage = lastMessage?.content || "";

	const runner = new Runner({ agent, appName: "chat-app" });
	const result = await runner.runAsync({ userMessage });

	let responseText = "";
	for await (const event of result) {
		if (event.content?.parts) {
			for (const part of event.content.parts) {
				if (part.text) {
					responseText += part.text;
				}
			}
		}
	}

	const encoder = new TextEncoder();
	const readable = new ReadableStream({
		start(controller) {
			controller.enqueue(encoder.encode(\`data: \${JSON.stringify({ content: responseText })}\\n\\n\`));
			controller.enqueue(encoder.encode("data: [DONE]\\n\\n"));
			controller.close();
		},
	});

	return new Response(readable, {
		headers: {
			"Content-Type": "text/event-stream",
			"Cache-Control": "no-cache",
			Connection: "keep-alive",
		},
	});
}
{{else}}
import { google } from "@ai-sdk/google";
import { streamText, type UIMessage, convertToModelMessages, wrapLanguageModel } from "ai";
import { devToolsMiddleware } from "@ai-sdk/devtools";

export const maxDuration = 30;

export async function POST(req: Request) {
	const { messages }: { messages: UIMessage[] } = await req.json();

	const model = wrapLanguageModel({
		model: google("gemini-2.5-flash"),
		middleware: devToolsMiddleware(),
	});
	const result = streamText({
		model,
		messages: await convertToModelMessages(messages),
	});

	return result.toUIMessageStreamResponse();
}
{{/if}}
`],
  ["examples/todo/web/react/next/src/app/todos/page.tsx.hbs", `"use client"

import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Checkbox } from "@/components/ui/checkbox";
import { Input } from "@/components/ui/input";
import { Loader2, Trash2 } from "lucide-react";
import { useState } from "react";

{{#if (eq backend "convex")}}
import { useMutation, useQuery } from "convex/react";
import { api } from "@{{projectName}}/backend/convex/_generated/api";
import type { Id } from "@{{projectName}}/backend/convex/_generated/dataModel";
{{else}}
import { useMutation, useQuery } from "@tanstack/react-query";
  {{#if (eq api "orpc")}}
import { orpc } from "@/utils/orpc";
  {{/if}}
  {{#if (eq api "trpc")}}
import { trpc } from "@/utils/trpc";
  {{/if}}
{{/if}}


export default function TodosPage() {
  const [newTodoText, setNewTodoText] = useState("");

  {{#if (eq backend "convex")}}
  const todos = useQuery(api.todos.getAll);
  const createTodoMutation = useMutation(api.todos.create);
  const toggleTodoMutation = useMutation(api.todos.toggle);
  const deleteTodoMutation = useMutation(api.todos.deleteTodo);

  const handleAddTodo = async (e: React.FormEvent) => {
    e.preventDefault();
    const text = newTodoText.trim();
    if (!text) return;
    await createTodoMutation({ text });
    setNewTodoText("");
  };

  const handleToggleTodo = (id: Id<"todos">, currentCompleted: boolean) => {
    toggleTodoMutation({ id, completed: !currentCompleted });
  };

  const handleDeleteTodo = (id: Id<"todos">) => {
    deleteTodoMutation({ id });
  };
  {{else}}
    {{#if (eq api "orpc")}}
    const todos = useQuery(orpc.todo.getAll.queryOptions());
    const createMutation = useMutation(
      orpc.todo.create.mutationOptions({
        onSuccess: () => {
          todos.refetch();
          setNewTodoText("");
        },
      }),
    );
    const toggleMutation = useMutation(
      orpc.todo.toggle.mutationOptions({
        onSuccess: () => { todos.refetch() },
      }),
    );
    const deleteMutation = useMutation(
      orpc.todo.delete.mutationOptions({
        onSuccess: () => { todos.refetch() },
      }),
    );
    {{/if}}
    {{#if (eq api "trpc")}}
    const todos = useQuery(trpc.todo.getAll.queryOptions());
    const createMutation = useMutation(
      trpc.todo.create.mutationOptions({
        onSuccess: () => {
          todos.refetch();
          setNewTodoText("");
        },
      }),
    );
    const toggleMutation = useMutation(
      trpc.todo.toggle.mutationOptions({
        onSuccess: () => { todos.refetch() },
      }),
    );
    const deleteMutation = useMutation(
      trpc.todo.delete.mutationOptions({
        onSuccess: () => { todos.refetch() },
      }),
    );
    {{/if}}

  const handleAddTodo = (e: React.FormEvent) => {
    e.preventDefault();
    if (newTodoText.trim()) {
      createMutation.mutate({ text: newTodoText });
    }
  };

  const handleToggleTodo = (id: number, completed: boolean) => {
    toggleMutation.mutate({ id, completed: !completed });
  };

  const handleDeleteTodo = (id: number) => {
    deleteMutation.mutate({ id });
  };
  {{/if}}

  return (
    <div className="mx-auto w-full max-w-md py-10">
      <Card>
        <CardHeader>
          <CardTitle>Todo List</CardTitle>
          <CardDescription>Manage your tasks efficiently</CardDescription>
        </CardHeader>
        <CardContent>
          <form
            onSubmit={handleAddTodo}
            className="mb-6 flex items-center space-x-2"
          >
            <Input
              value={newTodoText}
              onChange={(e) => setNewTodoText(e.target.value)}
              placeholder="Add a new task..."
              {{#if (eq backend "convex")}}
              {{else}}
              disabled={createMutation.isPending}
              {{/if}}
            />
            <Button
              type="submit"
              {{#if (eq backend "convex")}}
              disabled={!newTodoText.trim()}
              {{else}}
              disabled={createMutation.isPending || !newTodoText.trim()}
              {{/if}}
            >
              {{#if (eq backend "convex")}}
                Add
              {{else}}
                {createMutation.isPending ? (
                  <Loader2 className="h-4 w-4 animate-spin" />
                ) : (
                  "Add"
                )}
              {{/if}}
            </Button>
          </form>

          {{#if (eq backend "convex")}}
            {todos === undefined ? (
              <div className="flex justify-center py-4">
                <Loader2 className="h-6 w-6 animate-spin" />
              </div>
            ) : todos.length === 0 ? (
              <p className="py-4 text-center">No todos yet. Add one above!</p>
            ) : (
              <ul className="space-y-2">
                {todos.map((todo) => (
                  <li
                    key={todo._id}
                    className="flex items-center justify-between rounded-md border p-2"
                  >
                    <div className="flex items-center space-x-2">
                      <Checkbox
                        checked={todo.completed}
                        onCheckedChange={() =>
                          handleToggleTodo(todo._id, todo.completed)
                        }
                        id={\`todo-\${todo._id}\`}
                      />
                      <label
                        htmlFor={\`todo-\${todo._id}\`}
                        className={\`\${todo.completed ? "line-through text-muted-foreground" : ""}\`}
                      >
                        {todo.text}
                      </label>
                    </div>
                    <Button
                      variant="ghost"
                      size="icon"
                      onClick={() => handleDeleteTodo(todo._id)}
                      aria-label="Delete todo"
                    >
                      <Trash2 className="h-4 w-4" />
                    </Button>
                  </li>
                ))}
              </ul>
            )}
          {{else}}
            {todos.isLoading ? (
              <div className="flex justify-center py-4">
                <Loader2 className="h-6 w-6 animate-spin" />
              </div>
            ) : todos.data?.length === 0 ? (
              <p className="py-4 text-center">
                No todos yet. Add one above!
              </p>
            ) : (
              <ul className="space-y-2">
                {todos.data?.map((todo) => (
                  <li
                    key={todo.id}
                    className="flex items-center justify-between rounded-md border p-2"
                  >
                    <div className="flex items-center space-x-2">
                      <Checkbox
                        checked={todo.completed}
                        onCheckedChange={() =>
                          handleToggleTodo(todo.id, todo.completed)
                        }
                        id={\`todo-\${todo.id}\`}
                      />
                      <label
                        htmlFor={\`todo-\${todo.id}\`}
                        className={\`\${todo.completed ? "line-through text-muted-foreground" : ""}\`}
                      >
                        {todo.text}
                      </label>
                    </div>
                    <Button
                      variant="ghost"
                      size="icon"
                      onClick={() => handleDeleteTodo(todo.id)}
                      aria-label="Delete todo"
                    >
                      <Trash2 className="h-4 w-4" />
                    </Button>
                  </li>
                ))}
              </ul>
            )}
          {{/if}}
        </CardContent>
      </Card>
    </div>
  );
}
`],
  ["auth/clerk/convex/web/react/tanstack-start/src/routes/dashboard.tsx.hbs", `import { SignInButton, UserButton, useUser } from "@clerk/tanstack-react-start";
import { api } from "@{{projectName}}/backend/convex/_generated/api";
import { createFileRoute } from "@tanstack/react-router";
import {
	Authenticated,
	AuthLoading,
	Unauthenticated,
	useQuery,
} from "convex/react";

export const Route = createFileRoute("/dashboard")({
	component: RouteComponent,
});

function RouteComponent() {
	const privateData = useQuery(api.privateData.get);
	const user = useUser();

	return (
		<>
			<Authenticated>
				<div>
					<h1>Dashboard</h1>
					<p>Welcome {user.user?.fullName}</p>
					<p>privateData: {privateData?.message}</p>
					<UserButton />
				</div>
			</Authenticated>
			<Unauthenticated>
				<SignInButton />
			</Unauthenticated>
			<AuthLoading>
				<div>Loading...</div>
			</AuthLoading>
		</>
	);
}
`],
  ["auth/clerk/convex/web/react/tanstack-router/src/routes/dashboard.tsx.hbs", `import { SignInButton, UserButton, useUser } from "@clerk/clerk-react";
import { api } from "@{{projectName}}/backend/convex/_generated/api";
import { createFileRoute } from "@tanstack/react-router";
import {
	Authenticated,
	AuthLoading,
	Unauthenticated,
	useQuery,
} from "convex/react";

export const Route = createFileRoute("/dashboard")({
	component: RouteComponent,
});

function RouteComponent() {
	const privateData = useQuery(api.privateData.get);
	const user = useUser()

	return (
		<>
			<Authenticated>
				<div>
					<h1>Dashboard</h1>
					<p>Welcome {user.user?.fullName}</p>
					<p>privateData: {privateData?.message}</p>
					<UserButton />
				</div>
			</Authenticated>
			<Unauthenticated>
				<SignInButton />
			</Unauthenticated>
			<AuthLoading>
				<div>Loading...</div>
			</AuthLoading>
		</>
	);
}
`],
  ["auth/clerk/convex/web/react/react-router/src/routes/dashboard.tsx.hbs", `import { SignInButton, UserButton, useUser } from "@clerk/clerk-react";
import { api } from "@{{projectName}}/backend/convex/_generated/api";
import {
	Authenticated,
	AuthLoading,
	Unauthenticated,
	useQuery,
} from "convex/react";

export default function Dashboard() {
	const privateData = useQuery(api.privateData.get);
	const user = useUser();

	return (
		<>
			<Authenticated>
				<div>
					<h1>Dashboard</h1>
					<p>Welcome {user.user?.fullName}</p>
					<p>privateData: {privateData?.message}</p>
					<UserButton />
				</div>
			</Authenticated>
			<Unauthenticated>
				<SignInButton />
			</Unauthenticated>
			<AuthLoading>
				<div>Loading...</div>
			</AuthLoading>
		</>
	);
}
`],
  ["auth/better-auth/fullstack/tanstack-start/src/routes/api/auth/$.ts.hbs", `import { auth } from '@{{projectName}}/auth'
import { createFileRoute } from '@tanstack/react-router'

export const Route = createFileRoute('/api/auth/$')({
  server: {
    handlers: {
      GET: ({ request }) => {
        return auth.handler(request)
      },
      POST: ({ request }) => {
        return auth.handler(request)
      },
    },
  },
})
`],
  ["auth/better-auth/convex/web/react/tanstack-start/src/routes/dashboard.tsx.hbs", `import SignInForm from "@/components/sign-in-form";
import SignUpForm from "@/components/sign-up-form";
import UserMenu from "@/components/user-menu";
import { api } from "@{{projectName}}/backend/convex/_generated/api";
import { createFileRoute } from "@tanstack/react-router";
import {
  Authenticated,
  AuthLoading,
  Unauthenticated,
  useQuery,
} from "convex/react";
import { useState } from "react";

export const Route = createFileRoute("/dashboard")({
  component: RouteComponent,
});

function RouteComponent() {
  const [showSignIn, setShowSignIn] = useState(false);
  const privateData = useQuery(api.privateData.get);

  return (
    <>
      <Authenticated>
        <div>
          <h1>Dashboard</h1>
          <p>privateData: {privateData?.message}</p>
          <UserMenu />
        </div>
      </Authenticated>
      <Unauthenticated>
        {showSignIn ? (
          <SignInForm onSwitchToSignUp={() => setShowSignIn(false)} />
        ) : (
          <SignUpForm onSwitchToSignIn={() => setShowSignIn(true)} />
        )}
      </Unauthenticated>
      <AuthLoading>
        <div>Loading...</div>
      </AuthLoading>
    </>
  );
}
`],
  ["auth/better-auth/convex/web/react/next/src/components/user-menu.tsx.hbs", `import {
	DropdownMenu,
	DropdownMenuContent,
	DropdownMenuGroup,
	DropdownMenuItem,
	DropdownMenuLabel,
	DropdownMenuSeparator,
	DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { authClient } from "@/lib/auth-client";
import { Button } from "./ui/button";
import { useRouter } from "next/navigation";
import { useQuery } from "convex/react";
import { api } from "@{{projectName}}/backend/convex/_generated/api";

export default function UserMenu() {
	const router = useRouter();
	const user = useQuery(api.auth.getCurrentUser)

	return (
		<DropdownMenu>
			<DropdownMenuTrigger render={<Button variant="outline" />}>
				{user?.name}
			</DropdownMenuTrigger>
			<DropdownMenuContent className="bg-card">
				<DropdownMenuGroup>
					<DropdownMenuLabel>My Account</DropdownMenuLabel>
					<DropdownMenuSeparator />
					<DropdownMenuItem>{user?.email}</DropdownMenuItem>
					<DropdownMenuItem
						variant="destructive"
						onClick={() => {
							authClient.signOut({
								fetchOptions: {
									onSuccess: () => {
										router.push("/dashboard");
									},
								},
							});
						}}
					>
						Sign Out
					</DropdownMenuItem>
				</DropdownMenuGroup>
			</DropdownMenuContent>
		</DropdownMenu>
	);
}
`],
  ["auth/better-auth/convex/web/react/next/src/components/sign-in-form.tsx.hbs", `import { authClient } from "@/lib/auth-client";
import { useForm } from "@tanstack/react-form";
import { toast } from "sonner";
import z from "zod";
import { Button } from "./ui/button";
import { Input } from "./ui/input";
import { Label } from "./ui/label";
import { useRouter } from "next/navigation";

export default function SignInForm({
	onSwitchToSignUp,
}: {
	onSwitchToSignUp: () => void;
}) {
	const router = useRouter();

	const form = useForm({
		defaultValues: {
			email: "",
			password: "",
		},
		onSubmit: async ({ value }) => {
			await authClient.signIn.email(
				{
					email: value.email,
					password: value.password,
				},
				{
					onSuccess: () => {
						router.push("/dashboard");
						toast.success("Sign in successful");
					},
					onError: (error) => {
						toast.error(error.error.message || error.error.statusText);
					},
				},
			);
		},
		validators: {
			onSubmit: z.object({
				email: z.email("Invalid email address"),
				password: z.string().min(8, "Password must be at least 8 characters"),
			}),
		},
	});

	return (
		<div className="mx-auto w-full mt-10 max-w-md p-6">
			<h1 className="mb-6 text-center text-3xl font-bold">Welcome Back</h1>

			<form
				onSubmit={(e) => {
					e.preventDefault();
					e.stopPropagation();
					form.handleSubmit();
				}}
				className="space-y-4"
			>
				<div>
					<form.Field name="email">
						{(field) => (
							<div className="space-y-2">
								<Label htmlFor={field.name}>Email</Label>
								<Input
									id={field.name}
									name={field.name}
									type="email"
									value={field.state.value}
									onBlur={field.handleBlur}
									onChange={(e) => field.handleChange(e.target.value)}
								/>
								{field.state.meta.errors.map((error) => (
									<p key={error?.message} className="text-red-500">
										{error?.message}
									</p>
								))}
							</div>
						)}
					</form.Field>
				</div>

				<div>
					<form.Field name="password">
						{(field) => (
							<div className="space-y-2">
								<Label htmlFor={field.name}>Password</Label>
								<Input
									id={field.name}
									name={field.name}
									type="password"
									value={field.state.value}
									onBlur={field.handleBlur}
									onChange={(e) => field.handleChange(e.target.value)}
								/>
								{field.state.meta.errors.map((error) => (
									<p key={error?.message} className="text-red-500">
										{error?.message}
									</p>
								))}
							</div>
						)}
					</form.Field>
				</div>

				<form.Subscribe>
					{(state) => (
						<Button
							type="submit"
							className="w-full"
							disabled={!state.canSubmit || state.isSubmitting}
						>
							{state.isSubmitting ? "Submitting..." : "Sign In"}
						</Button>
					)}
				</form.Subscribe>
			</form>

			<div className="mt-4 text-center">
				<Button
					variant="link"
					onClick={onSwitchToSignUp}
					className="text-indigo-600 hover:text-indigo-800"
				>
					Need an account? Sign Up
				</Button>
			</div>
		</div>
	);
}
`],
  ["auth/better-auth/convex/web/react/next/src/components/sign-up-form.tsx.hbs", `import { authClient } from "@/lib/auth-client";
import { useForm } from "@tanstack/react-form";
import { toast } from "sonner";
import z from "zod";
import { Button } from "./ui/button";
import { Input } from "./ui/input";
import { Label } from "./ui/label";
import { useRouter } from "next/navigation";

export default function SignUpForm({
	onSwitchToSignIn,
}: {
	onSwitchToSignIn: () => void;
}) {
	const router = useRouter();

	const form = useForm({
		defaultValues: {
			email: "",
			password: "",
			name: "",
		},
		onSubmit: async ({ value }) => {
			await authClient.signUp.email(
				{
					email: value.email,
					password: value.password,
					name: value.name,
				},
				{
					onSuccess: () => {
						router.push("/dashboard");
						toast.success("Sign up successful");
					},
					onError: (error) => {
						toast.error(error.error.message || error.error.statusText);
					},
				},
			);
		},
		validators: {
			onSubmit: z.object({
				name: z.string().min(2, "Name must be at least 2 characters"),
				email: z.email("Invalid email address"),
				password: z.string().min(8, "Password must be at least 8 characters"),
			}),
		},
	});

	return (
		<div className="mx-auto w-full mt-10 max-w-md p-6">
			<h1 className="mb-6 text-center text-3xl font-bold">Create Account</h1>

			<form
				onSubmit={(e) => {
					e.preventDefault();
					e.stopPropagation();
					form.handleSubmit();
				}}
				className="space-y-4"
			>
				<div>
					<form.Field name="name">
						{(field) => (
							<div className="space-y-2">
								<Label htmlFor={field.name}>Name</Label>
								<Input
									id={field.name}
									name={field.name}
									value={field.state.value}
									onBlur={field.handleBlur}
									onChange={(e) => field.handleChange(e.target.value)}
								/>
								{field.state.meta.errors.map((error) => (
									<p key={error?.message} className="text-red-500">
										{error?.message}
									</p>
								))}
							</div>
						)}
					</form.Field>
				</div>

				<div>
					<form.Field name="email">
						{(field) => (
							<div className="space-y-2">
								<Label htmlFor={field.name}>Email</Label>
								<Input
									id={field.name}
									name={field.name}
									type="email"
									value={field.state.value}
									onBlur={field.handleBlur}
									onChange={(e) => field.handleChange(e.target.value)}
								/>
								{field.state.meta.errors.map((error) => (
									<p key={error?.message} className="text-red-500">
										{error?.message}
									</p>
								))}
							</div>
						)}
					</form.Field>
				</div>

				<div>
					<form.Field name="password">
						{(field) => (
							<div className="space-y-2">
								<Label htmlFor={field.name}>Password</Label>
								<Input
									id={field.name}
									name={field.name}
									type="password"
									value={field.state.value}
									onBlur={field.handleBlur}
									onChange={(e) => field.handleChange(e.target.value)}
								/>
								{field.state.meta.errors.map((error) => (
									<p key={error?.message} className="text-red-500">
										{error?.message}
									</p>
								))}
							</div>
						)}
					</form.Field>
				</div>

				<form.Subscribe>
					{(state) => (
						<Button
							type="submit"
							className="w-full"
							disabled={!state.canSubmit || state.isSubmitting}
						>
							{state.isSubmitting ? "Submitting..." : "Sign Up"}
						</Button>
					)}
				</form.Subscribe>
			</form>

			<div className="mt-4 text-center">
				<Button
					variant="link"
					onClick={onSwitchToSignIn}
					className="text-indigo-600 hover:text-indigo-800"
				>
					Already have an account? Sign In
				</Button>
			</div>
		</div>
	);
}
`],
  ["auth/better-auth/convex/web/react/next/src/lib/auth-server.ts.hbs", `import { convexBetterAuthNextJs } from "@convex-dev/better-auth/nextjs";
import { env } from "@{{projectName}}/env/web";

export const {
	handler,
	preloadAuthQuery,
	isAuthenticated,
	getToken,
	fetchAuthQuery,
	fetchAuthMutation,
	fetchAuthAction,
} = convexBetterAuthNextJs({
	convexUrl: env.NEXT_PUBLIC_CONVEX_URL,
	convexSiteUrl: env.NEXT_PUBLIC_CONVEX_SITE_URL,
});
`],
  ["auth/better-auth/convex/web/react/next/src/lib/auth-client.ts.hbs", `import { createAuthClient } from "better-auth/react";
import { convexClient } from "@convex-dev/better-auth/client/plugins";

export const authClient = createAuthClient({
  plugins: [convexClient()],
});
`],
  ["auth/better-auth/convex/web/react/tanstack-start/src/components/user-menu.tsx.hbs", `import {
    DropdownMenu,
    DropdownMenuContent,
    DropdownMenuGroup,
    DropdownMenuItem,
    DropdownMenuLabel,
    DropdownMenuSeparator,
    DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { authClient } from "@/lib/auth-client";
import { useQuery } from "convex/react";
import { api } from "@{{projectName}}/backend/convex/_generated/api";

import { Button } from "./ui/button";

export default function UserMenu() {
    const user = useQuery(api.auth.getCurrentUser)

    return (
        <DropdownMenu>
            <DropdownMenuTrigger render={<Button variant="outline" />}>
                {user?.name}
            </DropdownMenuTrigger>
            <DropdownMenuContent className="bg-card">
                <DropdownMenuGroup>
                    <DropdownMenuLabel>My Account</DropdownMenuLabel>
                    <DropdownMenuSeparator />
                    <DropdownMenuItem>{user?.email}</DropdownMenuItem>
                    <DropdownMenuItem
                        variant="destructive"
                        onClick={() => {
                            authClient.signOut({
                                fetchOptions: {
                                    onSuccess: () => {
                                        location.reload();
                                    },
                                },
                            });
                        }}
                    >
                        Sign Out
                    </DropdownMenuItem>
                </DropdownMenuGroup>
            </DropdownMenuContent>
        </DropdownMenu>
    );
}
`],
  ["auth/better-auth/convex/web/react/tanstack-start/src/components/sign-in-form.tsx.hbs", `import { authClient } from "@/lib/auth-client";
import { useForm } from "@tanstack/react-form";
import { useNavigate } from "@tanstack/react-router";
import { toast } from "sonner";
import z from "zod";
import { Button } from "./ui/button";
import { Input } from "./ui/input";
import { Label } from "./ui/label";

export default function SignInForm({
    onSwitchToSignUp,
}: {
    onSwitchToSignUp: () => void;
}) {
    const navigate = useNavigate({
        from: "/",
    });

    const form = useForm({
        defaultValues: {
            email: "",
            password: "",
        },
        onSubmit: async ({ value }) => {
            await authClient.signIn.email(
                {
                    email: value.email,
                    password: value.password,
                },
                {
                    onSuccess: () => {
                        navigate({
                            to: "/dashboard",
                        });
                        toast.success("Sign in successful");
                    },
                    onError: (error) => {
                        toast.error(error.error.message || error.error.statusText);
                    },
                },
            );
        },
        validators: {
            onSubmit: z.object({
                email: z.email("Invalid email address"),
                password: z.string().min(8, "Password must be at least 8 characters"),
            }),
        },
    });

    return (
        <div className="mx-auto w-full mt-10 max-w-md p-6">
            <h1 className="mb-6 text-center text-3xl font-bold">Welcome Back</h1>

            <form
                onSubmit={(e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    form.handleSubmit();
                }}
                className="space-y-4"
            >
                <div>
                    <form.Field name="email">
                        {(field) => (
                            <div className="space-y-2">
                                <Label htmlFor={field.name}>Email</Label>
                                <Input
                                    id={field.name}
                                    name={field.name}
                                    type="email"
                                    value={field.state.value}
                                    onBlur={field.handleBlur}
                                    onChange={(e) => field.handleChange(e.target.value)}
                                />
                                {field.state.meta.errors.map((error) => (
                                    <p key={error?.message} className="text-red-500">
                                        {error?.message}
                                    </p>
                                ))}
                            </div>
                        )}
                    </form.Field>
                </div>

                <div>
                    <form.Field name="password">
                        {(field) => (
                            <div className="space-y-2">
                                <Label htmlFor={field.name}>Password</Label>
                                <Input
                                    id={field.name}
                                    name={field.name}
                                    type="password"
                                    value={field.state.value}
                                    onBlur={field.handleBlur}
                                    onChange={(e) => field.handleChange(e.target.value)}
                                />
                                {field.state.meta.errors.map((error) => (
                                    <p key={error?.message} className="text-red-500">
                                        {error?.message}
                                    </p>
                                ))}
                            </div>
                        )}
                    </form.Field>
                </div>

                <form.Subscribe>
                    {(state) => (
                        <Button
                            type="submit"
                            className="w-full"
                            disabled={!state.canSubmit || state.isSubmitting}
                        >
                            {state.isSubmitting ? "Submitting..." : "Sign In"}
                        </Button>
                    )}
                </form.Subscribe>
            </form>

            <div className="mt-4 text-center">
                <Button
                    variant="link"
                    onClick={onSwitchToSignUp}
                    className="text-indigo-600 hover:text-indigo-800"
                >
                    Need an account? Sign Up
                </Button>
            </div>
        </div>
    );
}
`],
  ["auth/better-auth/convex/web/react/tanstack-start/src/components/sign-up-form.tsx.hbs", `import { authClient } from "@/lib/auth-client";
import { useForm } from "@tanstack/react-form";
import { useNavigate } from "@tanstack/react-router";
import { toast } from "sonner";
import z from "zod";
import { Button } from "./ui/button";
import { Input } from "./ui/input";
import { Label } from "./ui/label";

export default function SignUpForm({
    onSwitchToSignIn,
}: {
    onSwitchToSignIn: () => void;
}) {
    const navigate = useNavigate({
        from: "/",
    });

    const form = useForm({
        defaultValues: {
            email: "",
            password: "",
            name: "",
        },
        onSubmit: async ({ value }) => {
            await authClient.signUp.email(
                {
                    email: value.email,
                    password: value.password,
                    name: value.name,
                },
                {
                    onSuccess: () => {
                        navigate({
                            to: "/dashboard",
                        });
                        toast.success("Sign up successful");
                    },
                    onError: (error) => {
                        toast.error(error.error.message || error.error.statusText);
                    },
                },
            );
        },
        validators: {
            onSubmit: z.object({
                name: z.string().min(2, "Name must be at least 2 characters"),
                email: z.email("Invalid email address"),
                password: z.string().min(8, "Password must be at least 8 characters"),
            }),
        },
    });

    return (
        <div className="mx-auto w-full mt-10 max-w-md p-6">
            <h1 className="mb-6 text-center text-3xl font-bold">Create Account</h1>

            <form
                onSubmit={(e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    form.handleSubmit();
                }}
                className="space-y-4"
            >
                <div>
                    <form.Field name="name">
                        {(field) => (
                            <div className="space-y-2">
                                <Label htmlFor={field.name}>Name</Label>
                                <Input
                                    id={field.name}
                                    name={field.name}
                                    value={field.state.value}
                                    onBlur={field.handleBlur}
                                    onChange={(e) => field.handleChange(e.target.value)}
                                />
                                {field.state.meta.errors.map((error) => (
                                    <p key={error?.message} className="text-red-500">
                                        {error?.message}
                                    </p>
                                ))}
                            </div>
                        )}
                    </form.Field>
                </div>

                <div>
                    <form.Field name="email">
                        {(field) => (
                            <div className="space-y-2">
                                <Label htmlFor={field.name}>Email</Label>
                                <Input
                                    id={field.name}
                                    name={field.name}
                                    type="email"
                                    value={field.state.value}
                                    onBlur={field.handleBlur}
                                    onChange={(e) => field.handleChange(e.target.value)}
                                />
                                {field.state.meta.errors.map((error) => (
                                    <p key={error?.message} className="text-red-500">
                                        {error?.message}
                                    </p>
                                ))}
                            </div>
                        )}
                    </form.Field>
                </div>

                <div>
                    <form.Field name="password">
                        {(field) => (
                            <div className="space-y-2">
                                <Label htmlFor={field.name}>Password</Label>
                                <Input
                                    id={field.name}
                                    name={field.name}
                                    type="password"
                                    value={field.state.value}
                                    onBlur={field.handleBlur}
                                    onChange={(e) => field.handleChange(e.target.value)}
                                />
                                {field.state.meta.errors.map((error) => (
                                    <p key={error?.message} className="text-red-500">
                                        {error?.message}
                                    </p>
                                ))}
                            </div>
                        )}
                    </form.Field>
                </div>

                <form.Subscribe>
                    {(state) => (
                        <Button
                            type="submit"
                            className="w-full"
                            disabled={!state.canSubmit || state.isSubmitting}
                        >
                            {state.isSubmitting ? "Submitting..." : "Sign Up"}
                        </Button>
                    )}
                </form.Subscribe>
            </form>

            <div className="mt-4 text-center">
                <Button
                    variant="link"
                    onClick={onSwitchToSignIn}
                    className="text-indigo-600 hover:text-indigo-800"
                >
                    Already have an account? Sign In
                </Button>
            </div>
        </div>
    );
}
`],
  ["auth/better-auth/convex/web/react/tanstack-start/src/lib/auth-server.ts.hbs", `import { convexBetterAuthReactStart } from "@convex-dev/better-auth/react-start";
import { env } from "@{{projectName}}/env/web";

export const {
	handler,
	getToken,
	fetchAuthQuery,
	fetchAuthMutation,
	fetchAuthAction,
} = convexBetterAuthReactStart({
	convexUrl: env.VITE_CONVEX_URL,
	convexSiteUrl: env.VITE_CONVEX_SITE_URL,
});
`],
  ["auth/better-auth/convex/web/react/tanstack-start/src/lib/auth-client.ts.hbs", `import { createAuthClient } from "better-auth/react";
import { convexClient } from "@convex-dev/better-auth/client/plugins";

export const authClient = createAuthClient({
  plugins: [convexClient()],
});`],
  ["auth/better-auth/convex/web/react/tanstack-router/src/routes/dashboard.tsx.hbs", `import SignInForm from "@/components/sign-in-form";
import SignUpForm from "@/components/sign-up-form";
import UserMenu from "@/components/user-menu";
import { api } from "@{{projectName}}/backend/convex/_generated/api";
import { createFileRoute } from "@tanstack/react-router";
import {
  Authenticated,
  AuthLoading,
  Unauthenticated,
  useQuery,
} from "convex/react";
import { useState } from "react";

export const Route = createFileRoute("/dashboard")({
  component: RouteComponent,
});

function RouteComponent() {
  const [showSignIn, setShowSignIn] = useState(false);
  const privateData = useQuery(api.privateData.get);

  return (
    <>
      <Authenticated>
        <div>
          <h1>Dashboard</h1>
          <p>privateData: {privateData?.message}</p>
          <UserMenu />
        </div>
      </Authenticated>
      <Unauthenticated>
        {showSignIn ? (
          <SignInForm onSwitchToSignUp={() => setShowSignIn(false)} />
        ) : (
          <SignUpForm onSwitchToSignIn={() => setShowSignIn(true)} />
        )}
      </Unauthenticated>
      <AuthLoading>
        <div>Loading...</div>
      </AuthLoading>
    </>
  );
}
`],
  ["auth/better-auth/convex/web/react/tanstack-router/src/components/user-menu.tsx.hbs", `import { useNavigate } from "@tanstack/react-router";

import {
    DropdownMenu,
    DropdownMenuContent,
    DropdownMenuGroup,
    DropdownMenuItem,
    DropdownMenuLabel,
    DropdownMenuSeparator,
    DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { authClient } from "@/lib/auth-client";
import { useQuery } from "convex/react";
import { api } from "@{{projectName}}/backend/convex/_generated/api";

import { Button } from "./ui/button";

export default function UserMenu() {
    const navigate = useNavigate();
    const user = useQuery(api.auth.getCurrentUser)

    return (
        <DropdownMenu>
            <DropdownMenuTrigger render={<Button variant="outline" />}>
                {user?.name}
            </DropdownMenuTrigger>
            <DropdownMenuContent className="bg-card">
                <DropdownMenuGroup>
                    <DropdownMenuLabel>My Account</DropdownMenuLabel>
                    <DropdownMenuSeparator />
                    <DropdownMenuItem>{user?.email}</DropdownMenuItem>
                    <DropdownMenuItem
                        variant="destructive"
                        onClick={() => {
                            authClient.signOut({
                                fetchOptions: {
                                    onSuccess: () => {
                                        navigate({
                                            to: "/dashboard",
                                        });
                                    },
                                },
                            });
                        }}
                    >
                        Sign Out
                    </DropdownMenuItem>
                </DropdownMenuGroup>
            </DropdownMenuContent>
        </DropdownMenu>
    );
}
`],
  ["auth/better-auth/convex/web/react/tanstack-router/src/components/sign-in-form.tsx.hbs", `import { authClient } from "@/lib/auth-client";
import { useForm } from "@tanstack/react-form";
import { useNavigate } from "@tanstack/react-router";
import { toast } from "sonner";
import z from "zod";
import { Button } from "./ui/button";
import { Input } from "./ui/input";
import { Label } from "./ui/label";

export default function SignInForm({
    onSwitchToSignUp,
}: {
    onSwitchToSignUp: () => void;
}) {
    const navigate = useNavigate({
        from: "/",
    });

    const form = useForm({
        defaultValues: {
            email: "",
            password: "",
        },
        onSubmit: async ({ value }) => {
            await authClient.signIn.email(
                {
                    email: value.email,
                    password: value.password,
                },
                {
                    onSuccess: () => {
                        navigate({
                            to: "/dashboard",
                        });
                        toast.success("Sign in successful");
                    },
                    onError: (error) => {
                        toast.error(error.error.message || error.error.statusText);
                    },
                },
            );
        },
        validators: {
            onSubmit: z.object({
                email: z.email("Invalid email address"),
                password: z.string().min(8, "Password must be at least 8 characters"),
            }),
        },
    });

    return (
        <div className="mx-auto w-full mt-10 max-w-md p-6">
            <h1 className="mb-6 text-center text-3xl font-bold">Welcome Back</h1>

            <form
                onSubmit={(e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    form.handleSubmit();
                }}
                className="space-y-4"
            >
                <div>
                    <form.Field name="email">
                        {(field) => (
                            <div className="space-y-2">
                                <Label htmlFor={field.name}>Email</Label>
                                <Input
                                    id={field.name}
                                    name={field.name}
                                    type="email"
                                    value={field.state.value}
                                    onBlur={field.handleBlur}
                                    onChange={(e) => field.handleChange(e.target.value)}
                                />
                                {field.state.meta.errors.map((error) => (
                                    <p key={error?.message} className="text-red-500">
                                        {error?.message}
                                    </p>
                                ))}
                            </div>
                        )}
                    </form.Field>
                </div>

                <div>
                    <form.Field name="password">
                        {(field) => (
                            <div className="space-y-2">
                                <Label htmlFor={field.name}>Password</Label>
                                <Input
                                    id={field.name}
                                    name={field.name}
                                    type="password"
                                    value={field.state.value}
                                    onBlur={field.handleBlur}
                                    onChange={(e) => field.handleChange(e.target.value)}
                                />
                                {field.state.meta.errors.map((error) => (
                                    <p key={error?.message} className="text-red-500">
                                        {error?.message}
                                    </p>
                                ))}
                            </div>
                        )}
                    </form.Field>
                </div>

                <form.Subscribe>
                    {(state) => (
                        <Button
                            type="submit"
                            className="w-full"
                            disabled={!state.canSubmit || state.isSubmitting}
                        >
                            {state.isSubmitting ? "Submitting..." : "Sign In"}
                        </Button>
                    )}
                </form.Subscribe>
            </form>

            <div className="mt-4 text-center">
                <Button
                    variant="link"
                    onClick={onSwitchToSignUp}
                    className="text-indigo-600 hover:text-indigo-800"
                >
                    Need an account? Sign Up
                </Button>
            </div>
        </div>
    );
}
`],
  ["auth/better-auth/convex/web/react/tanstack-router/src/components/sign-up-form.tsx.hbs", `import { authClient } from "@/lib/auth-client";
import { useForm } from "@tanstack/react-form";
import { useNavigate } from "@tanstack/react-router";
import { toast } from "sonner";
import z from "zod";
import { Button } from "./ui/button";
import { Input } from "./ui/input";
import { Label } from "./ui/label";

export default function SignUpForm({
    onSwitchToSignIn,
}: {
    onSwitchToSignIn: () => void;
}) {
    const navigate = useNavigate({
        from: "/",
    });

    const form = useForm({
        defaultValues: {
            email: "",
            password: "",
            name: "",
        },
        onSubmit: async ({ value }) => {
            await authClient.signUp.email(
                {
                    email: value.email,
                    password: value.password,
                    name: value.name,
                },
                {
                    onSuccess: () => {
                        navigate({
                            to: "/dashboard",
                        });
                        toast.success("Sign up successful");
                    },
                    onError: (error) => {
                        toast.error(error.error.message || error.error.statusText);
                    },
                },
            );
        },
        validators: {
            onSubmit: z.object({
                name: z.string().min(2, "Name must be at least 2 characters"),
                email: z.email("Invalid email address"),
                password: z.string().min(8, "Password must be at least 8 characters"),
            }),
        },
    });

    return (
        <div className="mx-auto w-full mt-10 max-w-md p-6">
            <h1 className="mb-6 text-center text-3xl font-bold">Create Account</h1>

            <form
                onSubmit={(e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    form.handleSubmit();
                }}
                className="space-y-4"
            >
                <div>
                    <form.Field name="name">
                        {(field) => (
                            <div className="space-y-2">
                                <Label htmlFor={field.name}>Name</Label>
                                <Input
                                    id={field.name}
                                    name={field.name}
                                    value={field.state.value}
                                    onBlur={field.handleBlur}
                                    onChange={(e) => field.handleChange(e.target.value)}
                                />
                                {field.state.meta.errors.map((error) => (
                                    <p key={error?.message} className="text-red-500">
                                        {error?.message}
                                    </p>
                                ))}
                            </div>
                        )}
                    </form.Field>
                </div>

                <div>
                    <form.Field name="email">
                        {(field) => (
                            <div className="space-y-2">
                                <Label htmlFor={field.name}>Email</Label>
                                <Input
                                    id={field.name}
                                    name={field.name}
                                    type="email"
                                    value={field.state.value}
                                    onBlur={field.handleBlur}
                                    onChange={(e) => field.handleChange(e.target.value)}
                                />
                                {field.state.meta.errors.map((error) => (
                                    <p key={error?.message} className="text-red-500">
                                        {error?.message}
                                    </p>
                                ))}
                            </div>
                        )}
                    </form.Field>
                </div>

                <div>
                    <form.Field name="password">
                        {(field) => (
                            <div className="space-y-2">
                                <Label htmlFor={field.name}>Password</Label>
                                <Input
                                    id={field.name}
                                    name={field.name}
                                    type="password"
                                    value={field.state.value}
                                    onBlur={field.handleBlur}
                                    onChange={(e) => field.handleChange(e.target.value)}
                                />
                                {field.state.meta.errors.map((error) => (
                                    <p key={error?.message} className="text-red-500">
                                        {error?.message}
                                    </p>
                                ))}
                            </div>
                        )}
                    </form.Field>
                </div>

                <form.Subscribe>
                    {(state) => (
                        <Button
                            type="submit"
                            className="w-full"
                            disabled={!state.canSubmit || state.isSubmitting}
                        >
                            {state.isSubmitting ? "Submitting..." : "Sign Up"}
                        </Button>
                    )}
                </form.Subscribe>
            </form>

            <div className="mt-4 text-center">
                <Button
                    variant="link"
                    onClick={onSwitchToSignIn}
                    className="text-indigo-600 hover:text-indigo-800"
                >
                    Already have an account? Sign In
                </Button>
            </div>
        </div>
    );
}
`],
  ["auth/better-auth/convex/web/react/tanstack-router/src/lib/auth-client.ts.hbs", `import { createAuthClient } from "better-auth/react";
import {
	convexClient,
	crossDomainClient,
} from "@convex-dev/better-auth/client/plugins";
import { env } from "@{{projectName}}/env/web";

export const authClient = createAuthClient({
	baseURL: env.VITE_CONVEX_SITE_URL,
	plugins: [convexClient(), crossDomainClient()],
});`],
  ["auth/better-auth/server/db/mongoose/mongodb/src/models/auth.model.ts.hbs", `import mongoose from 'mongoose';

const { Schema, model } = mongoose;

const userSchema = new Schema(
    {
        _id: { type: String },
        name: { type: String, required: true },
        email: { type: String, required: true, unique: true },
        emailVerified: { type: Boolean, required: true },
        image: { type: String },
        createdAt: { type: Date, required: true },
        updatedAt: { type: Date, required: true },
    },
    { collection: 'user' }
);

const sessionSchema = new Schema(
    {
        _id: { type: String },
        expiresAt: { type: Date, required: true },
        token: { type: String, required: true, unique: true },
        createdAt: { type: Date, required: true },
        updatedAt: { type: Date, required: true },
        ipAddress: { type: String },
        userAgent: { type: String },
        userId: { type: String, ref: 'User', required: true },
    },
    { collection: 'session' }
);

const accountSchema = new Schema(
    {
        _id: { type: String },
        accountId: { type: String, required: true },
        providerId: { type: String, required: true },
        userId: { type: String, ref: 'User', required: true },
        accessToken: { type: String },
        refreshToken: { type: String },
        idToken: { type: String },
        accessTokenExpiresAt: { type: Date },
        refreshTokenExpiresAt: { type: Date },
        scope: { type: String },
        password: { type: String },
        createdAt: { type: Date, required: true },
        updatedAt: { type: Date, required: true },
    },
    { collection: 'account' }
);

const verificationSchema = new Schema(
    {
        _id: { type: String },
        identifier: { type: String, required: true },
        value: { type: String, required: true },
        expiresAt: { type: Date, required: true },
        createdAt: { type: Date },
        updatedAt: { type: Date },
    },
    { collection: 'verification' }
);

const User = model('User', userSchema);
const Session = model('Session', sessionSchema);
const Account = model('Account', accountSchema);
const Verification = model('Verification', verificationSchema);

export { User, Session, Account, Verification };
`],
  ["auth/nextauth/server/db/drizzle/sqlite/src/schema/auth.ts.hbs", `import { sqliteTable, text, integer, primaryKey } from "drizzle-orm/sqlite-core";

export const users = sqliteTable("user", {
  id: text("id")
    .primaryKey()
    .$defaultFn(() => crypto.randomUUID()),
  name: text("name"),
  email: text("email").unique(),
  emailVerified: integer("emailVerified", { mode: "timestamp" }),
  image: text("image"),
});

export const accounts = sqliteTable(
  "account",
  {
    userId: text("userId")
      .notNull()
      .references(() => users.id, { onDelete: "cascade" }),
    type: text("type").notNull(),
    provider: text("provider").notNull(),
    providerAccountId: text("providerAccountId").notNull(),
    refresh_token: text("refresh_token"),
    access_token: text("access_token"),
    expires_at: integer("expires_at"),
    token_type: text("token_type"),
    scope: text("scope"),
    id_token: text("id_token"),
    session_state: text("session_state"),
  },
  (account) => ({
    compoundKey: primaryKey({
      columns: [account.provider, account.providerAccountId],
    }),
  })
);

export const sessions = sqliteTable("session", {
  sessionToken: text("sessionToken").primaryKey(),
  userId: text("userId")
    .notNull()
    .references(() => users.id, { onDelete: "cascade" }),
  expires: integer("expires", { mode: "timestamp" }).notNull(),
});

export const verificationTokens = sqliteTable(
  "verificationToken",
  {
    identifier: text("identifier").notNull(),
    token: text("token").notNull(),
    expires: integer("expires", { mode: "timestamp" }).notNull(),
  },
  (verificationToken) => ({
    compositePk: primaryKey({
      columns: [verificationToken.identifier, verificationToken.token],
    }),
  })
);
`],
  ["auth/nextauth/server/db/drizzle/mysql/src/schema/auth.ts.hbs", `import { mysqlTable, varchar, text, timestamp, int, primaryKey } from "drizzle-orm/mysql-core";

export const users = mysqlTable("user", {
  id: varchar("id", { length: 255 })
    .primaryKey()
    .$defaultFn(() => crypto.randomUUID()),
  name: varchar("name", { length: 255 }),
  email: varchar("email", { length: 255 }).unique(),
  emailVerified: timestamp("emailVerified", { mode: "date", fsp: 3 }),
  image: varchar("image", { length: 255 }),
});

export const accounts = mysqlTable(
  "account",
  {
    userId: varchar("userId", { length: 255 })
      .notNull()
      .references(() => users.id, { onDelete: "cascade" }),
    type: varchar("type", { length: 255 }).notNull(),
    provider: varchar("provider", { length: 255 }).notNull(),
    providerAccountId: varchar("providerAccountId", { length: 255 }).notNull(),
    refresh_token: text("refresh_token"),
    access_token: text("access_token"),
    expires_at: int("expires_at"),
    token_type: varchar("token_type", { length: 255 }),
    scope: varchar("scope", { length: 255 }),
    id_token: text("id_token"),
    session_state: varchar("session_state", { length: 255 }),
  },
  (account) => ({
    compoundKey: primaryKey({
      columns: [account.provider, account.providerAccountId],
    }),
  })
);

export const sessions = mysqlTable("session", {
  sessionToken: varchar("sessionToken", { length: 255 }).primaryKey(),
  userId: varchar("userId", { length: 255 })
    .notNull()
    .references(() => users.id, { onDelete: "cascade" }),
  expires: timestamp("expires", { mode: "date" }).notNull(),
});

export const verificationTokens = mysqlTable(
  "verificationToken",
  {
    identifier: varchar("identifier", { length: 255 }).notNull(),
    token: varchar("token", { length: 255 }).notNull(),
    expires: timestamp("expires", { mode: "date" }).notNull(),
  },
  (verificationToken) => ({
    compositePk: primaryKey({
      columns: [verificationToken.identifier, verificationToken.token],
    }),
  })
);
`],
  ["auth/better-auth/web/react/next/src/app/dashboard/dashboard.tsx.hbs", `"use client";
{{#if (eq payments "polar")}}
import { Button } from "@/components/ui/button";
{{/if}}
import { authClient } from "@/lib/auth-client";
{{#if (eq api "orpc")}}
import { useQuery } from "@tanstack/react-query";
import { orpc } from "@/utils/orpc";
{{/if}}
{{#if (eq api "trpc")}}
import { useQuery } from "@tanstack/react-query";
import { trpc } from "@/utils/trpc";
{{/if}}

export default function Dashboard({
	{{#if (eq payments "polar")}}
	customerState,
	{{/if}}
	session
}: {
	{{#if (eq payments "polar")}}
	customerState: ReturnType<typeof authClient.customer.state>;
	{{/if}}
	session: typeof authClient.$Infer.Session;
}) {
	{{#if (eq api "orpc")}}
	const privateData = useQuery(orpc.privateData.queryOptions());
	{{/if}}
	{{#if (eq api "trpc")}}
	const privateData = useQuery(trpc.privateData.queryOptions());
	{{/if}}

	{{#if (eq payments "polar")}}
	const hasProSubscription = customerState?.activeSubscriptions?.length! > 0;
	console.log("Active subscriptions:", customerState?.activeSubscriptions);
	{{/if}}

	return (
		<>
			{{#if (eq api "orpc")}}
			<p>API: {privateData.data?.message}</p>
			{{/if}}
			{{#if (eq api "trpc")}}
			<p>API: {privateData.data?.message}</p>
			{{/if}}
			{{#if (eq payments "polar")}}
			<p>Plan: {hasProSubscription ? "Pro" : "Free"}</p>
			{hasProSubscription ? (
				<Button onClick={async () => await authClient.customer.portal()}>
					Manage Subscription
				</Button>
			) : (
				<Button onClick={async () => await authClient.checkout({ slug: "pro" })}>
					Upgrade to Pro
				</Button>
			)}
			{{/if}}
		</>
	);
}
`],
  ["auth/better-auth/web/react/next/src/app/dashboard/page.tsx.hbs", `import { redirect } from "next/navigation";
import Dashboard from "./dashboard";
import { headers } from "next/headers";
{{#if (eq backend "self")}}
import { auth } from "@{{projectName}}/auth";
{{/if}}
import { authClient } from "@/lib/auth-client";

export default async function DashboardPage() {
	{{#if (eq backend "self")}}
	const session = await auth.api.getSession({
		headers: await headers(),
	});
	{{else}}
	const session = await authClient.getSession({
		fetchOptions: {
			headers: await headers(),
			throw: true
		}
	});
	{{/if}}

	if (!session?.user) {
		redirect("/login");
	}

	{{#if (eq payments "polar")}}
	const { data: customerState } = await authClient.customer.state({
		fetchOptions: {
			headers: await headers(),
		},
	});
	{{/if}}

	return (
		<div>
			<h1>Dashboard</h1>
			<p>Welcome {session.user.name}</p>
			<Dashboard session={session} {{#if (eq payments "polar")}}customerState={customerState}{{/if}} />
		</div>
	);
}
`],
  ["auth/better-auth/web/react/next/src/app/login/page.tsx.hbs", `"use client"

import SignInForm from "@/components/sign-in-form";
import SignUpForm from "@/components/sign-up-form";
import { useState } from "react";


export default function LoginPage() {
  const [showSignIn, setShowSignIn] = useState(false);

  return showSignIn ? (
    <SignInForm onSwitchToSignUp={() => setShowSignIn(false)} />
  ) : (
    <SignUpForm onSwitchToSignIn={() => setShowSignIn(true)} />
  );
}
`],
  ["auth/nextauth/server/db/drizzle/postgres/src/schema/auth.ts.hbs", `import { pgTable, text, timestamp, primaryKey, integer } from "drizzle-orm/pg-core";

export const users = pgTable("user", {
  id: text("id")
    .primaryKey()
    .$defaultFn(() => crypto.randomUUID()),
  name: text("name"),
  email: text("email").unique(),
  emailVerified: timestamp("emailVerified", { mode: "date" }),
  image: text("image"),
});

export const accounts = pgTable(
  "account",
  {
    userId: text("userId")
      .notNull()
      .references(() => users.id, { onDelete: "cascade" }),
    type: text("type").notNull(),
    provider: text("provider").notNull(),
    providerAccountId: text("providerAccountId").notNull(),
    refresh_token: text("refresh_token"),
    access_token: text("access_token"),
    expires_at: integer("expires_at"),
    token_type: text("token_type"),
    scope: text("scope"),
    id_token: text("id_token"),
    session_state: text("session_state"),
  },
  (account) => ({
    compoundKey: primaryKey({
      columns: [account.provider, account.providerAccountId],
    }),
  })
);

export const sessions = pgTable("session", {
  sessionToken: text("sessionToken").primaryKey(),
  userId: text("userId")
    .notNull()
    .references(() => users.id, { onDelete: "cascade" }),
  expires: timestamp("expires", { mode: "date" }).notNull(),
});

export const verificationTokens = pgTable(
  "verificationToken",
  {
    identifier: text("identifier").notNull(),
    token: text("token").notNull(),
    expires: timestamp("expires", { mode: "date" }).notNull(),
  },
  (verificationToken) => ({
    compositePk: primaryKey({
      columns: [verificationToken.identifier, verificationToken.token],
    }),
  })
);
`],
  ["auth/better-auth/server/db/prisma/postgres/prisma/schema/auth.prisma.hbs", `model User {
  id            String    @id
  name          String
  email         String
  emailVerified Boolean   @default(false)
  image         String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  sessions      Session[]
  accounts      Account[]

  @@unique([email])
  @@map("user")
}

model Session {
  id        String   @id
  expiresAt DateTime
  token     String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  ipAddress String?
  userAgent String?
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([token])
  @@index([userId])
  @@map("session")
}

model Account {
  id                    String    @id
  accountId             String
  providerId            String
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  @@index([userId])
  @@map("account")
}

model Verification {
  id         String   @id
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([identifier])
  @@map("verification")
}
`],
  ["auth/nextauth/server/db/prisma/postgres/prisma/schema/auth.prisma.hbs", `model User {
  id            String    @id @default(cuid())
  name          String?
  email         String?   @unique
  emailVerified DateTime?
  image         String?
  accounts      Account[]
  sessions      Session[]
}

model Account {
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([provider, providerAccountId])
}

model Session {
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@id([identifier, token])
}
`],
  ["auth/better-auth/server/db/prisma/mysql/prisma/schema/auth.prisma.hbs", `model User {
  id            String    @id
  name          String    @db.Text
  email         String
  emailVerified Boolean   @default(false)
  image         String?   @db.Text
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  sessions      Session[]
  accounts      Account[]

  @@unique([email])
  @@map("user")
}

model Session {
  id        String   @id
  expiresAt DateTime
  token     String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  ipAddress String?  @db.Text
  userAgent String?  @db.Text
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([token])
  @@index([userId(length: 191)])
  @@map("session")
}

model Account {
  id                    String    @id
  accountId             String    @db.Text
  providerId            String    @db.Text
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?   @db.Text
  refreshToken          String?   @db.Text
  idToken               String?   @db.Text
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?   @db.Text
  password              String?   @db.Text
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  @@index([userId(length: 191)])
  @@map("account")
}

model Verification {
  id         String   @id
  identifier String   @db.Text
  value      String   @db.Text
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([identifier(length: 191)])
  @@map("verification")
}
`],
  ["auth/better-auth/server/db/prisma/sqlite/prisma/schema/auth.prisma.hbs", `model User {
  id            String    @id
  name          String
  email         String
  emailVerified Boolean   @default(false)
  image         String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  sessions      Session[]
  accounts      Account[]

  @@unique([email])
  @@map("user")
}

model Session {
  id        String   @id
  expiresAt DateTime
  token     String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  ipAddress String?
  userAgent String?
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([token])
  @@index([userId])
  @@map("session")
}

model Account {
  id                    String    @id
  accountId             String
  providerId            String
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  @@index([userId])
  @@map("account")
}

model Verification {
  id         String   @id
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([identifier])
  @@map("verification")
}
`],
  ["auth/better-auth/server/db/prisma/mongodb/prisma/schema/auth.prisma.hbs", `model User {
  id            String    @id @map("_id")
  name          String
  email         String
  emailVerified Boolean   @default(false)
  image         String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  sessions      Session[]
  accounts      Account[]

  @@unique([email])
  @@map("user")
}

model Session {
  id        String   @id @map("_id")
  expiresAt DateTime
  token     String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  ipAddress String?
  userAgent String?
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([token])
  @@index([userId])
  @@map("session")
}

model Account {
  id                    String    @id @map("_id")
  accountId             String
  providerId            String
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  @@index([userId])
  @@map("account")
}

model Verification {
  id         String   @id @map("_id")
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([identifier])
  @@map("verification")
}
`],
  ["auth/nextauth/server/db/prisma/sqlite/prisma/schema/auth.prisma.hbs", `model User {
  id            String    @id @default(cuid())
  name          String?
  email         String?   @unique
  emailVerified DateTime?
  image         String?
  accounts      Account[]
  sessions      Session[]
}

model Account {
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([provider, providerAccountId])
}

model Session {
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@id([identifier, token])
}
`],
  ["auth/better-auth/server/db/drizzle/postgres/src/schema/auth.ts.hbs", `import { relations } from "drizzle-orm";
import { pgTable, text, timestamp, boolean, index } from "drizzle-orm/pg-core";

export const user = pgTable("user", {
  id: text("id").primaryKey(),
  name: text("name").notNull(),
  email: text("email").notNull().unique(),
  emailVerified: boolean("email_verified").default(false).notNull(),
  image: text("image"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at")
    .defaultNow()
    .$onUpdate(() => /* @__PURE__ */ new Date())
    .notNull(),
});

export const session = pgTable(
  "session",
  {
    id: text("id").primaryKey(),
    expiresAt: timestamp("expires_at").notNull(),
    token: text("token").notNull().unique(),
    createdAt: timestamp("created_at").defaultNow().notNull(),
    updatedAt: timestamp("updated_at")
      .$onUpdate(() => /* @__PURE__ */ new Date())
      .notNull(),
    ipAddress: text("ip_address"),
    userAgent: text("user_agent"),
    userId: text("user_id")
      .notNull()
      .references(() => user.id, { onDelete: "cascade" }),
  },
  (table) => [index("session_userId_idx").on(table.userId)],
);

export const account = pgTable(
  "account",
  {
    id: text("id").primaryKey(),
    accountId: text("account_id").notNull(),
    providerId: text("provider_id").notNull(),
    userId: text("user_id")
      .notNull()
      .references(() => user.id, { onDelete: "cascade" }),
    accessToken: text("access_token"),
    refreshToken: text("refresh_token"),
    idToken: text("id_token"),
    accessTokenExpiresAt: timestamp("access_token_expires_at"),
    refreshTokenExpiresAt: timestamp("refresh_token_expires_at"),
    scope: text("scope"),
    password: text("password"),
    createdAt: timestamp("created_at").defaultNow().notNull(),
    updatedAt: timestamp("updated_at")
      .$onUpdate(() => /* @__PURE__ */ new Date())
      .notNull(),
  },
  (table) => [index("account_userId_idx").on(table.userId)],
);

export const verification = pgTable(
  "verification",
  {
    id: text("id").primaryKey(),
    identifier: text("identifier").notNull(),
    value: text("value").notNull(),
    expiresAt: timestamp("expires_at").notNull(),
    createdAt: timestamp("created_at").defaultNow().notNull(),
    updatedAt: timestamp("updated_at")
      .defaultNow()
      .$onUpdate(() => /* @__PURE__ */ new Date())
      .notNull(),
  },
  (table) => [index("verification_identifier_idx").on(table.identifier)],
);

export const userRelations = relations(user, ({ many }) => ({
  sessions: many(session),
  accounts: many(account),
}));

export const sessionRelations = relations(session, ({ one }) => ({
  user: one(user, {
    fields: [session.userId],
    references: [user.id],
  }),
}));

export const accountRelations = relations(account, ({ one }) => ({
  user: one(user, {
    fields: [account.userId],
    references: [user.id],
  }),
}));
`],
  ["auth/nextauth/server/db/prisma/mysql/prisma/schema/auth.prisma.hbs", `model User {
  id            String    @id @default(cuid())
  name          String?
  email         String?   @unique
  emailVerified DateTime?
  image         String?
  accounts      Account[]
  sessions      Session[]
}

model Account {
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?   @db.Text
  access_token      String?   @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?   @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([provider, providerAccountId])
}

model Session {
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@id([identifier, token])
}
`],
  ["auth/better-auth/server/db/drizzle/sqlite/src/schema/auth.ts.hbs", `import { relations, sql } from "drizzle-orm";
import { sqliteTable, text, integer, index } from "drizzle-orm/sqlite-core";

export const user = sqliteTable("user", {
  id: text("id").primaryKey(),
  name: text("name").notNull(),
  email: text("email").notNull().unique(),
  emailVerified: integer("email_verified", { mode: "boolean" })
    .default(false)
    .notNull(),
  image: text("image"),
  createdAt: integer("created_at", { mode: "timestamp_ms" })
    .default(sql\`(cast(unixepoch('subsecond') * 1000 as integer))\`)
    .notNull(),
  updatedAt: integer("updated_at", { mode: "timestamp_ms" })
    .default(sql\`(cast(unixepoch('subsecond') * 1000 as integer))\`)
    .$onUpdate(() => /* @__PURE__ */ new Date())
    .notNull(),
});

export const session = sqliteTable(
  "session",
  {
    id: text("id").primaryKey(),
    expiresAt: integer("expires_at", { mode: "timestamp_ms" }).notNull(),
    token: text("token").notNull().unique(),
    createdAt: integer("created_at", { mode: "timestamp_ms" })
      .default(sql\`(cast(unixepoch('subsecond') * 1000 as integer))\`)
      .notNull(),
    updatedAt: integer("updated_at", { mode: "timestamp_ms" })
      .$onUpdate(() => /* @__PURE__ */ new Date())
      .notNull(),
    ipAddress: text("ip_address"),
    userAgent: text("user_agent"),
    userId: text("user_id")
      .notNull()
      .references(() => user.id, { onDelete: "cascade" }),
  },
  (table) => [index("session_userId_idx").on(table.userId)],
);

export const account = sqliteTable(
  "account",
  {
    id: text("id").primaryKey(),
    accountId: text("account_id").notNull(),
    providerId: text("provider_id").notNull(),
    userId: text("user_id")
      .notNull()
      .references(() => user.id, { onDelete: "cascade" }),
    accessToken: text("access_token"),
    refreshToken: text("refresh_token"),
    idToken: text("id_token"),
    accessTokenExpiresAt: integer("access_token_expires_at", {
      mode: "timestamp_ms",
    }),
    refreshTokenExpiresAt: integer("refresh_token_expires_at", {
      mode: "timestamp_ms",
    }),
    scope: text("scope"),
    password: text("password"),
    createdAt: integer("created_at", { mode: "timestamp_ms" })
      .default(sql\`(cast(unixepoch('subsecond') * 1000 as integer))\`)
      .notNull(),
    updatedAt: integer("updated_at", { mode: "timestamp_ms" })
      .$onUpdate(() => /* @__PURE__ */ new Date())
      .notNull(),
  },
  (table) => [index("account_userId_idx").on(table.userId)],
);

export const verification = sqliteTable(
  "verification",
  {
    id: text("id").primaryKey(),
    identifier: text("identifier").notNull(),
    value: text("value").notNull(),
    expiresAt: integer("expires_at", { mode: "timestamp_ms" }).notNull(),
    createdAt: integer("created_at", { mode: "timestamp_ms" })
      .default(sql\`(cast(unixepoch('subsecond') * 1000 as integer))\`)
      .notNull(),
    updatedAt: integer("updated_at", { mode: "timestamp_ms" })
      .default(sql\`(cast(unixepoch('subsecond') * 1000 as integer))\`)
      .$onUpdate(() => /* @__PURE__ */ new Date())
      .notNull(),
  },
  (table) => [index("verification_identifier_idx").on(table.identifier)],
);

export const userRelations = relations(user, ({ many }) => ({
  sessions: many(session),
  accounts: many(account),
}));

export const sessionRelations = relations(session, ({ one }) => ({
  user: one(user, {
    fields: [session.userId],
    references: [user.id],
  }),
}));

export const accountRelations = relations(account, ({ one }) => ({
  user: one(user, {
    fields: [account.userId],
    references: [user.id],
  }),
}));
`],
  ["auth/better-auth/server/db/drizzle/mysql/src/schema/auth.ts.hbs", `import { relations } from "drizzle-orm";
import {
  mysqlTable,
  varchar,
  text,
  timestamp,
  boolean,
  index,
} from "drizzle-orm/mysql-core";

export const user = mysqlTable("user", {
  id: varchar("id", { length: 36 }).primaryKey(),
  name: varchar("name", { length: 255 }).notNull(),
  email: varchar("email", { length: 255 }).notNull().unique(),
  emailVerified: boolean("email_verified").default(false).notNull(),
  image: text("image"),
  createdAt: timestamp("created_at", { fsp: 3 }).defaultNow().notNull(),
  updatedAt: timestamp("updated_at", { fsp: 3 })
    .defaultNow()
    .$onUpdate(() => /* @__PURE__ */ new Date())
    .notNull(),
});

export const session = mysqlTable(
  "session",
  {
    id: varchar("id", { length: 36 }).primaryKey(),
    expiresAt: timestamp("expires_at", { fsp: 3 }).notNull(),
    token: varchar("token", { length: 255 }).notNull().unique(),
    createdAt: timestamp("created_at", { fsp: 3 }).defaultNow().notNull(),
    updatedAt: timestamp("updated_at", { fsp: 3 })
      .$onUpdate(() => /* @__PURE__ */ new Date())
      .notNull(),
    ipAddress: text("ip_address"),
    userAgent: text("user_agent"),
    userId: varchar("user_id", { length: 36 })
      .notNull()
      .references(() => user.id, { onDelete: "cascade" }),
  },
  (table) => [index("session_userId_idx").on(table.userId)],
);

export const account = mysqlTable(
  "account",
  {
    id: varchar("id", { length: 36 }).primaryKey(),
    accountId: text("account_id").notNull(),
    providerId: text("provider_id").notNull(),
    userId: varchar("user_id", { length: 36 })
      .notNull()
      .references(() => user.id, { onDelete: "cascade" }),
    accessToken: text("access_token"),
    refreshToken: text("refresh_token"),
    idToken: text("id_token"),
    accessTokenExpiresAt: timestamp("access_token_expires_at", { fsp: 3 }),
    refreshTokenExpiresAt: timestamp("refresh_token_expires_at", { fsp: 3 }),
    scope: text("scope"),
    password: text("password"),
    createdAt: timestamp("created_at", { fsp: 3 }).defaultNow().notNull(),
    updatedAt: timestamp("updated_at", { fsp: 3 })
      .$onUpdate(() => /* @__PURE__ */ new Date())
      .notNull(),
  },
  (table) => [index("account_userId_idx").on(table.userId)],
);

export const verification = mysqlTable(
  "verification",
  {
    id: varchar("id", { length: 36 }).primaryKey(),
    identifier: varchar("identifier", { length: 255 }).notNull(),
    value: text("value").notNull(),
    expiresAt: timestamp("expires_at", { fsp: 3 }).notNull(),
    createdAt: timestamp("created_at", { fsp: 3 }).defaultNow().notNull(),
    updatedAt: timestamp("updated_at", { fsp: 3 })
      .defaultNow()
      .$onUpdate(() => /* @__PURE__ */ new Date())
      .notNull(),
  },
  (table) => [index("verification_identifier_idx").on(table.identifier)],
);

export const userRelations = relations(user, ({ many }) => ({
  sessions: many(session),
  accounts: many(account),
}));

export const sessionRelations = relations(session, ({ one }) => ({
  user: one(user, {
    fields: [session.userId],
    references: [user.id],
  }),
}));

export const accountRelations = relations(account, ({ one }) => ({
  user: one(user, {
    fields: [account.userId],
    references: [user.id],
  }),
}));
`],
  ["auth/nextauth/web/react/next/src/app/dashboard/dashboard.tsx.hbs", `"use client";

import type { User } from "next-auth";
import UserMenu from "@/components/user-menu";
import { AuthProvider } from "@/components/providers";

export default function Dashboard({ user }: { user: User }) {
  return (
    <AuthProvider>
      <div className="min-h-screen bg-background">
        <header className="border-b">
          <div className="container mx-auto px-4 py-4 flex justify-between items-center">
            <h1 className="text-xl font-bold">Dashboard</h1>
            <UserMenu />
          </div>
        </header>
        <main className="container mx-auto px-4 py-8">
          <div className="max-w-2xl mx-auto">
            <h2 className="text-2xl font-bold mb-4">
              Welcome, {user.name || user.email}!
            </h2>
            <p className="text-muted-foreground mb-6">
              You are now signed in with Auth.js (NextAuth).
            </p>
            <div className="bg-card border rounded-lg p-6">
              <h3 className="font-semibold mb-2">Your Profile</h3>
              <dl className="space-y-2">
                {user.name && (
                  <div>
                    <dt className="text-sm text-muted-foreground">Name</dt>
                    <dd className="font-medium">{user.name}</dd>
                  </div>
                )}
                <div>
                  <dt className="text-sm text-muted-foreground">Email</dt>
                  <dd className="font-medium">{user.email}</dd>
                </div>
                <div>
                  <dt className="text-sm text-muted-foreground">User ID</dt>
                  <dd className="font-mono text-sm">{user.id}</dd>
                </div>
              </dl>
            </div>
          </div>
        </main>
      </div>
    </AuthProvider>
  );
}
`],
  ["auth/nextauth/web/react/next/src/app/dashboard/page.tsx.hbs", `import { auth } from "@/lib/auth";
import { redirect } from "next/navigation";
import Dashboard from "./dashboard";

export default async function DashboardPage() {
  const session = await auth();

  if (!session?.user) {
    redirect("/login");
  }

  return <Dashboard user={session.user} />;
}
`],
  ["auth/nextauth/web/react/next/src/app/login/page.tsx.hbs", `"use client";

import { useState } from "react";
import SignInForm from "@/components/sign-in-form";
import SignUpForm from "@/components/sign-up-form";

export default function LoginPage() {
  const [isSignIn, setIsSignIn] = useState(true);

  return (
    <div className="min-h-screen flex items-center justify-center">
      {isSignIn ? (
        <SignInForm onSwitchToSignUp={() => setIsSignIn(false)} />
      ) : (
        <SignUpForm onSwitchToSignIn={() => setIsSignIn(true)} />
      )}
    </div>
  );
}
`],
  ["api/orpc/fullstack/astro/src/pages/api/rpc/[...rest].ts.hbs", `import type { APIRoute } from 'astro';
import { createContext } from '@{{projectName}}/api/context';
import { appRouter } from '@{{projectName}}/api/routers/index';
import { OpenAPIHandler } from '@orpc/openapi/fetch';
import { OpenAPIReferencePlugin } from '@orpc/openapi/plugins';
import { ZodToJsonSchemaConverter } from '@orpc/zod/zod4';
import { RPCHandler } from '@orpc/server/fetch';
import { onError } from '@orpc/server';

const rpcHandler = new RPCHandler(appRouter, {
	interceptors: [
		onError((error) => {
			console.error(error);
		}),
	],
});

const apiHandler = new OpenAPIHandler(appRouter, {
	plugins: [
		new OpenAPIReferencePlugin({
			schemaConverters: [new ZodToJsonSchemaConverter()],
		}),
	],
	interceptors: [
		onError((error) => {
			console.error(error);
		}),
	],
});

const handler: APIRoute = async ({ request }) => {
	const rpcResult = await rpcHandler.handle(request, {
		prefix: '/api/rpc',
		context: await createContext(request),
	});
	if (rpcResult.response) return rpcResult.response;

	const apiResult = await apiHandler.handle(request, {
		prefix: '/api/rpc/api-reference',
		context: await createContext(request),
	});
	if (apiResult.response) return apiResult.response;

	return new Response('Not found', { status: 404 });
};

export const GET = handler;
export const POST = handler;
export const PUT = handler;
export const PATCH = handler;
export const DELETE = handler;
`],
  ["api/orpc/fullstack/tanstack-start/src/routes/api/rpc/$.ts.hbs", `import { createContext } from "@{{projectName}}/api/context";
import { appRouter } from "@{{projectName}}/api/routers/index";
import { OpenAPIHandler } from "@orpc/openapi/fetch";
import { OpenAPIReferencePlugin } from "@orpc/openapi/plugins";
import { ZodToJsonSchemaConverter } from "@orpc/zod/zod4";
import { RPCHandler } from "@orpc/server/fetch";
import { onError } from "@orpc/server";
import { createFileRoute } from "@tanstack/react-router";

const rpcHandler = new RPCHandler(appRouter, {
	interceptors: [
		onError((error) => {
			console.error(error);
		}),
	],
});

const apiHandler = new OpenAPIHandler(appRouter, {
	plugins: [
		new OpenAPIReferencePlugin({
			schemaConverters: [new ZodToJsonSchemaConverter()],
		}),
	],
	interceptors: [
		onError((error) => {
			console.error(error);
		}),
	],
});

async function handle({ request }: { request: Request }) {
	const rpcResult = await rpcHandler.handle(request, {
		prefix: "/api/rpc",
		context: await createContext({ req: request }),
	});
	if (rpcResult.response) return rpcResult.response;

	const apiResult = await apiHandler.handle(request, {
		prefix: "/api/rpc/api-reference",
		context: await createContext({ req: request }),
	});
	if (apiResult.response) return apiResult.response;

	return new Response("Not found", { status: 404 });
}

export const Route = createFileRoute('/api/rpc/$')({
  server: {
    handlers: {
      HEAD: handle,
      GET: handle,
      POST: handle,
      PUT: handle,
      PATCH: handle,
      DELETE: handle,
    },
  },
})`],
  ["api/trpc/fullstack/tanstack-start/src/routes/api/trpc/$.ts.hbs", `import { fetchRequestHandler } from '@trpc/server/adapters/fetch'
import { appRouter } from '@{{projectName}}/api/routers/index'
import { createContext } from '@{{projectName}}/api/context'
import { createFileRoute } from '@tanstack/react-router'

function handler({ request }: { request: Request }) {
  return fetchRequestHandler({
    req: request,
    router: appRouter,
    createContext,
    endpoint: '/api/trpc',
  })
}

export const Route = createFileRoute('/api/trpc/$')({
  server: {
    handlers: {
      GET: handler,
      POST: handler,
    },
  },
})
`],
  ["api/ts-rest/fullstack/astro/src/pages/api/rest/[...rest].ts.hbs", `import type { APIRoute } from "astro";
import { tsr } from "@ts-rest/serverless";
import { contract } from "@{{projectName}}/api/index";
import { createRouter } from "@{{projectName}}/api/routers";
import { createContext } from "@{{projectName}}/api/context";
{{#if (eq auth "better-auth")}}
import { auth } from "@/lib/auth";
{{/if}}

const handler = tsr.router(contract, async (args) => {
{{#if (eq auth "better-auth")}}
  const request = args.request;
  const session = await auth.api.getSession({
    headers: request.headers,
  });
  const ctx = createContext(args.astroContext, session);
{{else}}
  const ctx = createContext(args.astroContext);
{{/if}}
  const router = createRouter(ctx);

  // Handle nested routes
  const path = args.appRoute.path;
  if (path.startsWith("/todos")) {
    const method = args.appRoute.method;
    if (method === "GET" && path === "/todos") {
      return router.todos.getAll();
    }
    if (method === "POST" && path === "/todos") {
      return router.todos.create(args as any);
    }
    if (method === "PATCH" && path.includes("/toggle")) {
      return router.todos.toggle(args as any);
    }
    if (method === "DELETE") {
      return router.todos.delete(args as any);
    }
  }

  if (path === "/health") {
    return router.healthCheck();
  }
{{#if (eq auth "better-auth")}}
  if (path === "/private") {
    return router.privateData();
  }
{{/if}}

  return { status: 404 as const, body: { message: "Not found" } };
});

export const ALL: APIRoute = async (context) => {
  return handler.fetch(context.request, { astroContext: context });
};
`],
  ["api/trpc/fullstack/astro/src/pages/api/trpc/[...trpc].ts.hbs", `import type { APIRoute } from 'astro';
import { fetchRequestHandler } from '@trpc/server/adapters/fetch';
import { appRouter } from '@{{projectName}}/api/routers/index';
import { createContext } from '@{{projectName}}/api/context';

const handler: APIRoute = async ({ request }) => {
	return fetchRequestHandler({
		endpoint: '/api/trpc',
		req: request,
		router: appRouter,
		createContext: () => createContext(request),
	});
};

export const GET = handler;
export const POST = handler;
`],
  ["api/garph/fullstack/next/src/app/api/graphql/route.ts.hbs", `import { createYoga } from "graphql-yoga";
import { createSchema } from "@{{projectName}}/api/routers";
import { createContext } from "@{{projectName}}/api/context";
{{#if (eq auth "better-auth")}}
import { auth } from "@/lib/auth";
import { headers } from "next/headers";
{{/if}}
import type { NextRequest } from "next/server";

const yoga = createYoga({
  graphqlEndpoint: "/api/graphql",
  fetchAPI: { Response },
  context: async ({ request }) => {
{{#if (eq auth "better-auth")}}
    const session = await auth.api.getSession({
      headers: await headers(),
    });
    return createContext(request as NextRequest, session);
{{else}}
    return createContext(request as NextRequest);
{{/if}}
  },
  schema: async ({ request }) => {
{{#if (eq auth "better-auth")}}
    const session = await auth.api.getSession({
      headers: await headers(),
    });
    const ctx = createContext(request as NextRequest, session);
{{else}}
    const ctx = createContext(request as NextRequest);
{{/if}}
    return createSchema(ctx);
  },
});

export async function GET(request: NextRequest) {
  return yoga.handleRequest(request, {});
}

export async function POST(request: NextRequest) {
  return yoga.handleRequest(request, {});
}
`],
  ["api/ts-rest/fullstack/tanstack-start/src/routes/api/rest/$.ts.hbs", `import { createAPIFileRoute } from "@tanstack/react-start/api";
import { tsr } from "@ts-rest/serverless";
import { contract } from "@{{projectName}}/api/index";
import { createRouter } from "@{{projectName}}/api/routers";
import { createContext } from "@{{projectName}}/api/context";
{{#if (eq auth "better-auth")}}
import { auth } from "@/lib/auth";
{{/if}}

const handler = tsr.router(contract, async (args) => {
{{#if (eq auth "better-auth")}}
  const request = args.request;
  const session = await auth.api.getSession({
    headers: request.headers,
  });
  const ctx = createContext(request, session);
{{else}}
  const ctx = createContext(args.request);
{{/if}}
  const router = createRouter(ctx);

  // Handle nested routes
  const path = args.appRoute.path;
  if (path.startsWith("/todos")) {
    const method = args.appRoute.method;
    if (method === "GET" && path === "/todos") {
      return router.todos.getAll();
    }
    if (method === "POST" && path === "/todos") {
      return router.todos.create(args as any);
    }
    if (method === "PATCH" && path.includes("/toggle")) {
      return router.todos.toggle(args as any);
    }
    if (method === "DELETE") {
      return router.todos.delete(args as any);
    }
  }

  if (path === "/health") {
    return router.healthCheck();
  }
{{#if (eq auth "better-auth")}}
  if (path === "/private") {
    return router.privateData();
  }
{{/if}}

  return { status: 404 as const, body: { message: "Not found" } };
});

export const APIRoute = createAPIFileRoute("/api/rest/$")({
  GET: ({ request }) => handler.fetch(request),
  POST: ({ request }) => handler.fetch(request),
  PATCH: ({ request }) => handler.fetch(request),
  DELETE: ({ request }) => handler.fetch(request),
});
`],
  ["auth/clerk/convex/web/react/next/src/app/dashboard/page.tsx.hbs", `"use client";

import { api } from "@{{projectName}}/backend/convex/_generated/api";
import { SignInButton, UserButton, useUser } from "@clerk/nextjs";
import { Authenticated, AuthLoading, Unauthenticated, useQuery } from "convex/react";

export default function Dashboard() {
  const user = useUser();
  const privateData = useQuery(api.privateData.get);

  return (
    <>
      <Authenticated>
        <div>
          <h1>Dashboard</h1>
          <p>Welcome {user.user?.fullName}</p>
          <p>privateData: {privateData?.message}</p>
          <UserButton />
        </div>
      </Authenticated>
      <Unauthenticated>
        <SignInButton />
      </Unauthenticated>
      <AuthLoading>
        <div>Loading...</div>
      </AuthLoading>
    </>
  );
}
`],
  ["auth/better-auth/convex/web/react/next/src/app/dashboard/page.tsx.hbs", `"use client"

import SignInForm from "@/components/sign-in-form";
import SignUpForm from "@/components/sign-up-form";
import UserMenu from "@/components/user-menu";
import { api } from "@{{projectName}}/backend/convex/_generated/api";
import {
    Authenticated,
    AuthLoading,
    Unauthenticated,
    useQuery,
} from "convex/react";
import { useState } from "react";

export default function DashboardPage() {
    const [showSignIn, setShowSignIn] = useState(false);
    const privateData = useQuery(api.privateData.get);

    return (
        <>
            <Authenticated>
                <div>
                    <h1>Dashboard</h1>
                    <p>privateData: {privateData?.message}</p>
                    <UserMenu />
                </div>
            </Authenticated>
            <Unauthenticated>
                {showSignIn ? (
                    <SignInForm onSwitchToSignUp={() => setShowSignIn(false)} />
                ) : (
                    <SignUpForm onSwitchToSignIn={() => setShowSignIn(true)} />
                )}
            </Unauthenticated>
            <AuthLoading>
                <div>Loading...</div>
            </AuthLoading>
        </>
    );
}
`],
  ["auth/better-auth/fullstack/next/src/app/api/auth/[...all]/route.ts.hbs", `import { auth } from "@{{projectName}}/auth";
import { toNextJsHandler } from "better-auth/next-js";

export const { GET, POST } = toNextJsHandler(auth.handler);
`],
  ["auth/nextauth/fullstack/next/src/app/api/auth/[...nextauth]/route.ts.hbs", `import { handlers } from "@/lib/auth";

export const { GET, POST } = handlers;
`],
  ["api/orpc/fullstack/next/src/app/api/rpc/[[...rest]]/route.ts.hbs", `import { createContext } from "@{{projectName}}/api/context";
import { appRouter } from "@{{projectName}}/api/routers/index";
import { OpenAPIHandler } from "@orpc/openapi/fetch";
import { OpenAPIReferencePlugin } from "@orpc/openapi/plugins";
import { ZodToJsonSchemaConverter } from "@orpc/zod/zod4";
import { RPCHandler } from "@orpc/server/fetch";
import { onError } from "@orpc/server";
import { NextRequest } from "next/server";

const rpcHandler = new RPCHandler(appRouter, {
	interceptors: [
		onError((error) => {
			console.error(error);
		}),
	],
});
const apiHandler = new OpenAPIHandler(appRouter, {
	plugins: [
		new OpenAPIReferencePlugin({
			schemaConverters: [new ZodToJsonSchemaConverter()],
		}),
	],
	interceptors: [
		onError((error) => {
			console.error(error);
		}),
	],
});

async function handleRequest(req: NextRequest) {
	const rpcResult = await rpcHandler.handle(req, {
		prefix: "/api/rpc",
		context: await createContext(req),
	});
	if (rpcResult.response) return rpcResult.response;

	const apiResult = await apiHandler.handle(req, {
		prefix: "/api/rpc/api-reference",
		context: await createContext(req),
	});
	if (apiResult.response) return apiResult.response;

	return new Response("Not found", { status: 404 });
}

export const GET = handleRequest;
export const POST = handleRequest;
export const PUT = handleRequest;
export const PATCH = handleRequest;
export const DELETE = handleRequest;`],
  ["api/ts-rest/fullstack/next/src/app/api/rest/[[...rest]]/route.ts.hbs", `import { createNextHandler } from "@ts-rest/serverless/next";
import { contract } from "@{{projectName}}/api/index";
import { createRouter } from "@{{projectName}}/api/routers";
import { createContext } from "@{{projectName}}/api/context";
{{#if (eq auth "better-auth")}}
import { auth } from "@/lib/auth";
import { headers } from "next/headers";
{{/if}}

const handler = createNextHandler(
  contract,
  async (args, { request }) => {
{{#if (eq auth "better-auth")}}
    const session = await auth.api.getSession({
      headers: await headers(),
    });
    const ctx = createContext(request, session);
{{else}}
    const ctx = createContext(request);
{{/if}}
    const router = createRouter(ctx);
    
    // Handle nested routes
    const path = args.appRoute.path;
    if (path.startsWith("/todos")) {
      const method = args.appRoute.method;
      if (method === "GET" && path === "/todos") {
        return router.todos.getAll();
      }
      if (method === "POST" && path === "/todos") {
        return router.todos.create(args as any);
      }
      if (method === "PATCH" && path.includes("/toggle")) {
        return router.todos.toggle(args as any);
      }
      if (method === "DELETE") {
        return router.todos.delete(args as any);
      }
    }
    
    if (path === "/health") {
      return router.healthCheck();
    }
{{#if (eq auth "better-auth")}}
    if (path === "/private") {
      return router.privateData();
    }
{{/if}}
    
    return { status: 404 as const, body: { message: "Not found" } };
  },
  {
    basePath: "/api/rest",
    jsonQuery: true,
  }
);

export { handler as GET, handler as POST, handler as PATCH, handler as DELETE };
`],
  ["api/trpc/fullstack/next/src/app/api/trpc/[trpc]/route.ts.hbs", `import { fetchRequestHandler } from "@trpc/server/adapters/fetch";
import { appRouter } from "@{{projectName}}/api/routers/index";
import { createContext } from "@{{projectName}}/api/context";
import { NextRequest } from "next/server";

function handler(req: NextRequest) {
	return fetchRequestHandler({
		endpoint: "/api/trpc",
		req,
		router: appRouter,
		createContext: () => createContext(req),
	});
}
export { handler as GET, handler as POST };
`],
  ["auth/better-auth/convex/web/react/tanstack-start/src/routes/api/auth/$.ts.hbs", `import { createFileRoute } from "@tanstack/react-router";
import { handler } from "@/lib/auth-server";

export const Route = createFileRoute("/api/auth/$")({
  server: {
    handlers: {
      GET: ({ request }) => handler(request),
      POST: ({ request }) => handler(request),
    },
  },
});
`],
  ["auth/better-auth/convex/web/react/next/src/app/api/auth/[...all]/route.ts.hbs", `import { handler } from "@/lib/auth-server";

export const { GET, POST } = handler;
`]
]);

export const TEMPLATE_COUNT = 703;
